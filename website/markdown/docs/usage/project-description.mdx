---
name: Project description
excerpt: 'This page documents the models that users can use to define their project: how to initialize them, attributes and their meaning, protocol comformances.'
---

import PropertiesTable from '../components/properties-table'
import SettingsDictionaryTable from '../components/settingsdictionary-table'
import Message from '../components/message'
import EnumTable from '../components/enum'

# Project description

Projects are defined in `Project.swift` files, which we refer to as manifest files. Manifests need to import the framework `ProjectDescription` which contains all the classes and enums that are available for you to describe your projects. The snippet below shows an example project manifest:

```swift

let project = Project(name: "MyProject",
                      organizationName: "MyOrg",
                      targets: [
                          Target(name: "App",
                                 platform: .iOS,
                                 product: .app,
                                 bundleId: "io.tuist.App",
                                 infoPlist: "Config/App-Info.plist",
                                 sources: ["Sources/**"],
                                 resources: [
                                   "Resources/**",
                                   .folderReference(path: "Stubs")
                                 ],
                                 headers: Headers(public: ["Sources/public/A/**", "Sources/public/B/**"],
                                                  private: "Sources/private/**",
                                                  project: ["Sources/project/A/**", "Sources/project/B/**"]),
                                 dependencies: [
                                     .project(target: "Framework1", path: "../Framework1"),
                                     .project(target: "Framework2", path: "../Framework2")
                                 ])
                        ],
                        schemes: [
                            Scheme(name: "App-Debug",
                                   shared: true,
                                   buildAction: BuildAction(targets: ["App"]),
                                   testAction: TestAction(targets: ["AppTests"]),
                                   runAction: RunAction(executable: "App")),
                            Scheme(name: "App-Release",
                                   shared: true,
                                   buildAction: BuildAction(targets: ["App"]),
                                   runAction: RunAction(executable: "App"))
                        ],
                        additionalFiles: [
                                 "Dangerfile.swift",
                                 "Documentation/**",
                                 .folderReference(path: "Website")
                        ])
```

## Project

A `Project.swift` should initialize a variable of type `Project`. It can take any name, although we recommend to stick to `project`. A project accepts the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Name',
      description:
        "Name of the project. It's used to determine the name of the generated Xcode project.",
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'OrganizationName',
      description:
        'Name of the organization used by Xcode as copyright when generating new files.',
      type: 'String',
      optional: true,
      default: '',
    },
    {
      name: 'Packages',
      description: 'List of Swift Packages used by the project.',
      type: '[Package]',
      typeLink: '#package',
      optional: true,
      default: '[]',
    },
    {
      name: 'Targets',
      description: 'List of targets within the project.',
      type: '[Target]',
      typeLink: '#target',
      optional: false,
      default: '[]',
    },
    {
      name: 'Schemes',
      description:
        'List of custom schemes within the project, default scheme for each target is generated by default (see The [Configuration `generationOptions`](/docs/usage/config/#generationoption) to configure this behavior)',
      type: '[Scheme]',
      typeLink: '#scheme',
      optional: true,
      default: '[]',
    },
    {
      name: 'Settings',
      description: 'Project build settings and configuration files',
      type: 'Settings',
      typeLink: '#settings',
      optional: true,
      default: '',
    },
    {
      name: 'AdditionalFiles',
      description:
        "List of files to include in the project - these won't be included in any of the build phases",
      type: '[FileElement]',
      typeLink: '#fileelement',
      optional: true,
      default: '[]',
    },
  ]}
/>

## Environment

`Environment` is a special type that allows passing configuration down the manifest files at generation time using environment variables. Any variables following the convention `TUIST_XXX` defined in the environment or passed to Tuist when running commands will be accessible using the `Environment` type.
The following example shows how we access the `TUIST_APP_NAME` variable:

```swift
func appName() -> String {
  if case let .string(environmentAppName) = Environment.appName {
    return environmentAppName
  } else {
    return "MyApp"
  }
}
```

Accessing variables returns an instance of type `Environment.Value?` which can take any of the following values:

<EnumTable
  cases={[
    {
      case: '.boolean',
      description:
        'Used when the variable represents a boolean. The values 1, true, TRUE, yes and YES are casted to `true`, and 0, false, FALSE, no, and NO are casted to `false`',
    },
    {
      case: '.string',
      description: 'Used when the variable represents a string.',
    },
  ]}
/>

You can also retrieve the string or boolean Environment variable using either of the helper methods defined below, these methods require a default value to be passed to ensure the user gets consistent results each time. This avoids the need to define the function appName() defined above.

```swift
Environment.appName?.getString(default: "TuistApp")
```

```swift
Environment.isCI?.getBoolean(default: false)
```

## Package

You can add Swift Packages very similarly to how you add dependencies in a `Package.swift`:

For remote:

```swift
.package(url: "https://github.com/tuist/XcodeProj", .exact("6.7.0"))
```

```swift
.package(url: "https://github.com/tuist/XcodeProj", from: "6.7.0")
```

```swift
.package(url: "https://github.com/tuist/XcodeProj", "6.6.1"..<"6.8.0")
```

For local:

```swift
.package(path: "MyLibrary")
```

Targets can then depend on products from these Swift Packages. See [Dependencies](/docs/usage/dependencies/)

<Message
  info
  title="Package.resolved"
  description="Tuist creates a `.package.resolved` file, so your team can share the same versions of dependencies without committing your workspace."
/>

## Target

Each target in the list of project targets can be initialized with the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Name',
      description:
        'The name of the target. The Xcode project target and the derivated product take the same name.',
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'Platform',
      description: 'The platform the target product is built for.',
      type: 'Platform',
      typeLink: '#platform',
      optional: false,
      default: '',
    },
    {
      name: 'Product',
      description: 'The type of build product this target will output.',
      type: 'Product',
      typeLink: '#product',
      optional: false,
      default: '',
    },
    {
      name: 'Product Name',
      description: 'The built product name.',
      type: 'String',
      optional: true,
      default: '$(TARGET_NAME)',
    },
    {
      name: 'Deployment Target',
      description: 'The minimum iOS version your product will support.',
      type: 'DeploymentTarget',
      typeLink: '#deployment-target',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Bundle id',
      description: 'The product bundle identifier.',
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'Info plist',
      description: 'Relative path to the Info.plist',
      type: 'Path',
      typeLink: '#path',
      optional: false,
      default: '',
    },
    {
      name: 'Resources',
      description:
        'List of files to include in the resources build phase. Note that localizable files, `*.lproj`, are supported.',
      type: '[FileElement]',
      typeLink: '#fileelement',
      optional: true,
      default: '[]',
    },
    {
      name: 'Headers',
      description: 'The target headers',
      type: 'Headers',
      typeLink: '#headers',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Entitlements',
      description: 'Path to the entitlement file.',
      type: 'Path',
      typeLink: '#path',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Actions',
      description: 'Target actions allow defining extra script build phases.',
      type: '[TargetAction]',
      typeLink: '#target-action',
      optional: true,
      default: '[]',
    },
    {
      name: 'Dependencies',
      description: 'List of target dependencies',
      type: '[TargetDependency]',
      typeLink: '../dependencies',
      optional: true,
      default: '[]',
    },
    {
      name: 'Sources',
      description: 'Source files that are compiled by the target',
      type: 'SourceFilesList',
      typeLink: '#source-file-list',
      optional: false,
      default: '',
    },
    {
      name: 'Settings',
      description: 'Target build settings and configuration files.',
      type: 'Settings',
      typeLink: '#settings',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Core Data models',
      description: 'Core Data models.',
      type: '[CoreDataModel]',
      typeLink: '#core-data-model',
      optional: true,
      default: '[]',
    },
    {
      name: 'Environment',
      description:
        'List of variables that will be set to the scheme that Tuist automatically generates for the target.',
      type: '[String: String]',
      optional: true,
      default: '[:]',
    },
    {
      name: 'LaunchArguments',
      description:
        'List of launch arguments that will be set to the scheme that Tuist automatically generates for the target.',
      type: '[String: Bool]',
      optional: true,
      default: '[:]',
    },
  ]}
/>

```swift
import ProjectDescription

let target = Target(name: "App",
                    platform: .iOS,
                    product: .app,
                    bundleId: "io.tuist.App",
                    infoPlist: "Info.plist",
                    sources: "Sources/**",
                    dependencies: [])
```

## Source file list

It represents a list of source files that are part of a target:<PropertiesTable
properties={[
{
name: 'Globs',
description:
'Path to the source files. They are represented by a [glob pattern](https://facelessuser.github.io/wcmatch/glob/) and the compiler flags.',
type: '[SourceFileGlob]',
typeLink: '#source-file-glob',
optional: false,
default: '',
},
]}
/>

<Message
  info
  title="ExpressibleByStringLiteral and ExpressibleByArrayLiteral"
  description="The list of source files can be initialized with a string that represents the glob pattern, or an array of strings, which represents a list of glob patterns. In both cases the comiler flags will have no value."
/>
<Message
  info
  title="Patterns matching the same paths"
  description="If multiple patterns match the same paths, the latest one takes preference over the others. That also means that the latest compiler flags will be applied."
/>

### Source file glob

It represents a glob pattern that refers to source files and the compiler flags _(if any)_ to be set in the build phase:

<PropertiesTable
  properties={[
    {
      name: 'Glob',
      description: 'Glob pattern to the source files.',
      type: 'Path',
      typeLink: '#path',
      optional: false,
      default: '',
    },
    {
      name: 'Excluding',
      description: 'Glob patterns for source files that will be excluded.',
      type: '[Path]',
      typeLink: '#path',
      optional: true,
      default: '[]',
    },
    {
      name: 'Compiler flags',
      description:
        'The compiler flags to be set to the source files in the sources build phase.',
      type: 'String',
      optional: true,
      default: 'nil',
    },
  ]}
/>

## Headers

It represents the target headers:

<PropertiesTable
  properties={[
    {
      name: 'Public',
      description: 'Relative glob pattern that points to the public headers',
      type: 'FileList',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Private',
      description: 'Relative glob pattern that points to the private headers',
      type: 'FileList',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Project',
      description: 'Relative glob pattern that points to the project headers',
      type: 'FileList',
      optional: true,
      default: 'nil',
    },
  ]}
/>

## File List

It represents a list of glob patterns that refer to files:

<PropertiesTable
  properties={[
    {
      name: 'Globs',
      description: 'Glob pattern to the files.',
      type: '[Path]',
      typeLink: '#path',
      optional: false,
      default: '',
    },
  ]}
/>

## Core Data Model

The `CoreDataModel` type represents a Core Data model:

<PropertiesTable
  properties={[
    {
      name: 'Path',
      description: 'Relative path to the Core Data model.',
      type: 'Path',
      typeLink: '#path',
      optional: false,
      default: '',
    },
    {
      name: 'Current version',
      description: 'Current version without the extension.',
      type: 'String',
      optional: false,
      default: '',
    },
  ]}
/>

## Platform

The platform type represents the platform a target is built for. It can be any of the following types:

<EnumTable
  cases={[
    {
      case: '.iOS',
      description: 'An iOS platform.',
    },
    {
      case: '.macOS',
      description: 'A macOS platorm.',
    },
    {
      case: '.tvOS',
      description: 'A tvOS platform.',
    },
    {
      case: '.watchOS',
      description: 'A watchOS platform.',
    },
  ]}
/>

## Product

The type of build product this target will output. It can be any of the following types:

<EnumTable
  cases={[
    {
      case: '.app',
      description: 'An application.',
    },
    {
      case: '.staticLibrary',
      description: 'A static library.',
    },
    {
      case: '.dynamicLibrary',
      description: 'A dynamic library.',
    },
    {
      case: '.framework',
      description: 'A dynamic framework.',
    },
    {
      case: '.staticFramework',
      description:
        'A static framework. This is a regular framework product however is configured to be statically linked.',
    },
    {
      case: '.unitTests',
      description: 'A unit tests bundle.',
    },
    {
      case: '.uiTests',
      description: 'A UI tests bundle.',
    },
    {
      case: '.bundle',
      description:
        'A custom bundle. (Currently only iOS resource bundles are supported)',
    },
    {
      case: '.appExtension',
      description: 'An application extension.',
    },
    {
      case: '.stickerPackExtension',
      description: 'A sticker pack extension.',
    },
    {
      case: '.watch2App',
      description: 'A Watch application. (watchOS platform only)',
    },
    {
      case: '.watch2Extension',
      description: 'A Watch application extension. (watchOS platform only)',
    },
    {
      case: '.messagesExtension',
      description: 'An iMessage extension. (iOS platform only)',
    },
  ]}
/>

## InfoPlist

The `InfoPlist` model represents a target `Info.plist` file. It can have any of the following values:<EnumTable
cases={[
{
case: '.file(path: Path)',
description: 'The path to an existing Info.plist file',
},
{
case: '.dictionary([String: InfoPlist.Value])',
description:
'A dictionary with the Info.plist content. Tuist generates the Info.plist file at the generation time.',
},
{
case: '.extendingDefault(with: [String: InfoPlist.Value])',
description:
'It indicates Tuist to provide the default content for the target the InfoPlist belongs to, and extend it with the given values.',
},
]}
/>

<Message
  info
  title="ExpressibleByStringLiteral"
  description="The InfoPlist model conforms the ExpressibleByStringLiteral protocol, which means that it can be initialized with a String. In that case, the string is the path to the Info.plist file."
/>

## InfoPlist.Value

It represents the values of the InfoPlist file dictionary. The reason this type exists is to ensure that the values used to define the content of the dynamically generated `Info.plist` files ar valid:<EnumTable
cases={[
{
case: '.string(String)',
description: 'It represents a string value.',
},
{
case: '.integer(Int)',
description: 'It represents an integer value.',
},
{
case: '.boolean(Bool)',
description: 'It represents a boolean value.',
},
{
case: '.dictionary([String: InfoPlist.Value])',
description: 'It represents a dictionary value.',
},
{
case: '.array([InfoPlist.Value])',
description: 'It represents an array value.',
},
]}
/>

<Message
  info
  title="ExpressiveByLiteral"
  description="`InfoPlist.Value` conforms to the `ExpressiveByLiteral` protocols and therefore, it can be initialized with an instance of the primitive type that they encapsulate."
/>

## Target Action

Target actions, represented as target script build phases, are useful to define actions to be executed before of after the build process of a target.

<EnumTable
  cases={[
    {
      case:
        '.pre(tool: String, arguments: String..., name: String, inputPaths: [Path], inputFileListPaths: [Path], outputPaths: [Path], outputFileListPaths: [Path])',
      description:
        'Action executed before the target-specific build phases where tool is the name of the tool to be executed.',
    },
    {
      case:
        '.pre(path: Path, arguments: String..., name: String, inputPaths: [Path], inputFileListPaths: [Path], outputPaths: [Path], outputFileListPaths: [Path])',
      description:
        'Action executed before the target-specific build phases where path is the path to the tool to be executed.',
    },
    {
      case:
        '.post(tool: String, arguments: String..., name: String, inputPaths: [Path], inputFileListPaths: [Path], outputPaths: [Path], outputFileListPaths: [Path])',
      description:
        'Action executed after all the target-specific build phases where tool is the name of the tool to be executed.',
    },
    {
      case:
        '.post(path: Path, arguments: String..., name: String, inputPaths: [Path], inputFileListPaths: [Path], outputPaths: [Path], outputFileListPaths: [Path])',
      description:
        'Action executed after all the target-specific build phases where path is the path to the tool to be executed.',
    },
  ]}
/>

The following example shows the definition of an action that runs the `my_custom_script.sh` passing the argument `"hello"`:

```swift
.pre(path: "my_custom_script.sh", arguments: ["hello"], name: "My Custom Script Phase")
```

The following example shows the definition of an action that runs the `my_custom_script.sh` defining input and output files:

```swift
.pre(path: "my_custom_script.sh", name: "My Custom Script Phase", inputFileListPaths: [ "Data/Cars.raw.json", "Data/Drivers.raw.json" ], outputFileListPaths: [ "Data/Cars.swift", "Data/Drivers.swift" ])
```

## Preset Build Configuration

It represents the default build configurations available:

<EnumTable
  cases={[
    {
      case: '.debug',
      description:
        'Debug build configuration, traditionally used during local development.',
    },
    {
      case: '.release',
      description: 'Release build configuration.',
    },
  ]}
/>

## Scheme

A `Scheme` defines a collection of targets to `Build, Run, Test, Profile, Analyze and Archive`:<PropertiesTable
properties={[
{
name: 'Name',
description: 'The name of the scheme.',
type: 'String',
optional: false,
default: '',
},
{
name: 'Shared',
description:
'Marks the scheme as shared (i.e. one that is checked in to the repository and is visible to `xcodebuild` from the command line).',
type: 'Bool',
optional: true,
default: 'true',
},
{
name: 'Build action',
description: 'Action that builds the project targets.',
type: 'BuildAction',
typeLink: '#build-action',
optional: true,
default: 'nil',
},
{
name: 'Run action',
description: 'Action that runs project built products.',
type: 'RunAction',
typeLink: '#run-action',
optional: true,
default: 'nil',
},
{
name: 'Test action',
description: 'Action that runs the project tests.',
type: 'TestAction',
typeLink: '#test-action',
optional: true,
default: 'nil',
},
{
name: 'Archive action',
description: 'Action that runs the project archive.',
type: 'ArchiveAction',
typeLink: '#archive-action',
optional: true,
default: 'nil',
},
{
name: 'Profile action',
description: 'Action that profiles the project.',
type: 'ProfileAction',
typeLink: '#profile-action',
optional: true,
default: 'nil',
},
{
name: 'Analyze action',
description: 'Action that analyze the project.',
type: 'AnalyzeAction',
typeLink: '#analyze-action',
optional: true,
default: 'nil',
},
]}
/>

<Message
  info
  title="Auto-generation of schemes"
  description="Tuist will auto-generate a scheme for each target by default in addition to any defined schemes. This however can be disabled if needed via the [Configuration `generationOptions`](/docs/usage/config/#generationoption)."
/>

<Message
  info
  title="Schemes & Configurations"
  description="When generating the default target schemes, the 'Debug' configuration is used for the Run, Test and Analyze actions and the 'Release' configuration is used for the Profile & Archive actions. If those configurations aren't specified, the first (alphabetically ordered) custom configuration with the corresponding variant is selected in their place."
/>

<Message
  info
  title="Extension Schemes"
  description="Schemes for extensions have additional properties and settings, Tuist automatically applies those to any scheme in which the first Target in the Build Action's list of targets is an extension."
/>

### Build Action

It represents the scheme action that builds targets:

<PropertiesTable
  properties={[
    {
      name: 'Targets',
      description:
        'A list of targets to build, which are defined in the Project.',
      type: '[TargetReference]',
      optional: false,
      default: '',
    },
    {
      name: 'Pre-actions',
      description:
        'A list of actions that are executed before starting the build process.',
      type: '[ExecutionAction]',
      typeLink: '#execution-action',
      optional: true,
      default: '[]',
    },
    {
      name: 'Post-actions',
      description:
        'A list of actions that are executed after the build process.',
      type: '[ExecutionAction]',
      typeLink: '#execution-action',
      optional: true,
      default: '[]',
    },
  ]}
/>

### Run action

It represents the scheme action that runs the built products on the supported platforms:

<PropertiesTable
  properties={[
    {
      name: 'Config',
      description:
        'Indicates the build configuration the product should run with.',
      type: 'PresetBuildConfiguration',
      typeLink: '#preset-build-configuration',
      optional: true,
      default: '.debug',
    },
    {
      name: 'Executable',
      description: 'The name of the executable or target to run.',
      type: 'TargetReference',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Arguments',
      description:
        'Commandline arguments passed on launch and environment variables.',
      type: 'Arguments',
      typeLink: '#arguments',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Diagnostics options',
      description: 'List of diagnostics options to set to the action.',
      type: '[SchemeDiagnosticsOption]',
      typeLink: '#scheme-diagnostics-option',
      optional: true,
      default: '[]',
    },
  ]}
/>

Alternatively, when leveraging custom configurations, the configuration name can be explicitly specified:

<PropertiesTable
  properties={[
    {
      name: 'Configuration Name',
      description:
        'Indicates the build configuration the product should run with.',
      type: 'String',
      optional: false,
      default: '',
    },
  ]}
/>

### Test Action

<PropertiesTable
  properties={[
    {
      name: 'Targets',
      description:
        'A list of testable targets, that are targets which are defined in the project with testable information.',
      type: '[TestableTarget]',
      typeLink: '#testableTarget',
      optional: false,
      default: '[]',
    },
    {
      name: 'Arguments',
      description:
        'Commandline arguments passed on launch and environment variables.',
      type: 'Arguments',
      typeLink: '#arguments',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Build configuration',
      description: 'Build configuration to run the test with.',
      type: 'PresetBuildConfiguration',
      typeLink: '#preset-build-configuration',
      optional: true,
      default: '.debug',
    },
    {
      name: 'Coverage',
      description:
        'Whether the scheme should or not gather the test coverage data.',
      type: 'Bool',
      optional: true,
      default: 'false',
    },
    {
      name: 'codeCoverageTargets',
      description:
        'A list of targets you want to gather the test coverage data for them, which are defined in the project.',
      type: '[TargetReference]',
      optional: true,
      default: '[]',
    },
    {
      name: 'Pre-actions',
      description:
        'A list of actions that are executed before starting the tests-run process.',
      type: '[ExecutionAction]',
      typeLink: '#execution-action',
      optional: true,
      default: '[]',
    },
    {
      name: 'Post-actions',
      description:
        'A list of actions that are executed after the tests-run process.',
      type: '[ExecutionAction]',
      typeLink: '#execution-action',
      optional: true,
      default: '[]',
    },
    {
      name: 'Diagnostics options',
      description: 'List of diagnostics options to set to the action.',
      type: '[SchemeDiagnosticsOption]',
      typeLink: '#scheme-diagnostics-option',
      optional: true,
      default: '[]',
    },
    {
      name: 'Language',
      description: 'Language used to run the tests',
      type: 'String?',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Region',
      description: 'Region used to run the tests',
      type: 'String?',
      optional: true,
      default: 'nil',
    },
  ]}
/>

Alternatively, when leveraging custom configurations, the configuration name can be explicitly specified:

<PropertiesTable
  properties={[
    {
      name: 'Configuration Name',
      description: 'Indicates the build configuration to run the test with.',
      type: 'String',
      optional: false,
      default: '',
    },
  ]}
/>

### Execution Action

Scheme run scripts can be defined with the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Title',
      description: 'Name of a script.',
      type: 'String',
      optional: true,
      default: "'Run Stript'",
    },
    {
      name: 'Script text',
      description: 'An inline shell script.',
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'Target',
      description:
        "Name of the build or test target that will provide the action's build settings.",
      type: 'TargetReference',
      optional: true,
      default: 'nil',
    },
  ]}
/>

### TestableTarget

Testable target descibe target and tests information.

<PropertiesTable
  properties={[
    {
      name: 'Target',
      description: 'The target name and its project path.',
      type: 'TargetReference',
      optional: false,
    },
    {
      name: 'Skipped',
      description: 'Skip test target from TestAction.',
      type: 'Bool',
      optional: true,
      default: 'false',
    },
    {
      name: 'Parallelizable',
      description: 'Execute tests in parallel.',
      type: 'Bool',
      optional: true,
      default: 'false',
    },
    {
      name: 'RandomExecutionOrdering',
      description: 'Execute tests in random order.',
      type: 'Bool',
      optional: true,
      default: 'false',
    },
  ]}
/>

### Arguments

Arguments contain commandline arguments passed on launch and Environment variables.

<PropertiesTable
  properties={[
    {
      name: 'Environment',
      description:
        'The environment variables that are passed by the scheme when running a scheme action.',
      type: '[String: String]',
      optional: true,
      default: '[:]',
    },
    {
      name: 'LaunchArguments',
      description:
        "Commandline launch arguments where the key is a launch argument and the value is a boolean indicating if it's enabled.",
      type: '[String: Bool]',
      optional: true,
      default: '[:]',
    },
  ]}
/>

### Scheme Diagnostics Option

Diagnostics options represent the configurable diagnostics-related settings in the schemes' run and test actions.

<EnumTable
  cases={[
    {
      case: '.mainThreadChecker',
      description: 'Enable the main thread checker.',
    },
  ]}
/>

### Archive Action

<PropertiesTable
  properties={[
    {
      name: 'Configuration Name',
      description: 'Indicates the build configuration to run the archive with.',
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'Reveal Archive in Organizer',
      description:
        'If set to true, Xcode will reveal the Organizer on completion.',
      type: 'Bool',
      optional: true,
      default: 'true',
    },
    {
      name: 'Custom Archive Name',
      description: "Set if you want to override Xcode's default archive name.",
      type: 'String',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Pre-actions',
      description:
        'A list of actions that are executed before starting the archive process.',
      type: '[ExecutionAction]',
      optional: true,
      default: '[]',
    },
    {
      name: 'Post-actions',
      description:
        'A list of actions that are executed after the archive process.',
      type: '[ExecutionAction]',
      optional: true,
      default: '[]',
    },
  ]}
/>

### Profile action

It represents the scheme action that profiles the built products on the supported platforms:

<PropertiesTable
  properties={[
    {
      name: 'Config',
      description:
        'Indicates the build configuration the product should be profiled with.',
      type: 'PresetBuildConfiguration',
      typeLink: '#preset-build-configuration',
      optional: true,
      default: '.release',
    },
    {
      name: 'Executable',
      description: 'The name of the executable or target to profile.',
      type: 'TargetReference',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Arguments',
      description:
        'Commandline arguments passed on launch and environment variables.',
      type: 'Arguments',
      typeLink: '#arguments',
      optional: true,
      default: 'nil',
    },
  ]}
/>

Alternatively, when leveraging custom configurations, the configuration name can be explicitly specified:

<PropertiesTable
  properties={[
    {
      name: 'Configuration Name',
      description:
        'Indicates the build configuration the product should be profiled with.',
      type: 'String',
      optional: false,
      default: '',
    },
  ]}
/>

### Analyze action

It represents the scheme action that analyzes the built products:

<PropertiesTable
  properties={[
    {
      name: 'Config',
      description:
        'Indicates the build configuration the product should be analyzed with.',
      type: 'PresetBuildConfiguration',
      typeLink: '#preset-build-configuration',
      optional: true,
      default: '.debug',
    },
  ]}
/>

Alternatively, when leveraging custom configurations, the configuration name can be explicitly specified:

<PropertiesTable
  properties={[
    {
      name: 'Configuration Name',
      description:
        'Indicates the build configuration the product should be analyzed with.',
      type: 'String',
      optional: false,
      default: '',
    },
  ]}
/>

## Settings

A `Settings` object contains an optional dictionary with build settings and relative path to an `.xcconfig` file. It is initialized with the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Base',
      description:
        'A dictionary with build settings that are inherited from all the configurations.',
      type: 'SettingsDictionary',
      typeLink: '#settingsdictionary',
      optional: true,
      default: '[:]',
    },
    {
      name: 'Debug',
      description: 'The debug configuration settings.',
      type: 'Configuration',
      typeLink: '#configuration',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Release',
      description: 'Same as debug but for the release configuration.',
      type: 'Configuration',
      typeLink: '#configuration',
      optional: true,
      default: 'nil',
    },
    {
      name: 'Default settings',
      description: 'An enum specifying the set of default settings.',
      type: 'DefaultSettings',
      typeLink: '#defaultsettings',
      optional: true,
      default: '.recommended',
    },
  ]}
/>

To specify multiple configurations beyond the default Debug and Release configuration _(e.g. Debug, Beta, Release)_, `Settings` can alternatively be initialized with the following attributes:<PropertiesTable
properties={[
{
name: 'Base',
description:
'A dictionary with build settings that are inherited from all the configurations.',
type: 'SettingsDictionary',
typeLink: '#settingsdictionary',
optional: true,
default: '[:]',
},
{
name: 'Configurations',
description: 'A list of custom configurations',
type: '[CustomConfiguration]',
typeLink: '#custom-configuration',
optional: false,
default: '',
},
{
name: 'Default settings',
description: 'An enum specifying the set of default settings.',
type: 'DefaultSettings',
typeLink: '#defaultsettings',
optional: true,
default: '.recommended',
},
]}
/>

<Message
  warning
  title="Custom Configurations"
  description="The list of custom configurations should have unique names and can't be empty. Please use the alternate settings initializer to leverage the default Debug & Release configurations."
/>

### SettingsDictionary

`SettingsDictionary` is a typealias for the `[String: SettingValue]` dictionary, which is used to define a map of `xcodebuild` settings.

Besides the ability to define typed strings for these settings, Tuist has methods to avoid having typos when using strings for the keys. For example, instead of defining your dictionary this way:

```swift
let baseSettings: [String: SettingValue] = [
  "ENABLE_BITCODE": "YES",
  "SWIFT_COMPILATION_MODE": "wholemodule",
]
```

It can be written this way as well:

```swift
let baseSettings = SettingsDictionary()
    .bitcodeEnabled(true)
    .swiftCompilationMode(.wholemodule)
```

<Message
  warning
  title="Dictionary Literal"
  description="When using dictionary literals, it's necessary to set the type of the dictionary to `SettingsDictionary` to satisfy the compiler, as in `let mySettings: SettingsDictionary = [:]` "
/>

Here is the list of functions provided by Tuist:

<SettingsDictionaryTable
  methods={[
    {
      subject: 'Code Signing',
      signature:
        'func manualCodeSigning(identity: String? = nil, provisioningProfileSpecifier: String? = nil) -> SettingsDictionary',
      description:
        'Sets `"CODE_SIGN_STYLE"` to `"Manual"`, `"CODE_SIGN_IDENTITY"` to `identity`, and `"PROVISIONING_PROFILE_SPECIFIER"` to `provisioningProfileSpecifier`',
    },
    {
      subject: 'Code Signing',
      signature:
        'func automaticCodeSigning(devTeam: String) -> SettingsDictionary',
      description:
        'Sets `"CODE_SIGN_STYLE"` to `"Automatic"` and `"DEVELOPMENT_TEAM"` to `devTeam`',
    },
    {
      subject: 'Code Signing',
      signature:
        'func codeSignIdentityAppleDevelopment() -> SettingsDictionary',
      description: 'Sets `"CODE_SIGN_IDENTITY"` to `"Apple Development"`',
    },
    {
      subject: 'Code Signing',
      signature:
        'func codeSignIdentity(_ identity: String) -> SettingsDictionary',
      description: 'Sets `"CODE_SIGN_IDENTITY"` to `identity`',
    },
    {
      subject: 'Versioning',
      signature:
        'func currentProjectVersion(_ version: String) -> SettingsDictionary',
      description: 'Sets `"CURRENT_PROJECT_VERSION"` to `version`',
    },
    {
      subject: 'Versioning',
      signature: 'func appleGenericVersioningSystem() -> SettingsDictionary',
      description: 'Sets `"VERSIONING_SYSTEM"` to `"apple-generic"`',
    },
    {
      subject: 'Versioning',
      signature:
        'func versionInfo(_ version: String, prefix: String? = nil, suffix: String? = nil) -> SettingsDictionary',
      description:
        'Sets `"VERSION_INFO_PREFIX"` to `version`. If `prefix` and `suffix` are not `nil`, they\'re used as `"VERSION_INFO_PREFIX"` and `"VERSION_INFO_SUFFIX"` respectively.',
    },
    {
      subject: 'Swift Settings',
      signature: 'func swiftVersion(_ version: String) -> SettingsDictionary',
      description: 'Sets `"SWIFT_VERSION"` to `version`',
    },
    {
      subject: 'Swift Settings',
      signature:
        'func otherSwiftFlags(_ flags: String...) -> SettingsDictionary',
      description: 'Sets `"OTHER_SWIFT_FLAGS"` to `flags`',
    },
    {
      subject: 'Swift Settings',
      signature:
        'func swiftCompilationMode(_ mode: SwiftCompilationMode) -> SettingsDictionary',
      description:
        'Sets `"SWIFT_COMPILATION_MODE"` to the available `SwiftCompilationMode` (`"singlefile"` or `"wholemodule"`)',
    },
    {
      subject: 'Swift Settings',
      signature:
        'func swiftOptimizationLevel(_ level: SwiftOptimizationLevel) -> SettingsDictionary',
      description:
        'Sets `"SWIFT_OPTIMIZATION_LEVEL"` to the available `SwiftOptimizationLevel` (`"-O"`, `"-Onone"` or `"-Osize"`)',
    },
    {
      subject: 'Bitcode',
      signature: 'func bitcodeEnabled(_ enabled: Bool) -> SettingsDictionary',
      description: 'Sets `"ENABLE_BITCODE"` to `"YES"` or `"NO"`',
    },
  ]}
/>

Notice that you don't depend exclusively on Tuist's built-in functions.
You can create your own `SettingsDictionary` extension methods and add them to your
[Project description helpers](/docs/usage/helpers/) this way:

```swift
public extension SettingsDictionary {
  func setSomeBuildSetting(_ value: String) -> SettingsDictionary {
      merging(["SOME_BUILD_SETTING": SettingValue(stringLiteral: value)])
  }
}
```

## Configuration

A `Configuration` object describes the build settings and the `.xcconfig` file of a project or target. It is initialized with the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Settings',
      description: 'A dictionary that contains the build settings',
      type: 'SettingsDictionary',
      typeLink: '#settingsdictionary',
      optional: true,
      default: '[:]',
    },
    {
      name: 'Path',
      description: 'The path to the xcconfig file',
      type: 'Path',
      typeLink: '#path',
      optional: true,
      default: 'nil',
    },
  ]}
/>

## Custom Configuration

A `CustomConfiguration` allows specifying a named build configuration.

This is similar to `Configuration`, however allows specifying a custom name (e.g. "Beta") and configuration variant (`.debug` or `.release`) to help Tuist select the most appropriate default build settings.

For example, a `.debug` configuration would get `SWIFT_OPTIMIZATION_LEVEL = -Onone` whereas a `.release` would get `SWIFT_OPTIMIZATION_LEVEL = -Owholemodule`.

<EnumTable
  cases={[
    {
      case:
        '.debug(name: String, settings: SettingsDictionary, xcconfig: Path?)',
      description: 'A custom debug configuration',
    },
    {
      case:
        '.release(name: String, settings: SettingsDictionary, xcconfig: Path?)',
      description: 'A custom release configuration',
    },
  ]}
/>

### SettingValue

A `SettingValue` can be one of the following options:

<EnumTable
  cases={[
    {
      case: '.string(String)',
      description: 'A single setting value for example "DEBUG=1".',
    },
    {
      case: '.array([String])',
      description:
        'Multi-value setting value for example ["$(inherited)", "DEBUG=1"].',
    },
  ]}
/>

It conforms the `ExpressibleByStringLiteral` and `ExpressibleByArrayLiteral` protocols and therefore it can be initialized with a string or an array directly.

## FileElement

A `FileElement` can be one of the following options:

<EnumTable
  cases={[
    {
      case: '.glob(pattern: Path)',
      description:
        'A file path (or glob pattern) to include. For convenience, a string literal can be used as an alternate way to specify this option.',
    },
    {
      case: '.folderReference(path: Path)',
      description: 'A directory path to include as a folder reference.',
    },
  ]}
/>

## DefaultSettings

A `DefaultSettings` can be one of the following options:<EnumTable
cases={[
{
case: '.recommended',
description:
'Recommented settings including warning flags to help you catch some of the bugs at the early stage of development.',
},
{
case: '.essential',
description:
"A minimal set of settings to make the project compile without any additional settings for example `'PRODUCT_NAME'` or `'TARGETED_DEVICE_FAMILY'`.",
},
{
case: '.none',
description:
"Tuist won't generate any build settings for the target or project.",
},
]}
/>

<Message
  info
  title="Essential Settings"
  description="The .essential option can be used in the event all warnings are defined in an `xcconfig` file to prevent Tuist from overriding them at the project or target level."
/>
<Message
  warning
  title="None settings"
  description="Projects may fail to compile if some essential settings are missing. Use .none only if you are specifying all the necessary build settings manually or via xcconfig files."
/>

## Deployment Target

The `DeploymentTarget` model represents the minimum operating system version your product will support. It can have any of the following values:

<EnumTable
  cases={[
    {
      case: '.iOS(targetVersion: String, devices: DeploymentDevice)',
      description:
        'The minimum iOS version and the list of devices your product will support.',
    },
    {
      case: '.macOS(targetVersion: String)',
      description: 'The minimum macOS version your product will support.',
    },
  ]}
/>

## Deployment Device

The `DeploymentDevice` model represents the device your product will support. It can have any of the following values:

<EnumTable
  cases={[
    {
      case: '.iphone',
      description: 'An iPhone device.',
    },
    {
      case: '.ipad',
      description: 'An iPad device.',
    },
    {
      case: '.mac',
      description: 'A mac device.',
    },
  ]}
/>

# Workspace.swift

By default, `tuist generate` generates an Xcode workspace that has the same name as the current project. It includes the project and all its dependencies. Tuist allows customizing this behaviour by defining a workspace manifest within a `Workspace.swift` file.

Workspace manifests allow specifying a list of projects to generate and include in an Xcode workspace. Those projects don’t necessarily have to depend on one another.

Additionally, files and folder references _(such as documentation files)_ can be included in a workspace manifest.

The snippet below shows an example workspace manifest:

```swift
import ProjectDescription

let workspace = Workspace(name: "CustomWorkspace",
                          projects: [
                            "App",
                            "Modules/**"
                          ],
                          schemes: [
                            Scheme(name: "Workspace-App",
                                   shared: true,
                                   buildAction: BuildAction(targets: [.project(path: "App", target: "App")], preActions: []),
                                   testAction: TestAction(targets: [TestableTarget(target: .project(path: "App", target: "AppTests"))]),
                                   runAction: RunAction(executable: .project(path: "App", target: "App")),
                                   archiveAction: ArchiveAction(configurationName: "Debug", customArchiveName: "Something2"))
                          ],
                          additionalFiles: [
                            "Documentation/**",
                            .folderReference(path: "Website")
                          ])
```

A `Workspace.swift` file can reside in any directory (including a project directory).

## Workspace

A `Workspace.swift` should initialize a variable of type `Workspace`. It can take any name, although we recommend to stick to `workspace`. A workspace accepts the following attributes:

<PropertiesTable
  properties={[
    {
      name: 'Name',
      description:
        'Name of the workspace. It’s used to determine the name of the generated Xcode workspace.',
      type: 'String',
      optional: false,
      default: '',
    },
    {
      name: 'Projects',
      description:
        'List of paths (or glob patterns) to projects to generate and include within the generated Xcode workspace.',
      type: '[Path]',
      typeLink: '#path',
      optional: false,
      default: '',
    },
    {
      name: 'Schemes',
      description: 'List of custom schemes to include in the workspace',
      type: '[Scheme]',
      typeLink: '#scheme',
      optional: true,
      default: '[]',
    },
    {
      name: 'AdditionalFiles',
      description:
        "List of files to include in the workspace - these won't be included in any of the projects or their build phases.",
      type: '[FileElement]',
      typeLink: '#fileelement',
      optional: true,
      default: '[]',
    },
  ]}
/>

## Path

A path represents a path to a file, directory, or a group of files represented by a glob expression. Paths can be relative and absolute. We **discourage** using absolute paths because they create a dependency with the environment where they are defined.<EnumTable
cases={[
{
case: '.relativeToCurrentFile(String)',
description:
'Initialize a path that is relative to the file that defines the path.',
},
{
case: '.relativeToManifest(String)',
description:
'Initialize a path that is relative to the directory that contains the manifest file being loaded, for example the directory that contains the Project.swift file.',
},
{
case: '.relativeToRoot(String)',
description:
'Initialize a path that is relative to the closest directory that contains a Tuist or a .git directory.',
},
]}
/>

<Message
  info
  title="ExpressibleByStringLiteral"
  description="The path can be initialized with a plain string. It's equivalent to using `.relativeToManifest.` except when the path starts with `//`, in which case the path is considered relative to the root directory."
/>

## Target Reference

A target within a specified project. The project is specified through the path and should contain the target name.

<PropertiesTable
  properties={[
    {
      name: 'path',
      description: "Path to the target's project directory.",
      type: 'Path',
      typeLink: '#path',
      optional: true,
      default: 'Workspace or project path.',
    },
    {
      name: 'name',
      description: 'Name of the target.',
      type: 'String',
      optional: false,
    },
  ]}
/>
