import Foundation
import TSCBasic
import TuistCore
import XCTest

@testable import TuistGenerator
@testable import TuistSupport
@testable import TuistSupportTesting

final class AutogeneratedSchemesGraphMapperTests: TuistUnitTestCase {
    var subject: AutogeneratedSchemesGraphMapper!

    override func setUp() {
        super.setUp()
        subject = AutogeneratedSchemesGraphMapper()
    }

    override func tearDown() {
        super.tearDown()
        subject = nil
    }

    func test_map() throws {
        // Given
        let targetA = Target.test(name: "A")
        let targetB = Target.test(name: "B", product: .unitTests)
        let project = Project.test(targets: [targetA, targetB])
        let targetANode = TargetNode.test(project: project, target: targetA)
        let targetBNode = TargetNode.test(project: project, target: targetB, dependencies: [targetANode])
        let graph = Graph.test(projects: [project], targets: [
            project.path: [targetANode, targetBNode],
        ])

        // When
        let (got, sideEffects) = try subject.map(graph: graph)

        // Then
        XCTAssertEmpty(sideEffects)
        let gotProject = try XCTUnwrap(got.projects.first)
        XCTAssertEqual(gotProject.schemes.count, 2)

        // Then: A
        let aScheme = gotProject.schemes.first!
        XCTAssertEqual(aScheme.name, targetA.name)
        let aBuildAction = try XCTUnwrap(aScheme.buildAction)
        XCTAssertEqual(aBuildAction.targets.count, 1)
        let aBuildTargetReference = try XCTUnwrap(aBuildAction.targets.first)
        XCTAssertEqual(aBuildTargetReference.projectPath, project.path)
        XCTAssertEqual(aBuildTargetReference.name, targetA.name)

        // Then: A tests
        // Since B is a tests bundle with a dependency on A,
        // there should be a test action in A scheme to run the tests in B
        let aTestAction = try XCTUnwrap(aScheme.testAction)
        XCTAssertEqual(aTestAction.targets.count, 1)
        let aTestTargetReference = try XCTUnwrap(aTestAction.targets.first?.target)
        XCTAssertEqual(aTestTargetReference.projectPath, project.path)
        XCTAssertEqual(aTestTargetReference.name, targetB.name)

        // Then: B
        let bScheme = gotProject.schemes.last!
        XCTAssertEqual(bScheme.name, targetB.name)
        let bBuildAction = try XCTUnwrap(bScheme.buildAction)
        XCTAssertEqual(bBuildAction.targets.count, 1)
        let bBuildTargetReference = try XCTUnwrap(bBuildAction.targets.first)
        XCTAssertEqual(bBuildTargetReference.projectPath, project.path)
        XCTAssertEqual(bBuildTargetReference.name, targetB.name)
        let bTestAction = try XCTUnwrap(bScheme.testAction)
        XCTAssertEqual(bTestAction.targets.count, 1)
        let bTestTargetReference = try XCTUnwrap(bTestAction.targets.first?.target)
        XCTAssertEqual(bTestTargetReference.projectPath, project.path)
        XCTAssertEqual(bTestTargetReference.name, targetB.name)
    }

    func test_map_doesnt_override_user_schemes() throws {
        // Given
        let targetA = Target.test(name: "A")
        let aScheme = Scheme.test(name: "A",
                                  shared: true,
                                  buildAction: nil,
                                  testAction: nil,
                                  runAction: nil,
                                  archiveAction: nil,
                                  profileAction: nil,
                                  analyzeAction: nil)
        let project = Project.test(targets: [targetA],
                                   schemes: [aScheme])
        let targetANode = TargetNode.test(project: project, target: targetA)
        let graph = Graph.test(projects: [project], targets: [
            project.path: [targetANode],
        ])

        // When
        let (got, sideEffects) = try subject.map(graph: graph)

        // Then
        XCTAssertEmpty(sideEffects)
        let gotProject = try XCTUnwrap(got.projects.first)
        XCTAssertEqual(gotProject.schemes.count, 1)

        // Then: A
        let gotAScheme = gotProject.schemes.first!
        XCTAssertNil(gotAScheme.buildAction)
    }
}
