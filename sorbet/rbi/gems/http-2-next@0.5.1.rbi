# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `http-2-next` gem.
# Please instead update this file by running `bin/tapioca gem http-2-next`.

# The following task generates this file.
#   rake generate_huffman_table
#
# source://http-2-next//lib/http/2/next/version.rb#3
module HTTP2Next; end

# Default connection "fast-fail" preamble string as defined by the spec.
#
# source://http-2-next//lib/http/2/next/connection.rb#36
HTTP2Next::CONNECTION_PREFACE_MAGIC = T.let(T.unsafe(nil), String)

# HTTP 2.0 client connection class that implements appropriate header
# compression / decompression algorithms and stream management logic.
#
# Your code is responsible for driving the client object, which in turn
# performs all of the necessary HTTP 2.0 encoding / decoding, state
# management, and the rest. A simple example:
#
# @example
#   socket = YourTransport.new
#
#   conn = HTTP2Next::Client.new
#   conn.on(:frame) {|bytes| socket << bytes }
#
#   while bytes = socket.read
#   conn << bytes
#   end
#
# source://http-2-next//lib/http/2/next/client.rb#21
class HTTP2Next::Client < ::HTTP2Next::Connection
  # Initialize new HTTP 2.0 client object.
  #
  # @return [Client] a new instance of Client
  #
  # source://http-2-next//lib/http/2/next/client.rb#23
  def initialize(settings = T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/client.rb#43
  def receive(frame); end

  # Send an outgoing frame. Connection and stream flow control is managed
  # by Connection class.
  #
  # @param frame [Hash]
  # @see Connection
  #
  # source://http-2-next//lib/http/2/next/client.rb#38
  def send(frame); end

  # Emit the connection preface if not yet
  #
  # source://http-2-next//lib/http/2/next/client.rb#60
  def send_connection_preface; end

  # sends the preface and initializes the first stream in half-closed state
  #
  # @raise [ProtocolError]
  #
  # source://http-2-next//lib/http/2/next/client.rb#49
  def upgrade; end

  private

  # source://http-2-next//lib/http/2/next/client.rb#77
  def verify_pseudo_headers(frame); end

  class << self
    # source://http-2-next//lib/http/2/next/client.rb#70
    def settings_header(settings); end
  end
end

# Connection encapsulates all of the connection, stream, flow-control,
# error management, and other processing logic required for a well-behaved
# HTTP 2.0 endpoint.
#
# Note that this class should not be used directly. Instead, you want to
# use either Client or Server class to drive the HTTP 2.0 exchange.
#
#
# source://http-2-next//lib/http/2/next/connection.rb#49
class HTTP2Next::Connection
  include ::HTTP2Next::Error
  include ::HTTP2Next::FlowBuffer
  include ::HTTP2Next::Emitter

  # Initializes new connection object.
  #
  # @return [Connection] a new instance of Connection
  #
  # source://http-2-next//lib/http/2/next/connection.rb#81
  def initialize(settings = T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/connection.rb#401
  def <<(data); end

  # Number of active streams between client and server (reserved streams
  # are not counted towards the stream limit).
  #
  # source://http-2-next//lib/http/2/next/connection.rb#74
  def active_stream_count; end

  # @return [Boolean]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#112
  def closed?; end

  # Sends a GOAWAY frame indicating that the peer should stop creating
  # new streams for current connection.
  #
  # Endpoints MAY append opaque data to the payload of any GOAWAY frame.
  # Additional debug data is intended for diagnostic purposes only and
  # carries no semantic value. Debug data MUST NOT be persistently stored,
  # since it could contain sensitive information.
  #
  # @param error [Symbol]
  # @param payload [String]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#155
  def goaway(error = T.unsafe(nil), payload = T.unsafe(nil)); end

  # Current settings value for local and peer
  #
  # source://http-2-next//lib/http/2/next/connection.rb#66
  def local_settings; end

  # Size of current connection flow control window (by default, set to
  # infinity, but is automatically updated on receipt of peer settings).
  #
  # source://http-2-next//lib/http/2/next/connection.rb#61
  def local_window; end

  # Max number of streams that can be in-transit in this connection.
  #
  # source://http-2-next//lib/http/2/next/connection.rb#77
  def max_streams=(_arg0); end

  # Allocates new stream for current connection.
  #
  # @param priority [Integer]
  # @param window [Integer]
  # @param parent [Stream]
  # @raise [ConnectionClosed]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#121
  def new_stream(**args); end

  # Pending settings value
  #  Sent but not ack'ed settings
  #
  # source://http-2-next//lib/http/2/next/connection.rb#70
  def pending_settings; end

  # Sends PING frame to the peer.
  #
  # @param payload [String] optional payload must be 8 bytes long
  # @param blk [Proc] callback to execute when PONG is received
  #
  # source://http-2-next//lib/http/2/next/connection.rb#140
  def ping(payload, &blk); end

  # Decodes incoming bytes into HTTP 2.0 frames and routes them to
  # appropriate receivers: connection frames are handled directly, and
  # stream frames are passed to appropriate stream objects.
  #
  # @param data [String] Binary encoded string
  #
  # source://http-2-next//lib/http/2/next/connection.rb#193
  def receive(data); end

  # Returns the value of attribute remote_settings.
  #
  # source://http-2-next//lib/http/2/next/connection.rb#62
  def remote_settings; end

  # Returns the value of attribute remote_window.
  #
  # source://http-2-next//lib/http/2/next/connection.rb#62
  def remote_window; end

  # Sends a connection SETTINGS frame to the peer.
  # The values are reflected when the corresponding ACK is received.
  #
  # @param settings [Array or Hash]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#180
  def settings(payload); end

  # Connection state (:new, :closed).
  #
  # source://http-2-next//lib/http/2/next/connection.rb#57
  def state; end

  # Size of current connection flow control window (by default, set to
  # infinity, but is automatically updated on receipt of peer settings).
  #
  # source://http-2-next//lib/http/2/next/connection.rb#61
  def window; end

  # Sends a WINDOW_UPDATE frame to the peer.
  #
  # @param increment [Integer]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#171
  def window_update(increment); end

  private

  # source://http-2-next//lib/http/2/next/connection.rb#764
  def _verify_pseudo_headers(frame, mandatory_headers); end

  # Activates new incoming or outgoing stream and registers appropriate
  # connection managemet callbacks.
  #
  # @param id [Integer]
  # @param priority [Integer]
  # @param window [Integer]
  # @param parent [Stream]
  # @raise [StreamLimitExceeded]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#727
  def activate_stream(id:, **args); end

  # Emit GOAWAY error indicating to peer that the connection is being
  # aborted, and once sent, raise a local exception.
  #
  # @option error
  # @option error
  # @option error
  # @option error
  # @option error
  # @option error
  # @param error [Symbol]
  # @param msg [String]
  # @raise []
  #
  # source://http-2-next//lib/http/2/next/connection.rb#790
  def connection_error(error = T.unsafe(nil), msg: T.unsafe(nil), e: T.unsafe(nil)); end

  # Check if frame is a connection frame: SETTINGS, PING, GOAWAY, and any
  # frame addressed to stream ID = 0.
  #
  # @param frame [Hash]
  # @return [Boolean]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#450
  def connection_frame?(frame); end

  # Process received connection frame (stream ID = 0).
  # - Handle SETTINGS updates
  # - Connection flow control (WINDOW_UPDATE)
  # - Emit PONG auto-reply to PING frames
  # - Mark connection as closed on GOAWAY
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#464
  def connection_management(frame); end

  # Update connection settings based on parameters set by the peer.
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#579
  def connection_settings(frame); end

  # Decode headers payload and update connection decompressor state.
  #
  # The receiver endpoint reassembles the header block by concatenating
  # the individual fragments, then decompresses the block to reconstruct
  # the header set - aka, header payloads are buffered until END_HEADERS,
  # or an END_PROMISE flag is seen.
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#676
  def decode_headers(frame); end

  # Applies HTTP 2.0 binary encoding to the frame.
  #
  # @param frame [Hash]
  # @return [Array of Buffer] encoded frame
  #
  # source://http-2-next//lib/http/2/next/connection.rb#435
  def encode(frame); end

  # Encode headers payload and update connection compressor state.
  #
  # @param frame [Hash]
  # @return [Array of Frame]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#690
  def encode_headers(frame); end

  # Emit GOAWAY error indicating to peer that the connection is being
  # aborted, and once sent, raise a local exception.
  #
  # @option error
  # @option error
  # @option error
  # @option error
  # @option error
  # @option error
  # @param error [Symbol]
  # @param msg [String]
  # @raise []
  #
  # source://http-2-next//lib/http/2/next/connection.rb#790
  def error(error = T.unsafe(nil), msg: T.unsafe(nil), e: T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/connection.rb#801
  def manage_state(_); end

  # source://http-2-next//lib/http/2/next/connection.rb#516
  def ping_management(frame); end

  # Send an outgoing frame. DATA frames are subject to connection flow
  # control and may be split and / or buffered based on current window size.
  # All other frames are sent immediately.
  #
  # @note all frames are currently delivered in FIFO order.
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/connection.rb#413
  def send(frame); end

  # Validate settings parameters.  See sepc Section 6.5.2.
  #
  # @param role [Symbol] The sender's role: :client or :server
  # @return nil if no error.  Exception object in case of any error.
  #
  # source://http-2-next//lib/http/2/next/connection.rb#529
  def validate_settings(role, settings); end

  # source://http-2-next//lib/http/2/next/connection.rb#757
  def verify_stream_order(id); end
end

# source://http-2-next//lib/http/2/next/connection.rb#23
HTTP2Next::DEFAULT_CONNECTION_SETTINGS = T.let(T.unsafe(nil), Hash)

# Default connection and stream flow control window (64KB).
#
# source://http-2-next//lib/http/2/next/connection.rb#5
HTTP2Next::DEFAULT_FLOW_WINDOW = T.let(T.unsafe(nil), Integer)

# Default header table size
#
# source://http-2-next//lib/http/2/next/connection.rb#8
HTTP2Next::DEFAULT_HEADER_SIZE = T.let(T.unsafe(nil), Integer)

# Default stream_limit
#
# source://http-2-next//lib/http/2/next/connection.rb#11
HTTP2Next::DEFAULT_MAX_CONCURRENT_STREAMS = T.let(T.unsafe(nil), Integer)

# Default stream priority (lower values are higher priority).
#
# source://http-2-next//lib/http/2/next/connection.rb#33
HTTP2Next::DEFAULT_WEIGHT = T.let(T.unsafe(nil), Integer)

# Basic event emitter implementation with support for persistent and
# one-time event callbacks.
#
# source://http-2-next//lib/http/2/next/emitter.rb#7
module HTTP2Next::Emitter
  # Emit event with provided arguments.
  #
  # @param event [Symbol]
  # @param args [Array] arguments to be passed to the callbacks
  # @param block [Proc] callback function
  #
  # source://http-2-next//lib/http/2/next/emitter.rb#34
  def emit(event, *args, &block); end

  # Subscribe to all future events for specified type.
  #
  # @param event [Symbol]
  # @param block [Proc] callback function
  # @raise [ArgumentError]
  #
  # source://http-2-next//lib/http/2/next/emitter.rb#12
  def on(event, &block); end

  # Subscribe to next event (at most once) for specified type.
  #
  # @param event [Symbol]
  # @param block [Proc] callback function
  #
  # source://http-2-next//lib/http/2/next/emitter.rb#22
  def once(event, &block); end

  private

  # source://http-2-next//lib/http/2/next/emitter.rb#42
  def listeners(event); end
end

# Stream, connection, and compressor exceptions.
#
# source://http-2-next//lib/http/2/next/error.rb#5
module HTTP2Next::Error
  class << self
    # Returns the value of attribute types.
    #
    # source://http-2-next//lib/http/2/next/error.rb#9
    def types; end
  end
end

# Raised on any header encoding / decoding exception.
#
# @see ProtocolError
#
# source://http-2-next//lib/http/2/next/error.rb#38
class HTTP2Next::Error::CompressionError < ::HTTP2Next::Error::ProtocolError; end

# Raised if connection has been closed (or draining) and new stream
# cannot be opened.
#
# source://http-2-next//lib/http/2/next/error.rb#58
class HTTP2Next::Error::ConnectionClosed < ::HTTP2Next::Error::Error; end

# source://http-2-next//lib/http/2/next/error.rb#12
class HTTP2Next::Error::Error < ::StandardError
  class << self
    # @private
    #
    # source://http-2-next//lib/http/2/next/error.rb#13
    def inherited(klass); end
  end
end

# Raised on invalid flow control frame or command.
#
# @see ProtocolError
#
# source://http-2-next//lib/http/2/next/error.rb#43
class HTTP2Next::Error::FlowControlError < ::HTTP2Next::Error::ProtocolError; end

# source://http-2-next//lib/http/2/next/error.rb#63
class HTTP2Next::Error::FrameSizeError < ::HTTP2Next::Error::Error; end

# Raised if connection header is missing or invalid indicating that
# this is an invalid HTTP 2.0 request - no frames are emitted and the
# connection must be aborted.
#
# source://http-2-next//lib/http/2/next/error.rb#28
class HTTP2Next::Error::HandshakeError < ::HTTP2Next::Error::Error; end

# Raised on invalid stream processing: invalid frame type received or
# sent, or invalid command issued.
#
# source://http-2-next//lib/http/2/next/error.rb#47
class HTTP2Next::Error::InternalError < ::HTTP2Next::Error::ProtocolError; end

# Raised by stream or connection handlers, results in GOAWAY frame
# which signals termination of the current connection. You *cannot*
# recover from this exception, or any exceptions subclassed from it.
#
# source://http-2-next//lib/http/2/next/error.rb#33
class HTTP2Next::Error::ProtocolError < ::HTTP2Next::Error::Error; end

# Raised if stream has been closed and new frames cannot be sent.
#
# source://http-2-next//lib/http/2/next/error.rb#54
class HTTP2Next::Error::StreamClosed < ::HTTP2Next::Error::Error; end

# Raised if stream limit has been reached and new stream cannot be opened.
#
# source://http-2-next//lib/http/2/next/error.rb#61
class HTTP2Next::Error::StreamLimitExceeded < ::HTTP2Next::Error::Error; end

# Implementation of stream and connection DATA flow control: frames may
# be split and / or may be buffered based on current flow control window.
#
# source://http-2-next//lib/http/2/next/flow_buffer.rb#7
module HTTP2Next::FlowBuffer
  include ::HTTP2Next::Error

  # Amount of buffered data. Only DATA payloads are subject to flow stream
  # and connection flow control.
  #
  # @return [Integer]
  #
  # source://http-2-next//lib/http/2/next/flow_buffer.rb#16
  def buffered_amount; end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#20
  def flush; end

  private

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#36
  def calculate_window_update(window_max_size); end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#90
  def process_window_update(frame:, encode: T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#26
  def send_buffer; end

  # Buffers outgoing DATA frames and applies flow control logic to split
  # and emit DATA frames based on current flow control window. If the
  # window is large enough, the data is sent immediately. Otherwise, the
  # data is buffered until the flow control window is updated.
  #
  # Buffered DATA frames are emitted in FIFO order.
  #
  # @param frame [Hash]
  # @param encode [Boolean] set to true by connection
  #
  # source://http-2-next//lib/http/2/next/flow_buffer.rb#71
  def send_data(frame = T.unsafe(nil), encode = T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#30
  def update_local_window(frame); end
end

# source://http-2-next//lib/http/2/next/flow_buffer.rb#10
HTTP2Next::FlowBuffer::MAX_WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/flow_buffer.rb#103
class HTTP2Next::FrameBuffer
  # @return [FrameBuffer] a new instance of FrameBuffer
  #
  # source://http-2-next//lib/http/2/next/flow_buffer.rb#106
  def initialize; end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#111
  def <<(frame); end

  # Returns the value of attribute bytesize.
  #
  # source://http-2-next//lib/http/2/next/flow_buffer.rb#104
  def bytesize; end

  # @return [Boolean]
  #
  # source://http-2-next//lib/http/2/next/flow_buffer.rb#116
  def empty?; end

  # source://http-2-next//lib/http/2/next/flow_buffer.rb#120
  def retrieve(window_size); end
end

# Performs encoding, decoding, and validation of binary HTTP/2 frames.
#
# source://http-2-next//lib/http/2/next/framer.rb#6
class HTTP2Next::Framer
  include ::HTTP2Next::Error

  # Initializes new framer object.
  #
  # @return [Framer] a new instance of Framer
  #
  # source://http-2-next//lib/http/2/next/framer.rb#116
  def initialize(local_max_frame_size = T.unsafe(nil), remote_max_frame_size = T.unsafe(nil)); end

  # Generates common 9-byte frame header.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-4.1
  #
  # @param frame [Hash]
  # @raise [CompressionError]
  # @return [String]
  #
  # source://http-2-next//lib/http/2/next/framer.rb#127
  def common_header(frame); end

  # Generates encoded HTTP/2 frame.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/framer.rb#180
  def generate(frame); end

  # maximum frame size
  #
  # source://http-2-next//lib/http/2/next/framer.rb#15
  def local_max_frame_size; end

  # maximum frame size
  #
  # source://http-2-next//lib/http/2/next/framer.rb#15
  def local_max_frame_size=(_arg0); end

  # Decodes complete HTTP/2 frame from provided buffer. If the buffer
  # does not contain enough data, no further work is performed.
  #
  # @param buf [Buffer]
  # @raise [ProtocolError]
  #
  # source://http-2-next//lib/http/2/next/framer.rb#339
  def parse(buf); end

  # Decodes common 9-byte header.
  #
  # @param buf [Buffer]
  # @return [Hash] the corresponding frame
  #
  # source://http-2-next//lib/http/2/next/framer.rb#160
  def read_common_header(buf); end

  # maximum frame size
  #
  # source://http-2-next//lib/http/2/next/framer.rb#15
  def remote_max_frame_size; end

  # maximum frame size
  #
  # source://http-2-next//lib/http/2/next/framer.rb#15
  def remote_max_frame_size=(_arg0); end

  private

  # source://http-2-next//lib/http/2/next/framer.rb#459
  def pack_error(error); end

  # source://http-2-next//lib/http/2/next/framer.rb#469
  def unpack_error(error); end
end

# Default value of max frame size (16384 bytes)
#
# source://http-2-next//lib/http/2/next/framer.rb#12
HTTP2Next::Framer::DEFAULT_MAX_FRAME_SIZE = T.let(T.unsafe(nil), Integer)

# Default error types as defined by the spec
#
# source://http-2-next//lib/http/2/next/framer.rb#85
HTTP2Next::Framer::DEFINED_ERRORS = T.let(T.unsafe(nil), Hash)

# Default settings as defined by the spec
#
# source://http-2-next//lib/http/2/next/framer.rb#75
HTTP2Next::Framer::DEFINED_SETTINGS = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/framer.rb#104
HTTP2Next::Framer::EBIT = T.let(T.unsafe(nil), Integer)

# Per frame flags as defined by the spec
#
# source://http-2-next//lib/http/2/next/framer.rb#42
HTTP2Next::Framer::FRAME_FLAGS = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/framer.rb#109
HTTP2Next::Framer::FRAME_LENGTH_HISHIFT = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/framer.rb#110
HTTP2Next::Framer::FRAME_LENGTH_LOMASK = T.let(T.unsafe(nil), Integer)

# HTTP/2 frame type mapping as defined by the spec
#
# source://http-2-next//lib/http/2/next/framer.rb#24
HTTP2Next::Framer::FRAME_TYPES = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/framer.rb#39
HTTP2Next::Framer::FRAME_TYPES_WITH_PADDING = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/framer.rb#108
HTTP2Next::Framer::HEADERPACK = T.let(T.unsafe(nil), String)

# Maximum stream ID (2^31)
#
# source://http-2-next//lib/http/2/next/framer.rb#18
HTTP2Next::Framer::MAX_STREAM_ID = T.let(T.unsafe(nil), Integer)

# Maximum window increment value (2^31)
#
# source://http-2-next//lib/http/2/next/framer.rb#21
HTTP2Next::Framer::MAX_WINDOWINC = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/framer.rb#102
HTTP2Next::Framer::RBIT = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/framer.rb#103
HTTP2Next::Framer::RBYTE = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/framer.rb#106
HTTP2Next::Framer::UINT16 = T.let(T.unsafe(nil), String)

# source://http-2-next//lib/http/2/next/framer.rb#105
HTTP2Next::Framer::UINT32 = T.let(T.unsafe(nil), String)

# source://http-2-next//lib/http/2/next/framer.rb#107
HTTP2Next::Framer::UINT8 = T.let(T.unsafe(nil), String)

# Implementation of header compression for HTTP 2.0 (HPACK) format adapted
# to efficiently represent HTTP headers in the context of HTTP 2.0.
#
# - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10
#
# source://http-2-next//lib/http/2/next/header.rb#8
module HTTP2Next::Header; end

# Responsible for encoding header key-value pairs using HPACK algorithm.
#
# source://http-2-next//lib/http/2/next/header/compressor.rb#6
class HTTP2Next::Header::Compressor
  # @param options [Hash] encoding options
  # @return [Compressor] a new instance of Compressor
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#8
  def initialize(options = T.unsafe(nil)); end

  # Encodes provided list of HTTP headers.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Buffer]
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#124
  def encode(headers); end

  # Encodes header command with appropriate header representation.
  #
  # @param h [Hash] header command
  # @param buffer [String]
  # @return [Buffer]
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#94
  def header(h, buffer = T.unsafe(nil)); end

  # Encodes provided value via integer representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.1
  #
  #  If I < 2^N - 1, encode I on N bits
  #  Else
  #      encode 2^N - 1 on N bits
  #      I = I - (2^N - 1)
  #      While I >= 128
  #           Encode (I % 128 + 128) on 8 bits
  #           I = I / 128
  #      encode (I) on 8 bits
  #
  # @param i [Integer] value to encode
  # @param n [Integer] number of available bits
  # @return [String] binary string
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#33
  def integer(i, n); end

  # Encodes provided value via string literal representation.
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-5.2
  #
  # * The string length, defined as the number of bytes needed to store
  #   its UTF-8 representation, is represented as an integer with a seven
  #   bits prefix. If the string length is strictly less than 127, it is
  #   represented as one byte.
  # * If the bit 7 of the first byte is 1, the string value is represented
  #   as a list of Huffman encoded octets
  #   (padded with bit 1's until next octet boundary).
  # * If the bit 7 of the first byte is 0, the string value is
  #   represented as a list of UTF-8 encoded octets.
  #
  #  :never   Do not use Huffman encoding
  #  :always  Always use Huffman encoding
  #  :shorter Use Huffman when the result is strictly shorter
  #
  # @param str [String]
  # @return [String] binary string
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#70
  def string(str); end

  # Set dynamic table size in EncodingContext
  #
  # @param size [Integer] new dynamic table size
  #
  # source://http-2-next//lib/http/2/next/header/compressor.rb#14
  def table_size=(size); end
end

# Responsible for decoding received headers and maintaining compression
# context of the opposing peer. Decompressor must be initialized with
# appropriate starting context based on local role: client or server.
#
# @example
#   server_role = Decompressor.new(:request)
#   client_role = Decompressor.new(:response)
#
# source://http-2-next//lib/http/2/next/header/decompressor.rb#13
class HTTP2Next::Header::Decompressor
  include ::HTTP2Next::Error

  # @param options [Hash] decoding options.  Only :table_size is effective.
  # @return [Decompressor] a new instance of Decompressor
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#17
  def initialize(options = T.unsafe(nil)); end

  # Decodes and processes header commands within provided buffer.
  #
  # @param buf [Buffer]
  # @param frame [HTTP2Next::Frame, nil]
  # @return [Array] +[[name, value], ...]
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#109
  def decode(buf, frame = T.unsafe(nil)); end

  # Decodes header command from provided buffer.
  #
  # @param buf [Buffer]
  # @raise [CompressionError]
  # @return [Hash] command
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#70
  def header(buf); end

  # Decodes integer value from provided buffer.
  #
  # @param buf [String]
  # @param n [Integer] number of available bits
  # @return [Integer]
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#32
  def integer(buf, n); end

  # Decodes string value from provided buffer.
  #
  # @param buf [String]
  # @raise [CompressionError] when input is malformed
  # @return [String] UTF-8 encoded string
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#54
  def string(buf); end

  # Set dynamic table size in EncodingContext
  #
  # @param size [Integer] new dynamic table size
  #
  # source://http-2-next//lib/http/2/next/header/decompressor.rb#23
  def table_size=(size); end
end

# source://http-2-next//lib/http/2/next/header/decompressor.rb#102
HTTP2Next::Header::Decompressor::FORBIDDEN_HEADERS = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/header/encoding_context.rb#8
class HTTP2Next::Header::EncodingContext
  include ::HTTP2Next::Error

  # Initializes compression context with appropriate client/server
  # defaults and maximum size of the dynamic table.
  #
  # @param options [Hash] encoding options
  #   :table_size  Integer  maximum dynamic table size in bytes
  #   :huffman     Symbol   :always, :never, :shorter
  #   :index       Symbol   :all, :static, :never
  # @return [EncodingContext] a new instance of EncodingContext
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#106
  def initialize(options = T.unsafe(nil)); end

  # Emits command for a header.
  # Prefer static table over dynamic table.
  # Prefer exact match over name-only match.
  #
  # +@options [:index]+ controls whether to use the dynamic table,
  # static table, or both.
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param header [Array] +[name, value]+
  # @return [Hash] command
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#250
  def addcmd(*header); end

  # Returns current table size in octets
  #
  # @return [Integer]
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#295
  def current_table_size; end

  # Finds an entry in current dynamic table by index.
  # Note that index is zero-based in this module.
  #
  # If the index is greater than the last index in the static table,
  # an entry in the dynamic table is dereferenced.
  #
  # If the index is greater than the last header index, an error is raised.
  #
  # @param index [Integer] zero-based index in the dynamic table.
  # @raise [CompressionError]
  # @return [Array] +[key, value]+
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#141
  def dereference(index); end

  # Duplicates current compression context
  #
  # @return [EncodingContext]
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#120
  def dup; end

  # Plan header compression according to +@options [:index]+
  #  :never   Do not use dynamic table or static table reference at all.
  #  :static  Use static table only.
  #  :all     Use all of them.
  #
  # @param headers [Array] +[[name, value], ...]+
  # @return [Array] array of commands
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#221
  def encode(headers); end

  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#299
  def listen_on_table; end

  # Current encoding options
  #
  #   :table_size  Integer  maximum dynamic table size in bytes
  #   :huffman     Symbol   :always, :never, :shorter
  #   :index       Symbol   :all, :static, :never
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#97
  def options; end

  # Header Block Processing
  # - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#section-4.1
  #
  # @param cmd [Hash] { type:, name:, value:, index: }
  # @return [Array, nil] +[name, value]+ header field that is added to the decoded header list,
  #   or nil if +cmd[:type]+ is +:changetablesize+
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#155
  def process(cmd); end

  # Current table of header key-value pairs.
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#90
  def table; end

  # Alter dynamic table size.
  #  When the size is reduced, some headers might be evicted.
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#288
  def table_size=(size); end

  private

  # Add a name-value pair to the dynamic table.
  # Older entries might have been evicted so that
  # the new entry fits in the dynamic table.
  #
  # @param cmd [Array] +[name, value]+
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#312
  def add_to_table(cmd); end

  # To keep the dynamic table size lower than or equal to @limit,
  # remove one or more entries at the end of the dynamic table.
  #
  # @param cmd [Hash]
  # @return [Boolean] whether +cmd+ fits in the dynamic table.
  #
  # source://http-2-next//lib/http/2/next/header/encoding_context.rb#324
  def size_check(cmd); end
end

# Static table
# - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-A
#
# @private
#
# source://http-2-next//lib/http/2/next/header/encoding_context.rb#18
HTTP2Next::Header::EncodingContext::STATIC_TABLE = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/header/encoding_context.rb#82
HTTP2Next::Header::EncodingContext::STATIC_TABLE_BY_FIELD = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header/encoding_context.rb#87
HTTP2Next::Header::EncodingContext::STATIC_TABLE_SIZE = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/header/encoding_context.rb#13
HTTP2Next::Header::EncodingContext::UPPER = T.let(T.unsafe(nil), Regexp)

# Header representation as defined by the spec.
#
# source://http-2-next//lib/http/2/next/header.rb#10
HTTP2Next::Header::HEADREP = T.let(T.unsafe(nil), Hash)

# Huffman encoder/decoder
#
# source://http-2-next//lib/http/2/next/header/huffman.rb#12
class HTTP2Next::Header::Huffman
  include ::HTTP2Next::Error

  # Decodes provided Huffman coded string.
  #
  # @param buf [Buffer]
  # @raise [CompressionError] when Huffman coded string is malformed
  # @return [String] binary string
  #
  # source://http-2-next//lib/http/2/next/header/huffman.rb#37
  def decode(buf); end

  # Encodes provided value via huffman encoding.
  # Length is not encoded in this method.
  #
  # @param str [String]
  # @return [String] binary string
  #
  # source://http-2-next//lib/http/2/next/header/huffman.rb#26
  def encode(str); end
end

# source://http-2-next//lib/http/2/next/header/huffman.rb#17
HTTP2Next::Header::Huffman::BITS_AT_ONCE = T.let(T.unsafe(nil), Integer)

# Huffman table as specified in
# - http://tools.ietf.org/html/draft-ietf-httpbis-header-compression-10#appendix-B
#
# source://http-2-next//lib/http/2/next/header/huffman.rb#65
HTTP2Next::Header::Huffman::CODES = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/header/huffman.rb#325
HTTP2Next::Header::Huffman::ENCODE_TABLE = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/header/huffman.rb#18
HTTP2Next::Header::Huffman::EOS = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/header/huffman_statemachine.rb#14
HTTP2Next::Header::Huffman::MACHINE = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/header/huffman_statemachine.rb#13
HTTP2Next::Header::Huffman::MAX_FINAL_STATE = T.let(T.unsafe(nil), Integer)

# source://http-2-next//lib/http/2/next/header.rb#21
HTTP2Next::Header::LINEAR = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#25
HTTP2Next::Header::LINEARH = T.let(T.unsafe(nil), Hash)

# Predefined options set for Compressor
# http://mew.org/~kazu/material/2014-hpack.pdf
#
# source://http-2-next//lib/http/2/next/header.rb#20
HTTP2Next::Header::NAIVE = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#24
HTTP2Next::Header::NAIVEH = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#23
HTTP2Next::Header::SHORTER = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#27
HTTP2Next::Header::SHORTERH = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#22
HTTP2Next::Header::STATIC = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/header.rb#26
HTTP2Next::Header::STATICH = T.let(T.unsafe(nil), Hash)

# source://http-2-next//lib/http/2/next/connection.rb#38
HTTP2Next::REQUEST_MANDATORY_HEADERS = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/connection.rb#39
HTTP2Next::RESPONSE_MANDATORY_HEADERS = T.let(T.unsafe(nil), Array)

# source://http-2-next//lib/http/2/next/extensions.rb#4
module HTTP2Next::RegexpExtensions; end

# Default values for SETTINGS frame, as defined by the spec.
#
# source://http-2-next//lib/http/2/next/connection.rb#14
HTTP2Next::SPEC_DEFAULT_CONNECTION_SETTINGS = T.let(T.unsafe(nil), Hash)

# HTTP 2.0 server connection class that implements appropriate header
# compression / decompression algorithms and stream management logic.
#
# Your code is responsible for feeding request data to the server object,
# which in turn performs all of the necessary HTTP 2.0 decoding / encoding,
# state management, and the rest. A simple example:
#
# @example
#   socket = YourTransport.new
#
#   conn = HTTP2Next::Server.new
#   conn.on(:stream) do |stream|
#   ...
#   end
#
#   while bytes = socket.read
#   conn << bytes
#   end
#
# source://http-2-next//lib/http/2/next/server.rb#24
class HTTP2Next::Server < ::HTTP2Next::Connection
  # Initialize new HTTP 2.0 server object.
  #
  # @return [Server] a new instance of Server
  #
  # source://http-2-next//lib/http/2/next/server.rb#28
  def initialize(settings = T.unsafe(nil)); end

  # Returns the value of attribute origin_set.
  #
  # source://http-2-next//lib/http/2/next/server.rb#25
  def origin_set; end

  # source://http-2-next//lib/http/2/next/server.rb#122
  def origin_set=(origins); end

  # GET / HTTP/1.1
  #   Host: server.example.com
  #   Connection: Upgrade, HTTP2-Settings
  #   Upgrade: h2c
  #   HTTP2-Settings: <base64url encoding of HTTP/2 SETTINGS payload>
  #
  # Requests that contain a payload body MUST be sent in their entirety
  # before the client can send HTTP/2 frames. This means that a large
  # request can block the use of the connection until it is completely sent.
  #
  # If concurrency of an initial request with subsequent requests is
  # important, an OPTIONS request can be used to perform the upgrade to
  # HTTP/2, at the cost of an additional round trip.
  #
  #   HTTP/1.1 101 Switching Protocols
  #   Connection: Upgrade
  #   Upgrade: h2c
  #
  #   [ HTTP/2 connection ...
  #
  # - The first HTTP/2 frame sent by the server MUST be a server
  #   connection preface (Section 3.5) consisting of a SETTINGS frame.
  # - Upon receiving the 101 response, the client MUST send a connection
  #   preface (Section 3.5), which includes a SETTINGS frame.
  #
  # The HTTP/1.1 request that is sent prior to upgrade is assigned a stream
  # identifier of 1 (see Section 5.1.1) with default priority values
  # (Section 5.3.5). Stream 1 is implicitly "half-closed" from the client
  # toward the server (see Section 5.1), since the request is completed as
  # an HTTP/1.1 request. After commencing the HTTP/2 connection, stream 1
  # is used for the response.
  #
  # source://http-2-next//lib/http/2/next/server.rb#73
  def upgrade(settings, headers, body); end

  private

  # source://http-2-next//lib/http/2/next/server.rb#129
  def connection_settings(frame); end

  # Handle locally initiated server-push event emitted by the stream.
  #
  # @param parent [Stream]
  # @param headers [Enumerable[String, String]]
  # @param flags [Array[Symbol]]
  # @param callback [Proc]
  # @yield [promise]
  #
  # source://http-2-next//lib/http/2/next/server.rb#146
  def promise(parent, headers, flags); end

  # source://http-2-next//lib/http/2/next/server.rb#136
  def verify_pseudo_headers(frame); end
end

# A single HTTP 2.0 connection can multiplex multiple streams in parallel:
# multiple requests and responses can be in flight simultaneously and stream
# data can be interleaved and prioritized.
#
# This class encapsulates all of the state, transition, flow-control, and
# error management as defined by the HTTP 2.0 specification. All you have
# to do is subscribe to appropriate events (marked with ":" prefix in
# diagram below) and provide your application logic to handle request
# and response processing.
#
#                         +--------+
#                    PP   |        |   PP
#                ,--------|  idle  |--------.
#               /         |        |         \
#              v          +--------+          v
#       +----------+          |           +----------+
#       |          |          | H         |          |
#   ,---|:reserved |          |           |:reserved |---.
#   |   | (local)  |          v           | (remote) |   |
#   |   +----------+      +--------+      +----------+   |
#   |      | :active      |        |      :active |      |
#   |      |      ,-------|:active |-------.      |      |
#   |      | H   /   ES   |        |   ES   \   H |      |
#   |      v    v         +--------+         v    v      |
#   |   +-----------+          |          +-----------+  |
#   |   |:half_close|          |          |:half_close|  |
#   |   |  (remote) |          |          |  (local)  |  |
#   |   +-----------+          |          +-----------+  |
#   |        |                 v                |        |
#   |        |    ES/R    +--------+    ES/R    |        |
#   |        `----------->|        |<-----------'        |
#   | R                   | :close |                   R |
#   `-------------------->|        |<--------------------'
#                         +--------+
#
# source://http-2-next//lib/http/2/next/stream.rb#38
class HTTP2Next::Stream
  include ::HTTP2Next::Error
  include ::HTTP2Next::FlowBuffer
  include ::HTTP2Next::Emitter

  # Initializes new stream.
  #
  # Note that you should never have to call this directly. To create a new
  # client initiated stream, use Connection#new_stream. Similarly, Connection
  # will emit new stream objects, when new stream frames are received.
  #
  # @param id [Integer]
  # @param weight [Integer]
  # @param dependency [Integer]
  # @param exclusive [Boolean]
  # @param window [Integer]
  # @param parent [Stream]
  # @param state [Symbol]
  # @return [Stream] a new instance of Stream
  #
  # source://http-2-next//lib/http/2/next/stream.rb#76
  def initialize(connection:, id:, weight: T.unsafe(nil), dependency: T.unsafe(nil), exclusive: T.unsafe(nil), parent: T.unsafe(nil), state: T.unsafe(nil)); end

  # Processes incoming HTTP 2.0 frames. The frames must be decoded upstream.
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#106
  def <<(frame); end

  # source://http-2-next//lib/http/2/next/stream.rb#179
  def calculate_content_length(data_length); end

  # Sends a RST_STREAM indicating that the stream is no longer needed.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#284
  def cancel; end

  # Chunk data into max_size, yield each chunk, then return final chunk
  #
  # source://http-2-next//lib/http/2/next/stream.rb#265
  def chunk_data(payload, max_size); end

  # Sends a RST_STREAM frame which closes current stream - this does not
  # close the underlying connection.
  #
  # @param error [:Symbol] optional reason why stream was closed
  #
  # source://http-2-next//lib/http/2/next/stream.rb#279
  def close(error = T.unsafe(nil)); end

  # Reason why connection was closed.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#61
  def closed; end

  # @return [Boolean]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#99
  def closed?; end

  # Sends DATA frame containing response payload.
  #
  # @param payload [String]
  # @param end_stream [Boolean] indicates last response DATA frame
  #
  # source://http-2-next//lib/http/2/next/stream.rb#247
  def data(payload, end_stream: T.unsafe(nil)); end

  # Returns the value of attribute dependency.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#54
  def dependency; end

  # Sends a HEADERS frame containing HTTP response headers.
  # All pseudo-header fields MUST appear in the header block before regular header fields.
  #
  # @param headers [Array or Hash] Array of key-value pairs or Hash
  # @param end_headers [Boolean] indicates that no more headers will be sent
  # @param end_stream [Boolean] indicates that no payload will be sent
  #
  # source://http-2-next//lib/http/2/next/stream.rb#218
  def headers(headers, end_headers: T.unsafe(nil), end_stream: T.unsafe(nil)); end

  # Stream ID (odd for client initiated streams, even otherwise).
  #
  # source://http-2-next//lib/http/2/next/stream.rb#44
  def id; end

  # Size of current stream flow control window.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#57
  def local_window; end

  # Request parent stream of push stream.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#50
  def parent; end

  # @raise [ArgumentError]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#226
  def promise(headers, end_headers: T.unsafe(nil), &block); end

  # Processes incoming HTTP 2.0 frames. The frames must be decoded upstream.
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#106
  def receive(frame); end

  # Sends a RST_STREAM indicating that the stream has been refused prior
  # to performing any application processing.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#290
  def refuse; end

  # Returns the value of attribute remote_window.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#54
  def remote_window; end

  # Sends a PRIORITY frame with new stream priority value (can only be
  # performed by the client).
  #
  # @param weight [Integer] new stream weight value
  # @param dependency [Integer] new stream dependency stream
  #
  # source://http-2-next//lib/http/2/next/stream.rb#238
  def reprioritize(weight: T.unsafe(nil), dependency: T.unsafe(nil), exclusive: T.unsafe(nil)); end

  # Processes outgoing HTTP 2.0 frames. Data frames may be automatically
  # split and buffered based on maximum frame size and current stream flow
  # control window size.
  #
  # @param frame [Hash]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#193
  def send(frame); end

  # Stream state as defined by HTTP 2.0.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#47
  def state; end

  # source://http-2-next//lib/http/2/next/stream.rb#165
  def verify_trailers(frame); end

  # Stream priority as set by initiator.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#53
  def weight; end

  # Size of current stream flow control window.
  #
  # source://http-2-next//lib/http/2/next/stream.rb#57
  def window; end

  # Sends a WINDOW_UPDATE frame to the peer.
  #
  # @param increment [Integer]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#297
  def window_update(increment); end

  private

  # source://http-2-next//lib/http/2/next/stream.rb#627
  def complete_transition(frame); end

  # @return [Boolean]
  #
  # source://http-2-next//lib/http/2/next/stream.rb#654
  def end_stream?(frame); end

  # @raise []
  #
  # source://http-2-next//lib/http/2/next/stream.rb#662
  def error(error = T.unsafe(nil), msg: T.unsafe(nil)); end

  # source://http-2-next//lib/http/2/next/stream.rb#604
  def event(newstate); end

  # source://http-2-next//lib/http/2/next/stream.rb#672
  def manage_state(frame); end

  # source://http-2-next//lib/http/2/next/stream.rb#638
  def process_priority(frame); end

  # @raise []
  #
  # source://http-2-next//lib/http/2/next/stream.rb#662
  def stream_error(error = T.unsafe(nil), msg: T.unsafe(nil)); end

  # HTTP 2.0 Stream States
  # - http://tools.ietf.org/html/draft-ietf-httpbis-http2-16#section-5.1
  #
  #                         +--------+
  #                 send PP |        | recv PP
  #                ,--------|  idle  |--------.
  #               /         |        |         \
  #              v          +--------+          v
  #       +----------+          |           +----------+
  #       |          |          | send H/   |          |
  # ,-----| reserved |          | recv H    | reserved |-----.
  # |     | (local)  |          |           | (remote) |     |
  # |     +----------+          v           +----------+     |
  # |         |             +--------+             |         |
  # |         |     recv ES |        | send ES     |         |
  # |  send H |     ,-------|  open  |-------.     | recv H  |
  # |         |    /        |        |        \    |         |
  # |         v   v         +--------+         v   v         |
  # |     +----------+          |           +----------+     |
  # |     |   half   |          |           |   half   |     |
  # |     |  closed  |          | send R/   |  closed  |     |
  # |     | (remote) |          | recv R    | (local)  |     |
  # |     +----------+          |           +----------+     |
  # |          |                |                 |          |
  # |          | send ES/       |        recv ES/ |          |
  # |          | send R/        v         send R/ |          |
  # |          | recv R     +--------+    recv R  |          |
  # | send R/  `----------->|        |<-----------'  send R/ |
  # | recv R                | closed |               recv R  |
  # `---------------------->|        |<----------------------'
  #                         +--------+
  #
  # source://http-2-next//lib/http/2/next/stream.rb#338
  def transition(frame, sending); end
end

# source://http-2-next//lib/http/2/next/extensions.rb#14
module HTTP2Next::StringExtensions; end

# source://http-2-next//lib/http/2/next/version.rb#4
HTTP2Next::VERSION = T.let(T.unsafe(nil), String)
