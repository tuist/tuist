# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `appsignal` gem.
# Please instead update this file by running `bin/tapioca gem appsignal`.

# AppSignal for Ruby gem's main module.
#
# Provides method to control the AppSignal instrumentation and the system
# agent. Also provides direct access to instrumentation helpers (from
# {Appsignal::Helpers::Instrumentation}) and metrics helpers (from
# {Appsignal::Helpers::Metrics}) for ease of use.
#
# source://appsignal//lib/appsignal/logger.rb#6
module Appsignal
  extend ::Appsignal::Utils::DeprecationMessage
  extend ::Appsignal::Helpers::Instrumentation
  extend ::Appsignal::Helpers::Metrics

  class << self
    # Returns the active state of the AppSignal integration.
    #
    # Conditions apply for AppSignal to be marked as active:
    #
    # - There is a config set on the {.config} attribute.
    # - The set config is active {Config.active?}.
    # - The AppSignal Extension is loaded {.extension_loaded?}.
    #
    # This logic is used within instrument helper such as {.instrument} so it's
    # not necessary to wrap {.instrument} calls with this method.
    #
    # @example Do this
    #   Appsignal.instrument(..) do
    #   # Do this
    #   end
    # @example Don't do this
    #   if Appsignal.active?
    #   Appsignal.instrument(..) do
    #   # Don't do this
    #   end
    #   end
    # @return [Boolean]
    # @since 0.2.7
    #
    # source://appsignal//lib/appsignal.rb#258
    def active?; end

    # Accessor for the AppSignal configuration.
    # Return the current AppSignal configuration.
    #
    # Can return `nil` if no configuration has been set or automatically loaded
    # by an automatic integration or by calling {.start}.
    #
    # @example
    #   Appsignal.config
    # @example Setting the configuration
    #   Appsignal.config = Appsignal::Config.new(Dir.pwd, "production")
    # @return [Config, nil]
    # @see Config
    #
    # source://appsignal//lib/appsignal.rb#37
    def config; end

    # Accessor for the AppSignal configuration.
    # Return the current AppSignal configuration.
    #
    # Can return `nil` if no configuration has been set or automatically loaded
    # by an automatic integration or by calling {.start}.
    #
    # @example
    #   Appsignal.config
    # @example Setting the configuration
    #   Appsignal.config = Appsignal::Config.new(Dir.pwd, "production")
    # @return [Config, nil]
    # @see Config
    #
    # source://appsignal//lib/appsignal.rb#37
    def config=(_arg0); end

    # Accessor for toggle if the AppSignal C-extension is loaded.
    #
    # Can be `nil` if extension has not been loaded yet. See
    # {.extension_loaded?} for a boolean return value.
    #
    # @api private
    # @return [Boolean, nil]
    # @see Extension
    # @see extension_loaded?
    #
    # source://appsignal//lib/appsignal.rb#47
    def extension_loaded; end

    # Accessor for toggle if the AppSignal C-extension is loaded.
    #
    # Can be `nil` if extension has not been loaded yet. See
    # {.extension_loaded?} for a boolean return value.
    #
    # @api private
    # @return [Boolean, nil]
    # @see Extension
    # @see extension_loaded?
    #
    # source://appsignal//lib/appsignal.rb#47
    def extension_loaded=(_arg0); end

    # Returns if the C-extension was loaded properly.
    #
    # @return [Boolean]
    # @see Extension
    # @since 1.0.0
    #
    # source://appsignal//lib/appsignal.rb#229
    def extension_loaded?; end

    # source://appsignal//lib/appsignal.rb#157
    def forked; end

    # source://appsignal//lib/appsignal.rb#165
    def get_server_state(key); end

    # In memory internal logger used before any internal logger is started with
    # {.start_logger}.
    #
    # The contents of this logger are flushed to the logger in {.start_logger}.
    #
    # @api private
    # @return [StringIO]
    #
    # source://appsignal//lib/appsignal.rb#176
    def in_memory_log; end

    # source://appsignal//lib/appsignal.rb#184
    def internal_logger; end

    # Sets the attribute internal_logger
    #
    # @param value the value to set the attribute internal_logger to.
    #
    # source://appsignal//lib/appsignal.rb#64
    def internal_logger=(_arg0); end

    # @api private
    #
    # source://appsignal//lib/appsignal.rb#193
    def log_formatter(prefix = T.unsafe(nil)); end

    # Start the AppSignal integration.
    #
    # Starts AppSignal with the given configuration. If no configuration is set
    # yet it will try to automatically load the configuration using the
    # environment loaded from environment variables and the currently working
    # directory.
    #
    # This is not required for the automatic integrations AppSignal offers, but
    # this is required for all non-automatic integrations and pure Ruby
    # applications. For more information, see our [integrations
    # list](https://docs.appsignal.com/ruby/integrations/) and our [Integrating
    # AppSignal](https://docs.appsignal.com/ruby/instrumentation/integrating-appsignal.html)
    # guide.
    #
    # To start the logger see {.start_logger}.
    #
    # @example
    #   Appsignal.start
    # @example with custom loaded configuration
    #   Appsignal.config = Appsignal::Config.new(Dir.pwd, "production")
    #   Appsignal.start
    # @return [void]
    # @since 0.7.0
    #
    # source://appsignal//lib/appsignal.rb#96
    def start; end

    # Start the AppSignal internal logger.
    #
    # Sets the log level and sets the logger. Uses a file-based logger or the
    # STDOUT-based logger. See the `:log` configuration option.
    #
    # @return [void]
    # @since 0.7.0
    #
    # source://appsignal//lib/appsignal.rb#208
    def start_logger; end

    # Stop AppSignal's agent.
    #
    # Stops the AppSignal agent. Call this before the end of your program to
    # make sure the agent is stopped as well.
    #
    # @example
    #   Appsignal.start
    #   # Run your application
    #   Appsignal.stop
    # @param called_by [String] Name of the thing that requested the agent to
    #   be stopped. Will be used in the AppSignal log file.
    # @return [void]
    # @since 1.0.0
    #
    # source://appsignal//lib/appsignal.rb#148
    def stop(called_by = T.unsafe(nil)); end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal.rb#67
    def testing?; end

    private

    # source://appsignal//lib/appsignal.rb#278
    def collect_environment_metadata; end

    # source://appsignal//lib/appsignal.rb#269
    def start_internal_file_logger(path); end

    # source://appsignal//lib/appsignal.rb#264
    def start_internal_stdout_logger; end
  end
end

# Class used to perform a Push API validation / authentication check against
# the AppSignal Push API.
#
# @api private
# @example
#   config = Appsignal::Config.new(Dir.pwd, "production")
#   auth_check = Appsignal::AuthCheck.new(config)
#   # Valid push_api_key
#   auth_check.perform # => "200"
#   # Invalid push_api_key
#   auth_check.perform # => "401"
#
# source://appsignal//lib/appsignal/auth_check.rb#18
class Appsignal::AuthCheck
  # @api private
  # @return [AuthCheck] a new instance of AuthCheck
  #
  # source://appsignal//lib/appsignal/auth_check.rb#25
  def initialize(config); end

  # @api private
  # @return [Appsignal::Config] config to use in the authentication request.
  #
  # source://appsignal//lib/appsignal/auth_check.rb#23
  def config; end

  # Perform push api validation request and return response status code.
  #
  # @api private
  # @raise [StandardError] see {Appsignal::Transmitter#transmit}.
  # @return [String] response status code.
  #
  # source://appsignal//lib/appsignal/auth_check.rb#33
  def perform; end

  # Perform push api validation request and return a descriptive response
  # tuple.
  #
  # @api private
  # @return [Array<String/nil, String>] response tuple.
  #   - First value is the response status code.
  #   - Second value is a description of the response and the exception error
  #   message if an exception occured.
  #
  # source://appsignal//lib/appsignal/auth_check.rb#44
  def perform_with_result; end
end

# Path used on the AppSignal Push API
# https://push.appsignal.com/1/auth
#
# @api private
#
# source://appsignal//lib/appsignal/auth_check.rb#21
Appsignal::AuthCheck::ACTION = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/config.rb#10
class Appsignal::Config
  include ::Appsignal::Utils::DeprecationMessage

  # Initialize a new configuration object for AppSignal.
  #
  # If this is manually initialized, and not by {Appsignal.start}, it needs
  # to be assigned to the {Appsignal.config} attribute.
  #
  # @example
  #   require "appsignal"
  #   Appsignal.config = Appsignal::Config.new(
  #   app_path,
  #   "production"
  #   )
  #   Appsignal.start
  # @param root_path [String] Root path of the app.
  # @param env [String] The environment to load when AppSignal is started. It
  #   will look for an environment with this name in the `config/appsignal.yml`
  #   config file.
  # @param initial_config [Hash<String, Object>] The initial configuration to
  #   use. This will be overwritten by the file config and environment
  #   variables config.
  # @param logger [Logger] The logger to use for the AppSignal gem. This is
  #   used by the configuration class only. Default:
  #   {Appsignal.internal_logger}. See also {Appsignal.start_logger}.
  # @param config_file [String] Custom config file location. Default
  #   `config/appsignal.yml`.
  # @return [Config] a new instance of Config
  # @see https://docs.appsignal.com/ruby/configuration/ Configuration documentation
  # @see https://docs.appsignal.com/ruby/configuration/load-order.html Configuration load order
  # @see https://docs.appsignal.com/ruby/instrumentation/integrating-appsignal.html How to integrate AppSignal manually
  #
  # source://appsignal//lib/appsignal/config.rb#233
  def initialize(root_path, env, initial_config = T.unsafe(nil), logger = T.unsafe(nil), config_file = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/config.rb#288
  def [](key); end

  # Update the internal config hash.
  #
  # This method does not update the config in the extension and agent. It
  # should not be used to update the config after AppSignal has started.
  #
  # @api private
  #
  # source://appsignal//lib/appsignal/config.rb#298
  def []=(key, value); end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/config.rb#333
  def active?; end

  # Config used by the AppSignal gem.
  # Combined Hash of the {system_config}, {initial_config}, {file_config},
  # {env_config} attributes.
  #
  # @api private
  # @return [Hash]
  # @see #[]
  # @see #[]=
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def config_hash; end

  # Returns the value of attribute env.
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def env; end

  # Config loaded from the system environment.
  # Used in diagnose report.
  #
  # @api private
  # @return [Hash]
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def env_config; end

  # Config loaded from `config/appsignal.yml` config file.
  # Used in diagnose report.
  #
  # @api private
  # @return [Hash]
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def file_config; end

  # Config detected on the system level.
  # Used in diagnose report.
  #
  # @api private
  # @return [Hash]
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def initial_config; end

  # source://appsignal//lib/appsignal/config.rb#312
  def log_file_path; end

  # source://appsignal//lib/appsignal/config.rb#302
  def log_level; end

  # Returns the value of attribute logger.
  #
  # source://appsignal//lib/appsignal/config.rb#199
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://appsignal//lib/appsignal/config.rb#199
  def logger=(_arg0); end

  # Returns the value of attribute override_config.
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def override_config; end

  # Returns the value of attribute root_path.
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def root_path; end

  # Config detected on the system level.
  # Used in diagnose report.
  #
  # @api private
  # @return [Hash]
  #
  # source://appsignal//lib/appsignal/config.rb#197
  def system_config; end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/config.rb#329
  def valid?; end

  # source://appsignal//lib/appsignal/config.rb#380
  def validate; end

  # source://appsignal//lib/appsignal/config.rb#337
  def write_to_environment; end

  private

  # source://appsignal//lib/appsignal/config.rb#403
  def config_file; end

  # source://appsignal//lib/appsignal/config.rb#408
  def detect_from_system; end

  # Set config options based on the final user config. Fix any conflicting
  # config or set new config options based on deprecated config options.
  #
  # Make sure to remove behavior for deprecated config options in this method
  # in the next major version, but the method itself with an empty body can
  # stick around as a structure for future deprecations.
  #
  # source://appsignal//lib/appsignal/config.rb#510
  def determine_overrides; end

  # Does it use the new behavior?
  #
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/config.rb#543
  def inactive_on_config_file_error?; end

  # source://appsignal//lib/appsignal/config.rb#419
  def load_from_disk; end

  # source://appsignal//lib/appsignal/config.rb#474
  def load_from_environment; end

  # Maintain backwards compatibility with deprecated config options.
  #
  # Add warnings for deprecated config options here if they have no
  # replacement, or should be non-functional.
  #
  # Add them to {determine_overrides} if replacement config options should be
  # set instead.
  #
  # Make sure to remove the contents of this method in the next major
  # version, but the method itself with an empty body can stick around as a
  # structure for future deprecations.
  #
  # source://appsignal//lib/appsignal/config.rb#464
  def maintain_backwards_compatibility; end

  # source://appsignal//lib/appsignal/config.rb#535
  def merge(new_config); end

  class << self
    # @api private
    # @return [String] System's tmp directory.
    #
    # source://appsignal//lib/appsignal/config.rb#280
    def system_tmp_dir; end
  end
end

# source://appsignal//lib/appsignal/config.rb#13
Appsignal::Config::DEFAULT_CONFIG = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://appsignal//lib/appsignal/config.rb#52
Appsignal::Config::DEFAULT_LOG_LEVEL = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://appsignal//lib/appsignal/config.rb#157
Appsignal::Config::ENV_ARRAY_KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://appsignal//lib/appsignal/config.rb#133
Appsignal::Config::ENV_BOOLEAN_KEYS = T.let(T.unsafe(nil), Array)

# @api private
#
# source://appsignal//lib/appsignal/config.rb#114
Appsignal::Config::ENV_STRING_KEYS = T.let(T.unsafe(nil), Array)

# source://appsignal//lib/appsignal/config.rb#66
Appsignal::Config::ENV_TO_KEY_MAPPING = T.let(T.unsafe(nil), Hash)

# Map from the `log_level` config option to Ruby's Logger level value.
#
# The trace level doesn't exist in the Ruby logger so it's mapped to debug.
#
# @api private
#
# source://appsignal//lib/appsignal/config.rb#57
Appsignal::Config::LOG_LEVEL_MAP = T.let(T.unsafe(nil), Hash)

# @api private
#
# source://appsignal//lib/appsignal/environment.rb#5
class Appsignal::Environment
  class << self
    # Add environment metadata.
    #
    # The key and value of the environment metadata must be a String, even if
    # it's actually of another type.
    #
    # The value of the environment metadata is given as a block that captures
    # errors that might be raised while fetching the value. It will not
    # re-raise errors, but instead log them using the
    # {Appsignal.internal_logger}. This ensures AppSignal will not cause an
    # error in the application when collecting this metadata.
    #
    # @api private
    # @example Reporting a key and value
    #   Appsignal::Environment.report("ruby_version") { RUBY_VERSION }
    # @example When a value is nil
    #   Appsignal::Environment.report("ruby_version") { nil }
    #   # Key and value do not get reported. A warning gets logged instead.
    # @example When an error occurs
    #   Appsignal::Environment.report("ruby_version") { raise "uh oh" }
    #   # Error does not get reraised. A warning gets logged instead.
    # @param key [String] The name of the key of the environment metadata value.
    # @return [void]
    # @yieldreturn [String] The value of the key of the environment metadata.
    #
    # source://appsignal//lib/appsignal/environment.rb#31
    def report(key); end

    # @api private
    #
    # source://appsignal//lib/appsignal/environment.rb#132
    def report_enabled(feature); end

    # Report on the list of AppSignal supported gems
    #
    # This list is used to report if which AppSignal supported gems are present
    # in this app and what version. This data will help AppSignal improve its
    # support by knowing what gems and versions of gems it still needs to
    # support or can drop support for.
    #
    # It will ask Bundler to report name and version information from the gems
    # that are present in the app bundle.
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/environment.rb#117
    def report_supported_gems; end
  end
end

# @api private
# @see report_supported_gems
#
# source://appsignal//lib/appsignal/environment.rb#72
Appsignal::Environment::SUPPORTED_GEMS = T.let(T.unsafe(nil), Array)

# Keeps track of formatters for types event that we can use to get
# the title and body of an event. Formatters should inherit from this class
# and implement a format(payload) method which returns an array with the title
# and body.
#
# When implementing a formatter remember that it cannot keep separate state per
# event, the same object will be called intermittently in a threaded environment.
# So only keep global configuration as state and pass the payload around as an
# argument if you need to use helper methods.
#
# @api private
#
# source://appsignal//lib/appsignal/event_formatter.rb#15
class Appsignal::EventFormatter
  extend ::Appsignal::Utils::DeprecationMessage

  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#54
    def format(name, payload); end

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#23
    def formatter_classes; end

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#19
    def formatters; end

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#27
    def register(name, formatter = T.unsafe(nil)); end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#46
    def registered?(name, klass = T.unsafe(nil)); end

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#39
    def unregister(name, formatter = T.unsafe(nil)); end

    private

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#61
    def initialize_formatter(name, formatter); end

    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter.rb#75
    def logger; end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#6
module Appsignal::EventFormatter::ActionView; end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#7
class Appsignal::EventFormatter::ActionView::RenderFormatter
  # @api private
  # @return [RenderFormatter] a new instance of RenderFormatter
  #
  # source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#12
  def initialize; end

  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#16
  def format(payload); end

  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#10
  def root_path; end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/action_view/render_formatter.rb#8
Appsignal::EventFormatter::ActionView::RenderFormatter::BLANK = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/active_record/instantiation_formatter.rb#6
module Appsignal::EventFormatter::ActiveRecord; end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/active_record/instantiation_formatter.rb#7
class Appsignal::EventFormatter::ActiveRecord::InstantiationFormatter
  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/active_record/instantiation_formatter.rb#8
  def format(payload); end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/active_record/sql_formatter.rb#7
class Appsignal::EventFormatter::ActiveRecord::SqlFormatter
  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/active_record/sql_formatter.rb#8
  def format(payload); end
end

# @api public
#
# source://appsignal//lib/appsignal/event_formatter.rb#81
Appsignal::EventFormatter::DEFAULT = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/elastic_search/search_formatter.rb#6
module Appsignal::EventFormatter::ElasticSearch; end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/elastic_search/search_formatter.rb#7
class Appsignal::EventFormatter::ElasticSearch::SearchFormatter
  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/elastic_search/search_formatter.rb#8
  def format(payload); end

  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/elastic_search/search_formatter.rb#15
  def sanitized_search(search); end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/faraday/request_formatter.rb#6
module Appsignal::EventFormatter::Faraday; end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/faraday/request_formatter.rb#7
class Appsignal::EventFormatter::Faraday::RequestFormatter
  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/faraday/request_formatter.rb#8
  def format(payload); end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/mongo_ruby_driver/query_formatter.rb#6
module Appsignal::EventFormatter::MongoRubyDriver; end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/mongo_ruby_driver/query_formatter.rb#7
class Appsignal::EventFormatter::MongoRubyDriver::QueryFormatter
  class << self
    # Applies strategy on hash values based on keys
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter/mongo_ruby_driver/query_formatter.rb#69
    def apply_strategy(strategy, val); end

    # Format command based on given strategy
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/event_formatter/mongo_ruby_driver/query_formatter.rb#53
    def format(strategy, command); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/mongo_ruby_driver/query_formatter.rb#8
Appsignal::EventFormatter::MongoRubyDriver::QueryFormatter::ALLOWED = T.let(T.unsafe(nil), Hash)

# source://appsignal//lib/appsignal/event_formatter/rom/sql_formatter.rb#5
module Appsignal::EventFormatter::Rom; end

# source://appsignal//lib/appsignal/event_formatter/rom/sql_formatter.rb#6
class Appsignal::EventFormatter::Rom::SqlFormatter
  # source://appsignal//lib/appsignal/event_formatter/rom/sql_formatter.rb#7
  def format(payload); end
end

# @api public
#
# source://appsignal//lib/appsignal/event_formatter.rb#83
Appsignal::EventFormatter::SQL_BODY_FORMAT = T.let(T.unsafe(nil), Integer)

# @api private
#
# source://appsignal//lib/appsignal/event_formatter/sequel/sql_formatter.rb#6
module Appsignal::EventFormatter::Sequel; end

# Compatability with the sequel-rails gem.
# The sequel-rails gem adds its own ActiveSupport::Notifications events
# that conflict with our own sequel instrumentor. Without this event
# formatter the sequel-rails events are recorded without the SQL query
# that's being executed.
#
# @api private
#
# source://appsignal//lib/appsignal/event_formatter/sequel/sql_formatter.rb#12
class Appsignal::EventFormatter::Sequel::SqlFormatter
  # @api private
  #
  # source://appsignal//lib/appsignal/event_formatter/sequel/sql_formatter.rb#13
  def format(payload); end
end

# @api private
#
# source://appsignal//lib/appsignal/extension.rb#22
class Appsignal::Extension
  class << self
    def add_distribution_value(_arg0, _arg1, _arg2); end

    # @api private
    #
    # source://appsignal//lib/appsignal/extension.rb#24
    def agent_config; end

    # @api private
    #
    # source://appsignal//lib/appsignal/extension.rb#29
    def agent_version; end

    def data_array_new; end
    def data_map_new; end
    def diagnose; end
    def get_server_state(_arg0); end
    def increment_counter(_arg0, _arg1, _arg2); end
    def install_allocation_event_hook; end
    def log(_arg0, _arg1, _arg2, _arg3, _arg4); end

    # Do nothing if the extension methods are not loaded
    #
    # Disabled in testing so we can make sure that we don't miss a extension
    # function implementation.
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/extension.rb#37
    def method_missing(_method, *args, &block); end

    def running_in_container?; end
    def set_environment_metadata(_arg0, _arg1); end
    def set_gauge(_arg0, _arg1, _arg2); end
    def start; end
    def start_transaction(_arg0, _arg1, _arg2); end
    def stop; end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/extension.rb#72
class Appsignal::Extension::Data
  def ==(_arg0); end
  def append_boolean(_arg0); end
  def append_data(_arg0); end
  def append_float(_arg0); end
  def append_integer(_arg0); end
  def append_nil; end
  def append_string(_arg0); end

  # @api private
  #
  # source://appsignal//lib/appsignal/extension.rb#73
  def inspect; end

  def set_boolean(_arg0, _arg1); end
  def set_data(_arg0, _arg1); end
  def set_float(_arg0, _arg1); end
  def set_integer(_arg0, _arg1); end
  def set_nil(_arg0); end
  def set_string(_arg0, _arg1); end
  def to_s; end
end

# Mock of the {Data} class. This mock is used when the extension cannot be
# loaded. This mock listens to all method calls and does nothing, and
# prevents NoMethodErrors from being raised.
#
# Disabled in testing so we can make sure that we don't miss an extension
# function implementation.
#
# This class inherits from the {Data} class so that it passes type checks.
#
# @api private
#
# source://appsignal//lib/appsignal/extension.rb#86
class Appsignal::Extension::MockData < ::Appsignal::Extension::Data
  # @api private
  # @return [MockData] a new instance of MockData
  #
  # source://appsignal//lib/appsignal/extension.rb#87
  def initialize(*_args); end

  # @api private
  #
  # source://appsignal//lib/appsignal/extension.rb#92
  def method_missing(_method, *_args, &_block); end

  # @api private
  #
  # source://appsignal//lib/appsignal/extension.rb#96
  def to_s; end
end

# Mock of the {Transaction} class. This mock is used when the extension
# cannot be loaded. This mock listens to all method calls and does nothing,
# and prevents NoMethodErrors from being raised.
#
# Disabled in testing so we can make sure that we don't miss an extension
# function implementation.
#
# @api private
#
# source://appsignal//lib/appsignal/extension.rb#107
class Appsignal::Extension::MockTransaction
  # @api private
  # @return [MockTransaction] a new instance of MockTransaction
  #
  # source://appsignal//lib/appsignal/extension.rb#108
  def initialize(*_args); end

  # @api private
  #
  # source://appsignal//lib/appsignal/extension.rb#113
  def method_missing(_method, *_args, &_block); end
end

# Reassign Span class for JRuby extension usage.
#
# Makes sure the generated docs aren't always overwritten with the JRuby
# version.
#
# @api private
class Appsignal::Extension::Span
  def add_error(_arg0, _arg1, _arg2); end
  def child; end
  def close; end
  def set_attribute_bool(_arg0, _arg1); end
  def set_attribute_double(_arg0, _arg1); end
  def set_attribute_int(_arg0, _arg1); end
  def set_attribute_string(_arg0, _arg1); end
  def set_name(_arg0); end
  def set_sample_data(_arg0, _arg1); end
  def to_json; end

  class << self
    def root(_arg0); end
  end
end

# Reassign Transaction class for JRuby extension usage.
#
# Makes sure the generated docs aren't always overwritten with the JRuby
# version.
#
# @api private
class Appsignal::Extension::Transaction
  def complete; end
  def finish(_arg0); end
  def finish_event(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def record_event(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5); end
  def set_action(_arg0); end
  def set_error(_arg0, _arg1, _arg2); end
  def set_metadata(_arg0, _arg1); end
  def set_namespace(_arg0); end
  def set_queue_start(_arg0); end
  def set_sample_data(_arg0, _arg1); end
  def start_event(_arg0); end
  def to_json; end
end

# @api private
#
# source://appsignal//lib/appsignal/garbage_collection.rb#5
module Appsignal::GarbageCollection
  class << self
    # Unset the currently cached profilers.
    #
    # @api private
    # @return [void]
    #
    # source://appsignal//lib/appsignal/garbage_collection.rb#33
    def clear_profiler!; end

    # Check if Garbage Collection is enabled at the moment.
    #
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/garbage_collection.rb#26
    def enabled?; end

    # Return the GC profiler wrapper.
    #
    # Returns {Profiler} if the Ruby Garbage Collection profiler is enabled.
    # This is checked by calling `GC::Profiler.enabled?`.
    #
    # GC profiling is disabled by default due to the overhead it causes. Do not
    # enable this in production for long periods of time.
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/garbage_collection.rb#13
    def profiler; end
  end
end

# A dummy profiler that always returns 0 as the total time. Used when GC
# profiler is disabled.
#
# @api private
#
# source://appsignal//lib/appsignal/garbage_collection.rb#84
class Appsignal::GarbageCollection::NilProfiler
  # @api private
  #
  # source://appsignal//lib/appsignal/garbage_collection.rb#85
  def total_time; end
end

# A wrapper around Ruby's `GC::Profiler` that tracks garbage collection
# time, while clearing `GC::Profiler`'s total_time to make sure it doesn't
# leak memory by keeping garbage collection run samples in memory.
#
# @api private
#
# source://appsignal//lib/appsignal/garbage_collection.rb#41
class Appsignal::GarbageCollection::Profiler
  # @api private
  # @return [Profiler] a new instance of Profiler
  #
  # source://appsignal//lib/appsignal/garbage_collection.rb#46
  def initialize; end

  # Whenever {#total_time} is called, the current `GC::Profiler#total_time`
  # gets added to `@total_time`, after which `GC::Profiler.clear` is called
  # to prevent it from leaking memory. A class-level lock is used to make
  # sure garbage collection time is never counted more than once.
  #
  # Whenever `@total_time` gets above two billion milliseconds (about 23
  # days), it's reset to make sure the result fits in a signed 32-bit
  # integer.
  #
  # @api private
  # @return [Integer]
  #
  # source://appsignal//lib/appsignal/garbage_collection.rb#60
  def total_time; end

  private

  # @api private
  #
  # source://appsignal//lib/appsignal/garbage_collection.rb#73
  def internal_profiler; end

  # @api private
  #
  # source://appsignal//lib/appsignal/garbage_collection.rb#77
  def lock; end

  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/garbage_collection.rb#42
    def lock; end
  end
end

# source://appsignal//lib/appsignal/helpers/instrumentation.rb#4
module Appsignal::Helpers; end

# source://appsignal//lib/appsignal/helpers/instrumentation.rb#5
module Appsignal::Helpers::Instrumentation
  include ::Appsignal::Utils::DeprecationMessage

  # Add breadcrumbs to the transaction.
  #
  # Breadcrumbs can be used to trace what path a user has taken
  # before encounterin an error.
  #
  # Only the last 20 added breadcrumbs will be saved.
  #
  # @example
  #   Appsignal.add_breadcrumb(
  #   "Navigation",
  #   "http://blablabla.com",
  #   "",
  #   { :response => 200 },
  #   Time.now.utc
  #   )
  #   Appsignal.add_breadcrumb(
  #   "Network",
  #   "[GET] http://blablabla.com",
  #   "",
  #   { :response => 500 }
  #   )
  #   Appsignal.add_breadcrumb(
  #   "UI",
  #   "closed modal(change_password)",
  #   "User closed modal without actions"
  #   )
  # @option metadata
  # @option time
  # @option message
  # @param time [Hash] a customizable set of options
  # @param message [Hash] a customizable set of options
  # @param category [String] category of breadcrumb
  #   e.g. "UI", "Network", "Navigation", "Console".
  # @param action [String] name of breadcrumb
  #   e.g "The user clicked a button", "HTTP 500 from http://blablabla.com"
  # @param metadata [Hash] a customizable set of options
  # @return [void]
  # @see Transaction#add_breadcrumb
  # @see https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html Breadcrumb reference
  # @since 2.12.0
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#489
  def add_breadcrumb(category, action, message = T.unsafe(nil), metadata = T.unsafe(nil), time = T.unsafe(nil)); end

  # Set an error on the current transaction.
  #
  # **Note**: Does not do anything if AppSignal is not active, no
  # transaction is currently active or when the "error" is not a class
  # extended from Ruby's Exception class.
  #
  # @example Manual instrumentation of set_error.
  #   # Manually starting AppSignal here
  #   # Manually starting a transaction here.
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   # Manually completing the transaction here.
  #   # Manually stopping AppSignal here
  # @example In a Rails application
  #   class SomeController < ApplicationController
  #   # The AppSignal transaction is created by our integration for you.
  #   def create
  #   # Do something that breaks
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   end
  # @example Add more metadata to transaction
  #   Appsignal.set_error(e) do |transaction|
  #   transaction.params = { :search_query => params[:search_query] }
  #   transaction.set_action("my_action_name")
  #   transaction.set_tags(:key => "value")
  #   transaction.set_namespace("my_namespace")
  #   end
  # @param exception [Exception] The error to add to the current
  #   transaction.
  # @param tags [Hash{String, Symbol => String, Symbol, Integer}] Additional tags to add to the error. See also {.tag_request}.
  #   This parameter is deprecated. Use the block argument instead.
  # @param namespace [String] The namespace in which the error occurred.
  #   See also {.set_namespace}.
  #   This parameter is deprecated. Use the block argument instead.
  # @return [void]
  # @see Transaction#set_error
  # @see https://docs.appsignal.com/ruby/instrumentation/exception-handling.html Exception handling guide
  # @since 0.6.6
  # @yield [transaction] yields block to allow modification of the
  #   transaction.
  # @yieldparam transaction [Transaction] yields the AppSignal transaction
  #   used to store the error.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#300
  def add_exception(exception, tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Instrument helper for AppSignal.
  #
  # For more help, read our custom instrumentation guide, listed under "See
  # also".
  #
  # @example Simple instrumentation
  #   Appsignal.instrument("fetch.issue_fetcher") do
  #   # To be instrumented code
  #   end
  # @example Instrumentation with title and body
  #   Appsignal.instrument(
  #   "fetch.issue_fetcher",
  #   "Fetching issue",
  #   "GitHub API"
  #   ) do
  #   # To be instrumented code
  #   end
  # @param name [String] Name of the instrumented event. Read our event
  #   naming guide listed under "See also".
  # @param title [String, nil] Human readable name of the event.
  # @param body [String, nil] Value of importance for the event, such as
  #   the server against an API call is made.
  # @param body_format [Integer] Enum for the type of event that is
  #   instrumented. Accepted values are {EventFormatter::DEFAULT} and
  #   {EventFormatter::SQL_BODY_FORMAT}, but we recommend you use
  #   {.instrument_sql} instead of {EventFormatter::SQL_BODY_FORMAT}.
  # @return [Object] Returns the block's return value.
  # @see Appsignal::Transaction#instrument
  # @see .instrument_sql
  # @see https://docs.appsignal.com/ruby/instrumentation/instrumentation.html AppSignal custom instrumentation guide
  # @see https://docs.appsignal.com/api/event-names.html AppSignal event naming guide
  # @since 1.3.0
  # @yield yields the given block of code instrumented in an AppSignal
  #   event.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#536
  def instrument(name, title = T.unsafe(nil), body = T.unsafe(nil), body_format = T.unsafe(nil)); end

  # Instrumentation helper for SQL queries.
  #
  # This helper filters out values from SQL queries so you don't have to.
  #
  # @example SQL query instrumentation
  #   body = "SELECT * FROM ..."
  #   Appsignal.instrument_sql("perform.query", nil, body) do
  #   # To be instrumented code
  #   end
  # @example SQL query instrumentation
  #   body = "WHERE email = 'foo@..'"
  #   Appsignal.instrument_sql("perform.query", nil, body) do
  #   # query value will replace 'foo..' with a question mark `?`.
  #   end
  # @param name [String] Name of the instrumented event. Read our event
  #   naming guide listed under "See also".
  # @param title [String, nil] Human readable name of the event.
  # @param body [String, nil] SQL query that's being executed.
  # @return [Object] Returns the block's return value.
  # @see .instrument
  # @see https://docs.appsignal.com/ruby/instrumentation/instrumentation.html AppSignal custom instrumentation guide
  # @see https://docs.appsignal.com/api/event-names.html AppSignal event naming guide
  # @since 2.0.0
  # @yield yields the given block of code instrumented in an AppSignal
  #   event.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#580
  def instrument_sql(name, title = T.unsafe(nil), body = T.unsafe(nil), &block); end

  # Listen for an error to occur and send it to AppSignal.
  #
  # Uses {.send_error} to directly send the error in a separate
  # transaction. Does not add the error to the current transaction.
  #
  # Make sure that AppSignal is integrated in your application beforehand.
  # AppSignal won't record errors unless {Appsignal.active?} is `true`.
  #
  # @example
  #   # my_app.rb
  #   # setup AppSignal beforehand
  #
  #   Appsignal.listen_for_error do
  #   # my code
  #   raise "foo"
  #   end
  # @param tags [Hash, nil]
  # @param namespace [String] the namespace for this error.
  # @return [Object] returns the return value of the given block.
  # @see Transaction.set_tags
  # @see Transaction.set_namespace
  # @see .send_error
  # @see https://docs.appsignal.com/ruby/instrumentation/integrating-appsignal.html AppSignal integration guide
  # @yield yields the given block.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#136
  def listen_for_error(tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Listen for an error to occur and send it to AppSignal.
  #
  # Uses {.send_error} to directly send the error in a separate
  # transaction. Does not add the error to the current transaction.
  #
  # Make sure that AppSignal is integrated in your application beforehand.
  # AppSignal won't record errors unless {Appsignal.active?} is `true`.
  #
  # @example
  #   # my_app.rb
  #   # setup AppSignal beforehand
  #
  #   Appsignal.listen_for_error do
  #   # my code
  #   raise "foo"
  #   end
  # @param tags [Hash, nil]
  # @param namespace [String] the namespace for this error.
  # @return [Object] returns the return value of the given block.
  # @see Transaction.set_tags
  # @see Transaction.set_namespace
  # @see .send_error
  # @see https://docs.appsignal.com/ruby/instrumentation/integrating-appsignal.html AppSignal integration guide
  # @yield yields the given block.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#136
  def listen_for_exception(tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Monitor a transaction, stop AppSignal and wait for this single
  # transaction to be flushed.
  #
  # Useful for cases such as Rake tasks and Resque-like systems where a
  # process is forked and immediately exits after the transaction finishes.
  #
  # @see monitor_transaction
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#103
  def monitor_single_transaction(name, env = T.unsafe(nil), &block); end

  # Creates an AppSignal transaction for the given block.
  #
  # If AppSignal is not {Appsignal.active?} it will still execute the
  # block, but not create a transaction for it.
  #
  # A event is created for this transaction with the name given in the
  # `name` argument. The event name must start with either `perform_job` or
  # `process_action` to differentiate between the "web" and "background"
  # namespace. Custom namespaces are not supported by this helper method.
  #
  # This helper method also captures any exception that occurs in the given
  # block.
  #
  # @example
  #   Appsignal.monitor_transaction("perform_job.nightly_update") do
  #   # your code
  #   end
  # @example with an environment
  #   Appsignal.monitor_transaction(
  #   "perform_job.nightly_update",
  #   :metadata => { "user_id" => 1 }
  #   ) do
  #   # your code
  #   end
  # @option env
  # @option env
  # @option env
  # @option env
  # @option env
  # @option env
  # @option env
  # @param name [String] main event name.
  # @param env [Hash<Symbol, Object>]
  # @raise [Exception] any exception that occurs within the given block is
  #   re-raised by this method.
  # @return [Object] the value of the given block is returned.
  # @since 0.10.0
  # @yield the block to monitor.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#60
  def monitor_transaction(name, env = T.unsafe(nil), &block); end

  # Send an error to AppSignal regardless of the context.
  #
  # Records and send the exception to AppSignal.
  #
  # This instrumentation helper does not require a transaction to be
  # active, it starts a new transaction by itself.
  #
  # Use {.set_error} if your want to add an exception to the current
  # transaction.
  #
  # **Note**: Does not do anything if AppSignal is not active or when the
  # "error" is not a class extended from Ruby's Exception class.
  #
  # @example Send an exception
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.send_error(e)
  #   end
  # @example Send an exception with tags. Deprecated method.
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.send_error(e, :key => "value")
  #   end
  # @example Add more metadata to transaction
  #   Appsignal.send_error(e) do |transaction|
  #   transaction.params = { :search_query => params[:search_query] }
  #   transaction.set_action("my_action_name")
  #   transaction.set_tags(:key => "value")
  #   transaction.set_namespace("my_namespace")
  #   end
  # @param error [Exception] The error to send to AppSignal.
  # @param tags [Hash{String, Symbol => String, Symbol, Integer}] Additional tags to add to the error. See also {.tag_request}.
  #   This parameter is deprecated. Use the block argument instead.
  # @param namespace [String] The namespace in which the error occurred.
  #   See also {.set_namespace}.
  #   This parameter is deprecated. Use the block argument instead.
  # @return [void]
  # @see https://docs.appsignal.com/ruby/instrumentation/exception-handling.html Exception handling guide
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html Tagging guide
  # @since 0.6.0
  # @yield [transaction] yields block to allow modification of the
  #   transaction before it's send.
  # @yieldparam transaction [Transaction] yields the AppSignal transaction
  #   used to send the error.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#203
  def send_error(error, tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Send an error to AppSignal regardless of the context.
  #
  # Records and send the exception to AppSignal.
  #
  # This instrumentation helper does not require a transaction to be
  # active, it starts a new transaction by itself.
  #
  # Use {.set_error} if your want to add an exception to the current
  # transaction.
  #
  # **Note**: Does not do anything if AppSignal is not active or when the
  # "error" is not a class extended from Ruby's Exception class.
  #
  # @example Send an exception
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.send_error(e)
  #   end
  # @example Send an exception with tags. Deprecated method.
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.send_error(e, :key => "value")
  #   end
  # @example Add more metadata to transaction
  #   Appsignal.send_error(e) do |transaction|
  #   transaction.params = { :search_query => params[:search_query] }
  #   transaction.set_action("my_action_name")
  #   transaction.set_tags(:key => "value")
  #   transaction.set_namespace("my_namespace")
  #   end
  # @param error [Exception] The error to send to AppSignal.
  # @param tags [Hash{String, Symbol => String, Symbol, Integer}] Additional tags to add to the error. See also {.tag_request}.
  #   This parameter is deprecated. Use the block argument instead.
  # @param namespace [String] The namespace in which the error occurred.
  #   See also {.set_namespace}.
  #   This parameter is deprecated. Use the block argument instead.
  # @return [void]
  # @see https://docs.appsignal.com/ruby/instrumentation/exception-handling.html Exception handling guide
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html Tagging guide
  # @since 0.6.0
  # @yield [transaction] yields block to allow modification of the
  #   transaction before it's send.
  # @yieldparam transaction [Transaction] yields the AppSignal transaction
  #   used to send the error.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#203
  def send_exception(error, tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Set a custom action name for the current transaction.
  #
  # When using an integration such as the Rails or Sinatra AppSignal will
  # try to find the action name from the controller or endpoint for you.
  #
  # If you want to customize the action name as it appears on AppSignal.com
  # you can use this method. This overrides the action name AppSignal
  # generates in an integration.
  #
  # @example in a Rails controller
  #   class SomeController < ApplicationController
  #   before_action :set_appsignal_action
  #
  #   def set_appsignal_action
  #   Appsignal.set_action("DynamicController#dynamic_method")
  #   end
  #   end
  # @param action [String]
  # @return [void]
  # @see Transaction#set_action
  # @since 2.2.0
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#359
  def set_action(action); end

  # Set an error on the current transaction.
  #
  # **Note**: Does not do anything if AppSignal is not active, no
  # transaction is currently active or when the "error" is not a class
  # extended from Ruby's Exception class.
  #
  # @example Manual instrumentation of set_error.
  #   # Manually starting AppSignal here
  #   # Manually starting a transaction here.
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   # Manually completing the transaction here.
  #   # Manually stopping AppSignal here
  # @example In a Rails application
  #   class SomeController < ApplicationController
  #   # The AppSignal transaction is created by our integration for you.
  #   def create
  #   # Do something that breaks
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   end
  # @example Add more metadata to transaction
  #   Appsignal.set_error(e) do |transaction|
  #   transaction.params = { :search_query => params[:search_query] }
  #   transaction.set_action("my_action_name")
  #   transaction.set_tags(:key => "value")
  #   transaction.set_namespace("my_namespace")
  #   end
  # @param exception [Exception] The error to add to the current
  #   transaction.
  # @param tags [Hash{String, Symbol => String, Symbol, Integer}] Additional tags to add to the error. See also {.tag_request}.
  #   This parameter is deprecated. Use the block argument instead.
  # @param namespace [String] The namespace in which the error occurred.
  #   See also {.set_namespace}.
  #   This parameter is deprecated. Use the block argument instead.
  # @return [void]
  # @see Transaction#set_error
  # @see https://docs.appsignal.com/ruby/instrumentation/exception-handling.html Exception handling guide
  # @since 0.6.6
  # @yield [transaction] yields block to allow modification of the
  #   transaction.
  # @yieldparam transaction [Transaction] yields the AppSignal transaction
  #   used to store the error.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#300
  def set_error(exception, tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Set an error on the current transaction.
  #
  # **Note**: Does not do anything if AppSignal is not active, no
  # transaction is currently active or when the "error" is not a class
  # extended from Ruby's Exception class.
  #
  # @example Manual instrumentation of set_error.
  #   # Manually starting AppSignal here
  #   # Manually starting a transaction here.
  #   begin
  #   raise "oh no!"
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   # Manually completing the transaction here.
  #   # Manually stopping AppSignal here
  # @example In a Rails application
  #   class SomeController < ApplicationController
  #   # The AppSignal transaction is created by our integration for you.
  #   def create
  #   # Do something that breaks
  #   rescue => e
  #   Appsignal.set_error(e)
  #   end
  #   end
  # @example Add more metadata to transaction
  #   Appsignal.set_error(e) do |transaction|
  #   transaction.params = { :search_query => params[:search_query] }
  #   transaction.set_action("my_action_name")
  #   transaction.set_tags(:key => "value")
  #   transaction.set_namespace("my_namespace")
  #   end
  # @param exception [Exception] The error to add to the current
  #   transaction.
  # @param tags [Hash{String, Symbol => String, Symbol, Integer}] Additional tags to add to the error. See also {.tag_request}.
  #   This parameter is deprecated. Use the block argument instead.
  # @param namespace [String] The namespace in which the error occurred.
  #   See also {.set_namespace}.
  #   This parameter is deprecated. Use the block argument instead.
  # @return [void]
  # @see Transaction#set_error
  # @see https://docs.appsignal.com/ruby/instrumentation/exception-handling.html Exception handling guide
  # @since 0.6.6
  # @yield [transaction] yields block to allow modification of the
  #   transaction.
  # @yieldparam transaction [Transaction] yields the AppSignal transaction
  #   used to store the error.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#300
  def set_exception(exception, tags = T.unsafe(nil), namespace = T.unsafe(nil)); end

  # Set a custom namespace for the current transaction.
  #
  # When using an integration such as Rails or Sidekiq AppSignal will try
  # to find a appropriate namespace for the transaction.
  #
  # A Rails controller will be automatically put in the "http_request"
  # namespace, while a Sidekiq background job is put in the
  # "background_job" namespace.
  #
  # Note: The "http_request" namespace gets transformed on AppSignal.com to
  # "Web" and "background_job" gets transformed to "Background".
  #
  # If you want to customize the namespace in which transactions appear you
  # can use this method. This overrides the namespace AppSignal uses by
  # default.
  #
  # A common request we've seen is to split the administration panel from
  # the main application.
  #
  # @example create a custom admin namespace
  #   class AdminController < ApplicationController
  #   before_action :set_appsignal_namespace
  #
  #   def set_appsignal_namespace
  #   Appsignal.set_namespace("admin")
  #   end
  #   end
  # @param namespace [String]
  # @return [void]
  # @see Transaction#set_namespace
  # @since 2.2.0
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#399
  def set_namespace(namespace); end

  # Set tags on the current transaction.
  #
  # Tags are extra bits of information that are added to transaction and
  # appear on sample details pages on AppSignal.com.
  #
  # @example Nested hashes are not supported
  #   # Bad
  #   Appsignal.tag_request(:user => { :locale => "en" })
  # @example
  #   Appsignal.tag_request(:locale => "en")
  #   Appsignal.tag_request("locale" => "en")
  #   Appsignal.tag_request("user_id" => 1)
  # @example in a Rails controller
  #   class SomeController < ApplicationController
  #   before_action :set_appsignal_tags
  #
  #   def set_appsignal_tags
  #   Appsignal.tag_request(:locale => I18n.locale)
  #   end
  #   end
  # @option tags
  # @option tags
  # @param tags [Hash] Collection of tags.
  # @return [void]
  # @see Transaction.set_tags
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html Tagging guide
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#440
  def tag_job(tags = T.unsafe(nil)); end

  # Set tags on the current transaction.
  #
  # Tags are extra bits of information that are added to transaction and
  # appear on sample details pages on AppSignal.com.
  #
  # @example Nested hashes are not supported
  #   # Bad
  #   Appsignal.tag_request(:user => { :locale => "en" })
  # @example
  #   Appsignal.tag_request(:locale => "en")
  #   Appsignal.tag_request("locale" => "en")
  #   Appsignal.tag_request("user_id" => 1)
  # @example in a Rails controller
  #   class SomeController < ApplicationController
  #   before_action :set_appsignal_tags
  #
  #   def set_appsignal_tags
  #   Appsignal.tag_request(:locale => I18n.locale)
  #   end
  #   end
  # @option tags
  # @option tags
  # @param tags [Hash] Collection of tags.
  # @return [void]
  # @see Transaction.set_tags
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html Tagging guide
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#440
  def tag_request(tags = T.unsafe(nil)); end

  # Convenience method for skipping instrumentations around a block of code.
  #
  # @example
  #   Appsignal.without_instrumentation do
  #   # Complex code here
  #   end
  # @return [Object] Returns the return value of the block.
  # @since 0.8.7
  # @yield block of code that shouldn't be instrumented.
  #
  # source://appsignal//lib/appsignal/helpers/instrumentation.rb#600
  def without_instrumentation; end
end

# source://appsignal//lib/appsignal/helpers/metrics.rb#5
module Appsignal::Helpers::Metrics
  # source://appsignal//lib/appsignal/helpers/metrics.rb#44
  def add_distribution_value(key, value, tags = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/helpers/metrics.rb#33
  def increment_counter(key, value = T.unsafe(nil), tags = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/helpers/metrics.rb#6
  def set_gauge(key, value, tags = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/helpers/metrics.rb#17
  def set_host_gauge(_key, _value); end

  # source://appsignal//lib/appsignal/helpers/metrics.rb#25
  def set_process_gauge(_key, _value); end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks.rb#5
class Appsignal::Hooks
  class << self
    # Alias integration constants that have moved to their own module.
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/hooks.rb#74
    def const_missing(name); end

    # @api private
    #
    # source://appsignal//lib/appsignal/hooks.rb#17
    def hooks; end

    # @api private
    #
    # source://appsignal//lib/appsignal/hooks.rb#11
    def load_hooks; end

    # @api private
    #
    # source://appsignal//lib/appsignal/hooks.rb#7
    def register(name, hook); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/action_cable.rb#6
class Appsignal::Hooks::ActionCableHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/action_cable.rb#11
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/action_cable.rb#16
  def install; end

  private

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/action_cable.rb#25
  def install_callbacks; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/action_cable.rb#9
Appsignal::Hooks::ActionCableHook::REQUEST_ID = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/hooks/action_mailer.rb#5
class Appsignal::Hooks::ActionMailerHook < ::Appsignal::Hooks::Hook
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/action_mailer.rb#8
  def dependencies_present?; end

  # source://appsignal//lib/appsignal/hooks/action_mailer.rb#12
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/active_job.rb#6
class Appsignal::Hooks::ActiveJobHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/active_job.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/active_job.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/active_job.rb#20
module Appsignal::Hooks::ActiveJobHook::ActiveJobClassInstrumentation
  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/active_job.rb#21
  def execute(job); end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/active_job.rb#87
module Appsignal::Hooks::ActiveJobHook::ActiveJobHelpers
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/hooks/active_job.rb#94
    def action_name(job); end

    # @api private
    #
    # source://appsignal//lib/appsignal/hooks/active_job.rb#134
    def increment_counter(key, value, tags = T.unsafe(nil)); end

    # Returns an array of metrics with tags used to report the job metrics
    #
    # If job ONLY has a queue, it will return `queue_job_count` with tags.
    # If job has a queue AND priority, it will ALSO return
    # `queue_priority_job_count` with tags.
    #
    # @api private
    # @return [Array] Array of metrics with tags to report.
    #
    # source://appsignal//lib/appsignal/hooks/active_job.rb#110
    def metrics_for(job); end

    # @api private
    #
    # source://appsignal//lib/appsignal/hooks/active_job.rb#125
    def transaction_tags_for(job); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/active_job.rb#88
Appsignal::Hooks::ActiveJobHook::ActiveJobHelpers::ACTION_MAILER_CLASSES = T.let(T.unsafe(nil), Array)

# @api private
#
# source://appsignal//lib/appsignal/hooks/active_support_notifications.rb#6
class Appsignal::Hooks::ActiveSupportNotificationsHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/active_support_notifications.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/active_support_notifications.rb#13
  def install; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/active_support_notifications.rb#47
  def install_module(mod, instrumenter); end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/celluloid.rb#6
class Appsignal::Hooks::CelluloidHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/celluloid.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/celluloid.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/data_mapper.rb#6
class Appsignal::Hooks::DataMapperHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/data_mapper.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/data_mapper.rb#14
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/delayed_job.rb#6
class Appsignal::Hooks::DelayedJobHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/delayed_job.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/delayed_job.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/dry_monitor.rb#6
class Appsignal::Hooks::DryMonitorHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/dry_monitor.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/dry_monitor.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/excon.rb#6
class Appsignal::Hooks::ExconHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/excon.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/excon.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/gvl.rb#6
class Appsignal::Hooks::GvlHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/gvl.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/gvl.rb#18
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks.rb#59
module Appsignal::Hooks::Helpers
  # @api private
  #
  # source://appsignal//lib/appsignal/hooks.rb#60
  def string_or_inspect(string_or_other); end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks.rb#68
  def truncate(text); end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks.rb#22
class Appsignal::Hooks::Hook
  # @api private
  # @return [Hook] a new instance of Hook
  #
  # source://appsignal//lib/appsignal/hooks.rb#27
  def initialize; end

  # @api private
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks.rb#50
  def dependencies_present?; end

  # @api private
  # @raise [NotImplementedError]
  #
  # source://appsignal//lib/appsignal/hooks.rb#54
  def install; end

  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks.rb#46
  def installed?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks.rb#31
  def try_to_install(name); end

  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/hooks.rb#23
    def register(name, hook = T.unsafe(nil)); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/http.rb#6
class Appsignal::Hooks::HttpHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/http.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/http.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/mongo_ruby_driver.rb#6
class Appsignal::Hooks::MongoRubyDriverHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/mongo_ruby_driver.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/mongo_ruby_driver.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/mri.rb#6
class Appsignal::Hooks::MriHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/mri.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/mri.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/net_http.rb#8
class Appsignal::Hooks::NetHttpHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/net_http.rb#11
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/net_http.rb#15
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/passenger.rb#6
class Appsignal::Hooks::PassengerHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/passenger.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/passenger.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/puma.rb#6
class Appsignal::Hooks::PumaHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/puma.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/puma.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/que.rb#6
class Appsignal::Hooks::QueHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/que.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/que.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/rake.rb#6
class Appsignal::Hooks::RakeHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/rake.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/rake.rb#13
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/redis_client.rb#6
class Appsignal::Hooks::RedisClientHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/redis_client.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/redis_client.rb#15
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/redis.rb#6
class Appsignal::Hooks::RedisHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/redis.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/redis.rb#16
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/resque.rb#6
class Appsignal::Hooks::ResqueHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/resque.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/resque.rb#13
  def install; end
end

# source://appsignal//lib/appsignal/hooks/sequel.rb#34
class Appsignal::Hooks::SequelHook < ::Appsignal::Hooks::Hook
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/sequel.rb#37
  def dependencies_present?; end

  # source://appsignal//lib/appsignal/hooks/sequel.rb#43
  def install; end
end

# source://appsignal//lib/appsignal/hooks/sequel.rb#20
module Appsignal::Hooks::SequelLogConnectionExtension
  # Add query instrumentation
  #
  # source://appsignal//lib/appsignal/hooks/sequel.rb#22
  def log_connection_yield(sql, conn, args = T.unsafe(nil)); end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/sequel.rb#6
module Appsignal::Hooks::SequelLogExtension
  # Add query instrumentation
  #
  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/sequel.rb#8
  def log_yield(sql, args = T.unsafe(nil)); end
end

# source://appsignal//lib/appsignal/hooks/shoryuken.rb#68
class Appsignal::Hooks::ShoryukenHook < ::Appsignal::Hooks::Hook
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/shoryuken.rb#71
  def dependencies_present?; end

  # source://appsignal//lib/appsignal/hooks/shoryuken.rb#75
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/shoryuken.rb#6
class Appsignal::Hooks::ShoryukenMiddleware
  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/shoryuken.rb#7
  def call(worker_instance, queue, sqs_msg, body, &block); end
end

# source://appsignal//lib/appsignal/hooks/sidekiq.rb#5
class Appsignal::Hooks::SidekiqHook < ::Appsignal::Hooks::Hook
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/sidekiq.rb#8
  def dependencies_present?; end

  # source://appsignal//lib/appsignal/hooks/sidekiq.rb#12
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/unicorn.rb#6
class Appsignal::Hooks::UnicornHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/unicorn.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/unicorn.rb#14
  def install; end
end

# @api private
#
# source://appsignal//lib/appsignal/hooks/webmachine.rb#6
class Appsignal::Hooks::WebmachineHook < ::Appsignal::Hooks::Hook
  # @api private
  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/hooks/webmachine.rb#9
  def dependencies_present?; end

  # @api private
  #
  # source://appsignal//lib/appsignal/hooks/webmachine.rb#13
  def install; end
end

# source://appsignal//lib/appsignal/integrations/railtie.rb#9
module Appsignal::Integrations; end

# Report errors reported by the Rails error reporter.
#
# We only report that are not reraised by the error reporter, using
# `Rails.error.handle`.
#
# @api private
#
# source://appsignal//lib/appsignal/integrations/railtie.rb#55
class Appsignal::Integrations::RailsErrorReporterSubscriber
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/integrations/railtie.rb#57
    def report(error, handled:, severity:, context: T.unsafe(nil), source: T.unsafe(nil)); end

    private

    # @api private
    #
    # source://appsignal//lib/appsignal/integrations/railtie.rb#76
    def context_for(context); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/integrations/railtie.rb#11
class Appsignal::Integrations::Railtie < ::Rails::Railtie
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/integrations/railtie.rb#20
    def initialize_appsignal(app); end

    # @api private
    #
    # source://appsignal//lib/appsignal/integrations/railtie.rb#42
    def initialize_error_reporter; end
  end
end

# Logger that flushes logs to the AppSignal logging service
#
# source://appsignal//lib/appsignal/logger.rb#8
class Appsignal::Logger < ::Logger
  # Create a new logger instance
  #
  # @param group Name of the group for this logger.
  # @param level Log level to filter with
  # @raise [TypeError]
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#27
  def initialize(group, level: T.unsafe(nil), format: T.unsafe(nil)); end

  # We support the various methods in the Ruby
  # logger class by supplying this method.
  #
  # @api private
  #
  # source://appsignal//lib/appsignal/logger.rb#39
  def add(severity, message = T.unsafe(nil), group = T.unsafe(nil)); end

  # Log a debug level message
  #
  # @param message Mesage to log
  # @param attributes Attributes to tag the log with
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#70
  def debug(message = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # Log an error level message
  #
  # @param message Mesage to log
  # @param attributes Attributes to tag the log with
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#109
  def error(message = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # Log a fatal level message
  #
  # @param message Mesage to log
  # @param attributes Attributes to tag the log with
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#122
  def fatal(message = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # Log an info level message
  #
  # @param message Mesage to log
  # @param attributes Attributes to tag the log with
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#83
  def info(message = T.unsafe(nil), attributes = T.unsafe(nil)); end

  # Returns the value of attribute level.
  #
  # source://appsignal//lib/appsignal/logger.rb#20
  def level; end

  # We support the various methods in the Ruby
  # logger class by supplying this method.
  #
  # @api private
  #
  # source://appsignal//lib/appsignal/logger.rb#39
  def log(severity, message = T.unsafe(nil), group = T.unsafe(nil)); end

  # When using ActiveSupport::TaggedLogging without the broadcast feature,
  # the passed logger is required to respond to the `silence` method.
  # In our case it behaves as the broadcast feature of the Rails logger, but
  # we don't have to check if the parent logger has the `silence` method defined
  # as our logger directly inherits from Ruby base logger.
  #
  # Links:
  # https://github.com/rails/rails/blob/e11ebc04cfbe41c06cdfb70ee5a9fdbbd98bb263/activesupport/lib/active_support/logger.rb#L60-L76
  # https://github.com/rails/rails/blob/main/activesupport/e11ebc04cfbe41c06cdfb70ee5a9fdbbd98bb263/active_support/logger_silence.rb
  #
  # source://appsignal//lib/appsignal/logger.rb#140
  def silence(_severity = T.unsafe(nil), &block); end

  # Log a warn level message
  #
  # @param message Mesage to log
  # @param attributes Attributes to tag the log with
  # @return [void]
  #
  # source://appsignal//lib/appsignal/logger.rb#96
  def warn(message = T.unsafe(nil), attributes = T.unsafe(nil)); end

  private

  # source://appsignal//lib/appsignal/logger.rb#146
  def add_with_attributes(severity, message, group, attributes); end

  # source://appsignal//lib/appsignal/logger.rb#153
  def appsignal_attributes; end
end

# source://appsignal//lib/appsignal/logger.rb#11
Appsignal::Logger::JSON = T.let(T.unsafe(nil), Integer)

# source://appsignal//lib/appsignal/logger.rb#10
Appsignal::Logger::LOGFMT = T.let(T.unsafe(nil), Integer)

# source://appsignal//lib/appsignal/logger.rb#9
Appsignal::Logger::PLAINTEXT = T.let(T.unsafe(nil), Integer)

# source://appsignal//lib/appsignal/logger.rb#12
Appsignal::Logger::SEVERITY_MAP = T.let(T.unsafe(nil), Hash)

# Deploy markers are used on AppSignal.com to indicate changes in an
# application, "Deploy markers" indicate a deploy of an application.
#
# Incidents for exceptions and performance issues will be closed and
# reopened if they occur again in the new deploy.
#
# This class will help send a request to the AppSignal Push API to create a
# Deploy marker for the application on AppSignal.com.
#
# @api private
# @see Appsignal::CLI::NotifyOfDeploy
# @see https://docs.appsignal.com/appsignal/terminology.html#markers Terminology: Deploy marker
#
# source://appsignal//lib/appsignal/marker.rb#24
class Appsignal::Marker
  # @api private
  # @option marker_data
  # @option marker_data
  # @option marker_data
  # @option marker_data
  # @param marker_data [Hash] see {#marker_data}
  # @param config [Appsignal::Config]
  # @return [Marker] a new instance of Marker
  #
  # source://appsignal//lib/appsignal/marker.rb#40
  def initialize(marker_data, config); end

  # @api private
  # @return [Appsignal::Config] config to use in the authentication request.
  #   Set config does not override data set in {#marker_data}.
  #
  # source://appsignal//lib/appsignal/marker.rb#29
  def config; end

  # @api private
  # @return [Hash] marker data to send.
  #
  # source://appsignal//lib/appsignal/marker.rb#29
  def marker_data; end

  # Send a request to create the marker.
  #
  # Prints output to STDOUT.
  #
  # @api private
  # @return [void]
  #
  # source://appsignal//lib/appsignal/marker.rb#50
  def transmit; end
end

# Path used on the AppSignal Push API
# https://push.appsignal.com/1/markers
#
# @api private
#
# source://appsignal//lib/appsignal/marker.rb#27
Appsignal::Marker::ACTION = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/minutely.rb#4
class Appsignal::Minutely
  class << self
    # @return [ProbeCollection] Returns list of probes.
    # @see ProbeCollection
    #
    # source://appsignal//lib/appsignal/minutely.rb#118
    def probes; end

    # @api private
    #
    # source://appsignal//lib/appsignal/minutely.rb#123
    def start; end

    # @api private
    #
    # source://appsignal//lib/appsignal/minutely.rb#150
    def stop; end

    # @api private
    #
    # source://appsignal//lib/appsignal/minutely.rb#156
    def wait_time; end

    private

    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/minutely.rb#195
    def dependencies_present?(probe); end

    # source://appsignal//lib/appsignal/minutely.rb#162
    def initial_wait_time; end

    # source://appsignal//lib/appsignal/minutely.rb#175
    def initialize_probe(name, probe); end

    # source://appsignal//lib/appsignal/minutely.rb#169
    def initialize_probes; end

    # source://appsignal//lib/appsignal/minutely.rb#201
    def probe_instances; end
  end
end

# source://appsignal//lib/appsignal/minutely.rb#5
class Appsignal::Minutely::ProbeCollection
  # @return [ProbeCollection] a new instance of ProbeCollection
  #
  # source://appsignal//lib/appsignal/minutely.rb#6
  def initialize; end

  # Fetch a probe using its name.
  #
  # @param key [Symbol/String] The name of the probe to fetch.
  # @return [Object] Returns the registered probe.
  #
  # source://appsignal//lib/appsignal/minutely.rb#24
  def [](key); end

  # Clears all probes from the list.
  #
  # @return [void]
  #
  # source://appsignal//lib/appsignal/minutely.rb#17
  def clear; end

  # @return [Integer] Number of probes that are registered.
  #
  # source://appsignal//lib/appsignal/minutely.rb#11
  def count; end

  # @api private
  #
  # source://appsignal//lib/appsignal/minutely.rb#102
  def each(&block); end

  # Register a new minutely probe.
  #
  # Supported probe types are:
  #
  # - Lambda - A lambda is an object that listens to a `call` method call.
  #   This `call` method is called every minute.
  # - Class - A class object is an object that listens to a `new` and
  #   `call` method call. The `new` method is called when the Minutely
  #   probe thread is started to initialize all probes. This allows probes
  #   to load dependencies once beforehand. Their `call` method is called
  #   every minute.
  # - Class instance - A class instance object is an object that listens to
  #   a `call` method call. The `call` method is called every minute.
  #
  # @example Register a new probe
  #   Appsignal::Minutely.probes.register :my_probe, lambda {}
  # @example Overwrite an existing registered probe
  #   Appsignal::Minutely.probes.register :my_probe, lambda {}
  #   Appsignal::Minutely.probes.register :my_probe, lambda { puts "hello" }
  # @example Add a lambda as a probe
  #   Appsignal::Minutely.probes.register :my_probe, lambda { puts "hello" }
  #   # "hello" # printed every minute
  # @example Add a probe instance
  #   class MyProbe
  #   def initialize
  #   puts "started"
  #   end
  #
  #   def call
  #   puts "called"
  #   end
  #   end
  #
  #   Appsignal::Minutely.probes.register :my_probe, MyProbe.new
  #   # "started" # printed immediately
  #   # "called" # printed every minute
  # @example Add a probe class
  #   class MyProbe
  #   def initialize
  #   # Add things that only need to be done on start up for this probe
  #   require "some/library/dependency"
  #   @cache = {} # initialize a local cache variable
  #   puts "started"
  #   end
  #
  #   def call
  #   puts "called"
  #   end
  #   end
  #
  #   Appsignal::Minutely.probes.register :my_probe, MyProbe
  #   Appsignal::Minutely.start # This is called for you
  #   # "started" # Printed on Appsignal::Minutely.start
  #   # "called" # Repeated every minute
  # @param name [Symbol/String] Name of the probe. Can be used with {[]}.
  #   This name will be used in errors in the log and allows overwriting of
  #   probes by registering new ones with the same name.
  # @param probe [Object] Any object that listens to the `call` method will
  #   be used as a probe.
  # @return [void]
  #
  # source://appsignal//lib/appsignal/minutely.rb#93
  def register(name, probe); end

  private

  # source://appsignal//lib/appsignal/minutely.rb#110
  def logger; end

  # Returns the value of attribute probes.
  #
  # source://appsignal//lib/appsignal/minutely.rb#108
  def probes; end
end

# source://appsignal//lib/appsignal/probes.rb#4
module Appsignal::Probes; end

# source://appsignal//lib/appsignal/probes/gvl.rb#5
class Appsignal::Probes::GvlProbe
  include ::Appsignal::Probes::Helpers

  # @return [GvlProbe] a new instance of GvlProbe
  #
  # source://appsignal//lib/appsignal/probes/gvl.rb#24
  def initialize(appsignal: T.unsafe(nil), gvl_tools: T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/probes/gvl.rb#30
  def call; end

  private

  # source://appsignal//lib/appsignal/probes/gvl.rb#37
  def probe_global_timer; end

  # source://appsignal//lib/appsignal/probes/gvl.rb#47
  def probe_waiting_threads; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/gvl.rb#9
    def dependencies_present?; end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/gvl.rb#15
    def gvltools_0_2_or_newer?; end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/gvl.rb#20
    def ruby_3_2_or_newer?; end
  end
end

# source://appsignal//lib/appsignal/probes/helpers.rb#5
module Appsignal::Probes::Helpers
  private

  # Calculate the delta of two values for a gauge metric.
  #
  # When this method is called, the given value is stored in a cache
  # under the given cache key.
  #
  # A block must be passed to this method. The first time the method
  # is called for a given cache key, the block will not be yielded to.
  # In subsequent calls, the delta between the previously stored value
  # in the cache for that key and the value given in this invocation
  # will be yielded to the block.
  #
  # This is used for absolute counter values which we want to track as
  # gauges.
  #
  # @example
  #   gauge_delta :with_block, 10 do |delta|
  #   puts "this block will not be yielded to"
  #   end
  #   gauge_delta :with_block, 15 do |delta|
  #   # `delta` has a value of `5`
  #   puts "this block will be yielded to with delta = #{delta}"
  #   end
  # @yield [value - previous_value]
  #
  # source://appsignal//lib/appsignal/probes/helpers.rb#35
  def gauge_delta(cache_key, value); end

  # source://appsignal//lib/appsignal/probes/helpers.rb#8
  def gauge_delta_cache; end

  # source://appsignal//lib/appsignal/probes/helpers.rb#43
  def hostname; end

  # source://appsignal//lib/appsignal/probes/helpers.rb#56
  def set_gauge_with_hostname(metric, value, tags = T.unsafe(nil)); end
end

# source://appsignal//lib/appsignal/probes/mri.rb#5
class Appsignal::Probes::MriProbe
  include ::Appsignal::Probes::Helpers

  # @return [MriProbe] a new instance of MriProbe
  #
  # source://appsignal//lib/appsignal/probes/mri.rb#13
  def initialize(appsignal: T.unsafe(nil), gc_profiler: T.unsafe(nil)); end

  # @api private
  #
  # source://appsignal//lib/appsignal/probes/mri.rb#20
  def call; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/mri.rb#9
    def dependencies_present?; end
  end
end

# source://appsignal//lib/appsignal/probes/sidekiq.rb#5
class Appsignal::Probes::SidekiqProbe
  include ::Appsignal::Probes::Helpers

  # @return [SidekiqProbe] a new instance of SidekiqProbe
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#55
  def initialize(config = T.unsafe(nil)); end

  # @api private
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#67
  def call; end

  # @api private
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#41
  def config; end

  private

  # Returns the value of attribute adapter.
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#75
  def adapter; end

  # Returns the value of attribute cache.
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#75
  def cache; end

  # Track a gauge metric with the `sidekiq_` prefix
  #
  # source://appsignal//lib/appsignal/probes/sidekiq.rb#114
  def gauge(key, value, tags = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/probes/sidekiq.rb#121
  def hostname; end

  # source://appsignal//lib/appsignal/probes/sidekiq.rb#105
  def track_queues; end

  # source://appsignal//lib/appsignal/probes/sidekiq.rb#77
  def track_redis_info; end

  # source://appsignal//lib/appsignal/probes/sidekiq.rb#86
  def track_stats; end

  class << self
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/sidekiq.rb#48
    def dependencies_present?; end

    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/probes/sidekiq.rb#43
    def sidekiq7_and_greater?; end
  end
end

# source://appsignal//lib/appsignal/probes/sidekiq.rb#24
class Appsignal::Probes::SidekiqProbe::Sidekiq6Adapter
  class << self
    # source://appsignal//lib/appsignal/probes/sidekiq.rb#31
    def hostname; end

    # source://appsignal//lib/appsignal/probes/sidekiq.rb#25
    def redis_info; end
  end
end

# source://appsignal//lib/appsignal/probes/sidekiq.rb#8
class Appsignal::Probes::SidekiqProbe::Sidekiq7Adapter
  class << self
    # source://appsignal//lib/appsignal/probes/sidekiq.rb#15
    def hostname; end

    # source://appsignal//lib/appsignal/probes/sidekiq.rb#9
    def redis_info; end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#7
module Appsignal::Rack; end

# @api private
#
# source://appsignal//lib/appsignal/rack/generic_instrumentation.rb#8
class Appsignal::Rack::GenericInstrumentation
  # @api private
  # @return [GenericInstrumentation] a new instance of GenericInstrumentation
  #
  # source://appsignal//lib/appsignal/rack/generic_instrumentation.rb#9
  def initialize(app, options = T.unsafe(nil)); end

  # @api private
  #
  # source://appsignal//lib/appsignal/rack/generic_instrumentation.rb#15
  def call(env); end

  # @api private
  #
  # source://appsignal//lib/appsignal/rack/generic_instrumentation.rb#23
  def call_with_appsignal_monitoring(env); end
end

# @api private
#
# source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#8
class Appsignal::Rack::RailsInstrumentation
  # @api private
  # @return [RailsInstrumentation] a new instance of RailsInstrumentation
  #
  # source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#9
  def initialize(app, options = T.unsafe(nil)); end

  # @api private
  #
  # source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#15
  def call(env); end

  # @api private
  #
  # source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#23
  def call_with_appsignal_monitoring(env); end

  # @api private
  #
  # source://appsignal//lib/appsignal/rack/rails_instrumentation.rb#52
  def request_id(env); end
end

# System environment detection module.
#
# Provides useful methods to find out more about the host system.
#
# @api private
#
# source://appsignal//lib/appsignal/system.rb#9
module Appsignal::System
  class << self
    # Detect agent and extension architecture build
    #
    # Used by the `ext/*` tasks to select which architecture build it should download and install.
    #
    # - Use `export APPSIGNAL_BUILD_FOR_LINUX_ARM=1` to enable the experimental
    #   Linux ARM build.
    #
    # @api private
    # @return [String]
    #
    # source://appsignal//lib/appsignal/system.rb#68
    def agent_architecture; end

    # Detect agent and extension platform build
    #
    # Used by `ext/*` to select which build it should download and
    # install.
    #
    # - Use `export APPSIGNAL_BUILD_FOR_MUSL=1` if the detection doesn't work
    #   and to force selection of the musl build.
    # - Use `export APPSIGNAL_BUILD_FOR_LINUX_ARM=1` to enable the experimental
    #   Linux ARM build.
    #
    # @api private
    # @return [String]
    #
    # source://appsignal//lib/appsignal/system.rb#32
    def agent_platform; end

    # @api private
    #
    # source://appsignal//lib/appsignal/system.rb#100
    def extract_ldd_version(string); end

    # Returns whether or not the linux ARM build was selected by the user.
    #
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/system.rb#85
    def force_linux_arm_build?; end

    # Returns whether or not the musl build was forced by the user.
    #
    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/system.rb#78
    def force_musl_build?; end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/system.rb#16
    def heroku?; end

    # @api private
    # @return [Boolean]
    #
    # source://appsignal//lib/appsignal/system.rb#105
    def jruby?; end

    # @api private
    #
    # source://appsignal//lib/appsignal/system.rb#95
    def ldd_version_output; end

    # @api private
    #
    # source://appsignal//lib/appsignal/system.rb#90
    def versionify(version); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/system.rb#13
Appsignal::System::FREEBSD_TARGET = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/system.rb#14
Appsignal::System::GEM_EXT_PATH = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/system.rb#11
Appsignal::System::LINUX_ARM_ARCHITECTURE = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/system.rb#10
Appsignal::System::LINUX_TARGET = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/system.rb#12
Appsignal::System::MUSL_TARGET = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/transaction.rb#6
class Appsignal::Transaction
  # @return [Transaction] a new instance of Transaction
  #
  # source://appsignal//lib/appsignal/transaction.rb#91
  def initialize(transaction_id, namespace, request, options = T.unsafe(nil)); end

  # Returns the value of attribute action.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def action; end

  # Add breadcrumbs to the transaction.
  #
  # @option message
  # @option metadata
  # @option time
  # @param metadata [Hash] a customizable set of options
  # @param time [Hash] a customizable set of options
  # @param message [Hash] a customizable set of options
  # @param category [String] category of breadcrumb
  #   e.g. "UI", "Network", "Navigation", "Console".
  # @param action [String] name of breadcrumb
  #   e.g "The user clicked a button", "HTTP 500 from http://blablabla.com"
  # @return [void]
  # @see Appsignal.add_breadcrumb
  # @see https://docs.appsignal.com/ruby/instrumentation/breadcrumbs.html Breadcrumb reference
  #
  # source://appsignal//lib/appsignal/transaction.rb#189
  def add_breadcrumb(category, action, message = T.unsafe(nil), metadata = T.unsafe(nil), time = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/transaction.rb#363
  def add_exception(error); end

  # Returns the value of attribute breadcrumbs.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def breadcrumbs; end

  # source://appsignal//lib/appsignal/transaction.rb#115
  def complete; end

  # source://appsignal//lib/appsignal/transaction.rb#137
  def discard!; end

  # Returns the value of attribute discarded.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def discarded; end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/transaction.rb#145
  def discarded?; end

  # Returns the value of attribute ext.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def ext; end

  # source://appsignal//lib/appsignal/transaction.rb#422
  def finish_event(name, title, body, body_format = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/transaction.rb#447
  def instrument(name, title = T.unsafe(nil), body = T.unsafe(nil), body_format = T.unsafe(nil)); end

  # Returns the value of attribute namespace.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def namespace; end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/transaction.rb#111
  def nil_transaction?; end

  # Returns the value of attribute options.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def options; end

  # Attribute for parameters of the transaction.
  #
  # When no parameters are set with {#params=} the parameters it will look
  # for parameters on the {#request} environment.
  #
  # The parameters set using {#params=} are leading over those extracted
  # from a request's environment.
  #
  # @return [Hash]
  #
  # source://appsignal//lib/appsignal/transaction.rb#153
  def params; end

  # Sets the attribute params
  #
  # @param value the value to set the attribute params to.
  #
  # source://appsignal//lib/appsignal/transaction.rb#89
  def params=(_arg0); end

  # source://appsignal//lib/appsignal/transaction.rb#125
  def pause!; end

  # Returns the value of attribute paused.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def paused; end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/transaction.rb#133
  def paused?; end

  # source://appsignal//lib/appsignal/transaction.rb#434
  def record_event(name, title, body, duration, body_format = T.unsafe(nil)); end

  # Returns the value of attribute request.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def request; end

  # source://appsignal//lib/appsignal/transaction.rb#141
  def restore!; end

  # source://appsignal//lib/appsignal/transaction.rb#129
  def resume!; end

  # source://appsignal//lib/appsignal/transaction.rb#350
  def sample_data; end

  # Set an action name for the transaction.
  #
  # An action name is used to identify the location of a certain sample;
  # error and performance issues.
  #
  # @param action [String] the action name to set.
  # @return [void]
  # @see Appsignal.set_action
  # @see #set_action_if_nil
  # @since 2.2.0
  #
  # source://appsignal//lib/appsignal/transaction.rb#216
  def set_action(action); end

  # Set an action name only if there is no current action set.
  #
  # Commonly used by AppSignal integrations so that they don't override
  # custom action names.
  #
  # @example
  #   Appsignal.set_action("foo")
  #   Appsignal.set_action_if_nil("bar")
  #   # Transaction action will be "foo"
  # @param action [String]
  # @return [void]
  # @see #set_action
  # @since 2.2.0
  #
  # source://appsignal//lib/appsignal/transaction.rb#237
  def set_action_if_nil(action); end

  # source://appsignal//lib/appsignal/transaction.rb#363
  def set_error(error); end

  # source://appsignal//lib/appsignal/transaction.rb#265
  def set_http_or_background_action(from = T.unsafe(nil)); end

  # Set the queue time based on the HTTP header or `:queue_start` env key
  # value.
  #
  # This method will first try to read the queue time from the HTTP headers
  # `X-Request-Start` or `X-Queue-Start`. Which are parsed by Rack as
  # `HTTP_X_QUEUE_START` and `HTTP_X_REQUEST_START`.
  # The header value is parsed by AppSignal as either milliseconds or
  # microseconds.
  #
  # If no headers are found, or the value could not be parsed, it falls back
  # on the `:queue_start` env key on this Transaction's {request} environment
  # (called like `request.env[:queue_start]`). This value is parsed by
  # AppSignal as seconds.
  #
  # @return [void]
  # @see https://docs.appsignal.com/ruby/instrumentation/request-queue-time.html
  #
  # source://appsignal//lib/appsignal/transaction.rb#309
  def set_http_or_background_queue_start; end

  # source://appsignal//lib/appsignal/transaction.rb#316
  def set_metadata(key, value); end

  # Set the namespace for this transaction.
  #
  # Useful to split up parts of an application into certain namespaces. For
  # example: http requests, background jobs and administration panel
  # controllers.
  #
  # Note: The "http_request" namespace gets transformed on AppSignal.com to
  # "Web" and "background_job" gets transformed to "Background".
  #
  # @example
  #   transaction.set_namespace("background")
  # @param namespace [String] namespace name to use for this transaction.
  # @return [void]
  # @since 2.2.0
  #
  # source://appsignal//lib/appsignal/transaction.rb#258
  def set_namespace(namespace); end

  # Set queue start time for transaction.
  #
  # Most commononly called by {set_http_or_background_queue_start}.
  #
  # @param start [Integer] Queue start time in milliseconds.
  # @raise [RangeError] When the queue start time value is too big, this
  #   method raises a RangeError.
  # @raise [TypeError] Raises a TypeError when the given `start` argument is
  #   not an Integer.
  # @return [void]
  #
  # source://appsignal//lib/appsignal/transaction.rb#285
  def set_queue_start(start); end

  # source://appsignal//lib/appsignal/transaction.rb#323
  def set_sample_data(key, data); end

  # Set tags on the transaction.
  #
  # @option given_tags
  # @option given_tags
  # @param given_tags [Hash] Collection of tags.
  # @return [void]
  # @see Appsignal.tag_request
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html Tagging guide
  #
  # source://appsignal//lib/appsignal/transaction.rb#171
  def set_tags(given_tags = T.unsafe(nil)); end

  # source://appsignal//lib/appsignal/transaction.rb#416
  def start_event; end

  # source://appsignal//lib/appsignal/transaction.rb#149
  def store(key); end

  # Returns the value of attribute tags.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def tags; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transaction.rb#455
  def to_h; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transaction.rb#455
  def to_hash; end

  # Returns the value of attribute transaction_id.
  #
  # source://appsignal//lib/appsignal/transaction.rb#76
  def transaction_id; end

  private

  # Returns calculated background queue start time in milliseconds, based on
  # environment values.
  #
  # @return [nil] if no {#environment} is present.
  # @return [nil] if there is no `:queue_start` in the {#environment}.
  # @return [Integer] `:queue_start` time (in seconds) converted to milliseconds
  #
  # source://appsignal//lib/appsignal/transaction.rb#480
  def background_queue_start; end

  # source://appsignal//lib/appsignal/transaction.rb#614
  def cleaned_backtrace(backtrace); end

  # Clean error messages that are known to potentially contain user data.
  # Returns an unchanged message otherwise.
  #
  # source://appsignal//lib/appsignal/transaction.rb#624
  def cleaned_error_message(error); end

  # Returns the environment for a transaction.
  #
  # Returns an empty Hash when the {#request} object doesn't listen to the
  # `#env` method or the `#env` is nil.
  #
  # @return [Hash<String, Object>]
  #
  # source://appsignal//lib/appsignal/transaction.rb#594
  def environment; end

  # Returns HTTP queue start time in milliseconds.
  #
  # @return [nil] if no queue start time is found.
  # @return [nil] if begin time is too low to be plausible.
  # @return [Integer] queue start in milliseconds.
  #
  # source://appsignal//lib/appsignal/transaction.rb#495
  def http_queue_start; end

  # source://appsignal//lib/appsignal/transaction.rb#525
  def request_params; end

  # Returns sanitized environment for a transaction.
  #
  # The environment of a transaction can contain a lot of information, not
  # all of it useful for debugging.
  #
  # @return [nil] if no environment is present.
  # @return [Hash<String, Object>]
  #
  # source://appsignal//lib/appsignal/transaction.rb#544
  def sanitized_environment; end

  # Returns sanitized metadata set by {#set_metadata} and from the
  # {#environment}.
  #
  # @return [Hash<String, Object>]
  #
  # source://appsignal//lib/appsignal/transaction.rb#579
  def sanitized_metadata; end

  # source://appsignal//lib/appsignal/transaction.rb#518
  def sanitized_params; end

  # Returns sanitized session data.
  #
  # The session data is sanitized by the {Appsignal::Utils::HashSanitizer}.
  #
  # @return [nil] if `:send_session_data` config is set to `false`.
  # @return [nil] if the {#request} object doesn't respond to `#session`.
  # @return [nil] if the {#request} session data is `nil`.
  # @return [Hash<String, Object>]
  #
  # source://appsignal//lib/appsignal/transaction.rb#563
  def sanitized_session_data; end

  # Only keep tags if they meet the following criteria:
  # * Key is a symbol or string with less then 100 chars
  # * Value is a symbol or string with less then 100 chars
  # * Value is an integer
  #
  # @see https://docs.appsignal.com/ruby/instrumentation/tagging.html
  #
  # source://appsignal//lib/appsignal/transaction.rb#607
  def sanitized_tags; end

  class << self
    # Remove current transaction from current Thread.
    #
    # @api private
    #
    # source://appsignal//lib/appsignal/transaction.rb#71
    def clear_current_transaction!; end

    # source://appsignal//lib/appsignal/transaction.rb#59
    def complete_current!; end

    # source://appsignal//lib/appsignal/transaction.rb#18
    def create(id, namespace, request, options = T.unsafe(nil)); end

    # Returns currently active transaction or a {NilTransaction} if none is
    # active.
    #
    # @return [Boolean]
    # @see .current?
    #
    # source://appsignal//lib/appsignal/transaction.rb#46
    def current; end

    # Returns if any transaction is currently active or not. A
    # {NilTransaction} is not considered an active transaction.
    #
    # @return [Boolean]
    # @see .current
    #
    # source://appsignal//lib/appsignal/transaction.rb#55
    def current?; end
  end
end

# source://appsignal//lib/appsignal/transaction.rb#9
Appsignal::Transaction::ACTION_CABLE = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/transaction.rb#12
Appsignal::Transaction::ALLOWED_TAG_KEY_TYPES = T.let(T.unsafe(nil), Array)

# source://appsignal//lib/appsignal/transaction.rb#13
Appsignal::Transaction::ALLOWED_TAG_VALUE_TYPES = T.let(T.unsafe(nil), Array)

# source://appsignal//lib/appsignal/transaction.rb#8
Appsignal::Transaction::BACKGROUND_JOB = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/transaction.rb#11
Appsignal::Transaction::BLANK = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/transaction.rb#14
Appsignal::Transaction::BREADCRUMB_LIMIT = T.let(T.unsafe(nil), Integer)

# source://appsignal//lib/appsignal/transaction.rb#15
Appsignal::Transaction::ERROR_CAUSES_LIMIT = T.let(T.unsafe(nil), Integer)

# source://appsignal//lib/appsignal/transaction.rb#10
Appsignal::Transaction::FRONTEND = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/transaction.rb#460
class Appsignal::Transaction::GenericRequest
  # @return [GenericRequest] a new instance of GenericRequest
  #
  # source://appsignal//lib/appsignal/transaction.rb#463
  def initialize(env); end

  # Returns the value of attribute env.
  #
  # source://appsignal//lib/appsignal/transaction.rb#461
  def env; end

  # source://appsignal//lib/appsignal/transaction.rb#467
  def params; end
end

# source://appsignal//lib/appsignal/transaction.rb#7
Appsignal::Transaction::HTTP_REQUEST = T.let(T.unsafe(nil), String)

# Stub that is returned by {Transaction.current} if there is no current
# transaction, so that it's still safe to call methods on it if there is no
# current transaction.
#
# source://appsignal//lib/appsignal/transaction.rb#636
class Appsignal::Transaction::NilTransaction
  # Instrument should still yield
  #
  # source://appsignal//lib/appsignal/transaction.rb#641
  def instrument(*_args); end

  # source://appsignal//lib/appsignal/transaction.rb#637
  def method_missing(_method, *args, &block); end

  # @return [Boolean]
  #
  # source://appsignal//lib/appsignal/transaction.rb#645
  def nil_transaction?; end
end

# @api private
#
# source://appsignal//lib/appsignal/transmitter.rb#11
class Appsignal::Transmitter
  # @api private
  # @param base_uri [String] Base URI for the transmitter to use. If a full
  #   URI is given (including the HTTP protocol) it is used as the full base.
  #   If only a path is given the `config[:endpoint]` is prefixed along with
  #   `/1/` (API v1 endpoint).
  # @param config [Appsignal::Config] AppSignal configuration to use for this
  #   transmission.
  # @return [Transmitter] a new instance of Transmitter
  #
  # source://appsignal//lib/appsignal/transmitter.rb#34
  def initialize(base_uri, config = T.unsafe(nil)); end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#26
  def base_uri; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#26
  def config; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#56
  def transmit(payload); end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#44
  def uri; end

  private

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#70
  def http_client; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#63
  def http_post(payload); end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#98
  def proxy_addr; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#104
  def proxy_port; end

  # @api private
  #
  # source://appsignal//lib/appsignal/transmitter.rb#94
  def proxy_uri; end
end

# @api private
#
# source://appsignal//lib/appsignal/transmitter.rb#12
Appsignal::Transmitter::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/transmitter.rb#14
Appsignal::Transmitter::HTTP_ERRORS = T.let(T.unsafe(nil), Array)

# source://appsignal//lib/appsignal/utils/deprecation_message.rb#4
module Appsignal::Utils; end

# @api private
#
# source://appsignal//lib/appsignal/utils/data.rb#6
class Appsignal::Utils::Data
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/utils/data.rb#8
    def generate(body); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/data.rb#50
    def map_array(array_value); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/data.rb#18
    def map_hash(hash_value); end
  end
end

# source://appsignal//lib/appsignal/utils/deprecation_message.rb#5
module Appsignal::Utils::DeprecationMessage
  # source://appsignal//lib/appsignal/utils/deprecation_message.rb#11
  def deprecation_message(message, logger = T.unsafe(nil)); end

  class << self
    # source://appsignal//lib/appsignal/utils/deprecation_message.rb#6
    def message(message, logger = T.unsafe(nil)); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#6
class Appsignal::Utils::HashSanitizer
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#11
    def sanitize(value, filter_keys = T.unsafe(nil)); end

    private

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#66
    def inspected(value); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#47
    def sanitize_array(source, filter_keys, seen); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#30
    def sanitize_hash(source, filter_keys, seen); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#17
    def sanitize_value(value, filter_keys, seen); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#62
    def unmodified(value); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#7
Appsignal::Utils::HashSanitizer::FILTERED = T.let(T.unsafe(nil), String)

# @api private
#
# source://appsignal//lib/appsignal/utils/hash_sanitizer.rb#8
Appsignal::Utils::HashSanitizer::RECURSIVE = T.let(T.unsafe(nil), String)

# Subclass of logger with method to only log a warning once
# prevents the local log from filling up with repeated messages.
#
# source://appsignal//lib/appsignal/utils/integration_logger.rb#7
class Appsignal::Utils::IntegrationLogger < ::Logger
  # source://appsignal//lib/appsignal/utils/integration_logger.rb#8
  def seen_keys; end

  # source://appsignal//lib/appsignal/utils/integration_logger.rb#12
  def warn_once_then_debug(key, message); end
end

# @api private
#
# source://appsignal//lib/appsignal/utils/json.rb#6
class Appsignal::Utils::JSON
  class << self
    # @api private
    #
    # source://appsignal//lib/appsignal/utils/json.rb#8
    def generate(body); end

    private

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/json.rb#31
    def encode_utf8(value); end

    # @api private
    #
    # source://appsignal//lib/appsignal/utils/json.rb#14
    def jsonify(value); end
  end
end

# @api private
#
# source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#6
class Appsignal::Utils::QueryParamsSanitizer
  extend ::Appsignal::Utils::QueryParamsSanitizer::ClassMethods
end

# @api private
#
# source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#9
module Appsignal::Utils::QueryParamsSanitizer::ClassMethods
  # @api private
  #
  # source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#10
  def sanitize(params, only_top_level = T.unsafe(nil), key_sanitizer = T.unsafe(nil)); end

  private

  # @api private
  #
  # source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#36
  def sanitize_array(array, only_top_level, key_sanitizer); end

  # @api private
  #
  # source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#23
  def sanitize_hash(hash, only_top_level, key_sanitizer); end

  # @api private
  #
  # source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#46
  def sanitize_key(key, sanitizer); end
end

# @api private
#
# source://appsignal//lib/appsignal/utils/query_params_sanitizer.rb#7
Appsignal::Utils::QueryParamsSanitizer::REPLACEMENT_KEY = T.let(T.unsafe(nil), String)

# source://appsignal//lib/appsignal/utils/rails_helper.rb#5
module Appsignal::Utils::RailsHelper
  class << self
    # source://appsignal//lib/appsignal/utils/rails_helper.rb#15
    def application_config_path; end

    # source://appsignal//lib/appsignal/utils/rails_helper.rb#6
    def detected_rails_app_name; end
  end
end

# source://appsignal//lib/appsignal/version.rb#4
Appsignal::VERSION = T.let(T.unsafe(nil), String)
