# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `logtail` gem.
# Please instead update this file by running `bin/tapioca gem logtail`.

# source://logtail//lib/logtail/version.rb#1
module Logtail
  class << self
    # Access the main configuration object. Please see {{Logtail::Config}} for more details.
    #
    # source://logtail//lib/logtail.rb#22
    def config; end

    # Starts a timer for timing events. Please see {{Logtail::Logtail.start}} for more details.
    #
    # source://logtail//lib/logtail.rb#27
    def start_timer; end

    # Adds context to all logs written within the passed block. Please see
    # {{Logtail::CurrentContext.with}} for a more detailed description with examples.
    #
    # source://logtail//lib/logtail.rb#33
    def with_context(context, &block); end
  end
end

# Singleton class for reading and setting Logtail configuration.
#
# For Rails apps, this is installed into `config.logtail`. See examples below.
#
# @example Rails example
#   config.logtail.append_metadata = false
# @example Everything else
#   config = Logtail::Config.instance
#   config.append_metdata = false
#
# source://logtail//lib/logtail/config.rb#14
class Logtail::Config
  include ::Singleton
  extend ::Singleton::SingletonClassMethods

  # Convenience method for logging debug statements to the debug logger
  # set in this class.
  #
  # @private
  #
  # source://logtail//lib/logtail/config.rb#60
  def debug(&block); end

  # Accessor method for {#debug_logger=}.
  #
  # source://logtail//lib/logtail/config.rb#84
  def debug_logger; end

  # This is useful for debugging. This Sets a debug_logger to view internal Logtail library
  # log messages. The default is `nil`. Meaning log to nothing.
  #
  # See {#debug_to_file!} and {#debug_to_stdout!} for convenience methods that handle creating
  # and setting the logger.
  #
  # @example Rails
  #   config.logtail.debug_logger = ::Logger.new(STDOUT)
  # @example Everything else
  #   Logtail::Config.instance.debug_logger = ::Logger.new(STDOUT)
  #
  # source://logtail//lib/logtail/config.rb#79
  def debug_logger=(value); end

  # A convenience method for writing internal Logtail debug messages to a file.
  #
  # @example Rails
  #   config.Logtail.debug_to_file!("#{Rails.root}/log/logtail.log")
  # @example Everything else
  #   Logtail::Config.instance.debug_to_file!("log/logtail.log")
  #
  # source://logtail//lib/logtail/config.rb#94
  def debug_to_file!(file_path); end

  # A convenience method for writing internal Logtail debug messages to STDOUT.
  #
  # @example Rails
  #   config.logtail.debug_to_stdout!
  # @example Everything else
  #   Logtail::Config.instance.debug_to_stdout!
  #
  # source://logtail//lib/logtail/config.rb#108
  def debug_to_stdout!; end

  # @private
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/config.rb#157
  def development?; end

  # Accessor method for {#environment=}
  #
  # source://logtail//lib/logtail/config.rb#125
  def environment; end

  # The environment your app is running in. Defaults to `RACK_ENV` and `RAILS_ENV`.
  # It should be rare that you have to set this. If the aforementioned env vars are not
  # set please do.
  #
  # @example If you do not set `RACK_ENV` or `RAILS_ENV`
  #   Logtail::Config.instance.environment = "staging"
  #
  # source://logtail//lib/logtail/config.rb#120
  def environment=(value); end

  # This allows filtering logs that are sent to Better Stack. Can be called multiple times, all filters will
  # be applied. If the passed block RETURNS TRUE for a particular LogEntry, it WILL NOT BE SENT to Better Stack.
  #
  # See {Logtail::LogEntry} for available attributes of the block parameter.
  #
  # @example Rails
  #   config.logtail.filter_sent_to_better_stack { |log_entry| log_entry.context_snapshot[:http][:path].start_with?('/_') }
  # @example Everything else
  #   Logtail.config.filter_sent_to_better_stack { |log_entry| log_entry.message.include?('IGNORE') }
  #
  # source://logtail//lib/logtail/config.rb#52
  def filter_sent_to_better_stack(&block); end

  # Sets the attribute http_body_limit
  #
  # @param value the value to set the attribute http_body_limit to.
  #
  # source://logtail//lib/logtail/config.rb#33
  def http_body_limit=(_arg0); end

  # Convenience method for accessing the various `Logtail::Integrations::*` class
  # settings. These provides settings for enabling, disabled, and silencing integrations.
  # See {Integrations} for a full list of available methods.
  #
  # source://logtail//lib/logtail/config.rb#132
  def integrations; end

  # Accessor method for {#logger=}.
  #
  # source://logtail//lib/logtail/config.rb#148
  def logger; end

  # This is the _main_ logger Logtail writes to. All of the Logtail integrations write to
  # this logger instance. It should be set to your global logger. For Rails, this is set
  # automatically to `Rails.logger`, you should not have to set this.
  #
  # @example Non-rails frameworks
  #   my_global_logger = Logtail::Logger.new(STDOUT)
  #   Logtail::Config.instance.logger = my_global_logger
  #
  # source://logtail//lib/logtail/config.rb#143
  def logger=(value); end

  # @private
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/config.rb#167
  def production?; end

  # Whether a particular {Logtail::LogEntry} should be sent to Better Stack
  #
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/config.rb#36
  def send_to_better_stack?(log_entry); end

  # @private
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/config.rb#172
  def staging?; end

  # @private
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/config.rb#162
  def test?; end

  class << self
    private

    def allocate; end
    def new(*_arg0); end
  end
end

# source://logtail//lib/logtail/config.rb#26
Logtail::Config::DEVELOPMENT_NAME = T.let(T.unsafe(nil), String)

# @private
#
# source://logtail//lib/logtail/config.rb#16
class Logtail::Config::NoLoggerError < ::StandardError; end

# source://logtail//lib/logtail/config.rb#27
Logtail::Config::PRODUCTION_NAME = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/config.rb#28
Logtail::Config::STAGING_NAME = T.let(T.unsafe(nil), String)

# @private
#
# source://logtail//lib/logtail/config.rb#19
class Logtail::Config::SimpleLogFormatter < ::Logger::Formatter
  # This method is invoked when a log event occurs
  #
  # source://logtail//lib/logtail/config.rb#21
  def call(severity, timestamp, progname, msg); end
end

# source://logtail//lib/logtail/config.rb#29
Logtail::Config::TEST_NAME = T.let(T.unsafe(nil), String)

# Base class for all `Logtail::Contexts::*` classes.
#
# @private
#
# source://logtail//lib/logtail/context.rb#4
class Logtail::Context
  # @raise [NotImplementedError]
  #
  # source://logtail//lib/logtail/context.rb#5
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/contexts/http.rb#4
module Logtail::Contexts; end

# @private
#
# source://logtail//lib/logtail/contexts/http.rb#6
class Logtail::Contexts::HTTP < ::Logtail::Context
  # @return [HTTP] a new instance of HTTP
  #
  # source://logtail//lib/logtail/contexts/http.rb#9
  def initialize(attributes); end

  # Returns the value of attribute host.
  #
  # source://logtail//lib/logtail/contexts/http.rb#7
  def host; end

  # Returns the value of attribute method.
  #
  # source://logtail//lib/logtail/contexts/http.rb#7
  def method; end

  # Returns the value of attribute path.
  #
  # source://logtail//lib/logtail/contexts/http.rb#7
  def path; end

  # Returns the value of attribute remote_addr.
  #
  # source://logtail//lib/logtail/contexts/http.rb#7
  def remote_addr; end

  # Returns the value of attribute request_id.
  #
  # source://logtail//lib/logtail/contexts/http.rb#7
  def request_id; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/http.rb#18
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/contexts/release.rb#8
class Logtail::Contexts::Release < ::Logtail::Context
  # @return [Release] a new instance of Release
  #
  # source://logtail//lib/logtail/contexts/release.rb#34
  def initialize(attributes); end

  # Returns the value of attribute commit_hash.
  #
  # source://logtail//lib/logtail/contexts/release.rb#32
  def commit_hash; end

  # Returns the value of attribute created_at.
  #
  # source://logtail//lib/logtail/contexts/release.rb#32
  def created_at; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/release.rb#41
  def to_hash; end

  # Returns the value of attribute version.
  #
  # source://logtail//lib/logtail/contexts/release.rb#32
  def version; end

  class << self
    # Builds a release context based on environment variables. Simply add the
    # `RELEASE_COMMIT`, `RELEASE_CREATED_AT`, or the `RELEASE_VERSION` env vars
    # to get this context automatially. All are optional, but at least one
    # must be present.
    #
    # If you're on Heroku, simply enable dyno metadata to get this automatically:
    # https://devcenter.heroku.com/articles/dyno-metadata
    #
    # source://logtail//lib/logtail/contexts/release.rb#17
    def from_env; end
  end
end

# @private
#
# source://logtail//lib/logtail/contexts/runtime.rb#6
class Logtail::Contexts::Runtime < ::Logtail::Context
  # @return [Runtime] a new instance of Runtime
  #
  # source://logtail//lib/logtail/contexts/runtime.rb#9
  def initialize(attributes); end

  # Returns the value of attribute thread_id.
  #
  # source://logtail//lib/logtail/contexts/runtime.rb#7
  def thread_id; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/runtime.rb#14
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/contexts/session.rb#7
class Logtail::Contexts::Session < ::Logtail::Context
  # @return [Session] a new instance of Session
  #
  # source://logtail//lib/logtail/contexts/session.rb#10
  def initialize(attributes); end

  # Returns the value of attribute id.
  #
  # source://logtail//lib/logtail/contexts/session.rb#8
  def id; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/session.rb#15
  def to_hash; end
end

# The system context tracks OS level process information, such as the process ID.
#
# @note This is tracked automatically in {CurrentContext}. When the current context
#   is initialized, the system context gets added automatically.
#
# source://logtail//lib/logtail/contexts/system.rb#10
class Logtail::Contexts::System < ::Logtail::Context
  # @return [System] a new instance of System
  #
  # source://logtail//lib/logtail/contexts/system.rb#13
  def initialize(attributes); end

  # Returns the value of attribute hostname.
  #
  # source://logtail//lib/logtail/contexts/system.rb#11
  def hostname; end

  # Returns the value of attribute pid.
  #
  # source://logtail//lib/logtail/contexts/system.rb#11
  def pid; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/system.rb#19
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/contexts/user.rb#7
class Logtail::Contexts::User < ::Logtail::Context
  # @return [User] a new instance of User
  #
  # source://logtail//lib/logtail/contexts/user.rb#10
  def initialize(attributes); end

  # Returns the value of attribute email.
  #
  # source://logtail//lib/logtail/contexts/user.rb#8
  def email; end

  # Returns the value of attribute id.
  #
  # source://logtail//lib/logtail/contexts/user.rb#8
  def id; end

  # Returns the value of attribute name.
  #
  # source://logtail//lib/logtail/contexts/user.rb#8
  def name; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail//lib/logtail/contexts/user.rb#17
  def to_hash; end
end

# Holds the current context in a thread safe memory storage. This context is
# appended to every log line. Think of context as join data between your log lines,
# allowing you to relate them and filter them appropriately.
#
# @note Because context is appended to every log line, it is recommended that you limit this
#   to only necessary data needed to relate your log lines.
#
# source://logtail//lib/logtail/current_context.rb#12
class Logtail::CurrentContext
  # Adds contexts but does not remove them. See {#with} for automatic maintenance and {#remove}
  # to remove them yourself.
  #
  # @note Because context is included with every log line, it is recommended that you limit this
  #   to only necessary data.
  #
  # source://logtail//lib/logtail/current_context.rb#53
  def add(*objects); end

  # Fetch a specific context by key.
  #
  # source://logtail//lib/logtail/current_context.rb#62
  def fetch(*args); end

  # Removes a context. If you wish to remove by key, or some other way, use {#hash} and
  # modify the hash accordingly.
  #
  # source://logtail//lib/logtail/current_context.rb#68
  def remove(*keys); end

  # source://logtail//lib/logtail/current_context.rb#76
  def replace(hash); end

  # Resets the context to be blank. Use this carefully! This will remove *any* context,
  # include context that is automatically included with Logtail.
  #
  # source://logtail//lib/logtail/current_context.rb#84
  def reset; end

  # Snapshots the current context so that you get a moment in time representation of the context,
  # since the context can change as execution proceeds. Note that individual contexts
  # should be immutable, and we implement snapshot caching as a result of this assumption.
  #
  # source://logtail//lib/logtail/current_context.rb#93
  def snapshot; end

  # Adds a context and then removes it when the block is finished executing.
  #
  # do
  #
  #   Logtail::CurrentContext.with(job: {job_id: "123", job_name: "Refresh User Account"})
  #
  # @example Adding a custom context
  #   Logtail::CurrentContext.with({build: {version: "1.0.0"}}) do
  #   # ... anything logged here will include the context ...
  #   end
  # @example Adding multiple contexts
  #   Logtail::CurrentContext.with(context1, context2) { ... }
  # @note Because context is included with every log line, it is recommended that you limit this
  #   to only necessary data.
  # @note Any custom context needs to have a single root key to be valid. i.e. instead of:
  #   Logtail::CurrentContext.with(job_id: "123", job_name: "Refresh User Account")
  #
  # source://logtail//lib/logtail/current_context.rb#116
  def with(*objects); end

  private

  # Builds the initial hash. This is extract into a method to support a threaded
  # environment. Each thread holds it's own context and also needs to instantiate
  # it's hash properly.
  #
  # source://logtail//lib/logtail/current_context.rb#135
  def build_initial_hash; end

  # Hook to clear any caching implement in this class
  #
  # source://logtail//lib/logtail/current_context.rb#164
  def expire_cache!; end

  # The internal hash that is maintained. Use {#with} and {#add} for hash maintenance.
  #
  # source://logtail//lib/logtail/current_context.rb#128
  def hash; end

  class << self
    # Convenience method for {CurrentContext#add}. See {CurrentContext#add} for more info.
    #
    # source://logtail//lib/logtail/current_context.rb#23
    def add(*args); end

    # Convenience method for {CurrentContext#fetch}. See {CurrentContext#fetch} for more info.
    #
    # source://logtail//lib/logtail/current_context.rb#28
    def fetch(*args); end

    # Implements the Singleton pattern in a thread specific way. Each thread receives
    # its own context.
    #
    # source://logtail//lib/logtail/current_context.rb#18
    def instance; end

    # Convenience method for {CurrentContext#remove}. See {CurrentContext#remove} for more info.
    #
    # source://logtail//lib/logtail/current_context.rb#33
    def remove(*args); end

    # Convenience method for {CurrentContext#reset}. See {CurrentContext#reset} for more info.
    #
    # source://logtail//lib/logtail/current_context.rb#38
    def reset(*args); end

    # Convenience method for {CurrentContext#with}. See {CurrentContext#with} for more info.
    #
    # source://logtail//lib/logtail/current_context.rb#43
    def with(*args, &block); end
  end
end

# source://logtail//lib/logtail/current_context.rb#13
Logtail::CurrentContext::THREAD_NAMESPACE = T.let(T.unsafe(nil), Symbol)

# Base class for `Logtail::Events::*`
#
# @private
#
# source://logtail//lib/logtail/event.rb#4
class Logtail::Event
  # @return [Event] a new instance of Event
  #
  # source://logtail//lib/logtail/event.rb#6
  def initialize(message, metadata); end

  # This ensures that Logtail events get logged as messages if they are passed to
  # the standard ::Logger.
  #
  # See: https://github.com/ruby/ruby/blob/f6e77b9d3555c1fbaa8aab1cdc0bd6bde95f62c6/lib/logger.rb#L615
  #
  # source://logtail//lib/logtail/event.rb#15
  def inspect; end

  # Returns the value of attribute message.
  #
  # source://logtail//lib/logtail/event.rb#5
  def message; end

  # Returns the value of attribute metadata.
  #
  # source://logtail//lib/logtail/event.rb#5
  def metadata; end

  # source://logtail//lib/logtail/event.rb#23
  def to_h; end

  # source://logtail//lib/logtail/event.rb#23
  def to_hash; end

  # source://logtail//lib/logtail/event.rb#19
  def to_json(options = T.unsafe(nil)); end

  # source://logtail//lib/logtail/event.rb#28
  def to_msgpack(*args); end

  # source://logtail//lib/logtail/event.rb#32
  def to_s; end
end

# Namespace for all Logtail supported events.
#
# source://logtail//lib/logtail/events/controller_call.rb#5
module Logtail::Events; end

# @private
#
# source://logtail//lib/logtail/events/controller_call.rb#7
class Logtail::Events::ControllerCall < ::Logtail::Event
  # @return [ControllerCall] a new instance of ControllerCall
  #
  # source://logtail//lib/logtail/events/controller_call.rb#10
  def initialize(attributes); end

  # Returns the value of attribute action.
  #
  # source://logtail//lib/logtail/events/controller_call.rb#8
  def action; end

  # Returns the value of attribute controller.
  #
  # source://logtail//lib/logtail/events/controller_call.rb#8
  def controller; end

  # Returns the value of attribute format.
  #
  # source://logtail//lib/logtail/events/controller_call.rb#8
  def format; end

  # source://logtail//lib/logtail/events/controller_call.rb#22
  def message; end

  # Returns the value of attribute params.
  #
  # source://logtail//lib/logtail/events/controller_call.rb#8
  def params; end

  # Returns the value of attribute params_json.
  #
  # source://logtail//lib/logtail/events/controller_call.rb#8
  def params_json; end

  # source://logtail//lib/logtail/events/controller_call.rb#33
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/events/error.rb#7
class Logtail::Events::Error < ::Logtail::Event
  # @return [Error] a new instance of Error
  #
  # source://logtail//lib/logtail/events/error.rb#10
  def initialize(attributes); end

  # Returns the value of attribute backtrace_json.
  #
  # source://logtail//lib/logtail/events/error.rb#8
  def backtrace_json; end

  # Returns the value of attribute error_message.
  #
  # source://logtail//lib/logtail/events/error.rb#8
  def error_message; end

  # source://logtail//lib/logtail/events/error.rb#19
  def message; end

  # Returns the value of attribute name.
  #
  # source://logtail//lib/logtail/events/error.rb#8
  def name; end

  # source://logtail//lib/logtail/events/error.rb#29
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/events/sql_query.rb#7
class Logtail::Events::SQLQuery < ::Logtail::Event
  # @return [SQLQuery] a new instance of SQLQuery
  #
  # source://logtail//lib/logtail/events/sql_query.rb#10
  def initialize(attributes); end

  # Returns the value of attribute duration_ms.
  #
  # source://logtail//lib/logtail/events/sql_query.rb#8
  def duration_ms; end

  # Returns the value of attribute message.
  #
  # source://logtail//lib/logtail/events/sql_query.rb#8
  def message; end

  # Returns the value of attribute sql.
  #
  # source://logtail//lib/logtail/events/sql_query.rb#8
  def sql; end

  # source://logtail//lib/logtail/events/sql_query.rb#16
  def to_hash; end
end

# @private
#
# source://logtail//lib/logtail/events/template_render.rb#6
class Logtail::Events::TemplateRender < ::Logtail::Event
  # @return [TemplateRender] a new instance of TemplateRender
  #
  # source://logtail//lib/logtail/events/template_render.rb#9
  def initialize(attributes); end

  # Returns the value of attribute duration_ms.
  #
  # source://logtail//lib/logtail/events/template_render.rb#7
  def duration_ms; end

  # Returns the value of attribute message.
  #
  # source://logtail//lib/logtail/events/template_render.rb#7
  def message; end

  # Returns the value of attribute name.
  #
  # source://logtail//lib/logtail/events/template_render.rb#7
  def name; end

  # source://logtail//lib/logtail/events/template_render.rb#15
  def to_hash; end
end

# An integration represent an integration for an entire library. For example, `Rack`.
# While the Logtail `Rack` integration is comprised of multiple middlewares, the
# `Logtail::Integrations::Rack` module is an entire integration that extends this module.
#
# source://logtail//lib/logtail/integration.rb#5
module Logtail::Integration
  # Easily sisable entire library integrations. This is like removing the code from
  # Logtail. It will not touch this library and the library will function as it would
  # without Logtail.
  #
  # @example
  #   Logtail::Integrations::ActiveRecord.enabled = false
  #
  # source://logtail//lib/logtail/integration.rb#12
  def enabled=(value); end

  # Accessor method for {#enabled=}
  #
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/integration.rb#17
  def enabled?; end

  # Abstract method that each integration must implement.
  #
  # @raise [NotImplementedError]
  #
  # source://logtail//lib/logtail/integration.rb#36
  def integrate!; end

  # Silences a library's logs. This ensures that logs are not generated at all
  # from this library.
  #
  # @example
  #   Logtail::Integrations::ActiveRecord.silence = true
  #
  # source://logtail//lib/logtail/integration.rb#26
  def silence=(value); end

  # Accessor method for {#silence=}
  #
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/integration.rb#31
  def silence?; end
end

# Base class for `Logtail::Integrations::*`. Provides a common interface for all integrators.
# An integrator is a single specific integration into a part of a library. See
# {Integration} for higher library level integration settings.
#
# source://logtail//lib/logtail/integrator.rb#5
class Logtail::Integrator
  # Abstract method that each integration must implement.
  #
  # @raise [NotImplementedError]
  #
  # source://logtail//lib/logtail/integrator.rb#46
  def integrate!; end

  class << self
    # Sets the attribute enabled
    #
    # @param value the value to set the attribute enabled to.
    #
    # source://logtail//lib/logtail/integrator.rb#12
    def enabled=(_arg0); end

    # Allows you to enable / disable specific integrations.
    #
    # @example
    #   Logtail::Integrations::ActiveRecord::LogSubscriber.enabled = false
    # @note Disabling specific low level integrations should only be needed for edge cases.
    #   If you want to disable integration with an entire library, we recommend doing so
    #   at a higher level. Ex: `Logtail::Integrations::ActiveRecord.enabled = false`.
    # @return [Boolean]
    #
    # source://logtail//lib/logtail/integrator.rb#22
    def enabled?; end

    # Convenience class level method that runs the integrator by instantiating a new
    # object and calling {#integrate!}. It also takes care to look at the if the integrator
    # is enabled, skipping it if not.
    #
    # source://logtail//lib/logtail/integrator.rb#29
    def integrate!(*args); end
  end
end

# Raised when an integrators requirements are not met. For example, this will be raised
# in the ActiveRecord integration if ActiveRecord is not available as a dependency in
# the current application.
#
# source://logtail//lib/logtail/integrator.rb#9
class Logtail::Integrator::RequirementNotMetError < ::StandardError; end

# Namespace for all log devices.
#
# @private
#
# source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#2
module Logtail::LogDevices; end

# A highly efficient log device that buffers and delivers log messages over HTTPS to
# the Logtail API. It uses batches, keep-alive connections, and msgpack to deliver logs with
# high-throughput and little overhead. All log preparation and delivery is done asynchronously
# in a thread as not to block application execution and efficiently deliver logs for
# multi-threaded environments.
#
# See {#initialize} for options and more details.
#
# source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#3
class Logtail::LogDevices::HTTP
  # Instantiates a new HTTP log device that can be passed to {Logtail::Logger#initialize}.
  #
  # The class maintains a buffer which is flushed in batches to the Logtail API. 2
  # options control when the flush happens, `:batch_byte_size` and `:flush_interval`.
  # If either of these are surpassed, the buffer will be flushed.
  #
  # By default, the buffer will apply back pressure when the rate of log messages exceeds
  # the maximum delivery rate. If you don't want to sacrifice app performance in this case
  # you can drop the log messages instead by passing a {DroppingSizedQueue} via the
  # `:request_queue` option.
  #
  # @example Basic usage
  #   Logtail::Logger.new(Logtail::LogDevices::HTTP.new("my_logtail_source_token"))
  # @example Apply back pressure instead of dropping messages
  #   http_log_device = Logtail::LogDevices::HTTP.new("my_logtail_source_token", request_queue: SizedQueue.new(25))
  #   Logtail::Logger.new(http_log_device)
  # @option attributes
  # @option attributes
  # @option attributes
  # @option attributes
  # @option attributes
  # @option attributes
  # @param source_token [String] The API key provided to you after you add your application to
  #   [Logtail](https://logtail.com).
  # @param options [Hash] the options to create a HTTP log device with.
  # @param attributes [Hash] a customizable set of options
  # @return [HTTP] a new instance of HTTP
  #
  # source://logtail//lib/logtail/log_devices/http.rb#72
  def initialize(source_token, options = T.unsafe(nil)); end

  # Closes the log device, cleans up, and attempts one last delivery.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#119
  def close; end

  # source://logtail//lib/logtail/log_devices/http.rb#130
  def deliver_one(msg); end

  # Flush all log messages in the buffer synchronously. This method will not return
  # until delivery of the messages has been successful. If you want to flush
  # asynchronously see {#flush_async}.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#112
  def flush; end

  # source://logtail//lib/logtail/log_devices/http.rb#149
  def verify_delivery!; end

  # Write a new log line message to the buffer, and flush asynchronously if the
  # message queue is full. We flush asynchronously because the maximum message batch
  # size is constricted by the Logtail API. The actual application limit is a multiple
  # of this. Hence the `@request_queue`.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#91
  def write(msg); end

  private

  # Builds the `Authorization` header value for HTTP delivery to the Logtail API.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#375
  def authorization_payload; end

  # Builds an `Net::HTTP` object to deliver requests over.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#284
  def build_http; end

  # Builds an HTTP request based on the current messages queued.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#200
  def build_request(msgs); end

  # Creates a loop that delivers requests over an open (kept alive) HTTP connection.
  # If the connection dies, the request is thrown back onto the queue and
  # the method returns. It is the responsibility of the caller to implement retries
  # and establish a new connection.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#322
  def deliver_requests(conn); end

  # This is a convenience method to ensure the flush thread are
  # started. This is called lazily from {#write} so that we
  # only start the threads as needed, but it also ensures
  # threads are started after process forking.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#187
  def ensure_flush_threads_are_started; end

  # Flushes the message buffer asynchronously. The reason we provide this
  # method is because the message buffer limit is constricted by the
  # Logtail API. The application limit is multiples of the buffer limit,
  # hence the `@request_queue`, allowing us to buffer beyond the Logtail API
  # imposed limit.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#225
  def flush_async; end

  # source://logtail//lib/logtail/log_devices/http.rb#210
  def force_utf8_encoding(data); end

  # Flushes the message queue on an interval. You will notice that {#write} also
  # flushes the buffer if it is full. This method takes note of this via the
  # `@last_async_flush` variable as to not flush immediately after a write flush.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#258
  def intervaled_flush; end

  # Determines if the loop in {#intervaled_flush} is ready to be flushed again. It
  # uses the `@last_async_flush` variable to ensure that a flush does not happen
  # too rapidly ({#write} also triggers a flush).
  #
  # @return [Boolean]
  #
  # source://logtail//lib/logtail/log_devices/http.rb#279
  def intervaled_flush_ready?; end

  # Creates a loop that processes the `@request_queue` on an interval.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#299
  def request_outlet; end

  # Waits on the request queue. This is used in {#flush} to ensure
  # the log data has been delivered before returning.
  #
  # source://logtail//lib/logtail/log_devices/http.rb#240
  def wait_on_request_queue; end
end

# source://logtail//lib/logtail/log_devices/http.rb#25
Logtail::LogDevices::HTTP::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# A simple thread-safe queue implementation that provides a #flush method.
# The built-in ruby `Queue` class does not provide a #flush method that allows
# the caller to retrieve all items on the queue in one call. The Ruby `SizedQueue` also
# implements thread waiting, which is something we want to avoid. To keep things
# simple and straight-forward, we designed this queue class.
#
# @private
#
# source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#10
class Logtail::LogDevices::HTTP::FlushableDroppingSizedQueue
  # @return [FlushableDroppingSizedQueue] a new instance of FlushableDroppingSizedQueue
  #
  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#11
  def initialize(max_size); end

  # Removes a single item from the queue
  #
  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#27
  def deq; end

  # Adds a message to the queue
  #
  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#18
  def enq(msg); end

  # Flushes all message from the queue and returns them.
  #
  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#34
  def flush; end

  # @return [Boolean]
  #
  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#42
  def full?; end

  # source://logtail//lib/logtail/log_devices/http/flushable_dropping_sized_queue.rb#46
  def size; end
end

# source://logtail//lib/logtail/log_devices/http.rb#22
Logtail::LogDevices::HTTP::LOGTAIL_HOST = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/log_devices/http.rb#23
Logtail::LogDevices::HTTP::LOGTAIL_PORT = T.let(T.unsafe(nil), Integer)

# source://logtail//lib/logtail/log_devices/http.rb#21
Logtail::LogDevices::HTTP::LOGTAIL_PRODUCTION_HOST = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/log_devices/http.rb#24
Logtail::LogDevices::HTTP::LOGTAIL_SCHEME = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/log_devices/http.rb#20
Logtail::LogDevices::HTTP::LOGTAIL_STAGING_HOST = T.let(T.unsafe(nil), String)

# Represents an attempt to deliver a request. Requests can be retried, hence
# why we keep track of the number of attempts.
#
# source://logtail//lib/logtail/log_devices/http/request_attempt.rb#6
class Logtail::LogDevices::HTTP::RequestAttempt
  # @return [RequestAttempt] a new instance of RequestAttempt
  #
  # source://logtail//lib/logtail/log_devices/http/request_attempt.rb#9
  def initialize(req); end

  # source://logtail//lib/logtail/log_devices/http/request_attempt.rb#14
  def attempted!; end

  # Returns the value of attribute attempts.
  #
  # source://logtail//lib/logtail/log_devices/http/request_attempt.rb#7
  def attempts; end

  # Returns the value of attribute request.
  #
  # source://logtail//lib/logtail/log_devices/http/request_attempt.rb#7
  def request; end
end

# source://logtail//lib/logtail/log_devices/http.rb#26
Logtail::LogDevices::HTTP::USER_AGENT = T.let(T.unsafe(nil), String)

# Represents a new log entry into the log. This is an intermediary class between
# `Logger` and the log device that you set it up with.
#
# source://logtail//lib/logtail/log_entry.rb#11
class Logtail::LogEntry
  # Creates a log entry suitable to be sent to the Logtail API.
  #
  # @param level [Integer] the log level / severity
  # @param time [Time] the exact time the log message was written
  # @param progname [String] the progname scope for the log message
  # @param message [String] Human readable log message.
  # @param context_snapshot [Hash] structured data representing a snapshot of the context at
  #   the given point in time.
  # @param event [Logtail.Event] structured data representing the log line event. This should be
  #   an instance of {Logtail.Event}.
  # @return [LogEntry] the resulting LogEntry object
  #
  # source://logtail//lib/logtail/log_entry.rb#29
  def initialize(level, time, progname, message, context_snapshot, event, options = T.unsafe(nil)); end

  # Returns the value of attribute context_snapshot.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def context_snapshot; end

  # Returns the value of attribute event.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def event; end

  # source://logtail//lib/logtail/log_entry.rb#83
  def inspect; end

  # Returns the value of attribute level.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def level; end

  # Returns the value of attribute message.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def message; end

  # Returns the value of attribute progname.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def progname; end

  # Returns the value of attribute tags.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def tags; end

  # Returns the value of attribute time.
  #
  # source://logtail//lib/logtail/log_entry.rb#17
  def time; end

  # Builds a hash representation containing simple objects, suitable for serialization (JSON).
  #
  # source://logtail-rails/0.2.6/lib/logtail-rails/log_entry.rb#5
  def to_hash(options = T.unsafe(nil)); end

  # source://logtail//lib/logtail/log_entry.rb#46
  def to_hash_unfiltered(options = T.unsafe(nil)); end

  # source://logtail//lib/logtail/log_entry.rb#87
  def to_json(options = T.unsafe(nil)); end

  # source://logtail//lib/logtail/log_entry.rb#91
  def to_msgpack(*args); end

  # This is used when LogEntry objects make it to a non-Logtail logger.
  #
  # source://logtail//lib/logtail/log_entry.rb#96
  def to_s; end

  private

  # source://logtail//lib/logtail/log_entry.rb#128
  def convert_to_runtime_context(frame); end

  # source://logtail//lib/logtail/log_entry.rb#117
  def current_runtime_context; end

  # Attempts to encode a non UTF-8 string into UTF-8, discarding invalid characters.
  # If it fails, a nil is returned.
  #
  # source://logtail//lib/logtail/log_entry.rb#107
  def encode_string(string); end

  # source://logtail//lib/logtail/log_entry.rb#101
  def formatted_dt; end

  # @return [Boolean]
  #
  # source://logtail//lib/logtail/log_entry.rb#136
  def logtail_logger_frame?(frame); end

  # source://logtail//lib/logtail/log_entry.rb#140
  def path_relative_to_app_root(frame); end

  # source://logtail//lib/logtail/log_entry.rb#146
  def root_path; end
end

# source://logtail//lib/logtail/log_entry.rb#12
Logtail::LogEntry::BINARY_LIMIT_THRESHOLD = T.let(T.unsafe(nil), Integer)

# source://logtail//lib/logtail/log_entry.rb#13
Logtail::LogEntry::DT_PRECISION = T.let(T.unsafe(nil), Integer)

# source://logtail//lib/logtail/log_entry.rb#15
Logtail::LogEntry::LOGGER_FILE = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/log_entry.rb#14
Logtail::LogEntry::MESSAGE_MAX_BYTES = T.let(T.unsafe(nil), Integer)

# The Logtail Logger behaves exactly like the standard Ruby `::Logger`, except that it supports a
# transparent API for logging structured data and events.
#
# @example Basic logging
#   logger.info "Payment rejected for customer #{customer_id}"
# @example Logging an event
#   logger.info "Payment rejected", payment_rejected: {customer_id: customer_id, amount: 100}
#
# source://logtail//lib/logtail/logger.rb#18
class Logtail::Logger < ::Logger
  # Creates a new Logtail::Logger instance where the passed argument is an IO device. That is,
  # anything that responds to `#write` and `#close`.
  #
  # Note, this method does *not* accept the same arguments as the standard Ruby `::Logger`.
  # The Ruby `::Logger` accepts additional options controlling file rotation if the first argument
  # is a file *name*. This is a design flaw that Logtail does not assume. Logging to a file, or
  # multiple IO devices is demonstrated in the examples below.
  #
  # @example Logging to STDOUT
  #   logger = Logtail::Logger.new(STDOUT)
  # @example Logging to the Logtail HTTP device
  #   http_device = Logtail::LogDevices::HTTP.new("my-logtail-source-token")
  #   logger = Logtail::Logger.new(http_device)
  # @example Logging to a file (with rotation)
  #   file_device = Logger::LogDevice.new("path/to/file.log")
  #   logger = Logtail::Logger.new(file_device)
  # @example Logging to a file and the Logtail HTTP device (multiple log devices)
  #   http_device = Logtail::LogDevices::HTTP.new("my-logtail-source-token")
  #   file_logger = ::Logger.new("path/to/file.log")
  #   logger = Logtail::Logger.new(http_device, file_logger)
  # @return [Logger] a new instance of Logger
  #
  # source://logtail//lib/logtail/logger.rb#155
  def initialize(*io_devices_and_loggers); end

  # Patch to ensure that the {#level} method is used instead of `@level`.
  # This is required because of Rails' monkey patching on Logger via `::LoggerSilence`.
  #
  # source://logtail//lib/logtail/logger.rb#226
  def add(severity, message = T.unsafe(nil), progname = T.unsafe(nil), &block); end

  # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#31
  def broadcast_to(*io_devices_and_loggers); end

  # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#27
  def broadcasts; end

  # source://logtail//lib/logtail/logger.rb#239
  def debug(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def debug?; end

  # source://logtail//lib/logtail/logger.rb#239
  def error(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def error?; end

  # source://logtail//lib/logtail/logger.rb#239
  def fatal(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def fatal?; end

  # Sets a new formatted on the logger.
  #
  # @note The formatter cannot be changed if you are using the HTTP logger backend.
  #
  # source://logtail//lib/logtail/logger.rb#202
  def formatter=(value); end

  # source://logtail//lib/logtail/logger.rb#239
  def info(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def info?; end

  # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#20
  def is_a?(clazz); end

  # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#20
  def kind_of?(clazz); end

  # source://logtail//lib/logtail/logger.rb#212
  def level=(value); end

  # source://activesupport/7.1.3.2/lib/active_support/logger_silence.rb#12
  def silencer; end

  # source://activesupport/7.1.3.2/lib/active_support/logger_silence.rb#12
  def silencer=(val); end

  # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#39
  def stop_broadcasting_to(io_device_or_logger); end

  # source://logtail//lib/logtail/logger.rb#239
  def unknown(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def unknown?; end

  # source://logtail//lib/logtail/logger.rb#239
  def warn(*args, &block); end

  # source://logtail//lib/logtail/logger.rb#250
  def warn?; end

  # @private
  #
  # source://logtail//lib/logtail/logger.rb#220
  def with_context(context, &block); end

  private

  # source://logtail//lib/logtail/logger.rb#257
  def environment_level; end

  # @return [Boolean]
  #
  # source://logtail//lib/logtail/logger.rb#274
  def is_a_logger?(obj); end

  # source://logtail//lib/logtail/logger.rb#262
  def level_from_symbol(value); end

  class << self
    # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#58
    def create_default_logger(source_token); end

    # source://logtail-rails/0.2.6/lib/logtail-rails/logger.rb#49
    def create_logger(*io_devices_and_loggers); end

    # source://activesupport/7.1.3.2/lib/active_support/logger_silence.rb#12
    def silencer; end

    # source://activesupport/7.1.3.2/lib/active_support/logger_silence.rb#12
    def silencer=(val); end
  end
end

# Structures your log messages as strings and appends metadata if
# `Logtail::Config.instance.append_metadata?` is true.
#
# Example message with metdata:
#
#   My log message @metadata {"level":"info","dt":"2016-09-01T07:00:00.000000-05:00"}
#
# source://logtail//lib/logtail/logger.rb#92
class Logtail::Logger::AugmentedFormatter < ::Logtail::Logger::Formatter
  # source://logtail//lib/logtail/logger.rb#97
  def call(severity, time, progname, msg); end
end

# source://logtail//lib/logtail/logger.rb#95
Logtail::Logger::AugmentedFormatter::ESCAPED_NEW_LINE = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/logger.rb#93
Logtail::Logger::AugmentedFormatter::METADATA_CALLOUT = T.let(T.unsafe(nil), String)

# source://logtail//lib/logtail/logger.rb#94
Logtail::Logger::AugmentedFormatter::NEW_LINE = T.let(T.unsafe(nil), String)

# @private
#
# source://logtail//lib/logtail/logger.rb#21
class Logtail::Logger::Formatter
  private

  # source://logtail//lib/logtail/logger.rb#34
  def build_log_entry(severity, time, progname, logged_obj); end

  # Because of all the crazy ways Rails has attempted tags, we need this crazy method.
  #
  # source://logtail//lib/logtail/logger.rb#59
  def extract_active_support_tagged_logging_tags; end

  # source://logtail//lib/logtail/logger.rb#70
  def tagged_logging_object_key_name; end
end

# source://logtail//lib/logtail/logger.rb#31
Logtail::Logger::Formatter::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# Formatters get the formatted level from the logger.
#
# source://logtail//lib/logtail/logger.rb#23
Logtail::Logger::Formatter::SEVERITY_MAP = T.let(T.unsafe(nil), Hash)

# Structures your log messages into JSON.
#
#   logger = Logtail::Logger.new(STDOUT)
#   logger.formatter = Logtail::JSONFormatter.new
#
# Example message:
#
#   {"level":"info","dt":"2016-09-01T07:00:00.000000-05:00","message":"My log message"}
#
# source://logtail//lib/logtail/logger.rb#115
class Logtail::Logger::JSONFormatter < ::Logtail::Logger::Formatter
  # source://logtail//lib/logtail/logger.rb#116
  def call(severity, time, progname, msg); end
end

# For use in development and test environments where you do not want metadata
# included in the log lines.
#
# source://logtail//lib/logtail/logger.rb#77
class Logtail::Logger::MessageOnlyFormatter < ::Logtail::Logger::Formatter
  # This method is invoked when a log event occurs
  #
  # source://logtail//lib/logtail/logger.rb#79
  def call(severity, timestamp, progname, msg); end
end

# Passes through the LogEntry object. This is specifically used for the {Logtail::LogDevices::HTTP}
# class. This allows the IO device to format it however it wants. This is necessary for
# MessagePack because it requires a fixed array size before encoding. And since HTTP is
# sending data in batches, the encoding should happen there.
#
# source://logtail//lib/logtail/logger.rb#126
class Logtail::Logger::PassThroughFormatter < ::Logtail::Logger::Formatter
  # source://logtail//lib/logtail/logger.rb#127
  def call(severity, time, progname, msg); end
end

# This is an ultra-simple abstraction for timing code. This provides a little
# more control around how Logtail automatically processes "timers".
#
# @example
#   timer = Logtail::Timer.start
#   # ... code to time
#   logger.info("My log message", my_event: {time_ms: timer})
#
# source://logtail//lib/logtail/timer.rb#9
module Logtail::Timer
  class << self
    # Get the duration in milliseconds from the object returned in {#start}
    #
    # source://logtail//lib/logtail/timer.rb#16
    def duration_ms(timer); end

    # Abstract for starting a logtail. Currently this is simply calling `Time.now`.
    #
    # source://logtail//lib/logtail/timer.rb#11
    def start; end
  end
end

# @private
#
# source://logtail//lib/logtail/util/non_nil_hash_builder.rb#4
module Logtail::Util; end

# The purpose of this class is to efficiently build a hash that does not
# include nil values. It's proactive instead of reactive, avoiding the
# need to traverse and reduce a new hash dropping blanks.
#
# @private
#
# source://logtail//lib/logtail/util/non_nil_hash_builder.rb#10
class Logtail::Util::NonNilHashBuilder
  # @return [NonNilHashBuilder] a new instance of NonNilHashBuilder
  #
  # source://logtail//lib/logtail/util/non_nil_hash_builder.rb#21
  def initialize; end

  # source://logtail//lib/logtail/util/non_nil_hash_builder.rb#25
  def add(k, v, options = T.unsafe(nil)); end

  # Returns the value of attribute target.
  #
  # source://logtail//lib/logtail/util/non_nil_hash_builder.rb#19
  def target; end

  class << self
    # @yield [builder]
    #
    # source://logtail//lib/logtail/util/non_nil_hash_builder.rb#12
    def build(&block); end
  end
end

# source://logtail//lib/logtail/version.rb#2
Logtail::VERSION = T.let(T.unsafe(nil), String)
