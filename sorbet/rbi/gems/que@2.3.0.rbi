# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `que` gem.
# Please instead update this file by running `bin/tapioca gem que`.

# source://que//lib/que/active_job/extensions.rb#114
module ActiveJob
  class << self
    # source://activejob/7.1.3.2/lib/active_job/queue_adapter.rb#7
    def adapter_name(adapter); end

    # source://activejob/7.1.3.2/lib/active_job/deprecator.rb#4
    def deprecator; end

    # source://activejob/7.1.3.2/lib/active_job/gem_version.rb#5
    def gem_version; end

    # source://activejob/7.1.3.2/lib/active_job/enqueuing.rb#16
    def perform_all_later(*jobs); end

    # source://activejob/7.1.3.2/lib/active_job.rb#53
    def use_big_decimal_serializer; end

    # source://activejob/7.1.3.2/lib/active_job.rb#53
    def use_big_decimal_serializer=(_arg0); end

    # source://activejob/7.1.3.2/lib/active_job.rb#61
    def verbose_enqueue_logs; end

    # source://activejob/7.1.3.2/lib/active_job.rb#61
    def verbose_enqueue_logs=(_arg0); end

    # source://activejob/7.1.3.2/lib/active_job/version.rb#7
    def version; end

    private

    # source://activejob/7.1.3.2/lib/active_job/instrumentation.rb#6
    def instrument_enqueue_all(queue_adapter, jobs); end
  end
end

# source://que//lib/que/active_job/extensions.rb#115
module ActiveJob::QueueAdapters
  class << self
    # source://activejob/7.1.3.2/lib/active_job/queue_adapters.rb#137
    def lookup(name); end
  end
end

# source://que//lib/que/active_job/extensions.rb#119
class ActiveJob::QueueAdapters::QueAdapter
  # source://que//lib/que/active_job/extensions.rb#120
  def enqueue(job); end

  # source://que//lib/que/active_job/extensions.rb#127
  def enqueue_at(job, timestamp); end
end

# source://que//lib/que/active_job/extensions.rb#136
class ActiveJob::QueueAdapters::QueAdapter::JobWrapper < ::Que::Job
  include ::Que::ActiveJob::WrapperExtensions::InstanceMethods
  extend ::Que::ActiveJob::WrapperExtensions::ClassMethods

  # source://que//lib/que/active_job/extensions.rb#80
  def run(args); end
end

# A helper method to manage transactions, used mainly by the migration system.
# It's available for general use, but if you're using an ORM that provides its
# own transaction helper, be sure to use that instead, or the two may interfere
# with one another.
#
# source://que//lib/que.rb#6
module Que
  extend ::Que::Utils::Assertions
  extend ::Que::Utils::Constantization
  extend ::Que::Utils::ErrorNotification
  extend ::Que::Utils::Freeze
  extend ::Que::Utils::Introspection
  extend ::Que::Utils::JSONSerialization
  extend ::Que::Utils::Logging
  extend ::Que::Utils::Middleware
  extend ::Que::Utils::QueueManagement
  extend ::Que::Utils::Ruby2Keywords
  extend ::Que::Utils::Transactions

  class << self
    # source://forwardable/1.3.3/forwardable.rb#231
    def bulk_enqueue(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def checkout(*args, **_arg1, &block); end

    # Support simple integration with many common connection pools.
    #
    # source://que//lib/que.rb#87
    def connection=(conn); end

    # Integrate Que with any connection pool by passing it a reentrant block
    # that locks and yields a Postgres connection.
    #
    # source://que//lib/que.rb#108
    def connection_proc=(connection_proc); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def db_version(*args, **_arg1, &block); end

    # source://que//lib/que.rb#78
    def default_queue; end

    # Sets the attribute default_queue
    #
    # @param value the value to set the attribute default_queue to.
    #
    # source://que//lib/que.rb#50
    def default_queue=(_arg0); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def enqueue(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def execute(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def in_transaction?(*args, **_arg1, &block); end

    # source://que//lib/que/version.rb#6
    def job_schema_version; end

    # Returns the value of attribute locker.
    #
    # source://que//lib/que/locker.rb#11
    def locker; end

    # Sets the attribute locker
    #
    # @param value the value to set the attribute locker to.
    #
    # source://que//lib/que/locker.rb#11
    def locker=(_arg0); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def migrate!(*args, **_arg1, &block); end

    # How to actually access Que's established connection pool.
    #
    # source://que//lib/que.rb#113
    def pool; end

    # Set the current pool. Helpful for specs, but probably shouldn't be used
    # generally.
    #
    # source://que//lib/que.rb#119
    def pool=(_arg0); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def run_synchronously(*args, **_arg1, &block); end

    # source://forwardable/1.3.3/forwardable.rb#231
    def run_synchronously=(*args, **_arg1, &block); end

    # @return [Boolean]
    #
    # source://que//lib/que.rb#82
    def server?; end

    # Global configuration logic.
    #
    # source://que//lib/que.rb#76
    def use_prepared_statements; end

    # Global configuration logic.
    #
    # source://que//lib/que.rb#76
    def use_prepared_statements=(_arg0); end
  end
end

# source://que//lib/que/active_job/extensions.rb#4
module Que::ActiveJob; end

# A module that devs can include into their ApplicationJob classes to get
# access to Que-like job behavior.
#
# source://que//lib/que/active_job/extensions.rb#7
module Que::ActiveJob::JobExtensions
  include ::Que::JobMethods

  # source://que//lib/que/active_job/extensions.rb#15
  def perform(*args, **_arg1); end

  # @raise [Error]
  #
  # source://que//lib/que/active_job/extensions.rb#10
  def run(*args, **_arg1); end

  private

  # Filter out :_aj_symbol_keys constructs so that keywords work as
  # expected.
  #
  # source://que//lib/que/active_job/extensions.rb#48
  def que_filter_args(thing); end

  # Have helper methods like `destroy` and `retry_in` delegate to the actual
  # job object. If the current job is being run through an ActiveJob adapter
  # other than Que's, this will return nil, which is fine.
  #
  # source://que//lib/que/active_job/extensions.rb#42
  def que_target; end
end

# A module that we mix into ActiveJob's wrapper for Que::Job, to maintain
# backwards-compatibility with internal changes we make.
#
# source://que//lib/que/active_job/extensions.rb#64
module Que::ActiveJob::WrapperExtensions; end

# source://que//lib/que/active_job/extensions.rb#65
module Que::ActiveJob::WrapperExtensions::ClassMethods
  # We've dropped support for job options supplied as top-level keywords, but ActiveJob's QueAdapter still uses them. So we have to move them into the job_options hash ourselves.
  #
  # source://que//lib/que/active_job/extensions.rb#67
  def enqueue(args, priority:, queue:, run_at: T.unsafe(nil)); end
end

# source://que//lib/que/active_job/extensions.rb#72
module Que::ActiveJob::WrapperExtensions::InstanceMethods
  # The Rails adapter (built against a pre-1.0 version of this gem)
  # assumes that it can access a job's id via job.attrs["job_id"]. So,
  # oblige it.
  #
  # source://que//lib/que/active_job/extensions.rb#76
  def attrs; end

  # source://que//lib/que/active_job/extensions.rb#80
  def run(args); end
end

# source://que//lib/que/active_record/connection.rb#4
module Que::ActiveRecord; end

# source://que//lib/que/active_record/connection.rb#5
module Que::ActiveRecord::Connection
  class << self
    private

    # Check out a PG::Connection object from ActiveRecord's pool.
    #
    # source://que//lib/que/active_record/connection.rb#10
    def checkout; end

    # Use Rails' executor (if present) to make sure that the connection
    # we're using isn't taken from us while the block runs. See
    # https://github.com/que-rb/que/issues/166#issuecomment-274218910
    #
    # source://que//lib/que/active_record/connection.rb#21
    def wrap_in_rails_executor(&block); end
  end
end

# source://que//lib/que/active_record/connection.rb#30
module Que::ActiveRecord::Connection::JobMiddleware
  class << self
    # source://que//lib/que/active_record/connection.rb#32
    def call(job); end
  end
end

# source://que//lib/que.rb#10
Que::CONFIG_MUTEX = T.let(T.unsafe(nil), Thread::Mutex)

# source://que//lib/que.rb#7
Que::CURRENT_HOSTNAME = T.let(T.unsafe(nil), String)

# source://que//lib/que/connection.rb#20
class Que::Connection
  extend ::Forwardable

  # @return [Connection] a new instance of Connection
  #
  # source://que//lib/que/connection.rb#44
  def initialize(connection); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def backend_pid(*args, **_arg1, &block); end

  # source://que//lib/que/connection.rb#118
  def drain_notifications; end

  # source://que//lib/que/connection.rb#49
  def execute(command, params = T.unsafe(nil)); end

  # source://que//lib/que/connection.rb#81
  def execute_prepared(command, params = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://que//lib/que/connection.rb#126
  def in_transaction?; end

  # source://que//lib/que/connection.rb#114
  def next_notification; end

  # source://que//lib/que/connection.rb#122
  def server_version; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def wait_for_notify(*args, **_arg1, &block); end

  # Returns the value of attribute wrapped_connection.
  #
  # source://que//lib/que/connection.rb#23
  def wrapped_connection; end

  private

  # source://que//lib/que/connection.rb#132
  def convert_params(params); end

  # source://que//lib/que/connection.rb#176
  def convert_result(result); end

  class << self
    # source://que//lib/que/connection.rb#28
    def wrap(conn); end
  end
end

# Procs used to convert strings from Postgres into Ruby types.
#
# source://que//lib/que/connection.rb#149
Que::Connection::CAST_PROCS = T.let(T.unsafe(nil), Hash)

# source://que//lib/que/connection_pool.rb#7
class Que::ConnectionPool
  # @return [ConnectionPool] a new instance of ConnectionPool
  #
  # source://que//lib/que/connection_pool.rb#8
  def initialize(&block); end

  # source://que//lib/que/connection_pool.rb#15
  def checkout; end

  # source://que//lib/que/connection_pool.rb#56
  def execute(*args); end

  # @return [Boolean]
  #
  # source://que//lib/que/connection_pool.rb#60
  def in_transaction?; end

  private

  # source://que//lib/que/connection_pool.rb#70
  def current_connection; end

  # source://que//lib/que/connection_pool.rb#74
  def current_connection=(c); end

  # source://que//lib/que/connection_pool.rb#66
  def sync(&block); end
end

# source://que//lib/que.rb#8
Que::DEFAULT_QUEUE = T.let(T.unsafe(nil), String)

# source://que//lib/que.rb#13
class Que::Error < ::StandardError; end

# source://que//lib/que/job.rb#6
class Que::Job
  include ::Que::JobMethods

  # @return [Job] a new instance of Job
  #
  # source://que//lib/que/job.rb#53
  def initialize(attrs); end

  # Returns the value of attribute que_attrs.
  #
  # source://que//lib/que/job.rb#50
  def que_attrs; end

  # Returns the value of attribute que_error.
  #
  # source://que//lib/que/job.rb#51
  def que_error; end

  # Sets the attribute que_error
  #
  # @param value the value to set the attribute que_error to.
  #
  # source://que//lib/que/job.rb#51
  def que_error=(_arg0); end

  # Returns the value of attribute que_resolved.
  #
  # source://que//lib/que/job.rb#51
  def que_resolved; end

  # Sets the attribute que_resolved
  #
  # @param value the value to set the attribute que_resolved to.
  #
  # source://que//lib/que/job.rb#51
  def que_resolved=(_arg0); end

  # Subclasses should define their own run methods, but keep an empty one
  # here so that Que::Job.enqueue can queue an empty job in testing.
  #
  # source://que//lib/que/job.rb#60
  def run(*args); end

  private

  # Have the job helper methods act on this object.
  #
  # source://que//lib/que/job.rb#66
  def que_target; end

  class << self
    # source://que//lib/que/job.rb#155
    def _bulk_enqueue_insert(args_and_kwargs_array, notify:, job_options: T.unsafe(nil)); end

    # source://que//lib/que/job.rb#140
    def bulk_enqueue(job_options: T.unsafe(nil), notify: T.unsafe(nil)); end

    # source://que//lib/que/job.rb#80
    def enqueue(*args, **_arg1); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def maximum_retry_count; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def maximum_retry_count=(_arg0); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def priority; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def priority=(_arg0); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def queue; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def queue=(_arg0); end

    # source://que//lib/que/job.rb#227
    def resolve_que_setting(setting, *args); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def retry_interval; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def retry_interval=(_arg0); end

    # source://que//lib/que/job.rb#215
    def run(*args, **_arg1); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def run_at; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def run_at=(_arg0); end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def run_synchronously; end

    # Job class configuration options.
    #
    # source://que//lib/que/job.rb#72
    def run_synchronously=(_arg0); end

    private

    # source://que//lib/que/job.rb#242
    def _run_attrs(attrs); end
  end
end

# source://que//lib/que/job.rb#9
Que::Job::MAXIMUM_TAGS_COUNT = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/job.rb#10
Que::Job::MAXIMUM_TAG_LENGTH = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/job_buffer.rb#8
class Que::JobBuffer
  # Since we use a mutex, which is not reentrant, we have to be a little
  # careful to not call a method that locks the mutex when we've already
  # locked it. So, as a general rule, public methods handle locking the mutex
  # when necessary, while private methods handle the actual underlying data
  # changes. This lets us reuse those private methods without running into
  # locking issues.
  #
  # @return [JobBuffer] a new instance of JobBuffer
  #
  # source://que//lib/que/job_buffer.rb#18
  def initialize(maximum_size:, priorities:); end

  # @return [Boolean]
  #
  # source://que//lib/que/job_buffer.rb#74
  def accept?(metajobs); end

  # source://que//lib/que/job_buffer.rb#107
  def available_priorities; end

  # source://que//lib/que/job_buffer.rb#125
  def buffer_space; end

  # source://que//lib/que/job_buffer.rb#142
  def clear; end

  # @return [Boolean]
  #
  # source://que//lib/que/job_buffer.rb#150
  def job_available?(priority); end

  # Returns the value of attribute maximum_size.
  #
  # source://que//lib/que/job_buffer.rb#9
  def maximum_size; end

  # Returns the value of attribute priority_queues.
  #
  # source://que//lib/que/job_buffer.rb#9
  def priority_queues; end

  # source://que//lib/que/job_buffer.rb#37
  def push(*metajobs); end

  # source://que//lib/que/job_buffer.rb#65
  def shift(priority = T.unsafe(nil)); end

  # source://que//lib/que/job_buffer.rb#70
  def shift_job(priority = T.unsafe(nil)); end

  # source://que//lib/que/job_buffer.rb#129
  def size; end

  # source://que//lib/que/job_buffer.rb#137
  def stop; end

  # @return [Boolean]
  #
  # source://que//lib/que/job_buffer.rb#146
  def stopping?; end

  # source://que//lib/que/job_buffer.rb#133
  def to_a; end

  # source://que//lib/que/job_buffer.rb#99
  def waiting_count; end

  private

  # source://que//lib/que/job_buffer.rb#156
  def _buffer_space; end

  # source://que//lib/que/job_buffer.rb#164
  def _shift_job(priority); end

  # source://que//lib/que/job_buffer.rb#172
  def _size; end

  # @return [Boolean]
  #
  # source://que//lib/que/job_buffer.rb#176
  def _stopping?; end

  # source://que//lib/que/job_buffer.rb#160
  def pop(count); end

  # source://que//lib/que/job_buffer.rb#180
  def sync(&block); end
end

# A queue object dedicated to a specific worker priority. It's basically a
# Queue object from the standard library, but it's able to reach into the
# JobBuffer's buffer in order to satisfy a pop.
#
# source://que//lib/que/job_buffer.rb#187
class Que::JobBuffer::PriorityQueue
  # @return [PriorityQueue] a new instance of PriorityQueue
  #
  # source://que//lib/que/job_buffer.rb#190
  def initialize(job_buffer:, priority:); end

  # Returns the value of attribute job_buffer.
  #
  # source://que//lib/que/job_buffer.rb#188
  def job_buffer; end

  # Returns the value of attribute mutex.
  #
  # source://que//lib/que/job_buffer.rb#188
  def mutex; end

  # source://que//lib/que/job_buffer.rb#203
  def pop; end

  # source://que//lib/que/job_buffer.rb#228
  def populate; end

  # Returns the value of attribute priority.
  #
  # source://que//lib/que/job_buffer.rb#188
  def priority; end

  # source://que//lib/que/job_buffer.rb#221
  def stop; end

  # source://que//lib/que/job_buffer.rb#238
  def waiting_count; end

  private

  # source://que//lib/que/job_buffer.rb#248
  def _push(item); end

  # source://que//lib/que/job_buffer.rb#244
  def sync(&block); end
end

# source://que//lib/que/job_methods.rb#35
module Que::JobMethods
  # Run the job with error handling and cleanup logic. Optionally support
  # overriding the args, because it's necessary when jobs are invoked from
  # ActiveJob.
  #
  # source://que//lib/que/job_methods.rb#42
  def _run(args: T.unsafe(nil), kwargs: T.unsafe(nil), reraise_errors: T.unsafe(nil)); end

  # source://que//lib/que/job_methods.rb#72
  def log_level(elapsed); end

  private

  # source://que//lib/que/job_methods.rb#94
  def default_resolve_action; end

  # source://que//lib/que/job_methods.rb#166
  def destroy; end

  # source://que//lib/que/job_methods.rb#120
  def error_count; end

  # source://que//lib/que/job_methods.rb#100
  def expire; end

  # source://que//lib/que/job_methods.rb#110
  def finish; end

  # To be overridden in subclasses.
  #
  # source://que//lib/que/job_methods.rb#128
  def handle_error(error); end

  # This method defines the object on which the various job helper methods are
  # acting. When using Que in the default configuration this will just be
  # self, but when using the Que adapter for ActiveJob it'll be the actual
  # underlying job object. When running an ActiveJob::Base subclass that
  # includes this module through a separate adapter this will be nil - hence,
  # the defensive coding in every method that no-ops if que_target is falsy.
  #
  # @raise [NotImplementedError]
  #
  # source://que//lib/que/job_methods.rb#84
  def que_target; end

  # source://que//lib/que/job_methods.rb#88
  def resolve_que_setting(*args); end

  # Explicitly check for the job id in these helpers, because it won't exist
  # if we're running synchronously.
  #
  # source://que//lib/que/job_methods.rb#148
  def retry_in(period); end

  # source://que//lib/que/job_methods.rb#140
  def retry_in_default_interval; end
end

# source://que//lib/que/listener.rb#4
class Que::Listener
  # @return [Listener] a new instance of Listener
  #
  # source://que//lib/que/listener.rb#9
  def initialize(connection:, channel: T.unsafe(nil)); end

  # Returns the value of attribute channel.
  #
  # source://que//lib/que/listener.rb#7
  def channel; end

  # Returns the value of attribute connection.
  #
  # source://que//lib/que/listener.rb#7
  def connection; end

  # source://que//lib/que/listener.rb#20
  def listen; end

  # source://que//lib/que/listener.rb#129
  def unlisten; end

  # source://que//lib/que/listener.rb#24
  def wait_for_grouped_messages(timeout); end

  # source://que//lib/que/listener.rb#38
  def wait_for_messages(timeout); end

  private

  # @return [Boolean]
  #
  # source://que//lib/que/listener.rb#158
  def message_has_all_keys?(message, format); end

  # @return [Boolean]
  #
  # source://que//lib/que/listener.rb#162
  def message_has_no_excess_keys?(message, format); end

  # @return [Boolean]
  #
  # source://que//lib/que/listener.rb#166
  def message_keys_all_valid?(message, format); end

  # @return [Boolean]
  #
  # source://que//lib/que/listener.rb#152
  def message_matches_format?(message, format); end

  # source://que//lib/que/listener.rb#145
  def parse_payload(payload); end
end

# source://que//lib/que/listener.rb#5
Que::Listener::MESSAGE_FORMATS = T.let(T.unsafe(nil), Hash)

# source://que//lib/que/locker.rb#35
class Que::Locker
  # @return [Locker] a new instance of Locker
  #
  # source://que//lib/que/locker.rb#55
  def initialize(queues: T.unsafe(nil), connection_url: T.unsafe(nil), listen: T.unsafe(nil), poll: T.unsafe(nil), poll_interval: T.unsafe(nil), wait_period: T.unsafe(nil), maximum_buffer_size: T.unsafe(nil), worker_priorities: T.unsafe(nil), on_worker_start: T.unsafe(nil)); end

  # Returns the value of attribute job_buffer.
  #
  # source://que//lib/que/locker.rb#36
  def job_buffer; end

  # Returns the value of attribute locks.
  #
  # source://que//lib/que/locker.rb#36
  def locks; end

  # Returns the value of attribute poll_interval.
  #
  # source://que//lib/que/locker.rb#36
  def poll_interval; end

  # Returns the value of attribute queues.
  #
  # source://que//lib/que/locker.rb#36
  def queues; end

  # source://que//lib/que/locker.rb#224
  def stop; end

  # source://que//lib/que/locker.rb#220
  def stop!; end

  # @return [Boolean]
  #
  # source://que//lib/que/locker.rb#229
  def stopping?; end

  # Returns the value of attribute thread.
  #
  # source://que//lib/que/locker.rb#36
  def thread; end

  # source://que//lib/que/locker.rb#233
  def wait_for_stop; end

  # Returns the value of attribute workers.
  #
  # source://que//lib/que/locker.rb#36
  def workers; end

  private

  # Returns the value of attribute connection.
  #
  # source://que//lib/que/locker.rb#239
  def connection; end

  # source://que//lib/que/locker.rb#291
  def cycle; end

  # source://que//lib/que/locker.rb#469
  def finish_jobs(metajobs); end

  # source://que//lib/que/locker.rb#389
  def handle_results; end

  # source://que//lib/que/locker.rb#402
  def lock_jobs(metajobs); end

  # source://que//lib/que/locker.rb#510
  def mark_id_as_locked(id); end

  # source://que//lib/que/locker.rb#321
  def poll; end

  # Returns the value of attribute pollers.
  #
  # source://que//lib/que/locker.rb#239
  def pollers; end

  # source://que//lib/que/locker.rb#442
  def push_jobs(metajobs); end

  # source://que//lib/que/locker.rb#311
  def shutdown; end

  # source://que//lib/que/locker.rb#276
  def startup; end

  # source://que//lib/que/locker.rb#473
  def unlock_jobs(metajobs); end

  # source://que//lib/que/locker.rb#375
  def wait; end

  # source://que//lib/que/locker.rb#317
  def wait_for_shutdown; end

  # source://que//lib/que/locker.rb#241
  def work_loop; end
end

# source://que//lib/que/locker.rb#52
Que::Locker::DEFAULT_MAXIMUM_BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/locker.rb#50
Que::Locker::DEFAULT_POLL_INTERVAL = T.let(T.unsafe(nil), Float)

# source://que//lib/que/locker.rb#51
Que::Locker::DEFAULT_WAIT_PERIOD = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/locker.rb#53
Que::Locker::DEFAULT_WORKER_PRIORITIES = T.let(T.unsafe(nil), Array)

# source://que//lib/que/locker.rb#38
Que::Locker::MESSAGE_RESOLVERS = T.let(T.unsafe(nil), Hash)

# source://que//lib/que/locker.rb#39
Que::Locker::RESULT_RESOLVERS = T.let(T.unsafe(nil), Hash)

# source://que//lib/que.rb#11
Que::MAXIMUM_PRIORITY = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/metajob.rb#7
class Que::Metajob
  # @return [Metajob] a new instance of Metajob
  #
  # source://que//lib/que/metajob.rb#12
  def initialize(job); end

  # source://que//lib/que/metajob.rb#28
  def <=>(other); end

  # source://que//lib/que/metajob.rb#24
  def id; end

  # Returns the value of attribute job.
  #
  # source://que//lib/que/metajob.rb#10
  def job; end

  # @return [Boolean]
  #
  # source://que//lib/que/metajob.rb#43
  def priority_sufficient?(threshold); end

  # source://que//lib/que/metajob.rb#16
  def set_job(job); end
end

# source://que//lib/que/metajob.rb#8
Que::Metajob::SORT_KEYS = T.let(T.unsafe(nil), Array)

# source://que//lib/que/migrations.rb#4
module Que::Migrations
  class << self
    # The que_jobs table could be missing the schema version comment either due to:
    # - Being created before the migration system existed; or
    # - A bug in Rails schema dump in some versions of Rails
    # The former is the case on Que versions prior to v0.5.0 (2014-01-14). Upgrading directly from there is unsupported, so we just raise in all cases of the comment being missing
    #
    # @raise [Error]
    #
    # source://que//lib/que/migrations.rb#62
    def _raise_db_version_comment_missing_error; end

    # source://que//lib/que/migrations.rb#38
    def db_version; end

    # source://que//lib/que/migrations.rb#10
    def migrate!(version:); end

    # source://que//lib/que/migrations.rb#72
    def set_db_version(version); end
  end
end

# In order to ship a schema change, add the relevant up and down sql files
# to the migrations directory, and bump the version here.
#
# source://que//lib/que/migrations.rb#7
Que::Migrations::CURRENT_VERSION = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/poller.rb#4
class Que::Poller
  # @return [Poller] a new instance of Poller
  #
  # source://que//lib/que/poller.rb#122
  def initialize(connection:, queue:, poll_interval:); end

  # Returns the value of attribute connection.
  #
  # source://que//lib/que/poller.rb#115
  def connection; end

  # Returns the value of attribute last_poll_satisfied.
  #
  # source://que//lib/que/poller.rb#115
  def last_poll_satisfied; end

  # Returns the value of attribute last_polled_at.
  #
  # source://que//lib/que/poller.rb#115
  def last_polled_at; end

  # source://que//lib/que/poller.rb#142
  def poll(priorities:, held_locks:); end

  # Returns the value of attribute poll_interval.
  #
  # source://que//lib/que/poller.rb#115
  def poll_interval; end

  # @return [Boolean]
  #
  # source://que//lib/que/poller.rb#183
  def poll_interval_elapsed?; end

  # Returns the value of attribute queue.
  #
  # source://que//lib/que/poller.rb#115
  def queue; end

  # @return [Boolean]
  #
  # source://que//lib/que/poller.rb#175
  def should_poll?; end

  private

  # @return [Boolean]
  #
  # source://que//lib/que/poller.rb#269
  def poll_satisfied?(priorities, jobs); end

  class << self
    # source://que//lib/que/poller.rb#258
    def cleanup(connection); end

    # Manage some temporary infrastructure (specific to the connection) that
    # we'll use for polling. These could easily be created permanently in a
    # migration, but that'd require another migration if we wanted to tweak
    # them later.
    #
    # source://que//lib/que/poller.rb#194
    def setup(connection); end
  end
end

# source://que//lib/que/rails/railtie.rb#4
module Que::Rails; end

# source://que//lib/que/rails/railtie.rb#5
class Que::Rails::Railtie < ::Rails::Railtie; end

# source://que//lib/que/result_queue.rb#7
class Que::ResultQueue
  # @return [ResultQueue] a new instance of ResultQueue
  #
  # source://que//lib/que/result_queue.rb#8
  def initialize; end

  # source://que//lib/que/result_queue.rb#17
  def clear; end

  # source://que//lib/que/result_queue.rb#25
  def length; end

  # source://que//lib/que/result_queue.rb#13
  def push(item); end

  # source://que//lib/que/result_queue.rb#21
  def to_a; end

  private

  # source://que//lib/que/result_queue.rb#31
  def sync(&block); end
end

# Store SQL strings frozen, with squashed whitespace so logs read better.
#
# source://que//lib/que.rb#16
Que::SQL = T.let(T.unsafe(nil), Hash)

# source://que//lib/que.rb#9
Que::TIME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://que//lib/que/utils/assertions.rb#8
module Que::Utils; end

# source://que//lib/que/utils/assertions.rb#9
module Que::Utils::Assertions
  # @raise [AssertionFailed]
  #
  # source://que//lib/que/utils/assertions.rb#12
  def assert(*args); end

  # @return [Boolean]
  #
  # source://que//lib/que/utils/assertions.rb#29
  def assert?(*args); end

  private

  # Want to support:
  #   assert(x)                       # Truthiness.
  #   assert(thing, other)            # Trip-equals.
  #   assert([thing1, thing2], other) # Multiple Trip-equals.
  #
  # source://que//lib/que/utils/assertions.rb#40
  def _check_assertion_args(first, second = T.unsafe(nil)); end
end

# source://que//lib/que/utils/assertions.rb#10
class Que::Utils::Assertions::AssertionFailed < ::Que::Error; end

# source://que//lib/que/utils/constantization.rb#5
module Que::Utils::Constantization
  # source://que//lib/que/utils/constantization.rb#6
  def constantize(string); end
end

# source://que//lib/que/utils/error_notification.rb#5
module Que::Utils::ErrorNotification
  # source://que//lib/que/utils/error_notification.rb#57
  def async_error_thread; end

  # Returns the value of attribute error_notifier.
  #
  # source://que//lib/que/utils/error_notification.rb#6
  def error_notifier; end

  # Sets the attribute error_notifier
  #
  # @param value the value to set the attribute error_notifier to.
  #
  # source://que//lib/que/utils/error_notification.rb#6
  def error_notifier=(_arg0); end

  # source://que//lib/que/utils/error_notification.rb#8
  def notify_error(*args); end

  # Helper method to notify errors asynchronously. For use in high-priority
  # code, where we don't want to be held up by whatever I/O the error
  # notification proc contains.
  #
  # source://que//lib/que/utils/error_notification.rb#38
  def notify_error_async(*args); end
end

# source://que//lib/que/utils/error_notification.rb#32
Que::Utils::ErrorNotification::ASYNC_QUEUE = T.let(T.unsafe(nil), Thread::Queue)

# source://que//lib/que/utils/error_notification.rb#33
Que::Utils::ErrorNotification::MAX_QUEUE_SIZE = T.let(T.unsafe(nil), Integer)

# source://que//lib/que/utils/freeze.rb#7
module Que::Utils::Freeze
  # source://que//lib/que/utils/freeze.rb#8
  def recursively_freeze(thing); end
end

# source://que//lib/que/utils/introspection.rb#7
module Que::Utils::Introspection
  # source://que//lib/que/utils/introspection.rb#45
  def job_states; end

  # source://que//lib/que/utils/introspection.rb#27
  def job_stats; end
end

# source://que//lib/que/utils/json_serialization.rb#10
module Que::Utils::JSONSerialization
  # source://que//lib/que/utils/json_serialization.rb#15
  def deserialize_json(json); end

  # source://que//lib/que/utils/json_serialization.rb#11
  def serialize_json(object); end
end

# source://que//lib/que/utils/logging.rb#7
module Que::Utils::Logging
  # source://que//lib/que/utils/logging.rb#57
  def get_logger(internal: T.unsafe(nil)); end

  # Logging method used specifically to instrument Que's internals. There's
  # usually not an internal logger set up, so this method is generally a no-
  # op unless the specs are running or someone turns on internal logging so
  # we can debug an issue.
  #
  # source://que//lib/que/utils/logging.rb#35
  def internal_log(event, object = T.unsafe(nil)); end

  # Returns the value of attribute internal_logger.
  #
  # source://que//lib/que/utils/logging.rb#8
  def internal_logger; end

  # Sets the attribute internal_logger
  #
  # @param value the value to set the attribute internal_logger to.
  #
  # source://que//lib/que/utils/logging.rb#8
  def internal_logger=(_arg0); end

  # source://que//lib/que/utils/logging.rb#11
  def log(event:, level: T.unsafe(nil), **extra); end

  # source://que//lib/que/utils/logging.rb#63
  def log_formatter; end

  # Sets the attribute log_formatter
  #
  # @param value the value to set the attribute log_formatter to.
  #
  # source://que//lib/que/utils/logging.rb#9
  def log_formatter=(_arg0); end

  # Returns the value of attribute logger.
  #
  # source://que//lib/que/utils/logging.rb#8
  def logger; end

  # Sets the attribute logger
  #
  # @param value the value to set the attribute logger to.
  #
  # source://que//lib/que/utils/logging.rb#8
  def logger=(_arg0); end

  private

  # source://que//lib/que/utils/logging.rb#69
  def _default_log_data; end
end

# source://que//lib/que/utils/middleware.rb#7
module Que::Utils::Middleware
  def job_middleware; end
  def run_job_middleware(*args); end
  def run_sql_middleware(*args); end
  def sql_middleware; end

  private

  # source://que//lib/que/utils/middleware.rb#33
  def invoke_middleware(middleware:, args:, &block); end
end

# source://que//lib/que/utils/middleware.rb#8
Que::Utils::Middleware::TYPES = T.let(T.unsafe(nil), Array)

# source://que//lib/que/utils/queue_management.rb#7
module Que::Utils::QueueManagement
  # source://que//lib/que/utils/queue_management.rb#8
  def clear!; end

  # Very old migrations may use Que.create! and Que.drop!, which just
  # created and dropped the initial version of the jobs table.
  #
  # source://que//lib/que/utils/queue_management.rb#14
  def create!; end

  # source://que//lib/que/utils/queue_management.rb#15
  def drop!; end
end

# source://que//lib/que/utils/ruby2_keywords.rb#11
module Que::Utils::Ruby2Keywords
  # source://que//lib/que/utils/ruby2_keywords.rb#12
  def split_out_ruby2_keywords(args); end
end

# source://que//lib/que/utils/transactions.rb#10
module Que::Utils::Transactions
  # source://que//lib/que/utils/transactions.rb#11
  def transaction; end
end

# source://que//lib/que/version.rb#4
Que::VERSION = T.let(T.unsafe(nil), String)

# source://que//lib/que/worker.rb#9
class Que::Worker
  # @return [Worker] a new instance of Worker
  #
  # source://que//lib/que/worker.rb#21
  def initialize(job_buffer:, result_queue:, priority: T.unsafe(nil), start_callback: T.unsafe(nil)); end

  # Returns the value of attribute priority.
  #
  # source://que//lib/que/worker.rb#10
  def priority; end

  # Returns the value of attribute thread.
  #
  # source://que//lib/que/worker.rb#10
  def thread; end

  # source://que//lib/que/worker.rb#50
  def wait_until_stopped; end

  private

  # source://que//lib/que/worker.rb#93
  def fetch_next_metajob; end

  # source://que//lib/que/worker.rb#97
  def work_job(metajob); end

  # source://que//lib/que/worker.rb#56
  def work_loop; end
end

# source://que//lib/que/worker.rb#12
Que::Worker::VALID_LOG_LEVELS = T.let(T.unsafe(nil), Set)
