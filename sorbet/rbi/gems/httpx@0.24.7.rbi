# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httpx` gem.
# Please instead update this file by running `bin/tapioca gem httpx`.

# Top-Level Namespace
#
# source://httpx//lib/httpx/version.rb#3
module HTTPX
  extend ::HTTPX::Chainable

  class << self
    # :nocov:
    #
    # source://httpx//lib/httpx.rb#57
    def const_missing(const_name); end
  end
end

# source://httpx//lib/httpx/altsvc.rb#6
module HTTPX::AltSvc
  private

  # source://httpx//lib/httpx/altsvc.rb#12
  def cached_altsvc(origin); end

  # source://httpx//lib/httpx/altsvc.rb#19
  def cached_altsvc_set(origin, entry); end

  # source://httpx//lib/httpx/altsvc.rb#39
  def emit(request, response); end

  # source://httpx//lib/httpx/altsvc.rb#30
  def lookup(origin, ttl); end

  # source://httpx//lib/httpx/altsvc.rb#68
  def parse(altsvc); end

  # source://httpx//lib/httpx/altsvc.rb#117
  def parse_altsvc_origin(alt_proto, alt_origin); end

  # source://httpx//lib/httpx/altsvc.rb#92
  def parse_altsvc_scheme(alt_proto); end

  class << self
    # source://httpx//lib/httpx/altsvc.rb#12
    def cached_altsvc(origin); end

    # source://httpx//lib/httpx/altsvc.rb#19
    def cached_altsvc_set(origin, entry); end

    # source://httpx//lib/httpx/altsvc.rb#39
    def emit(request, response); end

    # source://httpx//lib/httpx/altsvc.rb#30
    def lookup(origin, ttl); end

    # source://httpx//lib/httpx/altsvc.rb#68
    def parse(altsvc); end

    # source://httpx//lib/httpx/altsvc.rb#117
    def parse_altsvc_origin(alt_proto, alt_origin); end

    # source://httpx//lib/httpx/altsvc.rb#92
    def parse_altsvc_scheme(alt_proto); end
  end
end

# source://httpx//lib/httpx/extensions.rb#96
module HTTPX::ArrayExtensions; end

# source://httpx//lib/httpx/extensions.rb#97
module HTTPX::ArrayExtensions::FilterMap; end

# source://httpx//lib/httpx/extensions.rb#121
module HTTPX::ArrayExtensions::Intersect; end

# source://httpx//lib/httpx/extensions.rb#111
module HTTPX::ArrayExtensions::Sum; end

# source://httpx//lib/httpx/buffer.rb#6
class HTTPX::Buffer
  extend ::Forwardable

  # @return [Buffer] a new instance of Buffer
  #
  # source://httpx//lib/httpx/buffer.rb#25
  def initialize(limit); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#34
  def capacity; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/buffer.rb#30
  def full?; end

  # Returns the value of attribute limit.
  #
  # source://httpx//lib/httpx/buffer.rb#23
  def limit; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def replace(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#38
  def shift!(fin); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/callbacks.rb#4
module HTTPX::Callbacks
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/callbacks.rb#27
  def callbacks_for?(type); end

  # source://httpx//lib/httpx/callbacks.rb#23
  def emit(type, *args); end

  # source://httpx//lib/httpx/callbacks.rb#5
  def on(type, &action); end

  # source://httpx//lib/httpx/callbacks.rb#10
  def once(type, &block); end

  # source://httpx//lib/httpx/callbacks.rb#18
  def only(type, &block); end

  protected

  # source://httpx//lib/httpx/callbacks.rb#33
  def callbacks(type = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/chainable.rb#4
module HTTPX::Chainable
  # :nocov:
  #
  # source://httpx//lib/httpx/chainable.rb#42
  def accept(type); end

  # source://httpx//lib/httpx/chainable.rb#7
  def connect(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#7
  def delete(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#7
  def get(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#7
  def head(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#36
  def headers(headers); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_connection_closed(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_connection_opened(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_request_body_chunk(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_request_completed(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_request_error(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_request_started(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_response_body_chunk(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_response_completed(&blk); end

  # source://httpx//lib/httpx/chainable.rb#20
  def on_response_started(&blk); end

  # source://httpx//lib/httpx/chainable.rb#7
  def options(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#7
  def patch(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#50
  def plugin(pl, options = T.unsafe(nil), &blk); end

  # deprecated
  # :nocov:
  #
  # source://httpx//lib/httpx/chainable.rb#59
  def plugins(pls); end

  # source://httpx//lib/httpx/chainable.rb#7
  def post(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#7
  def put(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#26
  def request(*args, **options); end

  # :nocov:
  #
  # source://httpx//lib/httpx/chainable.rb#31
  def timeout(**args); end

  # source://httpx//lib/httpx/chainable.rb#7
  def trace(*uri, **options); end

  # :nocov:
  #
  # source://httpx//lib/httpx/chainable.rb#68
  def with(options, &blk); end

  # source://httpx//lib/httpx/chainable.rb#46
  def wrap(&blk); end

  protected

  # source://httpx//lib/httpx/chainable.rb#74
  def on(*args, &blk); end

  private

  # source://httpx//lib/httpx/chainable.rb#84
  def branch(options, &blk); end

  # source://httpx//lib/httpx/chainable.rb#80
  def default_options; end

  # source://httpx//lib/httpx/chainable.rb#90
  def method_missing(meth, *args, **options); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/chainable.rb#100
  def respond_to_missing?(meth, *_arg1); end
end

# source://httpx//lib/httpx/errors.rb#27
class HTTPX::ConnectTimeoutError < ::HTTPX::TimeoutError; end

# The Connection can be watched for IO events.
#
# It contains the +io+ object to read/write from, and knows what to do when it can.
#
# It defers connecting until absolutely necessary. Connection should be triggered from
# the IO selector (until then, any request will be queued).
#
# A connection boots up its parser after connection is established. All pending requests
# will be redirected there after connection.
#
# A connection can be prevented from closing by the parser, that is, if there are pending
# requests. This will signal that the connection was prematurely closed, due to a possible
# number of conditions:
#
# * Remote peer closed the connection ("Connection: close");
# * Remote peer doesn't support pipelining;
#
# A connection may also route requests for a different host for which the +io+ was connected
# to, provided that the IP is the same and the port and scheme as well. This will allow to
# share the same socket to send HTTP/2 requests to different hosts.
#
# source://httpx//lib/httpx/connection.rb#30
class HTTPX::Connection
  include ::HTTPX::Loggable
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # @return [Connection] a new instance of Connection
  #
  # source://httpx//lib/httpx/connection.rb#51
  def initialize(type, uri, options); end

  # source://httpx//lib/httpx/connection.rb#88
  def addresses; end

  # this is a semi-private method, to be used by the resolver
  # to initiate the io object.
  #
  # source://httpx//lib/httpx/connection.rb#80
  def addresses=(addrs); end

  # source://httpx//lib/httpx/connection.rb#216
  def call; end

  # source://httpx//lib/httpx/connection.rb#230
  def close; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def closed?(*args, **_arg1, &block); end

  # coalescable connections need to be mergeable!
  # but internally, #mergeable? is called before #coalescable?
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#130
  def coalescable?(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#188
  def connecting?; end

  # source://httpx//lib/httpx/connection.rb#141
  def create_idle(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#306
  def deactivate; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#109
  def expired?; end

  # Returns the value of attribute family.
  #
  # source://httpx//lib/httpx/connection.rb#49
  def family; end

  # Sets the attribute family
  #
  # @param value the value to set the attribute family to.
  #
  # source://httpx//lib/httpx/connection.rb#49
  def family=(_arg0); end

  # bypasses the state machine to force closing of connections still connecting.
  # **only** used for Happy Eyeballs v2.
  #
  # source://httpx//lib/httpx/connection.rb#238
  def force_reset; end

  # source://httpx//lib/httpx/connection.rb#295
  def idling; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#192
  def inflight?; end

  # source://httpx//lib/httpx/connection.rb#196
  def interests; end

  # Returns the value of attribute io.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def io; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#92
  def match?(uri, options); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#180
  def match_altsvc_options?(uri, options); end

  # checks if this is connection is an alternative service of
  # +uri+
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#172
  def match_altsvcs?(uri); end

  # source://httpx//lib/httpx/connection.rb#145
  def merge(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#115
  def mergeable?(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#310
  def open?; end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def options; end

  # Returns the value of attribute origin.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def origin; end

  # Returns the value of attribute origins.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def origins; end

  # Returns the value of attribute pending.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def pending; end

  # source://httpx//lib/httpx/connection.rb#158
  def purge_pending(&block); end

  # source://httpx//lib/httpx/connection.rb#314
  def raise_timeout_error(interval); end

  # source://httpx//lib/httpx/connection.rb#244
  def reset; end

  # source://httpx//lib/httpx/connection.rb#250
  def send(request); end

  # Returns the value of attribute ssl_session.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def ssl_session; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def state; end

  # source://httpx//lib/httpx/connection.rb#272
  def timeout; end

  # Sets the attribute timers
  #
  # @param value the value to set the attribute timers to.
  #
  # source://httpx//lib/httpx/connection.rb#47
  def timers=(_arg0); end

  # source://httpx//lib/httpx/connection.rb#212
  def to_io; end

  # Returns the value of attribute type.
  #
  # source://httpx//lib/httpx/connection.rb#45
  def type; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#302
  def used?; end

  private

  # source://httpx//lib/httpx/connection.rb#478
  def build_parser(protocol = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#623
  def build_socket(addrs = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#322
  def connect; end

  # source://httpx//lib/httpx/connection.rb#330
  def consume; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#326
  def exhausted?; end

  # source://httpx//lib/httpx/connection.rb#668
  def handle_error(error); end

  # source://httpx//lib/httpx/connection.rb#575
  def handle_transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#643
  def on_error(error); end

  # source://httpx//lib/httpx/connection.rb#463
  def parser; end

  # source://httpx//lib/httpx/connection.rb#617
  def purge_after_closed; end

  # source://httpx//lib/httpx/connection.rb#702
  def read_timeout_callback(request, read_timeout, error_type = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#457
  def send_pending; end

  # source://httpx//lib/httpx/connection.rb#467
  def send_request_to_parser(request); end

  # source://httpx//lib/httpx/connection.rb#484
  def set_parser_callbacks(parser); end

  # source://httpx//lib/httpx/connection.rb#677
  def set_request_timeouts(request); end

  # source://httpx//lib/httpx/connection.rb#549
  def transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#694
  def write_timeout_callback(request, write_timeout); end

  class << self
    # source://httpx//lib/httpx/connection.rb#713
    def parser_type(protocol); end
  end
end

# source://httpx//lib/httpx/connection/http1.rb#6
class HTTPX::Connection::HTTP1
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http1.rb#15
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http1.rb#72
  def <<(data); end

  # source://httpx//lib/httpx/connection/http1.rb#52
  def close; end

  # source://httpx//lib/httpx/connection/http1.rb#88
  def consume; end

  # source://httpx//lib/httpx/connection/http1.rb#160
  def dispatch; end

  # source://httpx//lib/httpx/connection/http1.rb#61
  def empty?; end

  # source://httpx//lib/httpx/connection/http1.rb#57
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http1.rb#190
  def handle_error(ex); end

  # source://httpx//lib/httpx/connection/http1.rb#31
  def interests; end

  # source://httpx//lib/httpx/connection/http1.rb#151
  def on_complete; end

  # source://httpx//lib/httpx/connection/http1.rb#135
  def on_data(chunk); end

  # source://httpx//lib/httpx/connection/http1.rb#107
  def on_headers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#103
  def on_start; end

  # source://httpx//lib/httpx/connection/http1.rb#125
  def on_trailers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def pending; end

  # source://httpx//lib/httpx/connection/http1.rb#213
  def ping; end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def requests; end

  # source://httpx//lib/httpx/connection/http1.rb#46
  def reset; end

  # source://httpx//lib/httpx/connection/http1.rb#76
  def send(request); end

  # source://httpx//lib/httpx/connection/http1.rb#27
  def timeout; end

  private

  # source://httpx//lib/httpx/connection/http1.rb#380
  def capitalized(field); end

  # source://httpx//lib/httpx/connection/http1.rb#256
  def disable; end

  # source://httpx//lib/httpx/connection/http1.rb#262
  def disable_pipelining; end

  # source://httpx//lib/httpx/connection/http1.rb#315
  def handle(request); end

  # source://httpx//lib/httpx/connection/http1.rb#342
  def join_body(request); end

  # source://httpx//lib/httpx/connection/http1.rb#332
  def join_headers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#365
  def join_headers2(headers); end

  # source://httpx//lib/httpx/connection/http1.rb#328
  def join_headline(request); end

  # source://httpx//lib/httpx/connection/http1.rb#357
  def join_trailers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#220
  def manage_connection(response); end

  # source://httpx//lib/httpx/connection/http1.rb#282
  def set_protocol_headers(request); end
end

# source://httpx//lib/httpx/connection/http1.rb#11
HTTPX::Connection::HTTP1::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/connection/http1.rb#10
HTTPX::Connection::HTTP1::MAX_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/connection/http1.rb#375
HTTPX::Connection::HTTP1::UPCASED = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/connection/http2.rb#7
class HTTPX::Connection::HTTP2
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http2.rb#27
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http2.rb#90
  def <<(data); end

  # source://httpx//lib/httpx/connection/http2.rb#94
  def can_buffer_more_requests?; end

  # source://httpx//lib/httpx/connection/http2.rb#75
  def close; end

  # source://httpx//lib/httpx/connection/http2.rb#122
  def consume; end

  # source://httpx//lib/httpx/connection/http2.rb#80
  def empty?; end

  # source://httpx//lib/httpx/connection/http2.rb#84
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http2.rb#130
  def handle_error(ex); end

  # source://httpx//lib/httpx/connection/http2.rb#48
  def interests; end

  # source://httpx//lib/httpx/connection/http2.rb#25
  def pending; end

  # source://httpx//lib/httpx/connection/http2.rb#146
  def ping; end

  # source://httpx//lib/httpx/connection/http2.rb#173
  def reset; end

  # source://httpx//lib/httpx/connection/http2.rb#104
  def send(request); end

  # source://httpx//lib/httpx/connection/http2.rb#25
  def streams; end

  # source://httpx//lib/httpx/connection/http2.rb#42
  def timeout; end

  private

  # source://httpx//lib/httpx/connection/http2.rb#161
  def handle(request, stream); end

  # source://httpx//lib/httpx/connection/http2.rb#197
  def handle_stream(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#173
  def init_connection; end

  # source://httpx//lib/httpx/connection/http2.rb#243
  def join_body(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#217
  def join_headers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#231
  def join_trailers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#392
  def on_altsvc(origin, frame); end

  # source://httpx//lib/httpx/connection/http2.rb#354
  def on_close(_last_frame, error, _payload); end

  # source://httpx//lib/httpx/connection/http2.rb#336
  def on_frame(bytes); end

  # source://httpx//lib/httpx/connection/http2.rb#383
  def on_frame_received(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#374
  def on_frame_sent(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#404
  def on_origin(origin); end

  # source://httpx//lib/httpx/connection/http2.rb#408
  def on_pong(ping); end

  # source://httpx//lib/httpx/connection/http2.rb#400
  def on_promise(stream); end

  # source://httpx//lib/httpx/connection/http2.rb#340
  def on_settings(*_arg0); end

  # source://httpx//lib/httpx/connection/http2.rb#306
  def on_stream_close(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#295
  def on_stream_data(stream, request, data); end

  # source://httpx//lib/httpx/connection/http2.rb#268
  def on_stream_headers(stream, request, h); end

  # source://httpx//lib/httpx/connection/http2.rb#301
  def on_stream_refuse(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#288
  def on_stream_trailers(stream, response, h); end

  # source://httpx//lib/httpx/connection/http2.rb#155
  def send_pending; end

  # source://httpx//lib/httpx/connection/http2.rb#208
  def set_protocol_headers(request); end
end

# source://httpx//lib/httpx/connection/http2.rb#13
class HTTPX::Connection::HTTP2::Error < ::HTTPX::Error
  # source://httpx//lib/httpx/connection/http2.rb#14
  def initialize(id, code); end
end

# source://httpx//lib/httpx/connection/http2.rb#19
class HTTPX::Connection::HTTP2::GoawayError < ::HTTPX::Connection::HTTP2::Error
  # source://httpx//lib/httpx/connection/http2.rb#20
  def initialize; end
end

# source://httpx//lib/httpx/connection/http2.rb#11
HTTPX::Connection::HTTP2::MAX_CONCURRENT_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/errors.rb#8
class HTTPX::ConnectionError < ::HTTPX::Error; end

# source://httpx//lib/httpx/response.rb#322
class HTTPX::ContentType
  # @return [ContentType] a new instance of ContentType
  #
  # source://httpx//lib/httpx/response.rb#326
  def initialize(header_value); end

  # source://httpx//lib/httpx/response.rb#337
  def charset; end

  # source://httpx//lib/httpx/response.rb#330
  def mime_type; end
end

# source://httpx//lib/httpx/response.rb#324
HTTPX::ContentType::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/response.rb#323
HTTPX::ContentType::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# Represents a domain name ready for extracting its registered domain
# and TLD.
#
# source://httpx//lib/httpx/domain_name.rb#34
class HTTPX::DomainName
  include ::Comparable

  # Parses _hostname_ into a DomainName object.  An IP address is also
  # accepted.  An IPv6 address may be enclosed in square brackets.
  #
  # @raise [ArgumentError]
  # @return [DomainName] a new instance of DomainName
  #
  # source://httpx//lib/httpx/domain_name.rb#73
  def initialize(hostname); end

  # def ==(other)
  #   other = DomainName.new(other)
  #   other.hostname == @hostname
  # end
  #
  # source://httpx//lib/httpx/domain_name.rb#134
  def <=>(other); end

  # Checks if the server represented by this domain is qualified to
  # send and receive cookies with a domain attribute value of
  # _domain_.  A true value given as the second argument represents
  # cookies without a domain attribute value, in which case only
  # hostname equality is checked.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/domain_name.rb#113
  def cookie_domain?(domain, host_only = T.unsafe(nil)); end

  # The least "universally original" domain part of this domain name.
  # For example, "example.co.uk" for "www.sub.example.co.uk".  This
  # may be nil if the hostname does not have one, like when it is an
  # IP address, an effective TLD or higher itself, or of a
  # non-canonical domain.
  #
  # source://httpx//lib/httpx/domain_name.rb#52
  def domain; end

  # The full host name normalized, ASCII-ized and downcased using the
  # Unicode NFC rules and the Punycode algorithm.  If initialized with
  # an IP address, the string representation of the IP address
  # suitable for opening a connection to.
  #
  # source://httpx//lib/httpx/domain_name.rb#41
  def hostname; end

  class << self
    # source://httpx//lib/httpx/domain_name.rb#57
    def new(domain); end

    # Normalizes a _domain_ using the Punycode algorithm as necessary.
    # The result will be a downcased, ASCII-only string.
    #
    # source://httpx//lib/httpx/domain_name.rb#65
    def normalize(domain); end
  end
end

# source://httpx//lib/httpx/domain_name.rb#54
HTTPX::DomainName::DOT = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx.rb#27
HTTPX::EMPTY = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/errors.rb#4
class HTTPX::Error < ::StandardError; end

# source://httpx//lib/httpx/response.rb#345
class HTTPX::ErrorResponse
  include ::HTTPX::Loggable
  include ::HTTPX::ErrorResponsePatternMatchExtensions
  extend ::Forwardable

  # @return [ErrorResponse] a new instance of ErrorResponse
  #
  # source://httpx//lib/httpx/response.rb#353
  def initialize(request, error, options); end

  # source://httpx//lib/httpx/response.rb#377
  def close; end

  # Returns the value of attribute error.
  #
  # source://httpx//lib/httpx/response.rb#349
  def error; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#381
  def finished?; end

  # @raise [@error]
  #
  # source://httpx//lib/httpx/response.rb#385
  def raise_for_status; end

  # Returns the value of attribute request.
  #
  # source://httpx//lib/httpx/response.rb#349
  def request; end

  # Returns the value of attribute response.
  #
  # source://httpx//lib/httpx/response.rb#349
  def response; end

  # source://httpx//lib/httpx/response.rb#361
  def status; end

  # source://httpx//lib/httpx/response.rb#367
  def to_s; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uri(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#14
module HTTPX::ErrorResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#15
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#19
  def deconstruct_keys(_keys); end
end

# source://httpx//lib/httpx/errors.rb#63
class HTTPX::HTTPError < ::HTTPX::Error
  # @return [HTTPError] a new instance of HTTPError
  #
  # source://httpx//lib/httpx/errors.rb#66
  def initialize(response); end

  # Returns the value of attribute response.
  #
  # source://httpx//lib/httpx/errors.rb#64
  def response; end

  # source://httpx//lib/httpx/errors.rb#71
  def status; end
end

# source://httpx//lib/httpx/extensions.rb#83
module HTTPX::HashExtensions; end

# source://httpx//lib/httpx/headers.rb#4
class HTTPX::Headers
  include ::HTTPX::HeadersPatternMatchExtensions

  # @return [Headers] a new instance of Headers
  #
  # source://httpx//lib/httpx/headers.rb#13
  def initialize(headers = T.unsafe(nil)); end

  # source://httpx//lib/httpx/headers.rb#118
  def ==(other); end

  # returns the comma-separated values of the header field
  # identified by +field+, or nil otherwise.
  #
  # source://httpx//lib/httpx/headers.rb#68
  def [](field); end

  # sets +value+ (if not nil) as single value for the +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#75
  def []=(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  #
  # source://httpx//lib/httpx/headers.rb#90
  def add(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  # helper to be used when adding an header field as a value to another field
  #
  #     h2_headers.add_header("vary", "accept-encoding")
  #     h2_headers["vary"] #=> "accept-encoding"
  #     h1_headers.add_header("vary", "accept-encoding")
  #     h1_headers["vary"] #=> "Accept-Encoding"
  #
  # source://httpx//lib/httpx/headers.rb#90
  def add_header(field, value); end

  # deletes all values associated with +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#83
  def delete(field); end

  # returns the enumerable headers store in pairs of header field + the values in
  # the comma-separated string format
  #
  # source://httpx//lib/httpx/headers.rb#106
  def each(extra_headers = T.unsafe(nil)); end

  # freezes the headers hash
  #
  # source://httpx//lib/httpx/headers.rb#37
  def freeze; end

  # returns the values for the +field+ header in array format.
  # This method is more internal, and for this reason doesn't try
  # to "correct" the user input, i.e. it doesn't downcase the key.
  #
  # source://httpx//lib/httpx/headers.rb#156
  def get(field); end

  # :nocov:
  #
  # source://httpx//lib/httpx/headers.rb#139
  def inspect; end

  # this is internal API and doesn't abide to other public API
  # guarantees, like downcasing strings.
  # Please do not use this outside of core!
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#148
  def key?(downcased_key); end

  # merges headers with another header-quack.
  # the merge rule is, if the header already exists,
  # ignore what the +other+ headers has. Otherwise, set
  #
  # source://httpx//lib/httpx/headers.rb#57
  def merge(other); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#42
  def same_headers?(headers); end

  # the headers store in array of pairs format
  #
  # source://httpx//lib/httpx/headers.rb#129
  def to_a; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#123
  def to_h; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#123
  def to_hash; end

  # headers as string
  #
  # source://httpx//lib/httpx/headers.rb#134
  def to_s; end

  private

  # source://httpx//lib/httpx/headers.rb#162
  def array_value(value); end

  # source://httpx//lib/httpx/headers.rb#171
  def downcased(field); end

  # cloned initialization
  #
  # source://httpx//lib/httpx/headers.rb#25
  def initialize_clone(orig); end

  # dupped initialization
  #
  # source://httpx//lib/httpx/headers.rb#31
  def initialize_dup(orig); end

  class << self
    # source://httpx//lib/httpx/headers.rb#6
    def new(headers = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#24
module HTTPX::HeadersPatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#25
  def deconstruct; end
end

# source://httpx//lib/httpx/extensions.rb#136
module HTTPX::IOExtensions; end

# source://httpx//lib/httpx/loggable.rb#4
module HTTPX::Loggable
  # source://httpx//lib/httpx/loggable.rb#16
  def log(level: T.unsafe(nil), color: T.unsafe(nil), &msg); end

  # source://httpx//lib/httpx/loggable.rb#29
  def log_exception(ex, level: T.unsafe(nil), color: T.unsafe(nil)); end
end

# source://httpx//lib/httpx/loggable.rb#5
HTTPX::Loggable::COLORS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/errors.rb#76
class HTTPX::MisdirectedRequestError < ::HTTPX::HTTPError; end

# source://httpx//lib/httpx/errors.rb#53
class HTTPX::NativeResolveError < ::HTTPX::ResolveError
  # @return [NativeResolveError] a new instance of NativeResolveError
  #
  # source://httpx//lib/httpx/errors.rb#56
  def initialize(connection, host, message = T.unsafe(nil)); end

  # Returns the value of attribute connection.
  #
  # source://httpx//lib/httpx/errors.rb#54
  def connection; end

  # Returns the value of attribute host.
  #
  # source://httpx//lib/httpx/errors.rb#54
  def host; end
end

# source://httpx//lib/httpx/extensions.rb#57
module HTTPX::NumericExtensions; end

# source://httpx//lib/httpx/options.rb#6
class HTTPX::Options
  # @return [Options] a new instance of Options
  #
  # source://httpx//lib/httpx/options.rb#133
  def initialize(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#230
  def ==(other); end

  # source://httpx//lib/httpx/options.rb#101
  def addresses; end

  # source://httpx//lib/httpx/options.rb#101
  def base_path; end

  # source://httpx//lib/httpx/options.rb#101
  def body; end

  # source://httpx//lib/httpx/options.rb#101
  def body_threshold_size; end

  # source://httpx//lib/httpx/options.rb#101
  def buffer_size; end

  # source://httpx//lib/httpx/options.rb#101
  def connection_class; end

  # source://httpx//lib/httpx/options.rb#101
  def debug; end

  # source://httpx//lib/httpx/options.rb#101
  def debug_level; end

  # source://httpx//lib/httpx/options.rb#101
  def fallback_protocol; end

  # source://httpx//lib/httpx/options.rb#101
  def form; end

  # source://httpx//lib/httpx/options.rb#138
  def freeze; end

  # source://httpx//lib/httpx/options.rb#101
  def headers; end

  # source://httpx//lib/httpx/options.rb#101
  def headers_class; end

  # source://httpx//lib/httpx/options.rb#101
  def http2_settings; end

  # source://httpx//lib/httpx/options.rb#101
  def io; end

  # source://httpx//lib/httpx/options.rb#101
  def ip_families; end

  # source://httpx//lib/httpx/options.rb#101
  def json; end

  # source://httpx//lib/httpx/options.rb#101
  def max_concurrent_requests; end

  # source://httpx//lib/httpx/options.rb#101
  def max_requests; end

  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/options.rb#246
  def merge(other); end

  # source://httpx//lib/httpx/options.rb#209
  def option_addresses(value); end

  # source://httpx//lib/httpx/options.rb#151
  def option_base_path(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_body(v); end

  # source://httpx//lib/httpx/options.rb#198
  def option_body_threshold_size(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#190
  def option_buffer_size(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_connection_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_debug(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_debug_level(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_fallback_protocol(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_form(v); end

  # source://httpx//lib/httpx/options.rb#155
  def option_headers(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_headers_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_http2_settings(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_io(v); end

  # source://httpx//lib/httpx/options.rb#213
  def option_ip_families(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_json(v); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#170
  def option_max_concurrent_requests(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#176
  def option_max_requests(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_options_class(v); end

  # source://httpx//lib/httpx/options.rb#147
  def option_origin(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_params(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_persistent(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_request_body_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_request_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_resolver_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_resolver_options(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_response_body_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_response_class(v); end

  # source://httpx//lib/httpx/options.rb#107
  def option_ssl(v); end

  # source://httpx//lib/httpx/options.rb#159
  def option_timeout(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#202
  def option_transport(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_transport_options(v); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#182
  def option_window_size(value); end

  # source://httpx//lib/httpx/options.rb#107
  def option_xml(v); end

  # source://httpx//lib/httpx/options.rb#101
  def options_class; end

  # source://httpx//lib/httpx/options.rb#101
  def origin; end

  # source://httpx//lib/httpx/options.rb#101
  def params; end

  # source://httpx//lib/httpx/options.rb#101
  def persistent; end

  # source://httpx//lib/httpx/options.rb#101
  def request_body_class; end

  # source://httpx//lib/httpx/options.rb#101
  def request_class; end

  # source://httpx//lib/httpx/options.rb#101
  def resolver_class; end

  # source://httpx//lib/httpx/options.rb#101
  def resolver_options; end

  # source://httpx//lib/httpx/options.rb#101
  def response_body_class; end

  # source://httpx//lib/httpx/options.rb#101
  def response_class; end

  # source://httpx//lib/httpx/options.rb#101
  def ssl; end

  # source://httpx//lib/httpx/options.rb#101
  def timeout; end

  # source://httpx//lib/httpx/options.rb#267
  def to_hash; end

  # source://httpx//lib/httpx/options.rb#101
  def transport; end

  # source://httpx//lib/httpx/options.rb#101
  def transport_options; end

  # source://httpx//lib/httpx/options.rb#101
  def window_size; end

  # source://httpx//lib/httpx/options.rb#101
  def xml; end

  private

  # source://httpx//lib/httpx/options.rb#296
  def __initialize__(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#274
  def initialize_dup(other); end

  class << self
    # source://httpx//lib/httpx/options.rb#104
    def def_option(optname, *args, &block); end

    # source://httpx//lib/httpx/options.rb#115
    def deprecated_def_option(optname, layout = T.unsafe(nil), &interpreter); end

    # @private
    #
    # source://httpx//lib/httpx/options.rb#94
    def method_added(meth); end

    # source://httpx//lib/httpx/options.rb#86
    def new(options = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/options.rb#7
HTTPX::Options::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#10
HTTPX::Options::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#28
HTTPX::Options::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/options.rb#12
HTTPX::Options::KEEP_ALIVE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# 112K
#
# source://httpx//lib/httpx/options.rb#9
HTTPX::Options::MAX_BODY_THRESHOLD_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#11
HTTPX::Options::OPERATION_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::READ_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://httpx//lib/httpx/options.rb#227
HTTPX::Options::REQUEST_IVARS = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::REQUEST_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://httpx//lib/httpx/options.rb#13
HTTPX::Options::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# 16K
#
# source://httpx//lib/httpx/options.rb#8
HTTPX::Options::WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::WRITE_TIMEOUT = T.let(T.unsafe(nil), Float)

# source://httpx//lib/httpx/parser/http1.rb#4
module HTTPX::Parser; end

# source://httpx//lib/httpx/parser/http1.rb#5
class HTTPX::Parser::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/parser/http1.rb#7
class HTTPX::Parser::HTTP1
  # @return [HTTP1] a new instance of HTTP1
  #
  # source://httpx//lib/httpx/parser/http1.rb#12
  def initialize(observer); end

  # source://httpx//lib/httpx/parser/http1.rb#19
  def <<(chunk); end

  # Returns the value of attribute headers.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def headers; end

  # Returns the value of attribute http_version.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def http_version; end

  # source://httpx//lib/httpx/parser/http1.rb#24
  def reset!; end

  # Returns the value of attribute status_code.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def status_code; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#31
  def upgrade?; end

  # source://httpx//lib/httpx/parser/http1.rb#35
  def upgrade_data; end

  private

  # source://httpx//lib/httpx/parser/http1.rb#169
  def nextstate(state); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#159
  def no_more_data?; end

  # source://httpx//lib/httpx/parser/http1.rb#41
  def parse; end

  # source://httpx//lib/httpx/parser/http1.rb#115
  def parse_data; end

  # source://httpx//lib/httpx/parser/http1.rb#73
  def parse_headers; end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/parser/http1.rb#56
  def parse_headline; end

  # source://httpx//lib/httpx/parser/http1.rb#140
  def prepare_data(headers); end
end

# source://httpx//lib/httpx/parser/http1.rb#8
HTTPX::Parser::HTTP1::VERSIONS = T.let(T.unsafe(nil), Array)

# All plugins should be stored under this module/namespace. Can register and load
# plugins.
#
# source://httpx//lib/httpx.rb#32
module HTTPX::Plugins
  class << self
    # Loads a plugin based on a name. If the plugin hasn't been loaded, tries to load
    # it from the load path under "httpx/plugins/" directory.
    #
    # source://httpx//lib/httpx.rb#39
    def load_plugin(name); end

    # Registers a plugin (+mod+) in the central store indexed by +name+.
    #
    # source://httpx//lib/httpx.rb#50
    def register_plugin(name, mod); end
  end
end

# source://httpx//lib/httpx/pool.rb#9
class HTTPX::Pool
  extend ::Forwardable

  # @return [Pool] a new instance of Pool
  #
  # source://httpx//lib/httpx/pool.rb#15
  def initialize; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def after(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/pool.rb#52
  def close(connections = T.unsafe(nil)); end

  # source://httpx//lib/httpx/pool.rb#90
  def deactivate(connections); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/pool.rb#24
  def empty?; end

  # opens a connection to the IP reachable through +uri+.
  # Many hostnames are reachable through the same IP, so we try to
  # maximize pipelining by opening as few connections as possible.
  #
  # source://httpx//lib/httpx/pool.rb#101
  def find_connection(uri, options); end

  # source://httpx//lib/httpx/pool.rb#76
  def init_connection(connection, _options); end

  # source://httpx//lib/httpx/pool.rb#28
  def next_tick; end

  private

  # source://httpx//lib/httpx/pool.rb#249
  def coalesce_connections(conn1, conn2); end

  # source://httpx//lib/httpx/pool.rb#245
  def deselect_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#265
  def find_resolver_for(connection); end

  # source://httpx//lib/httpx/pool.rb#257
  def next_timeout; end

  # source://httpx//lib/httpx/pool.rb#210
  def on_resolver_close(resolver); end

  # source://httpx//lib/httpx/pool.rb#187
  def on_resolver_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#204
  def on_resolver_error(connection, error); end

  # source://httpx//lib/httpx/pool.rb#220
  def register_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#124
  def resolve_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#241
  def select_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#149
  def try_clone_connection(connection, family); end

  # source://httpx//lib/httpx/pool.rb#232
  def unregister_connection(connection); end
end

# source://httpx//lib/httpx/punycode.rb#66
module HTTPX::Punycode
  private

  # source://httpx//lib/httpx/punycode.rb#211
  def decode(string); end

  # source://httpx//lib/httpx/punycode.rb#296
  def decode_hostname(hostname); end

  # source://httpx//lib/httpx/punycode.rb#116
  def encode(string); end

  # source://httpx//lib/httpx/punycode.rb#198
  def encode_hostname(hostname); end

  class << self
    # source://httpx//lib/httpx/punycode.rb#211
    def decode(string); end

    # source://httpx//lib/httpx/punycode.rb#296
    def decode_hostname(hostname); end

    # source://httpx//lib/httpx/punycode.rb#116
    def encode(string); end

    # source://httpx//lib/httpx/punycode.rb#198
    def encode_hostname(hostname); end
  end
end

# source://httpx//lib/httpx/punycode.rb#110
class HTTPX::Punycode::ArgumentError < ::ArgumentError; end

# source://httpx//lib/httpx/punycode.rb#67
HTTPX::Punycode::BASE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#111
class HTTPX::Punycode::BufferOverflowError < ::HTTPX::Punycode::ArgumentError; end

# source://httpx//lib/httpx/punycode.rb#79
HTTPX::Punycode::CUTOFF = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#71
HTTPX::Punycode::DAMP = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#86
HTTPX::Punycode::DECODE_DIGIT = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/punycode.rb#74
HTTPX::Punycode::DELIMITER = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/punycode.rb#106
HTTPX::Punycode::DOT = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/punycode.rb#100
HTTPX::Punycode::ENCODE_DIGIT = T.let(T.unsafe(nil), Proc)

# source://httpx//lib/httpx/punycode.rb#72
HTTPX::Punycode::INITIAL_BIAS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#73
HTTPX::Punycode::INITIAL_N = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#78
HTTPX::Punycode::LOBASE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#76
HTTPX::Punycode::MAXINT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#107
HTTPX::Punycode::PREFIX = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/punycode.rb#81
HTTPX::Punycode::RE_NONBASIC = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/punycode.rb#70
HTTPX::Punycode::SKEW = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#69
HTTPX::Punycode::TMAX = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/punycode.rb#68
HTTPX::Punycode::TMIN = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/errors.rb#43
class HTTPX::ReadTimeoutError < ::HTTPX::RequestTimeoutError; end

# source://httpx//lib/httpx/extensions.rb#151
module HTTPX::RegexpExtensions; end

# source://httpx//lib/httpx/request.rb#7
class HTTPX::Request
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # source://httpx//lib/httpx/request.rb#21
  def initialize(verb, uri, options = T.unsafe(nil)); end

  # https://bugs.ruby-lang.org/issues/15278
  #
  # source://httpx//lib/httpx/request.rb#111
  def authority; end

  # Returns the value of attribute body.
  #
  # source://httpx//lib/httpx/request.rb#14
  def body; end

  # source://httpx//lib/httpx/request.rb#131
  def drain_body; end

  # Exception raised during enumerable body writes
  #
  # source://httpx//lib/httpx/request.rb#17
  def drain_error; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#284
  def expects?; end

  # Returns the value of attribute headers.
  #
  # source://httpx//lib/httpx/request.rb#14
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/request.rb#147
  def inspect; end

  # source://httpx//lib/httpx/request.rb#66
  def interests; end

  # source://httpx//lib/httpx/request.rb#82
  def merge_headers(h); end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/request.rb#14
  def options; end

  # https://bugs.ruby-lang.org/issues/15278
  #
  # source://httpx//lib/httpx/request.rb#116
  def origin; end

  # source://httpx//lib/httpx/request.rb#102
  def path; end

  # source://httpx//lib/httpx/request.rb#120
  def query; end

  # source://httpx//lib/httpx/request.rb#46
  def read_timeout; end

  # source://httpx//lib/httpx/request.rb#54
  def request_timeout; end

  # Returns the value of attribute response.
  #
  # source://httpx//lib/httpx/request.rb#14
  def response; end

  # source://httpx//lib/httpx/request.rb#90
  def response=(response); end

  # source://httpx//lib/httpx/request.rb#86
  def scheme; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/request.rb#14
  def state; end

  # source://httpx//lib/httpx/request.rb#62
  def trailers; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#58
  def trailers?; end

  # source://httpx//lib/httpx/request.rb#250
  def transition(nextstate); end

  # Returns the value of attribute uri.
  #
  # source://httpx//lib/httpx/request.rb#14
  def uri; end

  # Returns the value of attribute verb.
  #
  # source://httpx//lib/httpx/request.rb#14
  def verb; end

  # source://httpx//lib/httpx/request.rb#50
  def write_timeout; end
end

# :nocov:
#
# source://httpx//lib/httpx/request.rb#156
class HTTPX::Request::Body < ::SimpleDelegator
  # @return [Body] a new instance of Body
  #
  # source://httpx//lib/httpx/request.rb#165
  def initialize(headers, options); end

  # source://httpx//lib/httpx/request.rb#202
  def bytesize; end

  # source://httpx//lib/httpx/request.rb#224
  def chunk!; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#220
  def chunked?; end

  # source://httpx//lib/httpx/request.rb#175
  def each(&block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#195
  def empty?; end

  # :nocov:
  #
  # source://httpx//lib/httpx/request.rb#229
  def inspect; end

  # source://httpx//lib/httpx/request.rb#189
  def rewind; end

  # source://httpx//lib/httpx/request.rb#208
  def stream(body); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#214
  def unbounded_body?; end

  private

  # source://httpx//lib/httpx/request.rb#237
  def initialize_body(options); end

  class << self
    # source://httpx//lib/httpx/request.rb#158
    def new(_, options); end
  end
end

# source://httpx//lib/httpx/request.rb#288
class HTTPX::Request::ProcIO
  # @return [ProcIO] a new instance of ProcIO
  #
  # source://httpx//lib/httpx/request.rb#289
  def initialize(block); end

  # source://httpx//lib/httpx/request.rb#293
  def write(data); end
end

# source://httpx//lib/httpx/request.rb#12
HTTPX::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/errors.rb#29
class HTTPX::RequestTimeoutError < ::HTTPX::TimeoutError
  # @return [RequestTimeoutError] a new instance of RequestTimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#32
  def initialize(request, response, timeout); end

  # source://httpx//lib/httpx/errors.rb#38
  def marshal_dump; end

  # Returns the value of attribute request.
  #
  # source://httpx//lib/httpx/errors.rb#30
  def request; end
end

# source://httpx//lib/httpx/errors.rb#51
class HTTPX::ResolveError < ::HTTPX::Error; end

# source://httpx//lib/httpx/errors.rb#49
class HTTPX::ResolveTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/resolver.rb#7
module HTTPX::Resolver
  private

  # source://httpx//lib/httpx/resolver.rb#54
  def cached_lookup(hostname); end

  # source://httpx//lib/httpx/resolver.rb#61
  def cached_lookup_set(hostname, family, entries); end

  # source://httpx//lib/httpx/resolver.rb#115
  def decode_dns_answer(payload); end

  # source://httpx//lib/httpx/resolver.rb#107
  def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver.rb#103
  def generate_id; end

  # source://httpx//lib/httpx/resolver.rb#41
  def ip_resolve(hostname); end

  # do not use directly!
  #
  # source://httpx//lib/httpx/resolver.rb#87
  def lookup(hostname, ttl); end

  # source://httpx//lib/httpx/resolver.rb#37
  def nolookup_resolve(hostname); end

  # source://httpx//lib/httpx/resolver.rb#25
  def resolver_for(resolver_type); end

  # source://httpx//lib/httpx/resolver.rb#46
  def system_resolve(hostname); end

  class << self
    # source://httpx//lib/httpx/resolver.rb#54
    def cached_lookup(hostname); end

    # source://httpx//lib/httpx/resolver.rb#61
    def cached_lookup_set(hostname, family, entries); end

    # source://httpx//lib/httpx/resolver.rb#115
    def decode_dns_answer(payload); end

    # source://httpx//lib/httpx/resolver.rb#107
    def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

    # source://httpx//lib/httpx/resolver.rb#103
    def generate_id; end

    # source://httpx//lib/httpx/resolver.rb#41
    def ip_resolve(hostname); end

    # do not use directly!
    #
    # source://httpx//lib/httpx/resolver.rb#87
    def lookup(hostname, ttl); end

    # source://httpx//lib/httpx/resolver.rb#37
    def nolookup_resolve(hostname); end

    # source://httpx//lib/httpx/resolver.rb#25
    def resolver_for(resolver_type); end

    # source://httpx//lib/httpx/resolver.rb#46
    def system_resolve(hostname); end
  end
end

# source://httpx//lib/httpx/resolver/https.rb#9
class HTTPX::Resolver::HTTPS < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/https.rb#32
  def initialize(_, options); end

  # source://httpx//lib/httpx/resolver/https.rb#45
  def <<(connection); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def call(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#59
  def closed?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def connecting?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#63
  def empty?; end

  # source://httpx//lib/httpx/resolver/https.rb#67
  def resolver_connection; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_io(*args, **_arg1, &block); end

  private

  # source://httpx//lib/httpx/resolver/https.rb#204
  def build_request(hostname); end

  # source://httpx//lib/httpx/resolver/https.rb#223
  def decode_response_body(response); end

  # source://httpx//lib/httpx/resolver/https.rb#125
  def on_promise(_, stream); end

  # source://httpx//lib/httpx/resolver/https.rb#112
  def on_response(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#130
  def parse(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#155
  def parse_addresses(answers, request); end

  # source://httpx//lib/httpx/resolver/https.rb#233
  def reset_hostname(hostname, reset_candidates: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/https.rb#81
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/resolver/https.rb#25
HTTPX::Resolver::HTTPS::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/https.rb#14
module HTTPX::Resolver::HTTPS::DNSExtensions; end

# source://httpx//lib/httpx/resolver/https.rb#23
HTTPX::Resolver::HTTPS::NAMESERVER = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/resolver/multi.rb#7
class HTTPX::Resolver::Multi
  include ::HTTPX::Callbacks

  # source://httpx//lib/httpx/resolver/multi.rb#13
  def initialize(resolver_type, options); end

  # source://httpx//lib/httpx/resolver/multi.rb#36
  def close; end

  # source://httpx//lib/httpx/resolver/multi.rb#28
  def closed?; end

  # source://httpx//lib/httpx/resolver/multi.rb#40
  def connections; end

  # source://httpx//lib/httpx/resolver/multi.rb#44
  def early_resolve(connection); end

  # source://httpx//lib/httpx/resolver/multi.rb#11
  def resolvers; end

  # source://httpx//lib/httpx/resolver/multi.rb#32
  def timeout; end

  private

  # source://httpx//lib/httpx/resolver/multi.rb#70
  def on_resolver_close(resolver); end

  # source://httpx//lib/httpx/resolver/multi.rb#62
  def on_resolver_connection(connection); end

  # source://httpx//lib/httpx/resolver/multi.rb#66
  def on_resolver_error(connection, error); end
end

# source://httpx//lib/httpx/resolver/native.rb#7
class HTTPX::Resolver::Native < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/native.rb#32
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/native.rb#95
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/native.rb#64
  def call; end

  # source://httpx//lib/httpx/resolver/native.rb#52
  def close; end

  # source://httpx//lib/httpx/resolver/native.rb#56
  def closed?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/native.rb#83
  def interests; end

  # source://httpx//lib/httpx/resolver/native.rb#114
  def raise_timeout_error(interval); end

  # source://httpx//lib/httpx/resolver/native.rb#30
  def state; end

  # source://httpx//lib/httpx/resolver/native.rb#106
  def timeout; end

  # source://httpx//lib/httpx/resolver/native.rb#60
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/native.rb#381
  def build_socket; end

  # source://httpx//lib/httpx/resolver/native.rb#120
  def calculate_interests; end

  # source://httpx//lib/httpx/resolver/native.rb#128
  def consume; end

  # source://httpx//lib/httpx/resolver/native.rb#134
  def do_retry(loop_time = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#174
  def dread(wsize = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#224
  def dwrite; end

  # source://httpx//lib/httpx/resolver/native.rb#361
  def encode_dns_query(hostname); end

  # source://httpx//lib/httpx/resolver/native.rb#368
  def generate_candidates(name); end

  # source://httpx//lib/httpx/resolver/native.rb#424
  def handle_error(error); end

  # source://httpx//lib/httpx/resolver/native.rb#242
  def parse(buffer); end

  # source://httpx//lib/httpx/resolver/native.rb#284
  def parse_addresses(addresses); end

  # source://httpx//lib/httpx/resolver/native.rb#435
  def reset_hostname(hostname, connection: T.unsafe(nil), reset_candidates: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#336
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#396
  def transition(nextstate); end
end

# source://httpx//lib/httpx/resolver/native.rb#11
HTTPX::Resolver::Native::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/native.rb#26
HTTPX::Resolver::Native::DNS_PORT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver.rb#8
HTTPX::Resolver::RESOLVE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/resolver.rb#7
class HTTPX::Resolver::Resolver
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/resolver/resolver.rb#33
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/resolver.rb#39
  def close; end

  # source://httpx//lib/httpx/resolver/resolver.rb#41
  def closed?; end

  # source://httpx//lib/httpx/resolver/resolver.rb#49
  def emit_addresses(connection, family, addresses, early_resolve = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#45
  def empty?; end

  # source://httpx//lib/httpx/resolver/resolver.rb#29
  def family; end

  # source://httpx//lib/httpx/resolver/resolver.rb#31
  def pool=(_arg0); end

  private

  # source://httpx//lib/httpx/resolver/resolver.rb#81
  def early_resolve(connection, hostname: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#93
  def emit_resolve_error(connection, hostname = T.unsafe(nil), ex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#75
  def emit_resolved_connection(connection, addresses); end

  # source://httpx//lib/httpx/resolver/resolver.rb#97
  def resolve_error(hostname, ex = T.unsafe(nil)); end

  class << self
    # source://httpx//lib/httpx/resolver/resolver.rb#24
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/resolver.rb#18
HTTPX::Resolver::Resolver::FAMILY_TYPES = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/resolver.rb#13
HTTPX::Resolver::Resolver::RECORD_TYPES = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/system.rb#7
class HTTPX::Resolver::System < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/system.rb#29
  def initialize(options); end

  # source://httpx//lib/httpx/resolver/system.rb#90
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/system.rb#66
  def call; end

  # source://httpx//lib/httpx/resolver/system.rb#54
  def close; end

  # source://httpx//lib/httpx/resolver/system.rb#58
  def closed?; end

  # source://httpx//lib/httpx/resolver/system.rb#50
  def connections; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/system.rb#74
  def interests; end

  # source://httpx//lib/httpx/resolver/system.rb#44
  def resolvers; end

  # source://httpx//lib/httpx/resolver/system.rb#25
  def state; end

  # source://httpx//lib/httpx/resolver/system.rb#80
  def timeout; end

  # source://httpx//lib/httpx/resolver/system.rb#62
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/system.rb#205
  def __addrinfo_resolve(host, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#158
  def async_resolve(connection, hostname, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#114
  def consume; end

  # source://httpx//lib/httpx/resolver/system.rb#141
  def resolve(connection = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/system.rb#97
  def transition(nextstate); end

  class << self
    # source://httpx//lib/httpx/resolver/system.rb#20
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/system.rb#16
HTTPX::Resolver::System::DONE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#17
HTTPX::Resolver::System::ERROR = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#11
HTTPX::Resolver::System::RESOLV_ERRORS = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/response.rb#10
class HTTPX::Response
  include ::HTTPX::Callbacks
  include ::HTTPX::ResponsePatternMatchExtensions
  extend ::Forwardable

  # @return [Response] a new instance of Response
  #
  # source://httpx//lib/httpx/response.rb#28
  def initialize(request, status, version, headers); end

  # source://httpx//lib/httpx/response.rb#42
  def <<(data); end

  # Returns the value of attribute body.
  #
  # source://httpx//lib/httpx/response.rb#14
  def body; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#59
  def bodyless?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#64
  def complete?; end

  # source://httpx//lib/httpx/response.rb#46
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def copy_to(*args, **_arg1, &block); end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#78
  def error; end

  # source://httpx//lib/httpx/response.rb#54
  def finish!; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#50
  def finished?; end

  # source://httpx//lib/httpx/response.rb#94
  def form; end

  # Returns the value of attribute headers.
  #
  # source://httpx//lib/httpx/response.rb#14
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#69
  def inspect; end

  # source://httpx//lib/httpx/response.rb#90
  def json(*args); end

  # source://httpx//lib/httpx/response.rb#38
  def merge_headers(h); end

  # source://httpx//lib/httpx/response.rb#84
  def raise_for_status; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def read(*args, **_arg1, &block); end

  # Returns the value of attribute status.
  #
  # source://httpx//lib/httpx/response.rb#14
  def status; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uri(*args, **_arg1, &block); end

  # Returns the value of attribute version.
  #
  # source://httpx//lib/httpx/response.rb#14
  def version; end

  # source://httpx//lib/httpx/response.rb#98
  def xml; end

  private

  # @raise [Error]
  #
  # source://httpx//lib/httpx/response.rb#104
  def decode(transcoder, *args); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#116
  def no_data?; end
end

# source://httpx//lib/httpx/response.rb#128
class HTTPX::Response::Body
  # @return [Body] a new instance of Body
  #
  # source://httpx//lib/httpx/response.rb#131
  def initialize(response, options); end

  # source://httpx//lib/httpx/response.rb#250
  def ==(other); end

  # source://httpx//lib/httpx/response.rb#176
  def bytesize; end

  # closes/cleans the buffer, resets everything
  #
  # source://httpx//lib/httpx/response.rb#240
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#149
  def closed?; end

  # source://httpx//lib/httpx/response.rb#227
  def copy_to(dest); end

  # source://httpx//lib/httpx/response.rb#180
  def each; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#223
  def empty?; end

  # Returns the value of attribute encoding.
  #
  # source://httpx//lib/httpx/response.rb#129
  def encoding; end

  # source://httpx//lib/httpx/response.rb#195
  def filename; end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#261
  def inspect; end

  # source://httpx//lib/httpx/response.rb#165
  def read(*args); end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#268
  def rewind; end

  # source://httpx//lib/httpx/response.rb#201
  def to_s; end

  # source://httpx//lib/httpx/response.rb#201
  def to_str; end

  # source://httpx//lib/httpx/response.rb#153
  def write(chunk); end

  private

  # source://httpx//lib/httpx/response.rb#307
  def _with_same_buffer_pos; end

  # source://httpx//lib/httpx/response.rb#143
  def initialize_dup(other); end

  # source://httpx//lib/httpx/response.rb#279
  def transition; end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#4
module HTTPX::ResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#5
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#9
  def deconstruct_keys(_keys); end
end

# session may be overridden by certain adapters.
#
# source://httpx//lib/httpx/session.rb#356
HTTPX::S = HTTPX::Session

# source://httpx//lib/httpx/io/ssl.rb#8
class HTTPX::SSL < ::HTTPX::TCP
  # @return [SSL] a new instance of SSL
  #
  # source://httpx//lib/httpx/io/ssl.rb#22
  def initialize(_, _, options); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#61
  def can_verify_peer?; end

  # source://httpx//lib/httpx/io/ssl.rb#84
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#72
  def connected?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#76
  def expired?; end

  # source://httpx//lib/httpx/io/ssl.rb#55
  def protocol; end

  # session_new_cb not implemented under JRuby
  #
  # source://httpx//lib/httpx/io/ssl.rb#47
  def session_new_cb(&pr); end

  # Sets the attribute ssl_session
  #
  # @param value the value to set the attribute ssl_session to.
  #
  # source://httpx//lib/httpx/io/ssl.rb#20
  def ssl_session=(_arg0); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#80
  def ssl_session_expired?; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/ssl.rb#133
  def try_ssl_connect; end

  # source://httpx//lib/httpx/io/ssl.rb#65
  def verify_hostname(host); end

  private

  # source://httpx//lib/httpx/io/ssl.rb#177
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/ssl.rb#165
  def transition(nextstate); end
end

# source://httpx//lib/httpx/io/ssl.rb#11
HTTPX::SSL::TLS_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/selector.rb#5
class HTTPX::Selector
  # @return [Selector] a new instance of Selector
  #
  # source://httpx//lib/httpx/selector.rb#14
  def initialize; end

  # deregisters +io+ from selectables.
  #
  # source://httpx//lib/httpx/selector.rb#19
  def deregister(io); end

  # register +io+.
  #
  # source://httpx//lib/httpx/selector.rb#24
  def register(io); end

  # source://httpx//lib/httpx/selector.rb#126
  def select(interval, &block); end

  private

  # source://httpx//lib/httpx/selector.rb#32
  def select_many(interval, &block); end

  # source://httpx//lib/httpx/selector.rb#100
  def select_one(interval); end
end

# source://httpx//lib/httpx/selector.rb#6
HTTPX::Selector::READABLE = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/selector.rb#7
HTTPX::Selector::WRITABLE = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/session.rb#4
class HTTPX::Session
  include ::HTTPX::Loggable
  include ::HTTPX::Chainable
  include ::HTTPX::Callbacks

  # @return [Session] a new instance of Session
  #
  # source://httpx//lib/httpx/session.rb#11
  def initialize(options = T.unsafe(nil), &blk); end

  # source://httpx//lib/httpx/session.rb#43
  def build_request(verb, uri, options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/session.rb#29
  def close(*args); end

  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#33
  def request(*args, **options); end

  # source://httpx//lib/httpx/session.rb#18
  def wrap; end

  private

  # source://httpx//lib/httpx/session.rb#224
  def _send_requests(requests); end

  # source://httpx//lib/httpx/session.rb#134
  def build_altsvc_connection(existing_connection, connections, alt_origin, origin, alt_params, options); end

  # source://httpx//lib/httpx/session.rb#192
  def build_connection(uri, options); end

  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#169
  def build_requests(*args, options); end

  # source://httpx//lib/httpx/session.rb#92
  def fetch_response(request, _, _); end

  # source://httpx//lib/httpx/session.rb#96
  def find_connection(request, connections, options); end

  # source://httpx//lib/httpx/session.rb#206
  def init_connection(type, uri, options); end

  # source://httpx//lib/httpx/session.rb#87
  def on_promise(_, stream); end

  # source://httpx//lib/httpx/session.rb#83
  def on_response(request, response); end

  # source://httpx//lib/httpx/session.rb#79
  def pool; end

  # source://httpx//lib/httpx/session.rb#240
  def receive_requests(requests, connections); end

  # source://httpx//lib/httpx/session.rb#219
  def send_requests(*requests); end

  # source://httpx//lib/httpx/session.rb#107
  def set_connection_callbacks(connection, connections, options); end

  class << self
    # Returns the value of attribute default_options.
    #
    # source://httpx//lib/httpx/session.rb#284
    def default_options; end

    # @private
    #
    # source://httpx//lib/httpx/session.rb#286
    def inherited(klass); end

    # source://httpx//lib/httpx/session.rb#293
    def plugin(pl, options = T.unsafe(nil), &block); end

    # :nocov:
    #
    # source://httpx//lib/httpx/session.rb#344
    def plugins(pls); end
  end
end

# source://httpx//lib/httpx/session.rb#9
HTTPX::Session::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/errors.rb#47
class HTTPX::SettingsTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/extensions.rb#66
module HTTPX::StringExtensions; end

# source://httpx//lib/httpx/io/tcp.rb#7
class HTTPX::TCP
  include ::HTTPX::Loggable

  # @return [TCP] a new instance of TCP
  #
  # source://httpx//lib/httpx/io/tcp.rb#16
  def initialize(origin, addresses, options); end

  # source://httpx//lib/httpx/io/tcp.rb#47
  def add_addresses(addrs); end

  # Returns the value of attribute addresses.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def addresses; end

  # source://httpx//lib/httpx/io/tcp.rb#177
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#191
  def closed?; end

  # source://httpx//lib/httpx/io/tcp.rb#70
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#187
  def connected?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#195
  def expired?; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/tcp.rb#207
  def inspect; end

  # Returns the value of attribute interests.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def interests; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def ip; end

  # Returns the value of attribute port.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def port; end

  # source://httpx//lib/httpx/io/tcp.rb#66
  def protocol; end

  # source://httpx//lib/httpx/io/tcp.rb#153
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/tcp.rb#43
  def socket; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def state; end

  # source://httpx//lib/httpx/io/tcp.rb#62
  def to_io; end

  # source://httpx//lib/httpx/io/tcp.rb#165
  def write(buffer); end

  private

  # source://httpx//lib/httpx/io/tcp.rb#214
  def build_socket; end

  # source://httpx//lib/httpx/io/tcp.rb#230
  def do_transition(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#235
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#219
  def transition(nextstate); end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/tcp.rb#137
  def try_connect; end
end

# source://httpx//lib/httpx/io/ssl.rb#6
HTTPX::TLSError = OpenSSL::SSL::SSLError

# source://httpx//lib/httpx/errors.rb#10
class HTTPX::TimeoutError < ::HTTPX::Error
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#13
  def initialize(timeout, message); end

  # Returns the value of attribute timeout.
  #
  # source://httpx//lib/httpx/errors.rb#11
  def timeout; end

  # source://httpx//lib/httpx/errors.rb#18
  def to_connection_error; end
end

# source://httpx//lib/httpx/timers.rb#4
class HTTPX::Timers
  # @return [Timers] a new instance of Timers
  #
  # source://httpx//lib/httpx/timers.rb#5
  def initialize; end

  # source://httpx//lib/httpx/timers.rb#9
  def after(interval_in_secs, &blk); end

  # source://httpx//lib/httpx/timers.rb#44
  def cancel; end

  # source://httpx//lib/httpx/timers.rb#33
  def fire(error = T.unsafe(nil)); end

  # source://httpx//lib/httpx/timers.rb#25
  def wait_interval; end
end

# source://httpx//lib/httpx/timers.rb#49
class HTTPX::Timers::Interval
  include ::Comparable

  # @return [Interval] a new instance of Interval
  #
  # source://httpx//lib/httpx/timers.rb#54
  def initialize(interval); end

  # source://httpx//lib/httpx/timers.rb#73
  def <<(callback); end

  # source://httpx//lib/httpx/timers.rb#59
  def <=>(other); end

  # source://httpx//lib/httpx/timers.rb#63
  def ==(other); end

  # source://httpx//lib/httpx/timers.rb#77
  def elapse(elapsed); end

  # Returns the value of attribute interval.
  #
  # source://httpx//lib/httpx/timers.rb#52
  def interval; end

  # source://httpx//lib/httpx/timers.rb#69
  def to_f; end
end

# source://httpx//lib/httpx/errors.rb#25
class HTTPX::TotalTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/transcoder.rb#4
module HTTPX::Transcoder
  private

  # source://httpx//lib/httpx/transcoder.rb#9
  def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

  # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
  #
  # source://httpx//lib/httpx/transcoder.rb#30
  def normalize_query(params, name, v, depth); end

  # source://httpx//lib/httpx/transcoder.rb#73
  def params_hash_has_key?(hash, key); end

  class << self
    # source://httpx//lib/httpx/transcoder.rb#9
    def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

    # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
    #
    # @raise [Error]
    #
    # source://httpx//lib/httpx/transcoder.rb#30
    def normalize_query(params, name, v, depth); end

    # @return [Boolean]
    #
    # source://httpx//lib/httpx/transcoder.rb#73
    def params_hash_has_key?(hash, key); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#6
module HTTPX::Transcoder::Body
  private

  # source://httpx//lib/httpx/transcoder/body.rb#54
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/body.rb#54
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#11
class HTTPX::Transcoder::Body::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/body.rb#17
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/body.rb#21
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/body.rb#37
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  private

  # source://httpx//lib/httpx/transcoder/body.rb#47
  def method_missing(meth, *args, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/body.rb#43
  def respond_to_missing?(meth, *args); end
end

# source://httpx//lib/httpx/transcoder/body.rb#7
class HTTPX::Transcoder::Body::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/chunker.rb#6
module HTTPX::Transcoder::Chunker
  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#111
  def encode(chunks); end

  class << self
    # source://httpx//lib/httpx/transcoder/chunker.rb#111
    def encode(chunks); end
  end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#9
HTTPX::Transcoder::Chunker::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/chunker.rb#32
class HTTPX::Transcoder::Chunker::Decoder
  extend ::Forwardable

  # @return [Decoder] a new instance of Decoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#41
  def initialize(buffer, trailers = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/chunker.rb#53
  def each; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#98
  def finished?; end

  # source://httpx//lib/httpx/transcoder/chunker.rb#49
  def to_s; end

  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#104
  def nextstate(state); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#11
class HTTPX::Transcoder::Chunker::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#14
  def initialize(body); end

  # @yield ["0#{CRLF}"]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#18
  def each; end

  private

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#27
  def respond_to_missing?(meth, *args); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#7
class HTTPX::Transcoder::Chunker::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/form.rb#7
module HTTPX::Transcoder::Form
  private

  # source://httpx//lib/httpx/transcoder/form.rb#50
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/form.rb#46
  def encode(form); end

  class << self
    # @raise [HTTPX::Error]
    #
    # source://httpx//lib/httpx/transcoder/form.rb#50
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/form.rb#46
    def encode(form); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#36
module HTTPX::Transcoder::Form::Decoder
  private

  # source://httpx//lib/httpx/transcoder/form.rb#39
  def call(response, *_arg1); end

  class << self
    # source://httpx//lib/httpx/transcoder/form.rb#39
    def call(response, *_arg1); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#12
class HTTPX::Transcoder::Form::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/form.rb#21
  def initialize(form); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/form.rb#31
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/form.rb#10
HTTPX::Transcoder::Form::PARAM_DEPTH_LIMIT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/transcoder/json.rb#6
module HTTPX::Transcoder::JSON
  private

  # source://httpx//lib/httpx/transcoder/json.rb#34
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/json.rb#30
  def encode(json); end

  # source://httpx//lib/httpx/transcoder/json.rb#55
  def json_dump(*args); end

  # source://httpx//lib/httpx/transcoder/json.rb#54
  def json_load(*args); end

  class << self
    # @raise [HTTPX::Error]
    #
    # source://httpx//lib/httpx/transcoder/json.rb#34
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/json.rb#30
    def encode(json); end

    # source://httpx//lib/httpx/transcoder/json.rb#55
    def json_dump(*args); end

    # source://httpx//lib/httpx/transcoder/json.rb#54
    def json_load(*args); end
  end
end

# source://httpx//lib/httpx/transcoder/json.rb#13
class HTTPX::Transcoder::JSON::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/json.rb#20
  def initialize(json); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/json.rb#25
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/json.rb#7
HTTPX::Transcoder::JSON::JSON_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/xml.rb#8
module HTTPX::Transcoder::Xml
  private

  # source://httpx//lib/httpx/transcoder/xml.rb#41
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/xml.rb#34
  def encode(xml); end

  class << self
    # source://httpx//lib/httpx/transcoder/xml.rb#41
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/xml.rb#34
    def encode(xml); end
  end
end

# source://httpx//lib/httpx/transcoder/xml.rb#15
class HTTPX::Transcoder::Xml::Encoder
  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/xml.rb#16
  def initialize(xml); end

  # source://httpx//lib/httpx/transcoder/xml.rb#25
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/xml.rb#20
  def content_type; end

  # source://httpx//lib/httpx/transcoder/xml.rb#29
  def to_s; end
end

# source://httpx//lib/httpx/transcoder/xml.rb#13
HTTPX::Transcoder::Xml::MIME_TYPES = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/io/udp.rb#6
class HTTPX::UDP
  include ::HTTPX::Loggable

  # @return [UDP] a new instance of UDP
  #
  # source://httpx//lib/httpx/io/udp.rb#9
  def initialize(ip, port, options); end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/udp.rb#35
  def close; end

  # source://httpx//lib/httpx/io/udp.rb#20
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/udp.rb#22
  def connected?; end

  # source://httpx//lib/httpx/io/udp.rb#76
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/udp.rb#16
  def to_io; end

  # In JRuby, sendmsg_nonblock is not implemented
  #
  # source://httpx//lib/httpx/io/udp.rb#65
  def write(buffer); end
end

# source://httpx//lib/httpx/io/unix.rb#4
class HTTPX::UNIX < ::HTTPX::TCP
  # @return [UNIX] a new instance of UNIX
  #
  # source://httpx//lib/httpx/io/unix.rb#11
  def initialize(origin, addresses, options); end

  # source://httpx//lib/httpx/io/unix.rb#42
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/unix.rb#59
  def expired?; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#7
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/unix.rb#64
  def inspect; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#7
  def path; end

  private

  # source://httpx//lib/httpx/io/unix.rb#71
  def build_socket; end
end

# source://httpx//lib/httpx/extensions.rb#160
module HTTPX::URIExtensions; end

# source://httpx//lib/httpx/errors.rb#6
class HTTPX::UnsupportedSchemeError < ::HTTPX::Error; end

# source://httpx//lib/httpx/utils.rb#4
module HTTPX::Utils
  private

  # source://httpx//lib/httpx/utils.rb#19
  def elapsed_time(monotonic_timestamp); end

  # source://httpx//lib/httpx/utils.rb#34
  def get_filename(header, _prefix_regex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/utils.rb#15
  def now; end

  # The value of this field can be either an HTTP-date or a number of
  # seconds to delay after the response is received.
  #
  # source://httpx//lib/httpx/utils.rb#25
  def parse_retry_after(retry_after); end

  # source://httpx//lib/httpx/utils.rb#68
  def to_uri(uri); end

  class << self
    # source://httpx//lib/httpx/utils.rb#19
    def elapsed_time(monotonic_timestamp); end

    # source://httpx//lib/httpx/utils.rb#34
    def get_filename(header, _prefix_regex = T.unsafe(nil)); end

    # source://httpx//lib/httpx/utils.rb#15
    def now; end

    # The value of this field can be either an HTTP-date or a number of
    # seconds to delay after the response is received.
    #
    # source://httpx//lib/httpx/utils.rb#25
    def parse_retry_after(retry_after); end

    # source://httpx//lib/httpx/utils.rb#68
    def to_uri(uri); end
  end
end

# source://httpx//lib/httpx/utils.rb#11
HTTPX::Utils::FILENAME_EXTENSION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#10
HTTPX::Utils::FILENAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#8
HTTPX::Utils::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#66
HTTPX::Utils::URIParser = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# source://httpx//lib/httpx/utils.rb#9
HTTPX::Utils::VALUE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/version.rb#4
HTTPX::VERSION = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/errors.rb#45
class HTTPX::WriteTimeoutError < ::HTTPX::RequestTimeoutError; end
