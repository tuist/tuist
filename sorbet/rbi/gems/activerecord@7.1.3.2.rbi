# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `activerecord` gem.
# Please instead update this file by running `bin/tapioca gem activerecord`.

# :include: activerecord/README.rdoc
#
# source://activerecord//lib/active_record/gem_version.rb#3
module ActiveRecord
  include ::ActiveSupport::Deprecation::DeprecatedConstantAccessor
  extend ::ActiveSupport::Autoload

  class << self
    # source://activerecord//lib/active_record.rb#342
    def action_on_strict_loading_violation; end

    # source://activerecord//lib/active_record.rb#342
    def action_on_strict_loading_violation=(_arg0); end

    # source://activerecord//lib/active_record.rb#422
    def allow_deprecated_singular_associations_name; end

    # source://activerecord//lib/active_record.rb#422
    def allow_deprecated_singular_associations_name=(_arg0); end

    # source://activerecord//lib/active_record.rb#335
    def application_record_class; end

    # source://activerecord//lib/active_record.rb#335
    def application_record_class=(_arg0); end

    # source://activerecord//lib/active_record.rb#263
    def async_query_executor; end

    # source://activerecord//lib/active_record.rb#263
    def async_query_executor=(_arg0); end

    # source://activerecord//lib/active_record.rb#317
    def before_committed_on_all_records; end

    # source://activerecord//lib/active_record.rb#317
    def before_committed_on_all_records=(_arg0); end

    # source://activerecord//lib/active_record.rb#314
    def belongs_to_required_validates_foreign_key; end

    # source://activerecord//lib/active_record.rb#314
    def belongs_to_required_validates_foreign_key=(_arg0); end

    # source://activerecord//lib/active_record.rb#323
    def commit_transaction_on_non_local_return; end

    # source://activerecord//lib/active_record.rb#323
    def commit_transaction_on_non_local_return=(_arg0); end

    # source://activerecord//lib/active_record.rb#209
    def db_warnings_action; end

    # source://activerecord//lib/active_record.rb#211
    def db_warnings_action=(action); end

    # source://activerecord//lib/active_record.rb#236
    def db_warnings_ignore; end

    # source://activerecord//lib/active_record.rb#236
    def db_warnings_ignore=(_arg0); end

    # source://activerecord//lib/active_record.rb#192
    def default_timezone; end

    # Determines whether to use Time.utc (using :utc) or Time.local (using :local) when pulling
    # dates and times from the database. This is set to :utc by default.
    #
    # source://activerecord//lib/active_record.rb#196
    def default_timezone=(default_timezone); end

    # source://activerecord//lib/active_record/deprecator.rb#4
    def deprecator; end

    # source://activerecord//lib/active_record.rb#177
    def disable_prepared_statements; end

    # source://activerecord//lib/active_record.rb#177
    def disable_prepared_statements=(_arg0); end

    # Explicitly closes all database connections in all pools.
    #
    # source://activerecord//lib/active_record.rb#476
    def disconnect_all!; end

    # source://activerecord//lib/active_record.rb#382
    def dump_schema_after_migration; end

    # source://activerecord//lib/active_record.rb#382
    def dump_schema_after_migration=(_arg0); end

    # source://activerecord//lib/active_record.rb#392
    def dump_schemas; end

    # source://activerecord//lib/active_record.rb#392
    def dump_schemas=(_arg0); end

    # source://activerecord//lib/active_record.rb#465
    def eager_load!; end

    # source://activerecord//lib/active_record.rb#361
    def error_on_ignored_order; end

    # source://activerecord//lib/active_record.rb#361
    def error_on_ignored_order=(_arg0); end

    # Returns the currently loaded version of Active Record as a +Gem::Version+.
    #
    # source://activerecord//lib/active_record/gem_version.rb#5
    def gem_version; end

    # source://activerecord//lib/active_record.rb#454
    def generate_secure_token_on; end

    # source://activerecord//lib/active_record.rb#454
    def generate_secure_token_on=(_arg0); end

    # source://activerecord//lib/active_record.rb#286
    def global_executor_concurrency; end

    # Set the +global_executor_concurrency+. This configuration value can only be used
    # with the global thread pool async query executor.
    #
    # source://activerecord//lib/active_record.rb#278
    def global_executor_concurrency=(global_executor_concurrency); end

    # source://activerecord//lib/active_record.rb#266
    def global_thread_pool_async_query_executor; end

    # source://activerecord//lib/active_record.rb#290
    def index_nested_attribute_errors; end

    # source://activerecord//lib/active_record.rb#290
    def index_nested_attribute_errors=(_arg0); end

    # source://activerecord//lib/active_record.rb#183
    def lazily_load_schema_cache; end

    # source://activerecord//lib/active_record.rb#183
    def lazily_load_schema_cache=(_arg0); end

    # @raise [ArgumentError]
    #
    # source://activerecord//lib/active_record.rb#245
    def legacy_connection_handling=(_); end

    # source://activerecord//lib/active_record.rb#308
    def maintain_test_schema; end

    # source://activerecord//lib/active_record.rb#308
    def maintain_test_schema=(_arg0); end

    # source://activerecord//lib/active_record.rb#457
    def marshalling_format_version; end

    # source://activerecord//lib/active_record.rb#461
    def marshalling_format_version=(value); end

    # source://activerecord//lib/active_record.rb#373
    def migration_strategy; end

    # source://activerecord//lib/active_record.rb#373
    def migration_strategy=(_arg0); end

    # source://activerecord//lib/active_record.rb#425
    def query_transformers; end

    # source://activerecord//lib/active_record.rb#425
    def query_transformers=(_arg0); end

    # source://activerecord//lib/active_record.rb#305
    def queues; end

    # source://activerecord//lib/active_record.rb#305
    def queues=(_arg0); end

    # source://activerecord//lib/active_record.rb#440
    def raise_int_wider_than_64bit; end

    # source://activerecord//lib/active_record.rb#440
    def raise_int_wider_than_64bit=(_arg0); end

    # source://activerecord//lib/active_record.rb#311
    def raise_on_assign_to_attr_readonly; end

    # source://activerecord//lib/active_record.rb#311
    def raise_on_assign_to_attr_readonly=(_arg0); end

    # source://activerecord//lib/active_record.rb#242
    def reading_role; end

    # source://activerecord//lib/active_record.rb#242
    def reading_role=(_arg0); end

    # source://activerecord//lib/active_record.rb#320
    def run_after_transaction_callbacks_in_order_defined; end

    # source://activerecord//lib/active_record.rb#320
    def run_after_transaction_callbacks_in_order_defined=(_arg0); end

    # source://activerecord//lib/active_record.rb#189
    def schema_cache_ignored_tables; end

    # source://activerecord//lib/active_record.rb#189
    def schema_cache_ignored_tables=(_arg0); end

    # source://activerecord//lib/active_record.rb#353
    def schema_format; end

    # source://activerecord//lib/active_record.rb#353
    def schema_format=(_arg0); end

    # source://activerecord//lib/active_record.rb#395
    def suppress_multiple_database_warning; end

    # source://activerecord//lib/active_record.rb#402
    def suppress_multiple_database_warning=(value); end

    # source://activerecord//lib/active_record.rb#367
    def timestamped_migrations; end

    # source://activerecord//lib/active_record.rb#367
    def timestamped_migrations=(_arg0); end

    # source://activerecord//lib/active_record.rb#432
    def use_yaml_unsafe_load; end

    # source://activerecord//lib/active_record.rb#432
    def use_yaml_unsafe_load=(_arg0); end

    # source://activerecord//lib/active_record.rb#298
    def verbose_query_logs; end

    # source://activerecord//lib/active_record.rb#298
    def verbose_query_logs=(_arg0); end

    # source://activerecord//lib/active_record.rb#415
    def verify_foreign_keys_for_fixtures; end

    # source://activerecord//lib/active_record.rb#415
    def verify_foreign_keys_for_fixtures=(_arg0); end

    # Returns the currently loaded version of Active Record as a +Gem::Version+.
    #
    # source://activerecord//lib/active_record/version.rb#7
    def version; end

    # source://activerecord//lib/active_record.rb#332
    def warn_on_records_fetched_greater_than; end

    # source://activerecord//lib/active_record.rb#332
    def warn_on_records_fetched_greater_than=(_arg0); end

    # source://activerecord//lib/active_record.rb#239
    def writing_role; end

    # source://activerecord//lib/active_record.rb#239
    def writing_role=(_arg0); end

    # source://activerecord//lib/active_record.rb#447
    def yaml_column_permitted_classes; end

    # source://activerecord//lib/active_record.rb#447
    def yaml_column_permitted_classes=(_arg0); end
  end
end

# = Active Record Errors
#
# Generic Active Record exception class.
#
# source://activerecord//lib/active_record/errors.rb#7
class ActiveRecord::ActiveRecordError < ::StandardError; end

# Superclass for all errors raised from an Active Record adapter.
#
# source://activerecord//lib/active_record/errors.rb#59
class ActiveRecord::AdapterError < ::ActiveRecord::ActiveRecordError
  # @return [AdapterError] a new instance of AdapterError
  #
  # source://activerecord//lib/active_record/errors.rb#60
  def initialize(message = T.unsafe(nil), connection_pool: T.unsafe(nil)); end

  # Returns the value of attribute connection_pool.
  #
  # source://activerecord//lib/active_record/errors.rb#65
  def connection_pool; end
end

# Raised when Active Record cannot find database adapter specified in
# +config/database.yml+ or programmatically.
#
# source://activerecord//lib/active_record/errors.rb#55
class ActiveRecord::AdapterNotFound < ::ActiveRecord::ActiveRecordError; end

# Raised when adapter not specified on connection (or configuration file
# +config/database.yml+ misses adapter field).
#
# source://activerecord//lib/active_record/errors.rb#46
class ActiveRecord::AdapterNotSpecified < ::ActiveRecord::ActiveRecordError; end

# AdapterTimeout will be raised when database clients times out while waiting from the server.
#
# source://activerecord//lib/active_record/errors.rb#550
class ActiveRecord::AdapterTimeout < ::ActiveRecord::QueryAborted; end

# See ActiveRecord::Aggregations::ClassMethods for documentation
#
# source://activerecord//lib/active_record/aggregations.rb#5
module ActiveRecord::Aggregations
  # source://activerecord//lib/active_record/aggregations.rb#11
  def reload(*_arg0); end

  private

  # source://activerecord//lib/active_record/aggregations.rb#17
  def clear_aggregation_cache; end

  # source://activerecord//lib/active_record/aggregations.rb#21
  def init_internals; end

  # source://activerecord//lib/active_record/aggregations.rb#6
  def initialize_dup(*_arg0); end
end

# = Active Record \Aggregations
#
# Active Record implements aggregation through a macro-like class method called #composed_of
# for representing attributes as value objects. It expresses relationships like "Account [is]
# composed of Money [among other things]" or "Person [is] composed of [an] address". Each call
# to the macro adds a description of how the value objects are created from the attributes of
# the entity object (when the entity is initialized either as a new object or from finding an
# existing object) and how it can be turned back into attributes (when the entity is saved to
# the database).
#
#   class Customer < ActiveRecord::Base
#     composed_of :balance, class_name: "Money", mapping: { balance: :amount }
#     composed_of :address, mapping: { address_street: :street, address_city: :city }
#   end
#
# The customer class now has the following methods to manipulate the value objects:
# * <tt>Customer#balance, Customer#balance=(money)</tt>
# * <tt>Customer#address, Customer#address=(address)</tt>
#
# These methods will operate with value objects like the ones described below:
#
#  class Money
#    include Comparable
#    attr_reader :amount, :currency
#    EXCHANGE_RATES = { "USD_TO_DKK" => 6 }
#
#    def initialize(amount, currency = "USD")
#      @amount, @currency = amount, currency
#    end
#
#    def exchange_to(other_currency)
#      exchanged_amount = (amount * EXCHANGE_RATES["#{currency}_TO_#{other_currency}"]).floor
#      Money.new(exchanged_amount, other_currency)
#    end
#
#    def ==(other_money)
#      amount == other_money.amount && currency == other_money.currency
#    end
#
#    def <=>(other_money)
#      if currency == other_money.currency
#        amount <=> other_money.amount
#      else
#        amount <=> other_money.exchange_to(currency).amount
#      end
#    end
#  end
#
#  class Address
#    attr_reader :street, :city
#    def initialize(street, city)
#      @street, @city = street, city
#    end
#
#    def close_to?(other_address)
#      city == other_address.city
#    end
#
#    def ==(other_address)
#      city == other_address.city && street == other_address.street
#    end
#  end
#
# Now it's possible to access attributes from the database through the value objects instead. If
# you choose to name the composition the same as the attribute's name, it will be the only way to
# access that attribute. That's the case with our +balance+ attribute. You interact with the value
# objects just like you would with any other attribute:
#
#   customer.balance = Money.new(20)     # sets the Money value object and the attribute
#   customer.balance                     # => Money value object
#   customer.balance.exchange_to("DKK")  # => Money.new(120, "DKK")
#   customer.balance > Money.new(10)     # => true
#   customer.balance == Money.new(20)    # => true
#   customer.balance < Money.new(5)      # => false
#
# Value objects can also be composed of multiple attributes, such as the case of Address. The order
# of the mappings will determine the order of the parameters.
#
#   customer.address_street = "Hyancintvej"
#   customer.address_city   = "Copenhagen"
#   customer.address        # => Address.new("Hyancintvej", "Copenhagen")
#
#   customer.address = Address.new("May Street", "Chicago")
#   customer.address_street # => "May Street"
#   customer.address_city   # => "Chicago"
#
# == Writing value objects
#
# Value objects are immutable and interchangeable objects that represent a given value, such as
# a Money object representing $5. Two Money objects both representing $5 should be equal (through
# methods such as <tt>==</tt> and <tt><=></tt> from Comparable if ranking makes sense). This is
# unlike entity objects where equality is determined by identity. An entity class such as Customer can
# easily have two different objects that both have an address on Hyancintvej. Entity identity is
# determined by object or relational unique identifiers (such as primary keys). Normal
# ActiveRecord::Base classes are entity objects.
#
# It's also important to treat the value objects as immutable. Don't allow the Money object to have
# its amount changed after creation. Create a new Money object with the new value instead. The
# <tt>Money#exchange_to</tt> method is an example of this. It returns a new value object instead of changing
# its own values. Active Record won't persist value objects that have been changed through means
# other than the writer method.
#
# The immutable requirement is enforced by Active Record by freezing any object assigned as a value
# object. Attempting to change it afterwards will result in a +RuntimeError+.
#
# Read more about value objects on http://c2.com/cgi/wiki?ValueObject and on the dangers of not
# keeping value objects immutable on http://c2.com/cgi/wiki?ValueObjectsShouldBeImmutable
#
# == Custom constructors and converters
#
# By default value objects are initialized by calling the <tt>new</tt> constructor of the value
# class passing each of the mapped attributes, in the order specified by the <tt>:mapping</tt>
# option, as arguments. If the value class doesn't support this convention then #composed_of allows
# a custom constructor to be specified.
#
# When a new value is assigned to the value object, the default assumption is that the new value
# is an instance of the value class. Specifying a custom converter allows the new value to be automatically
# converted to an instance of value class if necessary.
#
# For example, the +NetworkResource+ model has +network_address+ and +cidr_range+ attributes that should be
# aggregated using the +NetAddr::CIDR+ value class (https://www.rubydoc.info/gems/netaddr/1.5.0/NetAddr/CIDR).
# The constructor for the value class is called +create+ and it expects a CIDR address string as a parameter.
# New values can be assigned to the value object using either another +NetAddr::CIDR+ object, a string
# or an array. The <tt>:constructor</tt> and <tt>:converter</tt> options can be used to meet
# these requirements:
#
#   class NetworkResource < ActiveRecord::Base
#     composed_of :cidr,
#                 class_name: 'NetAddr::CIDR',
#                 mapping: { network_address: :network, cidr_range: :bits },
#                 allow_nil: true,
#                 constructor: Proc.new { |network_address, cidr_range| NetAddr::CIDR.create("#{network_address}/#{cidr_range}") },
#                 converter: Proc.new { |value| NetAddr::CIDR.create(value.is_a?(Array) ? value.join('/') : value) }
#   end
#
#   # This calls the :constructor
#   network_resource = NetworkResource.new(network_address: '192.168.0.1', cidr_range: 24)
#
#   # These assignments will both use the :converter
#   network_resource.cidr = [ '192.168.2.1', 8 ]
#   network_resource.cidr = '192.168.0.1/24'
#
#   # This assignment won't use the :converter as the value is already an instance of the value class
#   network_resource.cidr = NetAddr::CIDR.create('192.168.2.1/8')
#
#   # Saving and then reloading will use the :constructor on reload
#   network_resource.save
#   network_resource.reload
#
# == Finding records by a value object
#
# Once a #composed_of relationship is specified for a model, records can be loaded from the database
# by specifying an instance of the value object in the conditions hash. The following example
# finds all customers with +address_street+ equal to "May Street" and +address_city+ equal to "Chicago":
#
#   Customer.where(address: Address.new("May Street", "Chicago"))
#
# source://activerecord//lib/active_record/aggregations.rb#183
module ActiveRecord::Aggregations::ClassMethods
  # Adds reader and writer methods for manipulating a value object:
  # <tt>composed_of :address</tt> adds <tt>address</tt> and <tt>address=(new_address)</tt> methods.
  #
  # Options are:
  # * <tt>:class_name</tt> - Specifies the class name of the association. Use it only if that name
  #   can't be inferred from the part id. So <tt>composed_of :address</tt> will by default be linked
  #   to the Address class, but if the real class name is +CompanyAddress+, you'll have to specify it
  #   with this option.
  # * <tt>:mapping</tt> - Specifies the mapping of entity attributes to attributes of the value
  #   object. Each mapping is represented as a key-value pair where the key is the name of the
  #   entity attribute and the value is the name of the attribute in the value object. The
  #   order in which mappings are defined determines the order in which attributes are sent to the
  #   value class constructor. The mapping can be written as a hash or as an array of pairs.
  # * <tt>:allow_nil</tt> - Specifies that the value object will not be instantiated when all mapped
  #   attributes are +nil+. Setting the value object to +nil+ has the effect of writing +nil+ to all
  #   mapped attributes.
  #   This defaults to +false+.
  # * <tt>:constructor</tt> - A symbol specifying the name of the constructor method or a Proc that
  #   is called to initialize the value object. The constructor is passed all of the mapped attributes,
  #   in the order that they are defined in the <tt>:mapping option</tt>, as arguments and uses them
  #   to instantiate a <tt>:class_name</tt> object.
  #   The default is <tt>:new</tt>.
  # * <tt>:converter</tt> - A symbol specifying the name of a class method of <tt>:class_name</tt>
  #   or a Proc that is called when a new value is assigned to the value object. The converter is
  #   passed the single value that is used in the assignment and is only called if the new value is
  #   not an instance of <tt>:class_name</tt>. If <tt>:allow_nil</tt> is set to true, the converter
  #   can return +nil+ to skip the assignment.
  #
  # Option examples:
  #   composed_of :temperature, mapping: { reading: :celsius }
  #   composed_of :balance, class_name: "Money", mapping: { balance: :amount }
  #   composed_of :address, mapping: { address_street: :street, address_city: :city }
  #   composed_of :address, mapping: [ %w(address_street street), %w(address_city city) ]
  #   composed_of :gps_location
  #   composed_of :gps_location, allow_nil: true
  #   composed_of :ip_address,
  #               class_name: 'IPAddr',
  #               mapping: { ip: :to_i },
  #               constructor: Proc.new { |ip| IPAddr.new(ip, Socket::AF_INET) },
  #               converter: Proc.new { |ip| ip.is_a?(Integer) ? IPAddr.new(ip, Socket::AF_INET) : IPAddr.new(ip.to_s) }
  #
  # source://activerecord//lib/active_record/aggregations.rb#225
  def composed_of(part_id, options = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/aggregations.rb#248
  def reader_method(name, class_name, mapping, allow_nil, constructor); end

  # source://activerecord//lib/active_record/aggregations.rb#261
  def writer_method(name, class_name, mapping, allow_nil, converter); end
end

# source://activerecord//lib/active_record/associations.rb#203
class ActiveRecord::AmbiguousSourceReflectionForThroughAssociation < ::ActiveRecord::ActiveRecordError
  # @return [AmbiguousSourceReflectionForThroughAssociation] a new instance of AmbiguousSourceReflectionForThroughAssociation
  #
  # source://activerecord//lib/active_record/associations.rb#204
  def initialize(klass, macro, association_name, options, possible_sources); end
end

# source://activerecord//lib/active_record/associations.rb#4
class ActiveRecord::AssociationNotFoundError < ::ActiveRecord::ConfigurationError
  include ::DidYouMean::Correctable

  # @return [AssociationNotFoundError] a new instance of AssociationNotFoundError
  #
  # source://activerecord//lib/active_record/associations.rb#7
  def initialize(record = T.unsafe(nil), association_name = T.unsafe(nil)); end

  # Returns the value of attribute association_name.
  #
  # source://activerecord//lib/active_record/associations.rb#5
  def association_name; end

  # source://activerecord//lib/active_record/associations.rb#20
  def corrections; end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/associations.rb#5
  def record; end
end

# source://activerecord//lib/active_record/association_relation.rb#4
class ActiveRecord::AssociationRelation < ::ActiveRecord::Relation
  # @return [AssociationRelation] a new instance of AssociationRelation
  #
  # source://activerecord//lib/active_record/association_relation.rb#5
  def initialize(klass, association, **_arg2); end

  # source://activerecord//lib/active_record/association_relation.rb#14
  def ==(other); end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def insert(attributes, **kwargs); end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def insert!(attributes, **kwargs); end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def insert_all(attributes, **kwargs); end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def insert_all!(attributes, **kwargs); end

  # source://activerecord//lib/active_record/association_relation.rb#10
  def proxy_association; end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def upsert(attributes, **kwargs); end

  # source://activerecord//lib/active_record/association_relation.rb#20
  def upsert_all(attributes, **kwargs); end

  private

  # source://activerecord//lib/active_record/association_relation.rb#35
  def _create(attributes, &block); end

  # source://activerecord//lib/active_record/association_relation.rb#39
  def _create!(attributes, &block); end

  # source://activerecord//lib/active_record/association_relation.rb#31
  def _new(attributes, &block); end

  # source://activerecord//lib/active_record/association_relation.rb#43
  def exec_queries; end
end

# Raised when an object assigned to an association has an incorrect type.
#
#   class Ticket < ActiveRecord::Base
#     has_many :patches
#   end
#
#   class Patch < ActiveRecord::Base
#     belongs_to :ticket
#   end
#
#   # Comments are not patches, this assignment raises AssociationTypeMismatch.
#   @ticket.patches << Comment.new(content: "Please attach tests to your patch.")
#
# source://activerecord//lib/active_record/errors.rb#37
class ActiveRecord::AssociationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

# See ActiveRecord::Associations::ClassMethods for documentation.
#
# source://activerecord//lib/active_record/associations.rb#267
module ActiveRecord::Associations
  extend ::ActiveSupport::Autoload
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Associations::ClassMethods

  # Returns the association instance for the given name, instantiating it if it doesn't already exist
  #
  # source://activerecord//lib/active_record/associations.rb#313
  def association(name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations.rb#327
  def association_cached?(name); end

  private

  # Returns the specified association instance if it exists, +nil+ otherwise.
  #
  # source://activerecord//lib/active_record/associations.rb#343
  def association_instance_get(name); end

  # Set the specified association instance.
  #
  # source://activerecord//lib/active_record/associations.rb#348
  def association_instance_set(name, association); end

  # source://activerecord//lib/active_record/associations.rb#337
  def init_internals; end

  # source://activerecord//lib/active_record/associations.rb#331
  def initialize_dup(*_arg0); end

  class << self
    # source://activerecord//lib/active_record/associations.rb#306
    def eager_load!; end
  end
end

# Keeps track of table aliases for ActiveRecord::Associations::JoinDependency
#
# source://activerecord//lib/active_record/associations/alias_tracker.rb#8
class ActiveRecord::Associations::AliasTracker
  # table_joins is an array of arel joins which might conflict with the aliases we assign here
  #
  # @return [AliasTracker] a new instance of AliasTracker
  #
  # source://activerecord//lib/active_record/associations/alias_tracker.rb#49
  def initialize(connection, aliases); end

  # source://activerecord//lib/active_record/associations/alias_tracker.rb#54
  def aliased_table_for(arel_table, table_name = T.unsafe(nil)); end

  # Returns the value of attribute aliases.
  #
  # source://activerecord//lib/active_record/associations/alias_tracker.rb#76
  def aliases; end

  private

  # source://activerecord//lib/active_record/associations/alias_tracker.rb#79
  def truncate(name); end

  class << self
    # source://activerecord//lib/active_record/associations/alias_tracker.rb#9
    def create(connection, initial_table, joins, aliases = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/associations/alias_tracker.rb#26
    def initial_count_for(connection, name, table_joins); end
  end
end

# = Active Record Associations
#
# This is the root class of all associations ('+ Foo' signifies an included module Foo):
#
#   Association
#     SingularAssociation
#       HasOneAssociation + ForeignAssociation
#         HasOneThroughAssociation + ThroughAssociation
#       BelongsToAssociation
#         BelongsToPolymorphicAssociation
#     CollectionAssociation
#       HasManyAssociation + ForeignAssociation
#         HasManyThroughAssociation + ThroughAssociation
#
# Associations in Active Record are middlemen between the object that
# holds the association, known as the <tt>owner</tt>, and the associated
# result set, known as the <tt>target</tt>. Association metadata is available in
# <tt>reflection</tt>, which is an instance of +ActiveRecord::Reflection::AssociationReflection+.
#
# For example, given
#
#   class Blog < ActiveRecord::Base
#     has_many :posts
#   end
#
#   blog = Blog.first
#
# The association of <tt>blog.posts</tt> has the object +blog+ as its
# <tt>owner</tt>, the collection of its posts as <tt>target</tt>, and
# the <tt>reflection</tt> object represents a <tt>:has_many</tt> macro.
#
# source://activerecord//lib/active_record/associations/association.rb#35
class ActiveRecord::Associations::Association
  # @return [Association] a new instance of Association
  #
  # source://activerecord//lib/active_record/associations/association.rb#41
  def initialize(owner, reflection); end

  # source://activerecord//lib/active_record/associations/association.rb#206
  def create(attributes = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/association.rb#210
  def create!(attributes = T.unsafe(nil), &block); end

  # Returns the value of attribute disable_joins.
  #
  # source://activerecord//lib/active_record/associations/association.rb#37
  def disable_joins; end

  # source://activerecord//lib/active_record/associations/association.rb#155
  def extensions; end

  # source://activerecord//lib/active_record/associations/association.rb#196
  def initialize_attributes(record, except_from_scope_attributes = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/association.rb#139
  def inversed_from(record); end

  # source://activerecord//lib/active_record/associations/association.rb#143
  def inversed_from_queries(record); end

  # Returns the class of the target. belongs_to polymorphic overrides this to look at the
  # polymorphic_type field on the owner.
  #
  # source://activerecord//lib/active_record/associations/association.rb#151
  def klass; end

  # Loads the \target if needed and returns it.
  #
  # This method is abstract in the sense that it relies on +find_target+,
  # which is expected to be provided by descendants.
  #
  # If the \target is already \loaded it is just returned. Thus, you can call
  # +load_target+ unconditionally to get the \target.
  #
  # ActiveRecord::RecordNotFound is rescued within the method, and it is
  # not reraised. The proxy is \reset and +nil+ is the return value.
  #
  # source://activerecord//lib/active_record/associations/association.rb#175
  def load_target; end

  # Asserts the \target has been loaded setting the \loaded flag to +true+.
  #
  # source://activerecord//lib/active_record/associations/association.rb#80
  def loaded!; end

  # Has the \target been already \loaded?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#75
  def loaded?; end

  # We can't dump @reflection and @through_reflection since it contains the scope proc
  #
  # source://activerecord//lib/active_record/associations/association.rb#185
  def marshal_dump; end

  # source://activerecord//lib/active_record/associations/association.rb#190
  def marshal_load(data); end

  # source://activerecord//lib/active_record/associations/association.rb#39
  def options(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/association.rb#36
  def owner; end

  # source://activerecord//lib/active_record/associations/association.rb#36
  def owner=(_arg0); end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations/association.rb#37
  def reflection; end

  # Reloads the \target and returns +self+ on success.
  # The QueryCache is cleared if +force+ is true.
  #
  # source://activerecord//lib/active_record/associations/association.rb#66
  def reload(force = T.unsafe(nil)); end

  # Remove the inverse association, if possible
  #
  # source://activerecord//lib/active_record/associations/association.rb#133
  def remove_inverse_instance(record); end

  # Resets the \loaded flag to +false+ and sets the \target to +nil+.
  #
  # source://activerecord//lib/active_record/associations/association.rb#54
  def reset; end

  # source://activerecord//lib/active_record/associations/association.rb#60
  def reset_negative_cache; end

  # source://activerecord//lib/active_record/associations/association.rb#113
  def reset_scope; end

  # source://activerecord//lib/active_record/associations/association.rb#101
  def scope; end

  # Set the inverse association, if possible
  #
  # source://activerecord//lib/active_record/associations/association.rb#118
  def set_inverse_instance(record); end

  # source://activerecord//lib/active_record/associations/association.rb#125
  def set_inverse_instance_from_queries(record); end

  # The target is stale if the target no longer points to the record(s) that the
  # relevant foreign_key(s) refers to. If stale, the association accessor method
  # on the owner will reload the target. It's up to subclasses to implement the
  # stale_state method if relevant.
  #
  # Note that if the target has not been loaded, it is not considered stale.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#91
  def stale_target?; end

  # Returns the value of attribute target.
  #
  # source://activerecord//lib/active_record/associations/association.rb#37
  def target; end

  # Sets the target of this association to <tt>\target</tt>, and the \loaded flag to +true+.
  #
  # source://activerecord//lib/active_record/associations/association.rb#96
  def target=(target); end

  private

  # The scope for this association.
  #
  # Note that the association_scope is merged into the target_scope only when the
  # scope method is called. This is because at that point the call may be surrounded
  # by scope.scoping { ... } or unscoped { ... } etc, which affects the scope which
  # actually gets built.
  #
  # source://activerecord//lib/active_record/associations/association.rb#269
  def association_scope; end

  # source://activerecord//lib/active_record/associations/association.rb#352
  def build_record(attributes); end

  # source://activerecord//lib/active_record/associations/association.rb#367
  def enqueue_destroy_association(options); end

  # Reader and writer methods call this so that consistent errors are presented
  # when the association target class does not exist.
  #
  # source://activerecord//lib/active_record/associations/association.rb#217
  def ensure_klass_exists!; end

  # source://activerecord//lib/active_record/associations/association.rb#221
  def find_target; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#289
  def find_target?; end

  # Returns true if record contains the foreign_key
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#339
  def foreign_key_for?(record); end

  # Returns true if there is a foreign key present on the owner which
  # references the target. This is used to determine whether we can load
  # the target if the owner is currently a new record (and therefore
  # without a key). If the owner is a new record then foreign_key must
  # be present in order to load target.
  #
  # Currently implemented by belongs_to (vanilla and polymorphic) and
  # has_one/has_many :through associations which go through a belongs_to.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#301
  def foreign_key_present?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#375
  def inversable?(record); end

  # source://activerecord//lib/active_record/associations/association.rb#319
  def inverse_association_for(record); end

  # Can be redefined by subclasses, notably polymorphic belongs_to
  # The record parameter is necessary to support polymorphic inverses as we must check for
  # the association in the specific class of the record.
  #
  # source://activerecord//lib/active_record/associations/association.rb#328
  def inverse_reflection_for(record); end

  # Returns true if inverse association on the given record needs to be set.
  # This method is redefined by subclasses.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#334
  def invertible_for?(record); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#380
  def matches_foreign_key?(record); end

  # Raises ActiveRecord::AssociationTypeMismatch unless +record+ is of
  # the kind of the class of the associated objects. Meant to be used as
  # a safety check when you are about to assign an associated record.
  #
  # source://activerecord//lib/active_record/associations/association.rb#308
  def raise_on_type_mismatch!(record); end

  # source://activerecord//lib/active_record/associations/association.rb#285
  def scope_for_create; end

  # Returns true if statement cache should be skipped on the association reader.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#360
  def skip_statement_cache?(scope); end

  # source://activerecord//lib/active_record/associations/association.rb#245
  def skip_strict_loading(&block); end

  # This should be implemented to return the values of the relevant key(s) on the owner,
  # so that when stale_state is different from the value stored on the last find_target,
  # the target is stale.
  #
  # This is only relevant to certain associations, which is why it returns +nil+ by default.
  #
  # source://activerecord//lib/active_record/associations/association.rb#349
  def stale_state; end

  # Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the
  # through association's scope)
  #
  # source://activerecord//lib/active_record/associations/association.rb#281
  def target_scope; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/association.rb#253
  def violates_strict_loading?; end
end

# source://activerecord//lib/active_record/associations/association_scope.rb#5
class ActiveRecord::Associations::AssociationScope
  # @return [AssociationScope] a new instance of AssociationScope
  #
  # source://activerecord//lib/active_record/associations/association_scope.rb#15
  def initialize(value_transformation); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#21
  def scope(association); end

  private

  # source://activerecord//lib/active_record/associations/association_scope.rb#124
  def add_constraints(scope, owner, chain); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#161
  def apply_scope(scope, table, key, value); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#169
  def eval_scope(reflection, scope, owner); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#112
  def get_chain(reflection, association, tracker); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#54
  def join(table, constraint); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#58
  def last_chain_scope(scope, reflection, owner); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#81
  def next_chain_scope(scope, reflection, next_reflection); end

  # source://activerecord//lib/active_record/associations/association_scope.rb#77
  def transform_value(value); end

  # Returns the value of attribute value_transformation.
  #
  # source://activerecord//lib/active_record/associations/association_scope.rb#52
  def value_transformation; end

  class << self
    # source://activerecord//lib/active_record/associations/association_scope.rb#10
    def create(&block); end

    # source://activerecord//lib/active_record/associations/association_scope.rb#34
    def get_bind_values(owner, chain); end

    # source://activerecord//lib/active_record/associations/association_scope.rb#6
    def scope(association); end
  end
end

# source://activerecord//lib/active_record/associations/association_scope.rb#19
ActiveRecord::Associations::AssociationScope::INSTANCE = T.let(T.unsafe(nil), ActiveRecord::Associations::AssociationScope)

# source://activerecord//lib/active_record/associations/association_scope.rb#101
class ActiveRecord::Associations::AssociationScope::ReflectionProxy < ::SimpleDelegator
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  #
  # source://activerecord//lib/active_record/associations/association_scope.rb#104
  def initialize(reflection, aliased_table); end

  # Returns the value of attribute aliased_table.
  #
  # source://activerecord//lib/active_record/associations/association_scope.rb#102
  def aliased_table; end

  # source://activerecord//lib/active_record/associations/association_scope.rb#109
  def all_includes; end
end

# = Active Record Belongs To Association
#
# source://activerecord//lib/active_record/associations/belongs_to_association.rb#6
class ActiveRecord::Associations::BelongsToAssociation < ::ActiveRecord::Associations::SingularAssociation
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#53
  def decrement_counters; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#61
  def decrement_counters_before_last_save; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#40
  def default(&block); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#7
  def handle_dependency; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#57
  def increment_counters; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#35
  def inversed_from(record); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#44
  def reset; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#84
  def saved_change_to_target?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#76
  def target_changed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#80
  def target_previously_changed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#49
  def updated?; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#118
  def find_target?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#141
  def foreign_key_present?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#145
  def invertible_for?(record); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#137
  def primary_key(klass); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#89
  def replace(record); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#126
  def replace_keys(record, force: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#122
  def require_counter_update?; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#150
  def stale_state; end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#103
  def update_counters(by); end

  # source://activerecord//lib/active_record/associations/belongs_to_association.rb#113
  def update_counters_via_scope(klass, foreign_key, by); end
end

# = Active Record Belongs To Polymorphic Association
#
# source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#6
class ActiveRecord::Associations::BelongsToPolymorphicAssociation < ::ActiveRecord::Associations::BelongsToAssociation
  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#7
  def klass; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#20
  def saved_change_to_target?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#12
  def target_changed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#16
  def target_previously_changed?; end

  private

  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#35
  def inverse_reflection_for(record); end

  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#39
  def raise_on_type_mismatch!(record); end

  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#25
  def replace_keys(record, force: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/belongs_to_polymorphic_association.rb#43
  def stale_state; end
end

# source://activerecord//lib/active_record/associations.rb#280
module ActiveRecord::Associations::Builder; end

# source://activerecord//lib/active_record/associations/builder/association.rb#15
class ActiveRecord::Associations::Builder::Association
  class << self
    # source://activerecord//lib/active_record/associations/builder/association.rb#25
    def build(model, name, scope, options, &block); end

    # @raise [ArgumentError]
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#40
    def create_reflection(model, name, scope, options, &block); end

    # Returns the value of attribute extensions.
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#17
    def extensions; end

    # Sets the attribute extensions
    #
    # @param value the value to set the attribute extensions to.
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#17
    def extensions=(_arg0); end

    private

    # source://activerecord//lib/active_record/associations/builder/association.rb#144
    def add_after_commit_jobs_callback(model, dependent); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#139
    def add_destroy_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#53
    def build_scope(scope); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#129
    def check_dependent_options(dependent, model); end

    # Defines the setter and getter methods for the association
    # class Post < ActiveRecord::Base
    #   has_many :comments
    # end
    #
    # Post.first.comments and Post.first.comments= methods are defined by this method...
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#94
    def define_accessors(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#76
    def define_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#121
    def define_change_tracking_methods(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#73
    def define_extensions(model, name); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#101
    def define_readers(mixin, name); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#117
    def define_validations(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#109
    def define_writers(mixin, name); end

    # @raise [NotImplementedError]
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#61
    def macro; end

    # @raise [NotImplementedError]
    #
    # source://activerecord//lib/active_record/associations/builder/association.rb#125
    def valid_dependent_options; end

    # source://activerecord//lib/active_record/associations/builder/association.rb#65
    def valid_options(options); end

    # source://activerecord//lib/active_record/associations/builder/association.rb#69
    def validate_options(options); end
  end
end

# source://activerecord//lib/active_record/associations/builder/association.rb#21
ActiveRecord::Associations::Builder::Association::VALID_OPTIONS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/associations/builder/belongs_to.rb#4
class ActiveRecord::Associations::Builder::BelongsTo < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#43
    def touch_record(o, changes, foreign_key, name, touch); end

    private

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#27
    def add_counter_cache_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#102
    def add_default_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#108
    def add_destroy_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#78
    def add_touch_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#20
    def define_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#143
    def define_change_tracking_methods(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#112
    def define_validations(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#5
    def macro; end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#16
    def valid_dependent_options; end

    # source://activerecord//lib/active_record/associations/builder/belongs_to.rb#9
    def valid_options(options); end
  end
end

# source://activerecord//lib/active_record/associations/builder/collection_association.rb#6
class ActiveRecord::Associations::Builder::CollectionAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#13
    def define_callbacks(model, reflection); end

    private

    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#30
    def define_callback(model, callback_name, name, options); end

    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#22
    def define_extensions(model, name, &block); end

    # Defines the setter and getter methods for the collection_singular_ids.
    #
    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#58
    def define_readers(mixin, name); end

    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#68
    def define_writers(mixin, name); end

    # source://activerecord//lib/active_record/associations/builder/collection_association.rb#9
    def valid_options(options); end
  end
end

# source://activerecord//lib/active_record/associations/builder/collection_association.rb#7
ActiveRecord::Associations::Builder::CollectionAssociation::CALLBACKS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#4
class ActiveRecord::Associations::Builder::HasAndBelongsToMany
  # @return [HasAndBelongsToMany] a new instance of HasAndBelongsToMany
  #
  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#7
  def initialize(association_name, lhs_model, options); end

  # Returns the value of attribute association_name.
  #
  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#5
  def association_name; end

  # Returns the value of attribute lhs_model.
  #
  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#5
  def lhs_model; end

  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#59
  def middle_reflection(join_model); end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#5
  def options; end

  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#13
  def through_model; end

  private

  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#92
  def belongs_to_options(options); end

  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#71
  def middle_options(join_model); end

  # source://activerecord//lib/active_record/associations/builder/has_and_belongs_to_many.rb#80
  def table_name; end
end

# source://activerecord//lib/active_record/associations/builder/has_many.rb#4
class ActiveRecord::Associations::Builder::HasMany < ::ActiveRecord::Associations::Builder::CollectionAssociation
  class << self
    private

    # source://activerecord//lib/active_record/associations/builder/has_many.rb#5
    def macro; end

    # source://activerecord//lib/active_record/associations/builder/has_many.rb#18
    def valid_dependent_options; end

    # source://activerecord//lib/active_record/associations/builder/has_many.rb#9
    def valid_options(options); end
  end
end

# source://activerecord//lib/active_record/associations/builder/has_one.rb#4
class ActiveRecord::Associations::Builder::HasOne < ::ActiveRecord::Associations::Builder::SingularAssociation
  class << self
    # source://activerecord//lib/active_record/associations/builder/has_one.rb#38
    def touch_record(record, name, touch); end

    private

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#27
    def add_destroy_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#47
    def add_touch_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#22
    def define_callbacks(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#31
    def define_validations(model, reflection); end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#5
    def macro; end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#18
    def valid_dependent_options; end

    # source://activerecord//lib/active_record/associations/builder/has_one.rb#9
    def valid_options(options); end
  end
end

# source://activerecord//lib/active_record/associations/builder/singular_association.rb#6
class ActiveRecord::Associations::Builder::SingularAssociation < ::ActiveRecord::Associations::Builder::Association
  class << self
    private

    # source://activerecord//lib/active_record/associations/builder/singular_association.rb#11
    def define_accessors(model, reflection); end

    # Defines the (build|create)_association methods for belongs_to or has_one association
    #
    # source://activerecord//lib/active_record/associations/builder/singular_association.rb#30
    def define_constructors(mixin, name); end

    # source://activerecord//lib/active_record/associations/builder/singular_association.rb#7
    def valid_options(options); end
  end
end

# = Active Record \Associations
#
# \Associations are a set of macro-like class methods for tying objects together through
# foreign keys. They express relationships like "Project has one Project Manager"
# or "Project belongs to a Portfolio". Each macro adds a number of methods to the
# class which are specialized according to the collection or association symbol and the
# options hash. It works much the same way as Ruby's own <tt>attr*</tt>
# methods.
#
#   class Project < ActiveRecord::Base
#     belongs_to              :portfolio
#     has_one                 :project_manager
#     has_many                :milestones
#     has_and_belongs_to_many :categories
#   end
#
# The project class now has the following methods (and more) to ease the traversal and
# manipulation of its relationships:
#
#   project = Project.first
#   project.portfolio
#   project.portfolio = Portfolio.first
#   project.reload_portfolio
#
#   project.project_manager
#   project.project_manager = ProjectManager.first
#   project.reload_project_manager
#
#   project.milestones.empty?
#   project.milestones.size
#   project.milestones
#   project.milestones << Milestone.first
#   project.milestones.delete(Milestone.first)
#   project.milestones.destroy(Milestone.first)
#   project.milestones.find(Milestone.first.id)
#   project.milestones.build
#   project.milestones.create
#
#   project.categories.empty?
#   project.categories.size
#   project.categories
#   project.categories << Category.first
#   project.categories.delete(category1)
#   project.categories.destroy(category1)
#
# === A word of warning
#
# Don't create associations that have the same name as {instance methods}[rdoc-ref:ActiveRecord::Core] of
# +ActiveRecord::Base+. Since the association adds a method with that name to
# its model, using an association with the same name as one provided by +ActiveRecord::Base+ will override the method inherited through +ActiveRecord::Base+ and will break things.
# For instance, +attributes+ and +connection+ would be bad choices for association names, because those names already exist in the list of +ActiveRecord::Base+ instance methods.
#
# == Auto-generated methods
# See also "Instance Public methods" below ( from #belongs_to ) for more details.
#
# === Singular associations (one-to-one)
#                                     |            |  belongs_to  |
#   generated methods                 | belongs_to | :polymorphic | has_one
#   ----------------------------------+------------+--------------+---------
#   other                             |     X      |      X       |    X
#   other=(other)                     |     X      |      X       |    X
#   build_other(attributes={})        |     X      |              |    X
#   create_other(attributes={})       |     X      |              |    X
#   create_other!(attributes={})      |     X      |              |    X
#   reload_other                      |     X      |      X       |    X
#   other_changed?                    |     X      |      X       |
#   other_previously_changed?         |     X      |      X       |
#
# === Collection associations (one-to-many / many-to-many)
#                                     |       |          | has_many
#   generated methods                 | habtm | has_many | :through
#   ----------------------------------+-------+----------+----------
#   others                            |   X   |    X     |    X
#   others=(other,other,...)          |   X   |    X     |    X
#   other_ids                         |   X   |    X     |    X
#   other_ids=(id,id,...)             |   X   |    X     |    X
#   others<<                          |   X   |    X     |    X
#   others.push                       |   X   |    X     |    X
#   others.concat                     |   X   |    X     |    X
#   others.build(attributes={})       |   X   |    X     |    X
#   others.create(attributes={})      |   X   |    X     |    X
#   others.create!(attributes={})     |   X   |    X     |    X
#   others.size                       |   X   |    X     |    X
#   others.length                     |   X   |    X     |    X
#   others.count                      |   X   |    X     |    X
#   others.sum(*args)                 |   X   |    X     |    X
#   others.empty?                     |   X   |    X     |    X
#   others.clear                      |   X   |    X     |    X
#   others.delete(other,other,...)    |   X   |    X     |    X
#   others.delete_all                 |   X   |    X     |    X
#   others.destroy(other,other,...)   |   X   |    X     |    X
#   others.destroy_all                |   X   |    X     |    X
#   others.find(*args)                |   X   |    X     |    X
#   others.exists?                    |   X   |    X     |    X
#   others.distinct                   |   X   |    X     |    X
#   others.reset                      |   X   |    X     |    X
#   others.reload                     |   X   |    X     |    X
#
# === Overriding generated methods
#
# Association methods are generated in a module included into the model
# class, making overrides easy. The original generated method can thus be
# called with +super+:
#
#   class Car < ActiveRecord::Base
#     belongs_to :owner
#     belongs_to :old_owner
#
#     def owner=(new_owner)
#       self.old_owner = self.owner
#       super
#     end
#   end
#
# The association methods module is included immediately after the
# generated attributes methods module, meaning an association will
# override the methods for an attribute with the same name.
#
# == Cardinality and associations
#
# Active Record associations can be used to describe one-to-one, one-to-many, and many-to-many
# relationships between models. Each model uses an association to describe its role in
# the relation. The #belongs_to association is always used in the model that has
# the foreign key.
#
# === One-to-one
#
# Use #has_one in the base, and #belongs_to in the associated model.
#
#   class Employee < ActiveRecord::Base
#     has_one :office
#   end
#   class Office < ActiveRecord::Base
#     belongs_to :employee    # foreign key - employee_id
#   end
#
# === One-to-many
#
# Use #has_many in the base, and #belongs_to in the associated model.
#
#   class Manager < ActiveRecord::Base
#     has_many :employees
#   end
#   class Employee < ActiveRecord::Base
#     belongs_to :manager     # foreign key - manager_id
#   end
#
# === Many-to-many
#
# There are two ways to build a many-to-many relationship.
#
# The first way uses a #has_many association with the <tt>:through</tt> option and a join model, so
# there are two stages of associations.
#
#   class Assignment < ActiveRecord::Base
#     belongs_to :programmer  # foreign key - programmer_id
#     belongs_to :project     # foreign key - project_id
#   end
#   class Programmer < ActiveRecord::Base
#     has_many :assignments
#     has_many :projects, through: :assignments
#   end
#   class Project < ActiveRecord::Base
#     has_many :assignments
#     has_many :programmers, through: :assignments
#   end
#
# For the second way, use #has_and_belongs_to_many in both models. This requires a join table
# that has no corresponding model or primary key.
#
#   class Programmer < ActiveRecord::Base
#     has_and_belongs_to_many :projects       # foreign keys in the join table
#   end
#   class Project < ActiveRecord::Base
#     has_and_belongs_to_many :programmers    # foreign keys in the join table
#   end
#
# Choosing which way to build a many-to-many relationship is not always simple.
# If you need to work with the relationship model as its own entity,
# use #has_many <tt>:through</tt>. Use #has_and_belongs_to_many when working with legacy schemas or when
# you never work directly with the relationship itself.
#
# == Is it a #belongs_to or #has_one association?
#
# Both express a 1-1 relationship. The difference is mostly where to place the foreign
# key, which goes on the table for the class declaring the #belongs_to relationship.
#
#   class User < ActiveRecord::Base
#     # I reference an account.
#     belongs_to :account
#   end
#
#   class Account < ActiveRecord::Base
#     # One user references me.
#     has_one :user
#   end
#
# The tables for these classes could look something like:
#
#   CREATE TABLE users (
#     id bigint NOT NULL auto_increment,
#     account_id bigint default NULL,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
#   CREATE TABLE accounts (
#     id bigint NOT NULL auto_increment,
#     name varchar default NULL,
#     PRIMARY KEY  (id)
#   )
#
# == Unsaved objects and associations
#
# You can manipulate objects and associations before they are saved to the database, but
# there is some special behavior you should be aware of, mostly involving the saving of
# associated objects.
#
# You can set the <tt>:autosave</tt> option on a #has_one, #belongs_to,
# #has_many, or #has_and_belongs_to_many association. Setting it
# to +true+ will _always_ save the members, whereas setting it to +false+ will
# _never_ save the members. More details about <tt>:autosave</tt> option is available at
# AutosaveAssociation.
#
# === One-to-one associations
#
# * Assigning an object to a #has_one association automatically saves that object and
#   the object being replaced (if there is one), in order to update their foreign
#   keys - except if the parent object is unsaved (<tt>new_record? == true</tt>).
# * If either of these saves fail (due to one of the objects being invalid), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * If you wish to assign an object to a #has_one association without saving it,
#   use the <tt>#build_association</tt> method (documented below). The object being
#   replaced will still be saved to update its foreign key.
# * Assigning an object to a #belongs_to association does not save the object, since
#   the foreign key field belongs on the parent. It does not save the parent either.
#
# === Collections
#
# * Adding an object to a collection (#has_many or #has_and_belongs_to_many) automatically
#   saves that object, except if the parent object (the owner of the collection) is not yet
#   stored in the database.
# * If saving any of the objects being added to a collection (via <tt>push</tt> or similar)
#   fails, then <tt>push</tt> returns +false+.
# * If saving fails while replacing the collection (via <tt>association=</tt>), an
#   ActiveRecord::RecordNotSaved exception is raised and the assignment is
#   cancelled.
# * You can add an object to a collection without automatically saving it by using the
#   <tt>collection.build</tt> method (documented below).
# * All unsaved (<tt>new_record? == true</tt>) members of the collection are automatically
#   saved when the parent is saved.
#
# == Customizing the query
#
# \Associations are built from <tt>Relation</tt> objects, and you can use the Relation syntax
# to customize them. For example, to add a condition:
#
#   class Blog < ActiveRecord::Base
#     has_many :published_posts, -> { where(published: true) }, class_name: 'Post'
#   end
#
# Inside the <tt>-> { ... }</tt> block you can use all of the usual Relation methods.
#
# === Accessing the owner object
#
# Sometimes it is useful to have access to the owner object when building the query. The owner
# is passed as a parameter to the block. For example, the following association would find all
# events that occur on the user's birthday:
#
#   class User < ActiveRecord::Base
#     has_many :birthday_events, ->(user) { where(starts_on: user.birthday) }, class_name: 'Event'
#   end
#
# Note: Joining or eager loading such associations is not possible because
# those operations happen before instance creation. Such associations
# _can_ be preloaded, but doing so will perform N+1 queries because there
# will be a different scope for each record (similar to preloading
# polymorphic scopes).
#
# == Association callbacks
#
# Similar to the normal callbacks that hook into the life cycle of an Active Record object,
# you can also define callbacks that get triggered when you add an object to or remove an
# object from an association collection.
#
#   class Firm < ActiveRecord::Base
#     has_many :clients,
#              dependent: :destroy,
#              after_add: :congratulate_client,
#              after_remove: :log_after_remove
#
#     def congratulate_client(record)
#       # ...
#     end
#
#     def log_after_remove(record)
#       # ...
#     end
#   end
#
# It's possible to stack callbacks by passing them as an array. Example:
#
#   class Firm < ActiveRecord::Base
#     has_many :clients,
#              dependent: :destroy,
#              after_add: [:congratulate_client, -> (firm, record) { firm.log << "after_adding#{record.id}" }],
#              after_remove: :log_after_remove
#   end
#
# Possible callbacks are: +before_add+, +after_add+, +before_remove+, and +after_remove+.
#
# If any of the +before_add+ callbacks throw an exception, the object will not be
# added to the collection.
#
# Similarly, if any of the +before_remove+ callbacks throw an exception, the object
# will not be removed from the collection.
#
# Note: To trigger remove callbacks, you must use +destroy+ / +destroy_all+ methods. For example:
#
# * <tt>firm.clients.destroy(client)</tt>
# * <tt>firm.clients.destroy(*clients)</tt>
# * <tt>firm.clients.destroy_all</tt>
#
# +delete+ / +delete_all+ methods like the following do *not* trigger remove callbacks:
#
# * <tt>firm.clients.delete(client)</tt>
# * <tt>firm.clients.delete(*clients)</tt>
# * <tt>firm.clients.delete_all</tt>
#
# == Association extensions
#
# The proxy objects that control the access to associations can be extended through anonymous
# modules. This is especially beneficial for adding new finders, creators, and other
# factory-type methods that are only used as part of this association.
#
#   class Account < ActiveRecord::Base
#     has_many :people do
#       def find_or_create_by_name(name)
#         first_name, last_name = name.split(" ", 2)
#         find_or_create_by(first_name: first_name, last_name: last_name)
#       end
#     end
#   end
#
#   person = Account.first.people.find_or_create_by_name("David Heinemeier Hansson")
#   person.first_name # => "David"
#   person.last_name  # => "Heinemeier Hansson"
#
# If you need to share the same extensions between many associations, you can use a named
# extension module.
#
#   module FindOrCreateByNameExtension
#     def find_or_create_by_name(name)
#       first_name, last_name = name.split(" ", 2)
#       find_or_create_by(first_name: first_name, last_name: last_name)
#     end
#   end
#
#   class Account < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
#   class Company < ActiveRecord::Base
#     has_many :people, -> { extending FindOrCreateByNameExtension }
#   end
#
# Some extensions can only be made to work with knowledge of the association's internals.
# Extensions can access relevant state using the following methods (where +items+ is the
# name of the association):
#
# * <tt>record.association(:items).owner</tt> - Returns the object the association is part of.
# * <tt>record.association(:items).reflection</tt> - Returns the reflection object that describes the association.
# * <tt>record.association(:items).target</tt> - Returns the associated object for #belongs_to and #has_one, or
#   the collection of associated objects for #has_many and #has_and_belongs_to_many.
#
# However, inside the actual extension code, you will not have access to the <tt>record</tt> as
# above. In this case, you can access <tt>proxy_association</tt>. For example,
# <tt>record.association(:items)</tt> and <tt>record.items.proxy_association</tt> will return
# the same object, allowing you to make calls like <tt>proxy_association.owner</tt> inside
# association extensions.
#
# == Association Join Models
#
# Has Many associations can be configured with the <tt>:through</tt> option to use an
# explicit join model to retrieve the data. This operates similarly to a
# #has_and_belongs_to_many association. The advantage is that you're able to add validations,
# callbacks, and extra attributes on the join model. Consider the following schema:
#
#   class Author < ActiveRecord::Base
#     has_many :authorships
#     has_many :books, through: :authorships
#   end
#
#   class Authorship < ActiveRecord::Base
#     belongs_to :author
#     belongs_to :book
#   end
#
#   @author = Author.first
#   @author.authorships.collect { |a| a.book } # selects all books that the author's authorships belong to
#   @author.books                              # selects all books by using the Authorship join model
#
# You can also go through a #has_many association on the join model:
#
#   class Firm < ActiveRecord::Base
#     has_many   :clients
#     has_many   :invoices, through: :clients
#   end
#
#   class Client < ActiveRecord::Base
#     belongs_to :firm
#     has_many   :invoices
#   end
#
#   class Invoice < ActiveRecord::Base
#     belongs_to :client
#   end
#
#   @firm = Firm.first
#   @firm.clients.flat_map { |c| c.invoices } # select all invoices for all clients of the firm
#   @firm.invoices                            # selects all invoices by going through the Client join model
#
# Similarly you can go through a #has_one association on the join model:
#
#   class Group < ActiveRecord::Base
#     has_many   :users
#     has_many   :avatars, through: :users
#   end
#
#   class User < ActiveRecord::Base
#     belongs_to :group
#     has_one    :avatar
#   end
#
#   class Avatar < ActiveRecord::Base
#     belongs_to :user
#   end
#
#   @group = Group.first
#   @group.users.collect { |u| u.avatar }.compact # select all avatars for all users in the group
#   @group.avatars                                # selects all avatars by going through the User join model.
#
# An important caveat with going through #has_one or #has_many associations on the
# join model is that these associations are *read-only*. For example, the following
# would not work following the previous example:
#
#   @group.avatars << Avatar.new   # this would work if User belonged_to Avatar rather than the other way around
#   @group.avatars.delete(@group.avatars.last)  # so would this
#
# == Setting Inverses
#
# If you are using a #belongs_to on the join model, it is a good idea to set the
# <tt>:inverse_of</tt> option on the #belongs_to, which will mean that the following example
# works correctly (where <tt>tags</tt> is a #has_many <tt>:through</tt> association):
#
#   @post = Post.first
#   @tag = @post.tags.build name: "ruby"
#   @tag.save
#
# The last line ought to save the through record (a <tt>Tagging</tt>). This will only work if the
# <tt>:inverse_of</tt> is set:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :post
#     belongs_to :tag, inverse_of: :taggings
#   end
#
# If you do not set the <tt>:inverse_of</tt> record, the association will
# do its best to match itself up with the correct inverse. Automatic
# inverse detection only works on #has_many, #has_one, and
# #belongs_to associations.
#
# <tt>:foreign_key</tt> and <tt>:through</tt> options on the associations
# will also prevent the association's inverse from being found automatically,
# as will a custom scopes in some cases. See further details in the
# {Active Record Associations guide}[https://guides.rubyonrails.org/association_basics.html#bi-directional-associations].
#
# The automatic guessing of the inverse association uses a heuristic based
# on the name of the class, so it may not work for all associations,
# especially the ones with non-standard names.
#
# You can turn off the automatic detection of inverse associations by setting
# the <tt>:inverse_of</tt> option to <tt>false</tt> like so:
#
#   class Tagging < ActiveRecord::Base
#     belongs_to :tag, inverse_of: false
#   end
#
# == Nested \Associations
#
# You can actually specify *any* association with the <tt>:through</tt> option, including an
# association which has a <tt>:through</tt> option itself. For example:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :comments, through: :posts
#     has_many :commenters, through: :comments
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
#   @author = Author.first
#   @author.commenters # => People who commented on posts written by the author
#
# An equivalent way of setting up this association this would be:
#
#   class Author < ActiveRecord::Base
#     has_many :posts
#     has_many :commenters, through: :posts
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :comments
#     has_many :commenters, through: :comments
#   end
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commenter
#   end
#
# When using a nested association, you will not be able to modify the association because there
# is not enough information to know what modification to make. For example, if you tried to
# add a <tt>Commenter</tt> in the example above, there would be no way to tell how to set up the
# intermediate <tt>Post</tt> and <tt>Comment</tt> objects.
#
# == Polymorphic \Associations
#
# Polymorphic associations on models are not restricted on what types of models they
# can be associated with. Rather, they specify an interface that a #has_many association
# must adhere to.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#   end
#
#   class Post < ActiveRecord::Base
#     has_many :assets, as: :attachable         # The :as option specifies the polymorphic interface to use.
#   end
#
#   @asset.attachable = @post
#
# This works by using a type column in addition to a foreign key to specify the associated
# record. In the Asset example, you'd need an +attachable_id+ integer column and an
# +attachable_type+ string column.
#
# Using polymorphic associations in combination with single table inheritance (STI) is
# a little tricky. In order for the associations to work as expected, ensure that you
# store the base model for the STI models in the type column of the polymorphic
# association. To continue with the asset example above, suppose there are guest posts
# and member posts that use the posts table for STI. In this case, there must be a +type+
# column in the posts table.
#
# Note: The <tt>attachable_type=</tt> method is being called when assigning an +attachable+.
# The +class_name+ of the +attachable+ is passed as a String.
#
#   class Asset < ActiveRecord::Base
#     belongs_to :attachable, polymorphic: true
#
#     def attachable_type=(class_name)
#        super(class_name.constantize.base_class.to_s)
#     end
#   end
#
#   class Post < ActiveRecord::Base
#     # because we store "Post" in attachable_type now dependent: :destroy will work
#     has_many :assets, as: :attachable, dependent: :destroy
#   end
#
#   class GuestPost < Post
#   end
#
#   class MemberPost < Post
#   end
#
# == Caching
#
# All of the methods are built on a simple caching principle that will keep the result
# of the last query around unless specifically instructed not to. The cache is even
# shared across methods to make it even cheaper to use the macro-added methods without
# worrying too much about performance at the first go.
#
#   project.milestones             # fetches milestones from the database
#   project.milestones.size        # uses the milestone cache
#   project.milestones.empty?      # uses the milestone cache
#   project.milestones.reload.size # fetches milestones from the database
#   project.milestones             # uses the milestone cache
#
# == Eager loading of associations
#
# Eager loading is a way to find objects of a certain class and a number of named associations.
# It is one of the easiest ways to prevent the dreaded N+1 problem in which fetching 100
# posts that each need to display their author triggers 101 database queries. Through the
# use of eager loading, the number of queries will be reduced from 101 to 2.
#
#   class Post < ActiveRecord::Base
#     belongs_to :author
#     has_many   :comments
#   end
#
# Consider the following loop using the class above:
#
#   Post.all.each do |post|
#     puts "Post:            " + post.title
#     puts "Written by:      " + post.author.name
#     puts "Last comment on: " + post.comments.first.created_on
#   end
#
# To iterate over these one hundred posts, we'll generate 201 database queries. Let's
# first just optimize it for retrieving the author:
#
#   Post.includes(:author).each do |post|
#
# This references the name of the #belongs_to association that also used the <tt>:author</tt>
# symbol. After loading the posts, +find+ will collect the +author_id+ from each one and load
# all of the referenced authors with one query. Doing so will cut down the number of queries
# from 201 to 102.
#
# We can improve upon the situation further by referencing both associations in the finder with:
#
#   Post.includes(:author, :comments).each do |post|
#
# This will load all comments with a single query. This reduces the total number of queries
# to 3. In general, the number of queries will be 1 plus the number of associations
# named (except if some of the associations are polymorphic #belongs_to - see below).
#
# To include a deep hierarchy of associations, use a hash:
#
#   Post.includes(:author, { comments: { author: :gravatar } }).each do |post|
#
# The above code will load all the comments and all of their associated
# authors and gravatars. You can mix and match any combination of symbols,
# arrays, and hashes to retrieve the associations you want to load.
#
# All of this power shouldn't fool you into thinking that you can pull out huge amounts
# of data with no performance penalty just because you've reduced the number of queries.
# The database still needs to send all the data to Active Record and it still needs to
# be processed. So it's no catch-all for performance problems, but it's a great way to
# cut down on the number of queries in a situation as the one described above.
#
# Since only one table is loaded at a time, conditions or orders cannot reference tables
# other than the main one. If this is the case, Active Record falls back to the previously
# used <tt>LEFT OUTER JOIN</tt> based strategy. For example:
#
#   Post.includes([:author, :comments]).where(['comments.approved = ?', true])
#
# This will result in a single SQL query with joins along the lines of:
# <tt>LEFT OUTER JOIN comments ON comments.post_id = posts.id</tt> and
# <tt>LEFT OUTER JOIN authors ON authors.id = posts.author_id</tt>. Note that using conditions
# like this can have unintended consequences.
# In the above example, posts with no approved comments are not returned at all because
# the conditions apply to the SQL statement as a whole and not just to the association.
#
# You must disambiguate column references for this fallback to happen, for example
# <tt>order: "author.name DESC"</tt> will work but <tt>order: "name DESC"</tt> will not.
#
# If you want to load all posts (including posts with no approved comments), then write
# your own <tt>LEFT OUTER JOIN</tt> query using <tt>ON</tt>:
#
#   Post.joins("LEFT OUTER JOIN comments ON comments.post_id = posts.id AND comments.approved = '1'")
#
# In this case, it is usually more natural to include an association which has conditions defined on it:
#
#   class Post < ActiveRecord::Base
#     has_many :approved_comments, -> { where(approved: true) }, class_name: 'Comment'
#   end
#
#   Post.includes(:approved_comments)
#
# This will load posts and eager load the +approved_comments+ association, which contains
# only those comments that have been approved.
#
# If you eager load an association with a specified <tt>:limit</tt> option, it will be ignored,
# returning all the associated objects:
#
#   class Picture < ActiveRecord::Base
#     has_many :most_recent_comments, -> { order('id DESC').limit(10) }, class_name: 'Comment'
#   end
#
#   Picture.includes(:most_recent_comments).first.most_recent_comments # => returns all associated comments.
#
# Eager loading is supported with polymorphic associations.
#
#   class Address < ActiveRecord::Base
#     belongs_to :addressable, polymorphic: true
#   end
#
# A call that tries to eager load the addressable model
#
#   Address.includes(:addressable)
#
# This will execute one query to load the addresses and load the addressables with one
# query per addressable type.
# For example, if all the addressables are either of class Person or Company, then a total
# of 3 queries will be executed. The list of addressable types to load is determined on
# the back of the addresses loaded. This is not supported if Active Record has to fall back
# to the previous implementation of eager loading and will raise ActiveRecord::EagerLoadPolymorphicError.
# The reason is that the parent model's type is a column value so its corresponding table
# name cannot be put in the +FROM+/+JOIN+ clauses of that query.
#
# == Table Aliasing
#
# Active Record uses table aliasing in the case that a table is referenced multiple times
# in a join. If a table is referenced only once, the standard table name is used. The
# second time, the table is aliased as <tt>#{reflection_name}_#{parent_table_name}</tt>.
# Indexes are appended for any more successive uses of the table name.
#
#   Post.joins(:comments)
#   # SELECT ... FROM posts INNER JOIN comments ON ...
#   Post.joins(:special_comments) # STI
#   # SELECT ... FROM posts INNER JOIN comments ON ... AND comments.type = 'SpecialComment'
#   Post.joins(:comments, :special_comments) # special_comments is the reflection name, posts is the parent table name
#   # SELECT ... FROM posts INNER JOIN comments ON ... INNER JOIN comments special_comments_posts
#
# Acts as tree example:
#
#   TreeMixin.joins(:children)
#   # SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#   TreeMixin.joins(children: :parent)
#   # SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#   #                        INNER JOIN parents_mixins ...
#   TreeMixin.joins(children: {parent: :children})
#   # SELECT ... FROM mixins INNER JOIN mixins childrens_mixins ...
#   #                        INNER JOIN parents_mixins ...
#   #                        INNER JOIN mixins childrens_mixins_2
#
# Has and Belongs to Many join tables use the same idea, but add a <tt>_join</tt> suffix:
#
#   Post.joins(:categories)
#   # SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#   Post.joins(categories: :posts)
#   # SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#   #                       INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#   Post.joins(categories: {posts: :categories})
#   # SELECT ... FROM posts INNER JOIN categories_posts ... INNER JOIN categories ...
#   #                       INNER JOIN categories_posts posts_categories_join INNER JOIN posts posts_categories
#   #                       INNER JOIN categories_posts categories_posts_join INNER JOIN categories categories_posts_2
#
# If you wish to specify your own custom joins using ActiveRecord::QueryMethods#joins method, those table
# names will take precedence over the eager associations:
#
#   Post.joins(:comments).joins("inner join comments ...")
#   # SELECT ... FROM posts INNER JOIN comments_posts ON ... INNER JOIN comments ...
#   Post.joins(:comments, :special_comments).joins("inner join comments ...")
#   # SELECT ... FROM posts INNER JOIN comments comments_posts ON ...
#   #                       INNER JOIN comments special_comments_posts ...
#   #                       INNER JOIN comments ...
#
# Table aliases are automatically truncated according to the maximum length of table identifiers
# according to the specific database.
#
# == Modules
#
# By default, associations will look for objects within the current module scope. Consider:
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base
#         has_many :clients
#       end
#
#       class Client < ActiveRecord::Base; end
#     end
#   end
#
# When <tt>Firm#clients</tt> is called, it will in turn call
# <tt>MyApplication::Business::Client.find_all_by_firm_id(firm.id)</tt>.
# If you want to associate with a class in another module scope, this can be done by
# specifying the complete class name.
#
#   module MyApplication
#     module Business
#       class Firm < ActiveRecord::Base; end
#     end
#
#     module Billing
#       class Account < ActiveRecord::Base
#         belongs_to :firm, class_name: "MyApplication::Business::Firm"
#       end
#     end
#   end
#
# == Bi-directional associations
#
# When you specify an association, there is usually an association on the associated model
# that specifies the same relationship in reverse. For example, with the following models:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps
#      has_one :evil_wizard
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon
#    end
#
# The +traps+ association on +Dungeon+ and the +dungeon+ association on +Trap+ are
# the inverse of each other, and the inverse of the +dungeon+ association on +EvilWizard+
# is the +evil_wizard+ association on +Dungeon+ (and vice-versa). By default,
# Active Record can guess the inverse of the association based on the name
# of the class. The result is the following:
#
#    d = Dungeon.first
#    t = d.traps.first
#    d.object_id == t.dungeon.object_id # => true
#
# The +Dungeon+ instances +d+ and <tt>t.dungeon</tt> in the above example refer to
# the same in-memory instance since the association matches the name of the class.
# The result would be the same if we added +:inverse_of+ to our model definitions:
#
#    class Dungeon < ActiveRecord::Base
#      has_many :traps, inverse_of: :dungeon
#      has_one :evil_wizard, inverse_of: :dungeon
#    end
#
#    class Trap < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :traps
#    end
#
#    class EvilWizard < ActiveRecord::Base
#      belongs_to :dungeon, inverse_of: :evil_wizard
#    end
#
# For more information, see the documentation for the +:inverse_of+ option and the
# {Active Record Associations guide}[https://guides.rubyonrails.org/association_basics.html#bi-directional-associations].
#
# == Deleting from associations
#
# === Dependent associations
#
# #has_many, #has_one, and #belongs_to associations support the <tt>:dependent</tt> option.
# This allows you to specify that associated records should be deleted when the owner is
# deleted.
#
# For example:
#
#     class Author
#       has_many :posts, dependent: :destroy
#     end
#     Author.find(1).destroy # => Will destroy all of the author's posts, too
#
# The <tt>:dependent</tt> option can have different values which specify how the deletion
# is done. For more information, see the documentation for this option on the different
# specific association types. When no option is given, the behavior is to do nothing
# with the associated records when destroying a record.
#
# Note that <tt>:dependent</tt> is implemented using \Rails' callback
# system, which works by processing callbacks in order. Therefore, other
# callbacks declared either before or after the <tt>:dependent</tt> option
# can affect what it does.
#
# Note that <tt>:dependent</tt> option is ignored for #has_one <tt>:through</tt> associations.
#
# === Delete or destroy?
#
# #has_many and #has_and_belongs_to_many associations have the methods <tt>destroy</tt>,
# <tt>delete</tt>, <tt>destroy_all</tt> and <tt>delete_all</tt>.
#
# For #has_and_belongs_to_many, <tt>delete</tt> and <tt>destroy</tt> are the same: they
# cause the records in the join table to be removed.
#
# For #has_many, <tt>destroy</tt> and <tt>destroy_all</tt> will always call the <tt>destroy</tt> method of the
# record(s) being removed so that callbacks are run. However <tt>delete</tt> and <tt>delete_all</tt> will either
# do the deletion according to the strategy specified by the <tt>:dependent</tt> option, or
# if no <tt>:dependent</tt> option is given, then it will follow the default strategy.
# The default strategy is to do nothing (leave the foreign keys with the parent ids set), except for
# #has_many <tt>:through</tt>, where the default strategy is <tt>delete_all</tt> (delete
# the join records, without running their callbacks).
#
# There is also a <tt>clear</tt> method which is the same as <tt>delete_all</tt>, except that
# it returns the association rather than the records which have been deleted.
#
# === What gets deleted?
#
# There is a potential pitfall here: #has_and_belongs_to_many and #has_many <tt>:through</tt>
# associations have records in join tables, as well as the associated records. So when we
# call one of these deletion methods, what exactly should be deleted?
#
# The answer is that it is assumed that deletion on an association is about removing the
# <i>link</i> between the owner and the associated object(s), rather than necessarily the
# associated objects themselves. So with #has_and_belongs_to_many and #has_many
# <tt>:through</tt>, the join records will be deleted, but the associated records won't.
#
# This makes sense if you think about it: if you were to call <tt>post.tags.delete(Tag.find_by(name: 'food'))</tt>
# you would want the 'food' tag to be unlinked from the post, rather than for the tag itself
# to be removed from the database.
#
# However, there are examples where this strategy doesn't make sense. For example, suppose
# a person has many projects, and each project has many tasks. If we deleted one of a person's
# tasks, we would probably not want the project to be deleted. In this scenario, the delete method
# won't actually work: it can only be used if the association on the join model is a
# #belongs_to. In other situations you are expected to perform operations directly on
# either the associated records or the <tt>:through</tt> association.
#
# With a regular #has_many there is no distinction between the "associated records"
# and the "link", so there is only one choice for what gets deleted.
#
# With #has_and_belongs_to_many and #has_many <tt>:through</tt>, if you want to delete the
# associated records themselves, you can always do something along the lines of
# <tt>person.tasks.each(&:destroy)</tt>.
#
# == Type safety with ActiveRecord::AssociationTypeMismatch
#
# If you attempt to assign an object to an association that doesn't match the inferred
# or specified <tt>:class_name</tt>, you'll get an ActiveRecord::AssociationTypeMismatch.
#
# == Options
#
# All of the association macros can be specialized through options. This makes cases
# more complex than the simple and guessable ones possible.
#
# source://activerecord//lib/active_record/associations.rb#1272
module ActiveRecord::Associations::ClassMethods
  # Specifies a one-to-one association with another class. This method should only be used
  # if this class contains the foreign key. If the other class contains the foreign key,
  # then you should use #has_one instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # Methods will be added for retrieval and query for a single associated object, for which
  # this object holds an id:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>belongs_to :author</tt> would add among others <tt>author.nil?</tt>.
  #
  # [<tt>association</tt>]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [<tt>association=(associate)</tt>]
  #   Assigns the associate object, extracts the primary key, and sets it as the foreign key.
  #   No modification or deletion of existing records takes place.
  # [<tt>build_association(attributes = {})</tt>]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not yet been saved.
  # [<tt>create_association(attributes = {})</tt>]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [<tt>create_association!(attributes = {})</tt>]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [<tt>reload_association</tt>]
  #   Returns the associated object, forcing a database read.
  # [<tt>reset_association</tt>]
  #   Unloads the associated object. The next access will query it from the database.
  # [<tt>association_changed?</tt>]
  #   Returns true if a new associate object has been assigned and the next save will update the foreign key.
  # [<tt>association_previously_changed?</tt>]
  #   Returns true if the previous save updated the association to reference a new associate object.
  #
  # ==== Example
  #
  #   class Post < ActiveRecord::Base
  #     belongs_to :author
  #   end
  #
  # Declaring <tt>belongs_to :author</tt> adds the following methods (and more):
  #
  #   post = Post.find(7)
  #   author = Author.find(19)
  #
  #   post.author           # similar to Author.find(post.author_id)
  #   post.author = author  # similar to post.author_id = author.id
  #   post.build_author     # similar to post.author = Author.new
  #   post.create_author    # similar to post.author = Author.new; post.author.save; post.author
  #   post.create_author!   # similar to post.author = Author.new; post.author.save!; post.author
  #   post.reload_author
  #   post.reset_author
  #   post.author_changed?
  #   post.author_previously_changed?
  #
  # ==== Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   belongs_to :firm, -> { where(id: 2) }
  #   belongs_to :user, -> { joins(:friends) }
  #   belongs_to :level, ->(game) { where("game_level > ?", game.current_level) }
  #
  # ==== Options
  #
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # [+:class_name+]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>belongs_to :author</tt> will by default be linked to the Author class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [+:foreign_key+]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of the association with an "_id" suffix. So a class that defines a <tt>belongs_to :person</tt>
  #   association will use "person_id" as the default <tt>:foreign_key</tt>. Similarly,
  #   <tt>belongs_to :favorite_person, class_name: "Person"</tt> will use a foreign key
  #   of "favorite_person_id".
  #
  #   Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's
  #   inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well.
  # [+:foreign_type+]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the association with a "_type"
  #   suffix. So a class that defines a <tt>belongs_to :taggable, polymorphic: true</tt>
  #   association will use "taggable_type" as the default <tt>:foreign_type</tt>.
  # [+:primary_key+]
  #   Specify the method that returns the primary key of associated object used for the association.
  #   By default this is +id+.
  # [+:dependent+]
  #   If set to <tt>:destroy</tt>, the associated object is destroyed when this object is. If set to
  #   <tt>:delete</tt>, the associated object is deleted *without* calling its destroy method. If set to
  #   <tt>:destroy_async</tt>, the associated object is scheduled to be destroyed in a background job.
  #   This option should not be specified when #belongs_to is used in conjunction with
  #   a #has_many relationship on another class because of the potential to leave
  #   orphaned records behind.
  # [+:counter_cache+]
  #   Caches the number of belonging objects on the associate class through the use of CounterCache::ClassMethods#increment_counter
  #   and CounterCache::ClassMethods#decrement_counter. The counter cache is incremented when an object of this
  #   class is created and decremented when it's destroyed. This requires that a column
  #   named <tt>#{table_name}_count</tt> (such as +comments_count+ for a belonging Comment class)
  #   is used on the associate class (such as a Post class) - that is the migration for
  #   <tt>#{table_name}_count</tt> is created on the associate class (such that <tt>Post.comments_count</tt> will
  #   return the count cached, see note below). You can also specify a custom counter
  #   cache column by providing a column name instead of a +true+/+false+ value to this
  #   option (e.g., <tt>counter_cache: :my_custom_counter</tt>.)
  #   Note: Specifying a counter cache will add it to that model's list of readonly attributes
  #   using +attr_readonly+.
  # [+:polymorphic+]
  #   Specify this association is a polymorphic association by passing +true+.
  #   Note: If you've enabled the counter cache, then you may want to add the counter cache attribute
  #   to the +attr_readonly+ list in the associated classes (e.g. <tt>class Post; attr_readonly :comments_count; end</tt>).
  # [+:validate+]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [+:autosave+]
  #   If true, always save the associated object or destroy it if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for
  #   sets <tt>:autosave</tt> to <tt>true</tt>.
  # [+:touch+]
  #   If true, the associated object will be touched (the +updated_at+ / +updated_on+ attributes set to current time)
  #   when this record is either saved or destroyed. If you specify a symbol, that attribute
  #   will be updated with the current time in addition to the +updated_at+ / +updated_on+ attribute.
  #   Please note that no validation will be performed when touching, and only the +after_touch+,
  #   +after_commit+, and +after_rollback+ callbacks will be executed.
  # [+:inverse_of+]
  #   Specifies the name of the #has_one or #has_many association on the associated
  #   object that is the inverse of this #belongs_to association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [+:optional+]
  #   When set to +true+, the association will not have its presence validated.
  # [+:required+]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  #   NOTE: <tt>required</tt> is set to <tt>true</tt> by default and is deprecated. If
  #   you don't want to have association presence validated, use <tt>optional: true</tt>.
  # [+:default+]
  #   Provide a callable (i.e. proc or lambda) to specify that the association should
  #   be initialized with a particular record before validation.
  #   Please note that callable won't be executed if the record exists.
  # [+:strict_loading+]
  #   Enforces strict loading every time the associated record is loaded through this association.
  # [+:ensuring_owner_was+]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  # [+:query_constraints+]
  #   Serves as a composite foreign key. Defines the list of columns to be used to query the associated object.
  #   This is an optional option. By default Rails will attempt to derive the value automatically.
  #   When the value is set the Array size must match associated model's primary key or +query_constraints+ size.
  #
  # Option examples:
  #   belongs_to :firm, foreign_key: "client_of"
  #   belongs_to :person, primary_key: "name", foreign_key: "person_name"
  #   belongs_to :author, class_name: "Person", foreign_key: "author_id"
  #   belongs_to :valid_coupon, ->(o) { where "discounts > ?", o.payments_count },
  #                             class_name: "Coupon", foreign_key: "coupon_id"
  #   belongs_to :attachable, polymorphic: true
  #   belongs_to :project, -> { readonly }
  #   belongs_to :post, counter_cache: true
  #   belongs_to :comment, touch: true
  #   belongs_to :company, touch: :employees_last_updated_at
  #   belongs_to :user, optional: true
  #   belongs_to :account, default: -> { company.account }
  #   belongs_to :account, strict_loading: true
  #   belong_to  :note, query_constraints: [:organization_id, :note_id]
  #
  # source://activerecord//lib/active_record/associations.rb#1886
  def belongs_to(name, scope = T.unsafe(nil), **options); end

  # Specifies a many-to-many relationship with another class. This associates two classes via an
  # intermediate join table. Unless the join table is explicitly specified as an option, it is
  # guessed using the lexical order of the class names. So a join between Developer and Project
  # will give the default join table name of "developers_projects" because "D" precedes "P" alphabetically.
  # Note that this precedence is calculated using the <tt><</tt> operator for String. This
  # means that if the strings are of different lengths, and the strings are equal when compared
  # up to the shortest length, then the longer string is considered of higher
  # lexical precedence than the shorter one. For example, one would expect the tables "paper_boxes" and "papers"
  # to generate a join table name of "papers_paper_boxes" because of the length of the name "paper_boxes",
  # but it in fact generates a join table name of "paper_boxes_papers". Be aware of this caveat, and use the
  # custom <tt>:join_table</tt> option if you need to.
  # If your tables share a common prefix, it will only appear once at the beginning. For example,
  # the tables "catalog_categories" and "catalog_products" generate a join table name of "catalog_categories_products".
  #
  # The join table should not have a primary key or a model associated with it. You must manually generate the
  # join table with a migration such as this:
  #
  #   class CreateDevelopersProjectsJoinTable < ActiveRecord::Migration[7.1]
  #     def change
  #       create_join_table :developers, :projects
  #     end
  #   end
  #
  # It's also a good idea to add indexes to each of those columns to speed up the joins process.
  # However, in MySQL it is advised to add a compound index for both of the columns as MySQL only
  # uses one index per table during the lookup.
  #
  # Adds the following methods for retrieval and query:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_and_belongs_to_many :categories</tt> would add among others <tt>categories.empty?</tt>.
  #
  # [<tt>collection</tt>]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [<tt>collection<<(object, ...)</tt>]
  #   Adds one or more objects to the collection by creating associations in the join table
  #   (<tt>collection.push</tt> and <tt>collection.concat</tt> are aliases to this method).
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  # [<tt>collection.delete(object, ...)</tt>]
  #   Removes one or more objects from the collection by removing their associations from the join table.
  #   This does not destroy the objects.
  # [<tt>collection.destroy(object, ...)</tt>]
  #   Removes one or more objects from the collection by running destroy on each association in the join table, overriding any dependent option.
  #   This does not destroy the objects.
  # [<tt>collection=objects</tt>]
  #   Replaces the collection's content by deleting and adding objects as appropriate.
  # [<tt>collection_singular_ids</tt>]
  #   Returns an array of the associated objects' ids.
  # [<tt>collection_singular_ids=ids</tt>]
  #   Replace the collection by the objects identified by the primary keys in +ids+.
  # [<tt>collection.clear</tt>]
  #   Removes every object from the collection. This does not destroy the objects.
  # [<tt>collection.empty?</tt>]
  #   Returns +true+ if there are no associated objects.
  # [<tt>collection.size</tt>]
  #   Returns the number of associated objects.
  # [<tt>collection.find(id)</tt>]
  #   Finds an associated object responding to the +id+ and that
  #   meets the condition that it has to be associated with this object.
  #   Uses the same rules as ActiveRecord::FinderMethods#find.
  # [<tt>collection.exists?(...)</tt>]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [<tt>collection.build(attributes = {})</tt>]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+ and linked to this object through the join table, but has not yet been saved.
  # [<tt>collection.create(attributes = {})</tt>]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through the join table, and that has already been
  #   saved (if it passed the validation).
  # [<tt>collection.reload</tt>]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # ==== Example
  #
  #   class Developer < ActiveRecord::Base
  #     has_and_belongs_to_many :projects
  #   end
  #
  # Declaring <tt>has_and_belongs_to_many :projects</tt> adds the following methods (and more):
  #
  #   developer = Developer.find(11)
  #   project   = Project.find(9)
  #
  #   developer.projects
  #   developer.projects << project
  #   developer.projects.delete(project)
  #   developer.projects.destroy(project)
  #   developer.projects = [project]
  #   developer.project_ids
  #   developer.project_ids = [9]
  #   developer.projects.clear
  #   developer.projects.empty?
  #   developer.projects.size
  #   developer.projects.find(9)
  #   developer.projects.exists?(9)
  #   developer.projects.build  # similar to Project.new(developer_id: 11)
  #   developer.projects.create # similar to Project.create(developer_id: 11)
  #   developer.projects.reload
  #
  # The declaration may include an +options+ hash to specialize the behavior of the association.
  #
  # ==== Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :categories, ->(post) {
  #     where("default_category = ?", post.default_category)
  #   }
  #
  # ==== Extensions
  #
  # The +extension+ argument allows you to pass a block into a
  # has_and_belongs_to_many association. This is useful for adding new
  # finders, creators, and other factory-type methods to be used as part of
  # the association.
  #
  # Extension examples:
  #   has_and_belongs_to_many :contractors do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # ==== Options
  #
  # [+:class_name+]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_and_belongs_to_many :projects</tt> will by default be linked to the
  #   Project class, but if the real class name is SuperProject, you'll have to specify it with this option.
  # [+:join_table+]
  #   Specify the name of the join table if the default based on lexical order isn't what you want.
  #   <b>WARNING:</b> If you're overwriting the table name of either class, the +table_name+ method
  #   MUST be declared underneath any #has_and_belongs_to_many declaration in order to work.
  # [+:foreign_key+]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes
  #   a #has_and_belongs_to_many association to Project will use "person_id" as the
  #   default <tt>:foreign_key</tt>.
  #
  #   Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's
  #   inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well.
  # [+:association_foreign_key+]
  #   Specify the foreign key used for the association on the receiving side of the association.
  #   By default this is guessed to be the name of the associated class in lower-case and "_id" suffixed.
  #   So if a Person class makes a #has_and_belongs_to_many association to Project,
  #   the association will use "project_id" as the default <tt>:association_foreign_key</tt>.
  # [+:validate+]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [+:autosave+]
  #   If true, always save the associated objects or destroy them if marked for destruction, when
  #   saving the parent object.
  #   If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [+:strict_loading+]
  #   Enforces strict loading every time an associated record is loaded through this association.
  #
  # Option examples:
  #   has_and_belongs_to_many :projects
  #   has_and_belongs_to_many :projects, -> { includes(:milestones, :manager) }
  #   has_and_belongs_to_many :nations, class_name: "Country"
  #   has_and_belongs_to_many :categories, join_table: "prods_cats"
  #   has_and_belongs_to_many :categories, -> { readonly }
  #   has_and_belongs_to_many :categories, strict_loading: true
  #
  # source://activerecord//lib/active_record/associations.rb#2067
  def has_and_belongs_to_many(name, scope = T.unsafe(nil), **options, &extension); end

  # Specifies a one-to-many association. The following methods for retrieval and query of
  # collections of associated objects will be added:
  #
  # +collection+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_many :clients</tt> would add among others <tt>clients.empty?</tt>.
  #
  # [<tt>collection</tt>]
  #   Returns a Relation of all the associated objects.
  #   An empty Relation is returned if none are found.
  # [<tt>collection<<(object, ...)</tt>]
  #   Adds one or more objects to the collection by setting their foreign keys to the collection's primary key.
  #   Note that this operation instantly fires update SQL without waiting for the save or update call on the
  #   parent object, unless the parent object is a new record.
  #   This will also run validations and callbacks of associated object(s).
  # [<tt>collection.delete(object, ...)</tt>]
  #   Removes one or more objects from the collection by setting their foreign keys to +NULL+.
  #   Objects will be in addition destroyed if they're associated with <tt>dependent: :destroy</tt>,
  #   and deleted if they're associated with <tt>dependent: :delete_all</tt>.
  #
  #   If the <tt>:through</tt> option is used, then the join records are deleted (rather than
  #   nullified) by default, but you can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [<tt>collection.destroy(object, ...)</tt>]
  #   Removes one or more objects from the collection by running <tt>destroy</tt> on
  #   each record, regardless of any dependent option, ensuring callbacks are run.
  #
  #   If the <tt>:through</tt> option is used, then the join records are destroyed
  #   instead, not the objects themselves.
  # [<tt>collection=objects</tt>]
  #   Replaces the collections content by deleting and adding objects as appropriate. If the <tt>:through</tt>
  #   option is true callbacks in the join models are triggered except destroy callbacks, since deletion is
  #   direct by default. You can specify <tt>dependent: :destroy</tt> or
  #   <tt>dependent: :nullify</tt> to override this.
  # [<tt>collection_singular_ids</tt>]
  #   Returns an array of the associated objects' ids
  # [<tt>collection_singular_ids=ids</tt>]
  #   Replace the collection with the objects identified by the primary keys in +ids+. This
  #   method loads the models and calls <tt>collection=</tt>. See above.
  # [<tt>collection.clear</tt>]
  #   Removes every object from the collection. This destroys the associated objects if they
  #   are associated with <tt>dependent: :destroy</tt>, deletes them directly from the
  #   database if <tt>dependent: :delete_all</tt>, otherwise sets their foreign keys to +NULL+.
  #   If the <tt>:through</tt> option is true no destroy callbacks are invoked on the join models.
  #   Join models are directly deleted.
  # [<tt>collection.empty?</tt>]
  #   Returns +true+ if there are no associated objects.
  # [<tt>collection.size</tt>]
  #   Returns the number of associated objects.
  # [<tt>collection.find(...)</tt>]
  #   Finds an associated object according to the same rules as ActiveRecord::FinderMethods#find.
  # [<tt>collection.exists?(...)</tt>]
  #   Checks whether an associated object with the given conditions exists.
  #   Uses the same rules as ActiveRecord::FinderMethods#exists?.
  # [<tt>collection.build(attributes = {}, ...)</tt>]
  #   Returns one or more new objects of the collection type that have been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but have not yet
  #   been saved.
  # [<tt>collection.create(attributes = {})</tt>]
  #   Returns a new object of the collection type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that has already
  #   been saved (if it passed the validation). *Note*: This only works if the base model
  #   already exists in the DB, not if it is a new (unsaved) record!
  # [<tt>collection.create!(attributes = {})</tt>]
  #   Does the same as <tt>collection.create</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [<tt>collection.reload</tt>]
  #   Returns a Relation of all of the associated objects, forcing a database read.
  #   An empty Relation is returned if none are found.
  #
  # ==== Example
  #
  #   class Firm < ActiveRecord::Base
  #     has_many :clients
  #   end
  #
  # Declaring <tt>has_many :clients</tt> adds the following methods (and more):
  #
  #   firm = Firm.find(2)
  #   client = Client.find(6)
  #
  #   firm.clients                       # similar to Client.where(firm_id: 2)
  #   firm.clients << client
  #   firm.clients.delete(client)
  #   firm.clients.destroy(client)
  #   firm.clients = [client]
  #   firm.client_ids
  #   firm.client_ids = [6]
  #   firm.clients.clear
  #   firm.clients.empty?                # similar to firm.clients.size == 0
  #   firm.clients.size                  # similar to Client.count "firm_id = 2"
  #   firm.clients.find                  # similar to Client.where(firm_id: 2).find(6)
  #   firm.clients.exists?(name: 'ACME') # similar to Client.exists?(name: 'ACME', firm_id: 2)
  #   firm.clients.build                 # similar to Client.new(firm_id: 2)
  #   firm.clients.create                # similar to Client.create(firm_id: 2)
  #   firm.clients.create!               # similar to Client.create!(firm_id: 2)
  #   firm.clients.reload
  #
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # ==== Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific set of records or customize the generated
  # query when you access the associated collection.
  #
  # Scope examples:
  #   has_many :comments, -> { where(author_id: 1) }
  #   has_many :employees, -> { joins(:address) }
  #   has_many :posts, ->(blog) { where("max_post_length > ?", blog.max_post_length) }
  #
  # ==== Extensions
  #
  # The +extension+ argument allows you to pass a block into a has_many
  # association. This is useful for adding new finders, creators, and other
  # factory-type methods to be used as part of the association.
  #
  # Extension examples:
  #   has_many :employees do
  #     def find_or_create_by_name(name)
  #       first_name, last_name = name.split(" ", 2)
  #       find_or_create_by(first_name: first_name, last_name: last_name)
  #     end
  #   end
  #
  # ==== Options
  # [+:class_name+]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_many :products</tt> will by default be linked
  #   to the +Product+ class, but if the real class name is +SpecialProduct+, you'll have to
  #   specify it with this option.
  # [+:foreign_key+]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_many
  #   association will use "person_id" as the default <tt>:foreign_key</tt>.
  #
  #   Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's
  #   inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well.
  # [+:foreign_type+]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_many :tags, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [+:primary_key+]
  #   Specify the name of the column to use as the primary key for the association. By default this is +id+.
  # [+:dependent+]
  #   Controls what happens to the associated objects when
  #   their owner is destroyed. Note that these are implemented as
  #   callbacks, and \Rails executes callbacks in order. Therefore, other
  #   similar callbacks may affect the <tt>:dependent</tt> behavior, and the
  #   <tt>:dependent</tt> behavior may affect other callbacks.
  #
  #   * <tt>nil</tt> do nothing (default).
  #   * <tt>:destroy</tt> causes all the associated objects to also be destroyed.
  #   * <tt>:destroy_async</tt> destroys all the associated objects in a background job. <b>WARNING:</b> Do not use
  #     this option if the association is backed by foreign key constraints in your database. The foreign key
  #     constraint actions will occur inside the same transaction that deletes its owner.
  #   * <tt>:delete_all</tt> causes all the associated objects to be deleted directly from the database (so callbacks will not be executed).
  #   * <tt>:nullify</tt> causes the foreign keys to be set to +NULL+. Polymorphic type will also be nullified
  #     on polymorphic associations. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an ActiveRecord::DeleteRestrictionError exception to be raised if there are any associated records.
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there are any associated objects.
  #
  #   If using with the <tt>:through</tt> option, the association on the join model must be
  #   a #belongs_to, and the records which get deleted are the join records, rather than
  #   the associated records.
  #
  #   If using <tt>dependent: :destroy</tt> on a scoped association, only the scoped objects are destroyed.
  #   For example, if a Post model defines
  #   <tt>has_many :comments, -> { where published: true }, dependent: :destroy</tt> and <tt>destroy</tt> is
  #   called on a post, only published comments are destroyed. This means that any unpublished comments in the
  #   database would still contain a foreign key pointing to the now deleted post.
  # [+:counter_cache+]
  #   This option can be used to configure a custom named <tt>:counter_cache.</tt> You only need this option,
  #   when you customized the name of your <tt>:counter_cache</tt> on the #belongs_to association.
  # [+:as+]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [+:through+]
  #   Specifies an association through which to perform the query. This can be any other type
  #   of association, including other <tt>:through</tt> associations. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt> and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection.
  #
  #   If the association on the join model is a #belongs_to, the collection can be modified
  #   and the records on the <tt>:through</tt> model will be automatically created and removed
  #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the
  #   <tt>:through</tt> association directly.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option on the source association on the
  #   join model. This allows associated records to be built which will automatically create
  #   the appropriate join model records when they are saved. (See the 'Association Join Models'
  #   and 'Setting Inverses' sections above.)
  # [+:disable_joins+]
  #   Specifies whether joins should be skipped for an association. If set to true, two or more queries
  #   will be generated. Note that in some cases, if order or limit is applied, it will be done in-memory
  #   due to database limitations. This option is only applicable on <tt>has_many :through</tt> associations as
  #   +has_many+ alone do not perform a join.
  # [+:source+]
  #   Specifies the source association name used by #has_many <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_many :subscribers, through: :subscriptions</tt> will look for either <tt>:subscribers</tt> or
  #   <tt>:subscriber</tt> on Subscription, unless a <tt>:source</tt> is given.
  # [+:source_type+]
  #   Specifies type of the source association used by #has_many <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [+:validate+]
  #   When set to +true+, validates new objects added to association when saving the parent object. +true+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [+:autosave+]
  #   If true, always save the associated objects or destroy them if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated objects.
  #   By default, only save associated objects that are new records. This option is implemented as a
  #   +before_save+ callback. Because callbacks are run in the order they are defined, associated objects
  #   may need to be explicitly saved in any user-defined +before_save+ callbacks.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [+:inverse_of+]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_many association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [+:extend+]
  #   Specifies a module or array of modules that will be extended into the association object returned.
  #   Useful for defining methods on associations, especially when they should be shared between multiple
  #   association objects.
  # [+:strict_loading+]
  #   When set to +true+, enforces strict loading every time the associated record is loaded through this
  #   association.
  # [+:ensuring_owner_was+]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  # [+:query_constraints+]
  #   Serves as a composite foreign key. Defines the list of columns to be used to query the associated object.
  #   This is an optional option. By default Rails will attempt to derive the value automatically.
  #   When the value is set the Array size must match associated model's primary key or +query_constraints+ size.
  #
  # Option examples:
  #   has_many :comments, -> { order("posted_on") }
  #   has_many :comments, -> { includes(:author) }
  #   has_many :people, -> { where(deleted: false).order("name") }, class_name: "Person"
  #   has_many :tracks, -> { order("position") }, dependent: :destroy
  #   has_many :comments, dependent: :nullify
  #   has_many :tags, as: :taggable
  #   has_many :reports, -> { readonly }
  #   has_many :subscribers, through: :subscriptions, source: :user
  #   has_many :subscribers, through: :subscriptions, disable_joins: true
  #   has_many :comments, strict_loading: true
  #   has_many :comments, query_constraints: [:blog_id, :post_id]
  #
  # source://activerecord//lib/active_record/associations.rb#1522
  def has_many(name, scope = T.unsafe(nil), **options, &extension); end

  # Specifies a one-to-one association with another class. This method should only be used
  # if the other class contains the foreign key. If the current class contains the foreign key,
  # then you should use #belongs_to instead. See also ActiveRecord::Associations::ClassMethods's overview
  # on when to use #has_one and when to use #belongs_to.
  #
  # The following methods for retrieval and query of a single associated object will be added:
  #
  # +association+ is a placeholder for the symbol passed as the +name+ argument, so
  # <tt>has_one :manager</tt> would add among others <tt>manager.nil?</tt>.
  #
  # [<tt>association</tt>]
  #   Returns the associated object. +nil+ is returned if none is found.
  # [<tt>association=(associate)</tt>]
  #   Assigns the associate object, extracts the primary key, sets it as the foreign key,
  #   and saves the associate object. To avoid database inconsistencies, permanently deletes an existing
  #   associated object when assigning a new one, even if the new one isn't saved to database.
  # [<tt>build_association(attributes = {})</tt>]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+ and linked to this object through a foreign key, but has not
  #   yet been saved.
  # [<tt>create_association(attributes = {})</tt>]
  #   Returns a new object of the associated type that has been instantiated
  #   with +attributes+, linked to this object through a foreign key, and that
  #   has already been saved (if it passed the validation).
  # [<tt>create_association!(attributes = {})</tt>]
  #   Does the same as <tt>create_association</tt>, but raises ActiveRecord::RecordInvalid
  #   if the record is invalid.
  # [<tt>reload_association</tt>]
  #   Returns the associated object, forcing a database read.
  # [<tt>reset_association</tt>]
  #   Unloads the associated object. The next access will query it from the database.
  #
  # ==== Example
  #
  #   class Account < ActiveRecord::Base
  #     has_one :beneficiary
  #   end
  #
  # Declaring <tt>has_one :beneficiary</tt> adds the following methods (and more):
  #
  #   account = Account.find(5)
  #   beneficiary = Beneficiary.find(8)
  #
  #   account.beneficiary               # similar to Beneficiary.find_by(account_id: 5)
  #   account.beneficiary = beneficiary # similar to beneficiary.update(account_id: 5)
  #   account.build_beneficiary         # similar to Beneficiary.new(account_id: 5)
  #   account.create_beneficiary        # similar to Beneficiary.create(account_id: 5)
  #   account.create_beneficiary!       # similar to Beneficiary.create!(account_id: 5)
  #   account.reload_beneficiary
  #   account.reset_beneficiary
  #
  # ==== Scopes
  #
  # You can pass a second argument +scope+ as a callable (i.e. proc or
  # lambda) to retrieve a specific record or customize the generated query
  # when you access the associated object.
  #
  # Scope examples:
  #   has_one :author, -> { where(comment_id: 1) }
  #   has_one :employer, -> { joins(:company) }
  #   has_one :latest_post, ->(blog) { where("created_at > ?", blog.enabled_at) }
  #
  # ==== Options
  #
  # The declaration can also include an +options+ hash to specialize the behavior of the association.
  #
  # Options are:
  # [+:class_name+]
  #   Specify the class name of the association. Use it only if that name can't be inferred
  #   from the association name. So <tt>has_one :manager</tt> will by default be linked to the Manager class, but
  #   if the real class name is Person, you'll have to specify it with this option.
  # [+:dependent+]
  #   Controls what happens to the associated object when
  #   its owner is destroyed:
  #
  #   * <tt>nil</tt> do nothing (default).
  #   * <tt>:destroy</tt> causes the associated object to also be destroyed
  #   * <tt>:destroy_async</tt> causes the associated object to be destroyed in a background job. <b>WARNING:</b> Do not use
  #     this option if the association is backed by foreign key constraints in your database. The foreign key
  #     constraint actions will occur inside the same transaction that deletes its owner.
  #   * <tt>:delete</tt> causes the associated object to be deleted directly from the database (so callbacks will not execute)
  #   * <tt>:nullify</tt> causes the foreign key to be set to +NULL+. Polymorphic type column is also nullified
  #     on polymorphic associations. Callbacks are not executed.
  #   * <tt>:restrict_with_exception</tt> causes an ActiveRecord::DeleteRestrictionError exception to be raised if there is an associated record
  #   * <tt>:restrict_with_error</tt> causes an error to be added to the owner if there is an associated object
  #
  #   Note that <tt>:dependent</tt> option is ignored when using <tt>:through</tt> option.
  # [+:foreign_key+]
  #   Specify the foreign key used for the association. By default this is guessed to be the name
  #   of this class in lower-case and "_id" suffixed. So a Person class that makes a #has_one association
  #   will use "person_id" as the default <tt>:foreign_key</tt>.
  #
  #   Setting the <tt>:foreign_key</tt> option prevents automatic detection of the association's
  #   inverse, so it is generally a good idea to set the <tt>:inverse_of</tt> option as well.
  # [+:foreign_type+]
  #   Specify the column used to store the associated object's type, if this is a polymorphic
  #   association. By default this is guessed to be the name of the polymorphic association
  #   specified on "as" option with a "_type" suffix. So a class that defines a
  #   <tt>has_one :tag, as: :taggable</tt> association will use "taggable_type" as the
  #   default <tt>:foreign_type</tt>.
  # [+:primary_key+]
  #   Specify the method that returns the primary key used for the association. By default this is +id+.
  # [+:as+]
  #   Specifies a polymorphic interface (See #belongs_to).
  # [+:through+]
  #   Specifies a Join Model through which to perform the query. Options for <tt>:class_name</tt>,
  #   <tt>:primary_key</tt>, and <tt>:foreign_key</tt> are ignored, as the association uses the
  #   source reflection. You can only use a <tt>:through</tt> query through a #has_one
  #   or #belongs_to association on the join model.
  #
  #   If the association on the join model is a #belongs_to, the collection can be modified
  #   and the records on the <tt>:through</tt> model will be automatically created and removed
  #   as appropriate. Otherwise, the collection is read-only, so you should manipulate the
  #   <tt>:through</tt> association directly.
  #
  #   If you are going to modify the association (rather than just read from it), then it is
  #   a good idea to set the <tt>:inverse_of</tt> option on the source association on the
  #   join model. This allows associated records to be built which will automatically create
  #   the appropriate join model records when they are saved. (See the 'Association Join Models'
  #   and 'Setting Inverses' sections above.)
  # [+:disable_joins+]
  #   Specifies whether joins should be skipped for an association. If set to true, two or more queries
  #   will be generated. Note that in some cases, if order or limit is applied, it will be done in-memory
  #   due to database limitations. This option is only applicable on <tt>has_one :through</tt> associations as
  #   +has_one+ alone does not perform a join.
  # [+:source+]
  #   Specifies the source association name used by #has_one <tt>:through</tt> queries.
  #   Only use it if the name cannot be inferred from the association.
  #   <tt>has_one :favorite, through: :favorites</tt> will look for a
  #   <tt>:favorite</tt> on Favorite, unless a <tt>:source</tt> is given.
  # [+:source_type+]
  #   Specifies type of the source association used by #has_one <tt>:through</tt> queries where the source
  #   association is a polymorphic #belongs_to.
  # [+:validate+]
  #   When set to +true+, validates new objects added to association when saving the parent object. +false+ by default.
  #   If you want to ensure associated objects are revalidated on every update, use +validates_associated+.
  # [+:autosave+]
  #   If true, always save the associated object or destroy it if marked for destruction,
  #   when saving the parent object. If false, never save or destroy the associated object.
  #   By default, only save the associated object if it's a new record.
  #
  #   Note that NestedAttributes::ClassMethods#accepts_nested_attributes_for sets
  #   <tt>:autosave</tt> to <tt>true</tt>.
  # [+:touch+]
  #   If true, the associated object will be touched (the +updated_at+ / +updated_on+ attributes set to current time)
  #   when this record is either saved or destroyed. If you specify a symbol, that attribute
  #   will be updated with the current time in addition to the +updated_at+ / +updated_on+ attribute.
  #   Please note that no validation will be performed when touching, and only the +after_touch+,
  #   +after_commit+, and +after_rollback+ callbacks will be executed.
  # [+:inverse_of+]
  #   Specifies the name of the #belongs_to association on the associated object
  #   that is the inverse of this #has_one association.
  #   See ActiveRecord::Associations::ClassMethods's overview on Bi-directional associations for more detail.
  # [+:required+]
  #   When set to +true+, the association will also have its presence validated.
  #   This will validate the association itself, not the id. You can use
  #   +:inverse_of+ to avoid an extra query during validation.
  # [+:strict_loading+]
  #   Enforces strict loading every time the associated record is loaded through this association.
  # [+:ensuring_owner_was+]
  #   Specifies an instance method to be called on the owner. The method must return true in order for the
  #   associated records to be deleted in a background job.
  # [+:query_constraints+]
  #   Serves as a composite foreign key. Defines the list of columns to be used to query the associated object.
  #   This is an optional option. By default Rails will attempt to derive the value automatically.
  #   When the value is set the Array size must match associated model's primary key or +query_constraints+ size.
  #
  # Option examples:
  #   has_one :credit_card, dependent: :destroy  # destroys the associated credit card
  #   has_one :credit_card, dependent: :nullify  # updates the associated records foreign
  #                                                 # key value to NULL rather than destroying it
  #   has_one :last_comment, -> { order('posted_on') }, class_name: "Comment"
  #   has_one :project_manager, -> { where(role: 'project_manager') }, class_name: "Person"
  #   has_one :attachment, as: :attachable
  #   has_one :boss, -> { readonly }
  #   has_one :club, through: :membership
  #   has_one :club, through: :membership, disable_joins: true
  #   has_one :primary_address, -> { where(primary: true) }, through: :addressables, source: :addressable
  #   has_one :credit_card, required: true
  #   has_one :credit_card, strict_loading: true
  #   has_one :employment_record_book, query_constraints: [:organization_id, :employee_id]
  #
  # source://activerecord//lib/active_record/associations.rb#1708
  def has_one(name, scope = T.unsafe(nil), **options); end
end

# = Active Record Association Collection
#
# CollectionAssociation is an abstract class that provides common stuff to
# ease the implementation of association proxies that represent
# collections. See the class hierarchy in Association.
#
#   CollectionAssociation:
#     HasManyAssociation => has_many
#       HasManyThroughAssociation + ThroughAssociation => has_many :through
#
# The CollectionAssociation class provides common methods to the collections
# defined by +has_and_belongs_to_many+, +has_many+ or +has_many+ with
# the <tt>:through association</tt> option.
#
# You need to be careful with assumptions regarding the target: The proxy
# does not fetch records from the database until it needs them, but new
# ones created with +build+ are added to the target. So, the target may be
# non-empty and still lack children waiting to be read from the database.
# If you look directly to the database you cannot assume that's the entire
# collection because new records may have been added to the target, etc.
#
# If you need to work on all current children, new and existing records,
# +load_target+ and the +loaded+ flag are your friends.
#
# source://activerecord//lib/active_record/associations/collection_association.rb#31
class ActiveRecord::Associations::CollectionAssociation < ::ActiveRecord::Associations::Association
  # source://activerecord//lib/active_record/associations/collection_association.rb#277
  def add_to_target(record, skip_callbacks: T.unsafe(nil), replace: T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#115
  def build(attributes = T.unsafe(nil), &block); end

  # Add +records+ to this association. Since +<<+ flattens its argument list
  # and inserts each record, +push+ and +concat+ behave identically.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#125
  def concat(*records); end

  # Removes +records+ from this association calling +before_remove+ and
  # +after_remove+ callbacks.
  #
  # This method is abstract in the sense that +delete_records+ has to be
  # provided by descendants. Note this method does not imply the records
  # are actually removed from the database, that depends precisely on
  # +delete_records+. They are in any case removed from the collection.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#184
  def delete(*records); end

  # Removes all records from the association without calling callbacks
  # on the associated records. It honors the +:dependent+ option. However
  # if the +:dependent+ value is +:destroy+ then in that case the +:delete_all+
  # deletion strategy for the association is applied.
  #
  # You can force a particular deletion strategy by passing a parameter.
  #
  # Example:
  #
  # @author.books.delete_all(:nullify)
  # @author.books.delete_all(:delete_all)
  #
  # See delete for more info.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#148
  def delete_all(dependent = T.unsafe(nil)); end

  # Deletes the +records+ and removes them from this association calling
  # +before_remove+, +after_remove+, +before_destroy+ and +after_destroy+ callbacks.
  #
  # Note that this method removes records from the database ignoring the
  # +:dependent+ option.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#193
  def destroy(*records); end

  # Destroy all the records from this association.
  #
  # See destroy for more info.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#170
  def destroy_all; end

  # Returns true if the collection is empty.
  #
  # If the collection has been loaded
  # it is equivalent to <tt>collection.size.zero?</tt>. If the
  # collection has not been loaded, it is equivalent to
  # <tt>!collection.exists?</tt>. If the collection has not already been
  # loaded and you are going to fetch the records anyway it is better to
  # check <tt>collection.length.zero?</tt>.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#230
  def empty?; end

  # source://activerecord//lib/active_record/associations/collection_association.rb#92
  def find(*args); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#304
  def find_from_target?; end

  # Implements the ids reader method, e.g. foo.item_ids for Foo.has_many :items
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#49
  def ids_reader; end

  # Implements the ids writer method, e.g. foo.item_ids= for Foo.has_many :items
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#60
  def ids_writer(ids); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#256
  def include?(record); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#268
  def load_target; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#300
  def null_scope?; end

  # Implements the reader method, e.g. foo.items for Foo.has_many :items
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#32
  def reader; end

  # Replace this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#240
  def replace(other_array); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#85
  def reset; end

  # source://activerecord//lib/active_record/associations/collection_association.rb#294
  def scope; end

  # Returns the size of the collection by executing a SELECT COUNT(*)
  # query if the collection hasn't been loaded, and calling
  # <tt>collection.size</tt> if it has.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  # This method is abstract in the sense that it relies on
  # +count_records+, which is a method descendants have to provide.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#207
  def size; end

  # source://activerecord//lib/active_record/associations/collection_association.rb#281
  def target=(record); end

  # Implements the writer method, e.g. foo.items= for Foo.has_many :items
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#44
  def writer(records); end

  private

  # source://activerecord//lib/active_record/associations/collection_association.rb#346
  def _create_record(attributes, raise = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#484
  def callback(method, record); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#490
  def callbacks_for(callback_name); end

  # @raise [ActiveRecord::Rollback]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#430
  def concat_records(records, raise = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#377
  def delete_or_destroy(records, method); end

  # Delete the given records from the association,
  # using one of the methods +:destroy+, +:delete_all+
  # or +:nullify+ (or +nil+, in which case a default is used).
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#406
  def delete_records(records, method); end

  # If the :inverse_of option has been
  # specified, then #find scans the entire collection.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#513
  def find_by_scan(*args); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#499
  def include_in_memory?(record); end

  # Do the relevant stuff to insert the given record into the association collection.
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#369
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil), &block); end

  # We have some records loaded from the database (persisted) and some that are
  # in-memory (memory). The same record may be represented in the persisted array
  # and in the memory array.
  #
  # So the task of this method is to merge them according to the following rules:
  #
  #   * The final array must not have duplicates
  #   * The order of the persisted array is to be preserved
  #   * Any changes made to attributes on objects in the memory array are to be preserved
  #   * Otherwise, attributes should have the value found in the database
  #
  # source://activerecord//lib/active_record/associations/collection_association.rb#327
  def merge_target_lists(persisted, memory); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#391
  def remove_records(existing_records, records, method); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#422
  def replace_common_records_in_memory(new_target, original_target); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#449
  def replace_on_target(record, skip_callbacks, replace:, inversing: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#410
  def replace_records(new_target, original_target); end

  # source://activerecord//lib/active_record/associations/collection_association.rb#313
  def transaction(&block); end
end

# = Active Record Collection Proxy
#
# Collection proxies in Active Record are middlemen between an
# <tt>association</tt>, and its <tt>target</tt> result set.
#
# For example, given
#
#   class Blog < ActiveRecord::Base
#     has_many :posts
#   end
#
#   blog = Blog.first
#
# The collection proxy returned by <tt>blog.posts</tt> is built from a
# <tt>:has_many</tt> <tt>association</tt>, and delegates to a collection
# of posts as the <tt>target</tt>.
#
# This class delegates unknown methods to the <tt>association</tt>'s
# relation class via a delegate cache.
#
# The <tt>target</tt> result set is not loaded until needed. For example,
#
#   blog.posts.count
#
# is computed directly through SQL and does not trigger by itself the
# instantiation of the actual post records.
#
# source://activerecord//lib/active_record/associations/collection_proxy.rb#31
class ActiveRecord::Associations::CollectionProxy < ::ActiveRecord::Relation
  # @return [CollectionProxy] a new instance of CollectionProxy
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#32
  def initialize(klass, association, **_arg2); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1036
  def <<(*records); end

  # Equivalent to <tt>Array#==</tt>. Returns +true+ if the two arrays
  # contain the same number of elements and if each element is equal
  # to the corresponding element in the +other+ array, otherwise returns
  # +false+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   other = person.pets.to_ary
  #
  #   person.pets == other
  #   # => true
  #
  #
  # Note that unpersisted records can still be seen as equal:
  #
  #   other = [Pet.new(id: 1), Pet.new(id: 2)]
  #
  #   person.pets == other
  #   # => true
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#967
  def ==(other); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def _select!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def and(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def and!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def annotate(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def annotate!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def annotate_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def annotate_values=(arg); end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1036
  def append(*records); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def arel(*_arg0, **_arg1, &_arg2); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#318
  def build(attributes = T.unsafe(nil), &block); end

  # --
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#724
  def calculate(operation, column_name); end

  # Equivalent to +delete_all+. The difference is that returns +self+, instead
  # of an array with the deleted objects, so methods can be chained. See
  # +delete_all+ for more information.
  # Note that because +delete_all+ removes records by directly
  # running an SQL query into the database, the +updated_at+ column of
  # the object is not changed.
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1053
  def clear; end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1036
  def concat(*records); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def construct_join_dependency(*_arg0, **_arg1, &_arg2); end

  # Returns a new object of the collection type that has been instantiated with
  # attributes, linked to this object and that has already been saved (if it
  # passes the validations).
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.create(name: 'Fancy-Fancy')
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.create([{name: 'Spook'}, {name: 'Choo-Choo'}])
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 3
  #   person.pets.count # => 3
  #
  #   person.pets.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#349
  def create(attributes = T.unsafe(nil), &block); end

  # Like #create, except that if the record is invalid, raises an exception.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   class Pet
  #     validates :name, presence: true
  #   end
  #
  #   person.pets.create!(name: nil)
  #   # => ActiveRecord::RecordInvalid: Validation failed: Name can't be blank
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#365
  def create!(attributes = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def create_with(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def create_with!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def create_with_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def create_with_value=(arg); end

  # Deletes the +records+ supplied from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy. Returns an array with the
  # deleted records.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>
  #
  # If it is set to <tt>:destroy</tt> all the +records+ are removed by calling
  # their +destroy+ method. See +destroy+ for more information.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 1
  #   person.pets
  #   # => [#<Pet id: 2, name: "Spook", person_id: 1>]
  #
  #   Pet.find(1, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the +records+ are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   Pet.find(1)
  #   # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=1
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and executes delete on them.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete("1")
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.delete(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#620
  def delete(*records); end

  # Deletes all the records from the collection according to the strategy
  # specified by the +:dependent+ option. If no +:dependent+ option is given,
  # then it will follow the default strategy.
  #
  # For <tt>has_many :through</tt> associations, the default deletion strategy is
  # +:delete_all+.
  #
  # For +has_many+ associations, the default deletion strategy is +:nullify+.
  # This sets the foreign keys to +NULL+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets # dependent: :nullify option by default
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1, 2, 3)
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: nil>,
  #   #       #<Pet id: 2, name: "Spook", person_id: nil>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: nil>
  #   #    ]
  #
  # Both +has_many+ and <tt>has_many :through</tt> dependencies default to the
  # +:delete_all+ strategy if the +:dependent+ option is set to +:destroy+.
  # Records are not instantiated and callbacks will not be fired.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :destroy
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # If it is set to <tt>:delete_all</tt>, all the objects are deleted
  # *without* calling their +destroy+ method.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets, dependent: :delete_all
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.delete_all
  #
  #   Pet.find(1, 2, 3)
  #   # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#474
  def delete_all(dependent = T.unsafe(nil)); end

  # Destroys the +records+ supplied and removes them from the collection.
  # This method will _always_ remove record from the database ignoring
  # the +:dependent+ option. Returns an array with the removed records.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(1))
  #   # => [#<Pet id: 1, name: "Fancy-Fancy", person_id: 1>]
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(Pet.find(2), Pet.find(3))
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(1, 2, 3) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (1, 2, 3)
  #
  # You can pass +Integer+ or +String+ values, it finds the records
  # responding to the +id+ and then deletes them from the database.
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy("4")
  #   # => #<Pet id: 4, name: "Benny", person_id: 1>
  #
  #   person.pets.size # => 2
  #   person.pets
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy(5, 6)
  #   # => [
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 0
  #   person.pets       # => []
  #
  #   Pet.find(4, 5, 6) # => ActiveRecord::RecordNotFound: Couldn't find all Pets with 'id': (4, 5, 6)
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#692
  def destroy(*records); end

  # Deletes the records of the collection directly from the database
  # ignoring the +:dependent+ option. Records are instantiated and it
  # invokes +before_remove+, +after_remove+, +before_destroy+, and
  # +after_destroy+ callbacks.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.destroy_all
  #
  #   person.pets.size # => 0
  #   person.pets      # => []
  #
  #   Pet.find(1) # => Couldn't find Pet with id=1
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#501
  def destroy_all; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def distinct(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def distinct!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def distinct_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def distinct_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def eager_load(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def eager_load!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def eager_load_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def eager_load_values=(arg); end

  # Returns +true+ if the collection is empty. If the collection has been
  # loaded it is equivalent
  # to <tt>collection.size.zero?</tt>. If the collection has not been loaded,
  # it is equivalent to <tt>!collection.exists?</tt>. If the collection has
  # not already been loaded and you are going to fetch the records anyway it
  # is better to check <tt>collection.load.empty?</tt>.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.count  # => 1
  #   person.pets.empty? # => false
  #
  #   person.pets.delete_all
  #
  #   person.pets.count  # => 0
  #   person.pets.empty? # => true
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#831
  def empty?; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def except(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def excluding(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def excluding!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extending(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extending!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extending_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extending_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extensions(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def extract_associated(*_arg0, **_arg1, &_arg2); end

  # Finds an object in the collection responding to the +id+. Uses the same
  # rules as ActiveRecord::FinderMethods.find. Returns ActiveRecord::RecordNotFound
  # error if the object cannot be found.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.find(1) # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #   person.pets.find(4) # => ActiveRecord::RecordNotFound: Couldn't find Pet with 'id'=4
  #
  #   person.pets.find(2) { |pet| pet.name.downcase! }
  #   # => #<Pet id: 2, name: "fancy-fancy", person_id: 1>
  #
  #   person.pets.find(2, 3)
  #   # => [
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#138
  def find(*args); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def from(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def from!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def from_clause(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def from_clause=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def group(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def group!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def group_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def group_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def having(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def having!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def having_clause(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def having_clause=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def in_order_of(*_arg0, **_arg1, &_arg2); end

  # Returns +true+ if the given +record+ is present in the collection.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # => [#<Pet id: 20, name: "Snoop">]
  #
  #   person.pets.include?(Pet.find(20)) # => true
  #   person.pets.include?(Pet.find(21)) # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#927
  def include?(record); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def includes(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def includes!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def includes_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def includes_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def insert(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def insert!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def insert_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def insert_all!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1105
  def inspect; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def invert_where(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def invert_where!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def joins!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def joins_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def joins_values=(arg); end

  # Returns the last record, or the last +n+ records, from the collection.
  # If the collection is empty, the first form returns +nil+, and the second
  # form returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.last # => #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #
  #   person.pets.last(2)
  #   # => [
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.last    # => nil
  #   another_person_without.pets.last(3) # => []
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#259
  def last(limit = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def left_joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def left_outer_joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def left_outer_joins!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def left_outer_joins_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def left_outer_joins_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def limit(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def limit!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def limit_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def limit_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def load_async(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#44
  def load_target; end

  # Returns +true+ if the association has been loaded, otherwise +false+.
  #
  #   person.pets.loaded? # => false
  #   person.pets.records
  #   person.pets.loaded? # => true
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#53
  def loaded; end

  # Returns +true+ if the association has been loaded, otherwise +false+.
  #
  #   person.pets.loaded? # => false
  #   person.pets.records
  #   person.pets.loaded? # => true
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#53
  def loaded?; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def lock(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def lock!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def lock_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def lock_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def merge(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def merge!(*_arg0, **_arg1, &_arg2); end

  # Returns a new object of the collection type that has been instantiated
  # with +attributes+ and linked to this object, but have not yet been saved.
  # You can pass an array of attributes hashes, this will return an array
  # with the new objects.
  #
  #   class Person
  #     has_many :pets
  #   end
  #
  #   person.pets.build
  #   # => #<Pet id: nil, name: nil, person_id: 1>
  #
  #   person.pets.build(name: 'Fancy-Fancy')
  #   # => #<Pet id: nil, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.build([{name: 'Spook'}, {name: 'Choo-Choo'}, {name: 'Brain'}])
  #   # => [
  #   #      #<Pet id: nil, name: "Spook", person_id: 1>,
  #   #      #<Pet id: nil, name: "Choo-Choo", person_id: 1>,
  #   #      #<Pet id: nil, name: "Brain", person_id: 1>
  #   #    ]
  #
  #   person.pets.size  # => 5 # size of the collection
  #   person.pets.count # => 0 # count from database
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#318
  def new(attributes = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def none(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def none!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def null_relation?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def offset(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def offset!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def offset_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def offset_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def only(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def optimizer_hints(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def optimizer_hints!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def optimizer_hints_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def optimizer_hints_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def or(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def or!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def order(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def order!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def order_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def order_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#728
  def pluck(*column_names); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def preload(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def preload!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def preload_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def preload_values=(arg); end

  # @raise [NoMethodError]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1043
  def prepend(*args); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1110
  def pretty_print(pp); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#931
  def proxy_association; end

  # Adds one or more +records+ to the collection by setting their foreign keys
  # to the association's primary key. Since <tt><<</tt> flattens its argument list and
  # inserts each record, +push+ and +concat+ behave identically. Returns +self+
  # so several appends may be chained together.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 0
  #   person.pets << Pet.new(name: 'Fancy-Fancy')
  #   person.pets << [Pet.new(name: 'Spook'), Pet.new(name: 'Choo-Choo')]
  #   person.pets.size # => 3
  #
  #   person.id # => 1
  #   person.pets
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #      #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1036
  def push(*records); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def readonly(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def readonly!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def readonly_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def readonly_value=(arg); end

  # :method: to_ary
  #
  # :call-seq:
  #   to_ary()
  #
  # Returns a new array of objects from the collection. If the collection
  # hasn't been loaded, it fetches the records from the database.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets = person.pets.to_ary
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  #   other_pets.replace([Pet.new(name: 'BooGoo')])
  #
  #   other_pets
  #   # => [#<Pet id: nil, name: "BooGoo", person_id: 1>]
  #
  #   person.pets
  #   # This is not affected by replace
  #   # => [
  #   #       #<Pet id: 4, name: "Benny", person_id: 1>,
  #   #       #<Pet id: 5, name: "Brain", person_id: 1>,
  #   #       #<Pet id: 6, name: "Boss",  person_id: 1>
  #   #    ]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1011
  def records; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def references(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def references!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def references_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def references_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def regroup(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def regroup!(*_arg0, **_arg1, &_arg2); end

  # Reloads the collection from the database. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reload # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1072
  def reload; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reorder(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reorder!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reordering_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reordering_value=(arg); end

  # Replaces this collection with +other_array+. This will perform a diff
  # and delete/add only records that have changed.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [#<Pet id: 1, name: "Gorby", group: "cats", person_id: 1>]
  #
  #   other_pets = [Pet.new(name: 'Puff', group: 'celebrities')]
  #
  #   person.pets.replace(other_pets)
  #
  #   person.pets
  #   # => [#<Pet id: 2, name: "Puff", group: "celebrities", person_id: 1>]
  #
  # If the supplied array has an incorrect association type, it raises
  # an ActiveRecord::AssociationTypeMismatch error:
  #
  #   person.pets.replace(["doo", "ggie", "gaga"])
  #   # => ActiveRecord::AssociationTypeMismatch: Pet expected, got String
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#391
  def replace(other_array); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reselect(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reselect!(*_arg0, **_arg1, &_arg2); end

  # Unloads the association. Returns +self+.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets # uses the pets cache
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  #   person.pets.reset # clears the pets cache
  #
  #   person.pets  # fetches pets from the database
  #   # => [#<Pet id: 1, name: "Snoop", group: "dogs", person_id: 1>]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1093
  def reset; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1099
  def reset_scope; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reverse_order(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reverse_order!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reverse_order_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def reverse_order_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def rewhere(*_arg0, **_arg1, &_arg2); end

  # Returns a Relation object for the records in this association
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#936
  def scope; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def scoping(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def select_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def select_values=(arg); end

  # Returns the size of the collection. If the collection hasn't been loaded,
  # it executes a <tt>SELECT COUNT(*)</tt> query. Else it calls <tt>collection.size</tt>.
  #
  # If the collection has been already loaded +size+ and +length+ are
  # equivalent. If not and you are going to need the records anyway
  # +length+ will take one less query. Otherwise +size+ is more efficient.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets.size # => 3
  #   # executes something like SELECT COUNT(*) FROM "pets" WHERE "pets"."person_id" = 1
  #
  #   person.pets # This will execute a SELECT * FROM query
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.size # => 3
  #   # Because the collection is already loaded, this will behave like
  #   # collection.size and no SQL count query is executed.
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#782
  def size; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def skip_preloading!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def skip_query_cache!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def skip_query_cache_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def skip_query_cache_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def spawn(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def strict_loading(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def strict_loading!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def strict_loading_value(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def strict_loading_value=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def structurally_compatible?(*_arg0, **_arg1, &_arg2); end

  # Gives a record (or N records if a parameter is supplied) from the collection
  # using the same rules as ActiveRecord::FinderMethods.take.
  #
  #   class Person < ActiveRecord::Base
  #     has_many :pets
  #   end
  #
  #   person.pets
  #   # => [
  #   #       #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #       #<Pet id: 2, name: "Spook", person_id: 1>,
  #   #       #<Pet id: 3, name: "Choo-Choo", person_id: 1>
  #   #    ]
  #
  #   person.pets.take # => #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>
  #
  #   person.pets.take(2)
  #   # => [
  #   #      #<Pet id: 1, name: "Fancy-Fancy", person_id: 1>,
  #   #      #<Pet id: 2, name: "Spook", person_id: 1>
  #   #    ]
  #
  #   another_person_without.pets         # => []
  #   another_person_without.pets.take    # => nil
  #   another_person_without.pets.take(2) # => []
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#289
  def take(limit = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#40
  def target; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def uniq!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def unscope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def unscope!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def unscope_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def unscope_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def upsert(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def upsert_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def where(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def where!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def where_clause(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def where_clause=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def with(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def with!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def with_values(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def with_values=(arg); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1124
  def without(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1145
  def exec_queries; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1141
  def find_from_target?; end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1132
  def find_nth_from_last(index); end

  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1127
  def find_nth_with_limit(index, limit); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/collection_proxy.rb#1137
  def null_scope?; end
end

# source://activerecord//lib/active_record/associations/disable_joins_association_scope.rb#5
class ActiveRecord::Associations::DisableJoinsAssociationScope < ::ActiveRecord::Associations::AssociationScope
  # source://activerecord//lib/active_record/associations/disable_joins_association_scope.rb#6
  def scope(association); end

  private

  # source://activerecord//lib/active_record/associations/disable_joins_association_scope.rb#33
  def add_constraints(reflection, key, join_ids, owner, ordered); end

  # source://activerecord//lib/active_record/associations/disable_joins_association_scope.rb#18
  def last_scope_chain(reverse_chain, owner); end
end

# source://activerecord//lib/active_record/associations/foreign_association.rb#4
module ActiveRecord::Associations::ForeignAssociation
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/foreign_association.rb#5
  def foreign_key_present?; end

  # source://activerecord//lib/active_record/associations/foreign_association.rb#13
  def nullified_owner_attributes; end

  private

  # Sets the owner attributes on the given record
  #
  # source://activerecord//lib/active_record/associations/foreign_association.rb#22
  def set_owner_attributes(record); end
end

# = Active Record Has Many Association
#
# This is the proxy that handles a has many association.
#
# If the association has a <tt>:through</tt> option further specialization
# is provided by its child HasManyThroughAssociation.
#
# source://activerecord//lib/active_record/associations/has_many_association.rb#11
class ActiveRecord::Associations::HasManyAssociation < ::ActiveRecord::Associations::CollectionAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  # source://activerecord//lib/active_record/associations/has_many_association.rb#14
  def handle_dependency; end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#61
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/associations/has_many_association.rb#143
  def _create_record(attributes, *_arg1); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#139
  def concat_records(records, *_arg1); end

  # Returns the number of records in this collection.
  #
  # If the association has a counter cache it gets that value. Otherwise
  # it will attempt to do a count via SQL, bounded to <tt>:limit</tt> if
  # there's one. Some configuration options like :group make it impossible
  # to do an SQL count, in those cases the array count will be used.
  #
  # That does not depend on whether the collection has already been loaded
  # or not. The +size+ method is the one that takes the loaded flag into
  # account and delegates to +count_records+ if needed.
  #
  # If the collection is empty the target is set to an empty array and
  # the loaded flag is set to true as well.
  #
  # source://activerecord//lib/active_record/associations/has_many_association.rb#80
  def count_records; end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#112
  def delete_count(method, scope); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#120
  def delete_or_nullify_all_records(method); end

  # Deletes the records according to the <tt>:dependent</tt> option.
  #
  # source://activerecord//lib/active_record/associations/has_many_association.rb#127
  def delete_records(records, method); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#158
  def difference(a, b); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#162
  def intersection(a, b); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#98
  def update_counter(difference, reflection = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#151
  def update_counter_if_success(saved_successfully, difference); end

  # source://activerecord//lib/active_record/associations/has_many_association.rb#104
  def update_counter_in_memory(difference, reflection = T.unsafe(nil)); end
end

# = Active Record Has Many Through Association
#
# source://activerecord//lib/active_record/associations/has_many_through_association.rb#6
class ActiveRecord::Associations::HasManyThroughAssociation < ::ActiveRecord::Associations::HasManyAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  # @return [HasManyThroughAssociation] a new instance of HasManyThroughAssociation
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#9
  def initialize(owner, reflection); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#14
  def concat(*records); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#24
  def insert_record(record, validate = T.unsafe(nil), raise = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#90
  def build_record(attributes); end

  # The through record (built with build_record) is temporarily cached
  # so that it may be reused if insert_record is subsequently called.
  #
  # However, after insert_record has been called, the cache is cleared in
  # order to allow multiple instances of the same record in an association.
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#56
  def build_through_record(record); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#37
  def concat_records(records); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#130
  def delete_or_nullify_all_records(method); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#134
  def delete_records(records, method); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#203
  def delete_through_records(records); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#171
  def difference(a, b); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#187
  def distribution(array); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#219
  def find_target; end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#177
  def intersection(a, b); end

  # NOTE - not sure that we can actually cope with inverses here
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#226
  def invertible_for?(record); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#183
  def mark_occurrence(distribution, record); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#110
  def remove_records(existing_records, records, method); end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#81
  def save_through_record(record); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#115
  def target_reflection_has_associated_record?; end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#193
  def through_records_for(record); end

  # Returns the value of attribute through_scope.
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#69
  def through_scope; end

  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#71
  def through_scope_attributes; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/has_many_through_association.rb#119
  def update_through_counter?(method); end
end

# = Active Record Has One Association
#
# source://activerecord//lib/active_record/associations/has_one_association.rb#6
class ActiveRecord::Associations::HasOneAssociation < ::ActiveRecord::Associations::SingularAssociation
  include ::ActiveRecord::Associations::ForeignAssociation

  # source://activerecord//lib/active_record/associations/has_one_association.rb#26
  def delete(method = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations/has_one_association.rb#9
  def handle_dependency; end

  private

  # source://activerecord//lib/active_record/associations/has_one_association.rb#133
  def _create_record(attributes, raise_error = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/has_one_association.rb#119
  def nullify_owner_attributes(record); end

  # source://activerecord//lib/active_record/associations/has_one_association.rb#95
  def remove_target!(method); end

  # source://activerecord//lib/active_record/associations/has_one_association.rb#59
  def replace(record, save = T.unsafe(nil)); end

  # The reason that the save param for replace is false, if for create (not just build),
  # is because the setting of the foreign keys is actually handled by the scoping when
  # the record is instantiated, and so they are set straight away and do not need to be
  # updated within replace.
  #
  # source://activerecord//lib/active_record/associations/has_one_association.rb#91
  def set_new_record(record); end

  # source://activerecord//lib/active_record/associations/has_one_association.rb#125
  def transaction_if(value, &block); end
end

# = Active Record Has One Through Association
#
# source://activerecord//lib/active_record/associations/has_one_through_association.rb#6
class ActiveRecord::Associations::HasOneThroughAssociation < ::ActiveRecord::Associations::HasOneAssociation
  include ::ActiveRecord::Associations::ThroughAssociation

  private

  # source://activerecord//lib/active_record/associations/has_one_through_association.rb#15
  def create_through_record(record, save); end

  # source://activerecord//lib/active_record/associations/has_one_through_association.rb#10
  def replace(record, save = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations/join_dependency.rb#5
class ActiveRecord::Associations::JoinDependency
  extend ::ActiveSupport::Autoload

  # @return [JoinDependency] a new instance of JoinDependency
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#71
  def initialize(base, table, associations, join_type); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#153
  def apply_column_aliases(relation); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#77
  def base_klass; end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#158
  def each(&block); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#105
  def instantiate(result_set, strict_loading_value, &block); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#85
  def join_constraints(joins_to_add, alias_tracker, references); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#81
  def reflections; end

  protected

  # Returns the value of attribute join_root.
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#163
  def join_root; end

  # Returns the value of attribute join_type.
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#163
  def join_type; end

  private

  # Returns the value of attribute alias_tracker.
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#166
  def alias_tracker; end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#168
  def aliases; end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#228
  def build(associations, base_klass); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#242
  def construct(ar_parent, parent, row, seen, model_cache, strict_loading_value); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#280
  def construct_model(record, node, row, model_cache, id, strict_loading_value); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#223
  def find_reflection(klass, name); end

  # Returns the value of attribute join_root_alias.
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#166
  def join_root_alias; end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#190
  def make_constraints(parent, child, join_type); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#184
  def make_join_constraints(join_root, join_type); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#214
  def walk(left, right, join_type); end

  class << self
    # source://activerecord//lib/active_record/associations/join_dependency.rb#47
    def make_tree(associations); end

    # source://activerecord//lib/active_record/associations/join_dependency.rb#53
    def walk_tree(associations, hash); end
  end
end

# source://activerecord//lib/active_record/associations/join_dependency.rb#13
class ActiveRecord::Associations::JoinDependency::Aliases
  # @return [Aliases] a new instance of Aliases
  #
  # source://activerecord//lib/active_record/associations/join_dependency.rb#14
  def initialize(tables); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#34
  def column_alias(node, column); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#30
  def column_aliases(node); end

  # source://activerecord//lib/active_record/associations/join_dependency.rb#26
  def columns; end
end

# source://activerecord//lib/active_record/associations/join_dependency.rb#44
class ActiveRecord::Associations::JoinDependency::Aliases::Column < ::Struct
  # Returns the value of attribute alias
  #
  # @return [Object] the current value of alias
  def alias; end

  # Sets the attribute alias
  #
  # @param value [Object] the value to set the attribute alias to.
  # @return [Object] the newly set value
  def alias=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/associations/join_dependency.rb#38
class ActiveRecord::Associations::JoinDependency::Aliases::Table < ::Struct
  # source://activerecord//lib/active_record/associations/join_dependency.rb#39
  def column_aliases; end

  # Returns the value of attribute columns
  #
  # @return [Object] the current value of columns
  def columns; end

  # Sets the attribute columns
  #
  # @param value [Object] the value to set the attribute columns to.
  # @return [Object] the newly set value
  def columns=(_); end

  # Returns the value of attribute node
  #
  # @return [Object] the current value of node
  def node; end

  # Sets the attribute node
  #
  # @param value [Object] the value to set the attribute node to.
  # @return [Object] the newly set value
  def node=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#9
class ActiveRecord::Associations::JoinDependency::JoinAssociation < ::ActiveRecord::Associations::JoinDependency::JoinPart
  # @return [JoinAssociation] a new instance of JoinAssociation
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#13
  def initialize(reflection, children); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#24
  def join_constraints(foreign_table, foreign_klass, join_type, alias_tracker); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#19
  def match?(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#78
  def readonly?; end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#10
  def reflection; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#84
  def strict_loading?; end

  # Returns the value of attribute table.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#11
  def table; end

  # Sets the attribute table
  #
  # @param value the value to set the attribute table to.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#11
  def table=(_arg0); end

  # Returns the value of attribute tables.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#10
  def tables; end

  private

  # source://activerecord//lib/active_record/associations/join_dependency/join_association.rb#91
  def append_constraints(join, constraints); end
end

# source://activerecord//lib/active_record/associations/join_dependency/join_base.rb#8
class ActiveRecord::Associations::JoinDependency::JoinBase < ::ActiveRecord::Associations::JoinDependency::JoinPart
  # @return [JoinBase] a new instance of JoinBase
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_base.rb#11
  def initialize(base_klass, table, children); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_base.rb#16
  def match?(other); end

  # Returns the value of attribute table.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_base.rb#9
  def table; end
end

# A JoinPart represents a part of a JoinDependency. It is inherited
# by JoinBase and JoinAssociation. A JoinBase represents the Active Record which
# everything else is being joined onto. A JoinAssociation represents an association which
# is joining to the base. A JoinAssociation may result in more than one actual join
# operations (for example a has_and_belongs_to_many JoinAssociation would result in
# two; one for the join table and one for the target table).
#
# source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#12
class ActiveRecord::Associations::JoinDependency::JoinPart
  include ::Enumerable

  # @return [JoinPart] a new instance of JoinPart
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#22
  def initialize(base_klass, children); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#20
  def attribute_types(*_arg0, **_arg1, &_arg2); end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#18
  def base_klass; end

  # The Active Record class which this join part is associated 'about'; for a JoinBase
  # this is the actual base model, for a JoinAssociation this is the target model of the
  # association.
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#18
  def children; end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#20
  def column_names(*_arg0, **_arg1, &_arg2); end

  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Associations::JoinDependency::JoinPart] the object that the method was called on
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#31
  def each(&block); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#36
  def each_children(&block); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#48
  def extract_record(row, column_names_with_alias); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#65
  def instantiate(row, aliases, column_types = T.unsafe(nil), &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#27
  def match?(other); end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#20
  def primary_key(*_arg0, **_arg1, &_arg2); end

  # An Arel::Table for the active_record
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#44
  def table; end

  # source://activerecord//lib/active_record/associations/join_dependency/join_part.rb#20
  def table_name(*_arg0, **_arg1, &_arg2); end
end

# = Active Record \Preloader
#
# Implements the details of eager loading of Active Record associations.
#
# Suppose that you have the following two Active Record models:
#
#   class Author < ActiveRecord::Base
#     # columns: name, age
#     has_many :books
#   end
#
#   class Book < ActiveRecord::Base
#     # columns: title, sales, author_id
#   end
#
# When you load an author with all associated books Active Record will make
# multiple queries like this:
#
#   Author.includes(:books).where(name: ['bell hooks', 'Homer']).to_a
#
#   # SELECT `authors`.* FROM `authors` WHERE `name` IN ('bell hooks', 'Homer')
#   # SELECT `books`.* FROM `books` WHERE `author_id` IN (2, 5)
#
# Active Record saves the ids of the records from the first query to use in
# the second. Depending on the number of associations involved there can be
# arbitrarily many SQL queries made.
#
# However, if there is a WHERE clause that spans across tables Active
# Record will fall back to a slightly more resource-intensive single query:
#
#   Author.includes(:books).where(books: {title: 'Illiad'}).to_a
#   # SELECT `authors`.`id` AS t0_r0, `authors`.`name` AS t0_r1, `authors`.`age` AS t0_r2,
#   #        `books`.`id`   AS t1_r0, `books`.`title`  AS t1_r1, `books`.`sales` AS t1_r2
#   # FROM `authors`
#   # LEFT OUTER JOIN `books` ON `authors`.`id` =  `books`.`author_id`
#   # WHERE `books`.`title` = 'Illiad'
#
# This could result in many rows that contain redundant data and it performs poorly at scale
# and is therefore only used when necessary.
#
# source://activerecord//lib/active_record/associations/preloader.rb#46
class ActiveRecord::Associations::Preloader
  extend ::ActiveSupport::Autoload

  # Eager loads the named associations for the given Active Record record(s).
  #
  # In this description, 'association name' shall refer to the name passed
  # to an association creation method. For example, a model that specifies
  # <tt>belongs_to :author</tt>, <tt>has_many :buyers</tt> has association
  # names +:author+ and +:buyers+.
  #
  # == Parameters
  # +records+ is an array of ActiveRecord::Base. This array needs not be flat,
  # i.e. +records+ itself may also contain arrays of records. In any case,
  # +preload_associations+ will preload all associations records by
  # flattening +records+.
  #
  # +associations+ specifies one or more associations that you want to
  # preload. It may be:
  # - a Symbol or a String which specifies a single association name. For
  #   example, specifying +:books+ allows this method to preload all books
  #   for an Author.
  # - an Array which specifies multiple association names. This array
  #   is processed recursively. For example, specifying <tt>[:avatar, :books]</tt>
  #   allows this method to preload an author's avatar as well as all of their
  #   books.
  # - a Hash which specifies multiple association names, as well as
  #   association names for the to-be-preloaded association objects. For
  #   example, specifying <tt>{ author: :avatar }</tt> will preload a
  #   book's author, as well as that author's avatar.
  #
  # +:associations+ has the same format as the arguments to
  # ActiveRecord::QueryMethods#includes. So +associations+ could look like
  # this:
  #
  #   :books
  #   [ :books, :author ]
  #   { author: :avatar }
  #   [ :books, { author: :avatar } ]
  #
  # +available_records+ is an array of ActiveRecord::Base. The Preloader
  # will try to use the objects in this array to preload the requested
  # associations before querying the database. This can save database
  # queries by reusing in-memory objects. The optimization is only applied
  # to single associations (i.e. :belongs_to, :has_one) with no scopes.
  #
  # @return [Preloader] a new instance of Preloader
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#99
  def initialize(records:, associations:, scope: T.unsafe(nil), available_records: T.unsafe(nil), associate_by_default: T.unsafe(nil)); end

  # Returns the value of attribute associate_by_default.
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#56
  def associate_by_default; end

  # Returns the value of attribute associations.
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#56
  def associations; end

  # source://activerecord//lib/active_record/associations/preloader.rb#126
  def branches; end

  # source://activerecord//lib/active_record/associations/preloader.rb#120
  def call; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#116
  def empty?; end

  # source://activerecord//lib/active_record/associations/preloader.rb#130
  def loaders; end

  # Returns the value of attribute records.
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#56
  def records; end

  # Returns the value of attribute scope.
  #
  # source://activerecord//lib/active_record/associations/preloader.rb#56
  def scope; end
end

# source://activerecord//lib/active_record/associations/preloader/association.rb#8
class ActiveRecord::Associations::Preloader::Association
  # @return [Association] a new instance of Association
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#104
  def initialize(klass, owners, reflection, preload_scope, reflection_scope, associate_by_default); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#218
  def associate_records_from_unscoped(unscoped_records); end

  # The name of the key on the associated records
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#161
  def association_key_name; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#119
  def future_classes; end

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#102
  def klass; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#197
  def load_records(raw_records = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#176
  def loaded?(owner); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#165
  def loader_query; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#169
  def owners_by_key; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#154
  def preloaded_records; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#148
  def records_by_owner; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#135
  def run; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#131
  def run?; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#127
  def runnable_loaders; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#184
  def scope; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#188
  def set_inverse(record); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#115
  def table_name; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#180
  def target_for(owner); end

  private

  # source://activerecord//lib/active_record/associations/preloader/association.rb#245
  def associate_records_to_owner(owner, records); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#281
  def association_key_type; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#293
  def build_scope; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#309
  def cascade_strict_loading(scope); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#273
  def convert_key(key); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#265
  def derive_key(owner, key); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#257
  def key_conversion_required?; end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#238
  def model; end

  # The name of the key on the model which declares the association
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#241
  def owner_key_name; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#285
  def owner_key_type; end

  # Returns the value of attribute owners.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#238
  def owners; end

  # Returns the value of attribute preload_scope.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#238
  def preload_scope; end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#238
  def reflection; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#289
  def reflection_scope; end
end

# source://activerecord//lib/active_record/associations/preloader/association.rb#9
class ActiveRecord::Associations::Preloader::Association::LoaderQuery
  # @return [LoaderQuery] a new instance of LoaderQuery
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#12
  def initialize(scope, association_key_name); end

  # Returns the value of attribute association_key_name.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#10
  def association_key_name; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#17
  def eql?(other); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#24
  def hash; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#41
  def load_records_for_keys(keys, &block); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#32
  def load_records_in_batch(loaders); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#28
  def records_for(loaders); end

  # Returns the value of attribute scope.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#10
  def scope; end
end

# source://activerecord//lib/active_record/associations/preloader/association.rb#60
class ActiveRecord::Associations::Preloader::Association::LoaderRecords
  # @return [LoaderRecords] a new instance of LoaderRecords
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#61
  def initialize(loaders, loader_query); end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#70
  def records; end

  private

  # source://activerecord//lib/active_record/associations/preloader/association.rb#97
  def already_loaded_records; end

  # Returns the value of attribute already_loaded_records_by_key.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#75
  def already_loaded_records_by_key; end

  # Returns the value of attribute keys_to_load.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#75
  def keys_to_load; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#91
  def load_records; end

  # Returns the value of attribute loader_query.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#75
  def loader_query; end

  # Returns the value of attribute loaders.
  #
  # source://activerecord//lib/active_record/associations/preloader/association.rb#75
  def loaders; end

  # source://activerecord//lib/active_record/associations/preloader/association.rb#77
  def populate_keys_to_load_and_already_loaded_records; end
end

# source://activerecord//lib/active_record/associations/preloader/batch.rb#6
class ActiveRecord::Associations::Preloader::Batch
  # @return [Batch] a new instance of Batch
  #
  # source://activerecord//lib/active_record/associations/preloader/batch.rb#7
  def initialize(preloaders, available_records:); end

  # source://activerecord//lib/active_record/associations/preloader/batch.rb#12
  def call; end

  private

  # source://activerecord//lib/active_record/associations/preloader/batch.rb#40
  def group_and_load_similar(loaders); end

  # Returns the value of attribute loaders.
  #
  # source://activerecord//lib/active_record/associations/preloader/batch.rb#38
  def loaders; end
end

# source://activerecord//lib/active_record/associations/preloader/branch.rb#6
class ActiveRecord::Associations::Preloader::Branch
  # @return [Branch] a new instance of Branch
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#11
  def initialize(association:, children:, parent:, associate_by_default:, scope:); end

  # Returns the value of attribute associate_by_default.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#8
  def associate_by_default; end

  # Returns the value of attribute association.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#7
  def association; end

  # Returns the value of attribute children.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#7
  def children; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#66
  def done?; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#21
  def future_classes; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#74
  def grouped_records; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#25
  def immediate_future_classes; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#47
  def likely_reflections; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#112
  def loaders; end

  # Returns the value of attribute parent.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#7
  def parent; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#102
  def polymorphic?; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#62
  def preloaded_records; end

  # Sets the attribute preloaded_records
  #
  # @param value the value to set the attribute preloaded_records to.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#9
  def preloaded_records=(_arg0); end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#85
  def preloaders_for_reflection(reflection, reflection_records); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#54
  def root?; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#70
  def runnable_loaders; end

  # Returns the value of attribute scope.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#8
  def scope; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#58
  def source_records; end

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#37
  def target_classes; end

  private

  # source://activerecord//lib/active_record/associations/preloader/branch.rb#120
  def build_children(children); end

  # Returns a class containing the logic needed to load preload the data
  # and attach it to a relation. The class returned implements a `run` method
  # that accepts a preloader.
  #
  # source://activerecord//lib/active_record/associations/preloader/branch.rb#137
  def preloader_for(reflection); end
end

# source://activerecord//lib/active_record/associations/preloader/through_association.rb#6
class ActiveRecord::Associations::Preloader::ThroughAssociation < ::ActiveRecord::Associations::Preloader::Association
  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#51
  def future_classes; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#7
  def preloaded_records; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#11
  def records_by_owner; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#41
  def runnable_loaders; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#67
  def data_available?; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#76
  def middle_records; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#100
  def preload_index; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#72
  def source_preloaders; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#92
  def source_records_by_owner; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#88
  def source_reflection; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#80
  def through_preloaders; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#96
  def through_records_by_owner; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#84
  def through_reflection; end

  # source://activerecord//lib/active_record/associations/preloader/through_association.rb#106
  def through_scope; end
end

# source://activerecord//lib/active_record/associations/singular_association.rb#6
class ActiveRecord::Associations::SingularAssociation < ::ActiveRecord::Associations::Association
  # source://activerecord//lib/active_record/associations/singular_association.rb#22
  def build(attributes = T.unsafe(nil), &block); end

  # Implements the reload reader method, e.g. foo.reload_bar for
  # Foo.has_one :bar
  #
  # source://activerecord//lib/active_record/associations/singular_association.rb#30
  def force_reload_reader; end

  # Implements the reader method, e.g. foo.bar for Foo.has_one :bar
  #
  # source://activerecord//lib/active_record/associations/singular_association.rb#7
  def reader; end

  # Implements the writer method, e.g. foo.bar= for Foo.belongs_to :bar
  #
  # source://activerecord//lib/active_record/associations/singular_association.rb#18
  def writer(record); end

  private

  # @raise [RecordInvalid]
  #
  # source://activerecord//lib/active_record/associations/singular_association.rb#56
  def _create_record(attributes, raise_error = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/associations/singular_association.rb#40
  def find_target; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/associations/singular_association.rb#48
  def replace(record); end

  # source://activerecord//lib/active_record/associations/singular_association.rb#36
  def scope_for_create; end

  # source://activerecord//lib/active_record/associations/singular_association.rb#52
  def set_new_record(record); end
end

# = Active Record Through Association
#
# source://activerecord//lib/active_record/associations/through_association.rb#6
module ActiveRecord::Associations::ThroughAssociation
  # source://activerecord//lib/active_record/associations/through_association.rb#7
  def source_reflection(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/associations/through_association.rb#116
  def build_record(attributes); end

  # Construct attributes for :through pointing to owner and associate. This is used by the
  # methods which create and delete records on the association.
  #
  # We only support indirectly modifying through associations which have a belongs_to source.
  # This is the "has_many :tags, through: :taggings" situation, where the join model
  # typically has a belongs_to on both side. In other words, associations which could also
  # be represented as has_and_belongs_to_many associations.
  #
  # We do not support creating/deleting records on the association where the source has
  # some other type, because this opens up a whole can of worms, and in basically any
  # situation it is more natural for the user to just create or modify their join records
  # directly as required.
  #
  # source://activerecord//lib/active_record/associations/through_association.rb#57
  def construct_join_attributes(*records); end

  # source://activerecord//lib/active_record/associations/through_association.rb#96
  def ensure_mutable; end

  # source://activerecord//lib/active_record/associations/through_association.rb#106
  def ensure_not_nested; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/associations/through_association.rb#90
  def foreign_key_present?; end

  # Note: this does not capture all cases, for example it would be impractical
  # to try to properly support stale-checking for nested associations.
  #
  # source://activerecord//lib/active_record/associations/through_association.rb#82
  def stale_state; end

  # We merge in these scopes for two reasons:
  #
  #   1. To get the default_scope conditions for any of the other reflections in the chain
  #   2. To get the type conditions for any STI models in the chain
  #
  # source://activerecord//lib/active_record/associations/through_association.rb#34
  def target_scope; end

  # source://activerecord//lib/active_record/associations/through_association.rb#26
  def through_association; end

  # source://activerecord//lib/active_record/associations/through_association.rb#14
  def through_reflection; end

  # source://activerecord//lib/active_record/associations/through_association.rb#10
  def transaction(&block); end
end

# source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#4
class ActiveRecord::AsynchronousQueriesTracker
  # @return [AsynchronousQueriesTracker] a new instance of AsynchronousQueriesTracker
  #
  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#46
  def initialize; end

  # Returns the value of attribute current_session.
  #
  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#44
  def current_session; end

  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#55
  def finalize_session; end

  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#50
  def start_session; end

  class << self
    # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#39
    def complete(asynchronous_queries_tracker); end

    # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#31
    def install_executor_hooks(executor = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#35
    def run; end
  end
end

# source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#5
module ActiveRecord::AsynchronousQueriesTracker::NullSession
  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#7
    def active?; end

    # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#11
    def finalize; end
  end
end

# source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#16
class ActiveRecord::AsynchronousQueriesTracker::Session
  # @return [Session] a new instance of Session
  #
  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#17
  def initialize; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#21
  def active?; end

  # source://activerecord//lib/active_record/asynchronous_queries_tracker.rb#25
  def finalize; end
end

# AsynchronousQueryInsideTransactionError will be raised when attempting
# to perform an asynchronous query from inside a transaction
#
# source://activerecord//lib/active_record/errors.rb#509
class ActiveRecord::AsynchronousQueryInsideTransactionError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/attribute_assignment.rb#4
module ActiveRecord::AttributeAssignment
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment

  private

  # source://activerecord//lib/active_record/attribute_assignment.rb#8
  def _assign_attributes(attributes); end

  # Instantiates objects for all attribute classes that needs more than one constructor parameter. This is done
  # by calling new on the column type or aggregation type (through composed_of) object with these parameters.
  # So having the pairs written_on(1) = "2004", written_on(2) = "6", written_on(3) = "24", will instantiate
  # written_on (a date type) with Date.new("2004", "6", "24"). You can also specify a typecast character in the
  # parentheses to have the parameters typecasted before they're used in the constructor. Use i for Integer and
  # f for Float. If all the values for a given attribute are empty, the attribute will be set to +nil+.
  #
  # source://activerecord//lib/active_record/attribute_assignment.rb#38
  def assign_multiparameter_attributes(pairs); end

  # Assign any deferred nested attributes after the base attributes have been set.
  #
  # source://activerecord//lib/active_record/attribute_assignment.rb#28
  def assign_nested_parameter_attributes(pairs); end

  # source://activerecord//lib/active_record/attribute_assignment.rb#44
  def execute_callstack_for_multiparameter_attributes(callstack); end

  # source://activerecord//lib/active_record/attribute_assignment.rb#62
  def extract_callstack_for_multiparameter_attributes(pairs); end

  # source://activerecord//lib/active_record/attribute_assignment.rb#80
  def find_parameter_position(multiparameter_name); end

  # source://activerecord//lib/active_record/attribute_assignment.rb#76
  def type_cast_attribute_value(multiparameter_name, value); end
end

# Raised when an error occurred while doing a mass assignment to an attribute through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
# The exception has an +attribute+ property that is the name of the offending attribute.
#
# source://activerecord//lib/active_record/errors.rb#422
class ActiveRecord::AttributeAssignmentError < ::ActiveRecord::ActiveRecordError
  # @return [AttributeAssignmentError] a new instance of AttributeAssignmentError
  #
  # source://activerecord//lib/active_record/errors.rb#425
  def initialize(message = T.unsafe(nil), exception = T.unsafe(nil), attribute = T.unsafe(nil)); end

  # Returns the value of attribute attribute.
  #
  # source://activerecord//lib/active_record/errors.rb#423
  def attribute; end

  # Returns the value of attribute exception.
  #
  # source://activerecord//lib/active_record/errors.rb#423
  def exception; end
end

# = Active Record Attribute Methods
#
# source://activerecord//lib/active_record/attribute_methods.rb#8
module ActiveRecord::AttributeMethods
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods

  # Returns the value of the attribute identified by +attr_name+ after it has
  # been type cast. (For information about specific type casting behavior, see
  # the types under ActiveModel::Type.)
  #
  #   class Person < ActiveRecord::Base
  #     belongs_to :organization
  #   end
  #
  #   person = Person.new(name: "Francesco", date_of_birth: "2004-12-12")
  #   person[:name]            # => "Francesco"
  #   person[:date_of_birth]   # => Date.new(2004, 12, 12)
  #   person[:organization_id] # => nil
  #
  # Raises ActiveModel::MissingAttributeError if the attribute is missing.
  # Note, however, that the +id+ attribute will never be considered missing.
  #
  #   person = Person.select(:name).first
  #   person[:name]            # => "Francesco"
  #   person[:date_of_birth]   # => ActiveModel::MissingAttributeError: missing attribute 'date_of_birth' for Person
  #   person[:organization_id] # => ActiveModel::MissingAttributeError: missing attribute 'organization_id' for Person
  #   person[:id]              # => nil
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#412
  def [](attr_name); end

  # Updates the attribute identified by +attr_name+ using the specified
  # +value+. The attribute value will be type cast upon being read.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person[:date_of_birth] = "2004-12-12"
  #   person[:date_of_birth] # => Date.new(2004, 12, 12)
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#425
  def []=(attr_name, value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#319
  def _has_attribute?(attr_name); end

  # Returns the name of all database fields which have been read from this
  # model. This can be useful in development mode to determine which fields
  # need to be selected. For performance critical pages, selecting only the
  # required fields can be an easy performance win (assuming you aren't using
  # all of the fields on the model).
  #
  # For example:
  #
  #   class PostsController < ActionController::Base
  #     after_action :print_accessed_fields, only: :index
  #
  #     def index
  #       @posts = Post.all
  #     end
  #
  #     private
  #       def print_accessed_fields
  #         p @posts.first.accessed_fields
  #       end
  #   end
  #
  # Which allows you to quickly change your code to:
  #
  #   class PostsController < ActionController::Base
  #     def index
  #       @posts = Post.select(:id, :title, :author_id, :updated_at)
  #     end
  #   end
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#457
  def accessed_fields; end

  # Returns an <tt>#inspect</tt>-like string for the value of the
  # attribute +attr_name+. String attributes are truncated up to 50
  # characters. Other attributes return the value of <tt>#inspect</tt>
  # without modification.
  #
  #   person = Person.create!(name: 'David Heinemeier Hansson ' * 3)
  #
  #   person.attribute_for_inspect(:name)
  #   # => "\"David Heinemeier Hansson David Heinemeier Hansson ...\""
  #
  #   person.attribute_for_inspect(:created_at)
  #   # => "\"2012-10-22 00:15:07.000000000 +0000\""
  #
  #   person.attribute_for_inspect(:tag_ids)
  #   # => "[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]"
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#362
  def attribute_for_inspect(attr_name); end

  # Returns an array of names for the attributes available on this object.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#331
  def attribute_names; end

  # Returns +true+ if the specified +attribute+ has been set by the user or by a
  # database load and is neither +nil+ nor <tt>empty?</tt> (the latter only applies
  # to objects that respond to <tt>empty?</tt>, most notably Strings). Otherwise, +false+.
  # Note that it always returns +true+ with boolean attributes.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: '', is_done: false)
  #   task.attribute_present?(:title)   # => false
  #   task.attribute_present?(:is_done) # => true
  #   task.title = 'Buy milk'
  #   task.is_done = true
  #   task.attribute_present?(:title)   # => true
  #   task.attribute_present?(:is_done) # => true
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#384
  def attribute_present?(attr_name); end

  # Returns a hash of all the attributes with their names as keys and the values of the attributes as values.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.create(name: 'Francesco', age: 22)
  #   person.attributes
  #   # => {"id"=>3, "created_at"=>Sun, 21 Oct 2012 04:53:04, "updated_at"=>Sun, 21 Oct 2012 04:53:04, "name"=>"Francesco", "age"=>22}
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#343
  def attributes; end

  # Returns +true+ if the given attribute is in the attributes hash, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #     alias_attribute :new_name, :name
  #   end
  #
  #   person = Person.new
  #   person.has_attribute?(:name)     # => true
  #   person.has_attribute?(:new_name) # => true
  #   person.has_attribute?('age')     # => true
  #   person.has_attribute?(:nothing)  # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#313
  def has_attribute?(attr_name); end

  # A Person object with a name attribute can ask <tt>person.respond_to?(:name)</tt>,
  # <tt>person.respond_to?(:name=)</tt>, and <tt>person.respond_to?(:name?)</tt>
  # which will all return +true+. It also defines the attribute methods if they have
  # not been generated.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.respond_to?(:name)    # => true
  #   person.respond_to?(:name=)   # => true
  #   person.respond_to?(:name?)   # => true
  #   person.respond_to?('age')    # => true
  #   person.respond_to?('age=')   # => true
  #   person.respond_to?('age?')   # => true
  #   person.respond_to?(:nothing) # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#286
  def respond_to?(name, include_private = T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#462
  def attribute_method?(attr_name); end

  # Filters out the virtual columns and also primary keys, from the attribute names, when the primary
  # key is to be generated (e.g. the id attribute has no value).
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#483
  def attributes_for_create(attribute_names); end

  # Filters the primary keys, readonly attributes and virtual columns from the attribute names.
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#472
  def attributes_for_update(attribute_names); end

  # source://activerecord//lib/active_record/attribute_methods.rb#467
  def attributes_with_values(attribute_names); end

  # source://activerecord//lib/active_record/attribute_methods.rb#491
  def format_for_inspect(name, value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#507
  def pk_attribute?(name); end

  class << self
    # source://activerecord//lib/active_record/attribute_methods.rb#31
    def dangerous_attribute_methods; end
  end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_patterns; end
    def attribute_method_patterns=(value); end
    def attribute_method_patterns?; end
    def default_column_serializer; end
    def default_column_serializer=(value); end
    def default_column_serializer?; end
    def partial_inserts; end
    def partial_inserts=(value); end
    def partial_inserts?; end
    def partial_updates; end
    def partial_updates=(value); end
    def partial_updates?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes=(value); end
    def time_zone_aware_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_patterns; end
    def attribute_method_patterns?; end
    def partial_inserts; end
    def partial_inserts?; end
    def partial_updates; end
    def partial_updates?; end
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

# = Active Record Attribute Methods Before Type Cast
#
# ActiveRecord::AttributeMethods::BeforeTypeCast provides a way to
# read the value of the attributes before typecasting and deserialization.
#
#   class Task < ActiveRecord::Base
#   end
#
#   task = Task.new(id: '1', completed_on: '2012-10-21')
#   task.id           # => 1
#   task.completed_on # => Sun, 21 Oct 2012
#
#   task.attributes_before_type_cast
#   # => {"id"=>"1", "completed_on"=>"2012-10-21", ... }
#   task.read_attribute_before_type_cast('id')           # => "1"
#   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
#
# In addition to #read_attribute_before_type_cast and #attributes_before_type_cast,
# it declares a method for all attributes with the <tt>*_before_type_cast</tt>
# suffix.
#
#   task.id_before_type_cast           # => "1"
#   task.completed_on_before_type_cast # => "2012-10-21"
#
# source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#28
module ActiveRecord::AttributeMethods::BeforeTypeCast
  extend ::ActiveSupport::Concern

  # Returns a hash of attributes before typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(title: nil, is_done: true, completed_on: '2012-10-21')
  #   task.attributes
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>Sun, 21 Oct 2012, "created_at"=>nil, "updated_at"=>nil}
  #   task.attributes_before_type_cast
  #   # => {"id"=>nil, "title"=>nil, "is_done"=>true, "completed_on"=>"2012-10-21", "created_at"=>nil, "updated_at"=>nil}
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#82
  def attributes_before_type_cast; end

  # Returns a hash of attributes for assignment to the database.
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#87
  def attributes_for_database; end

  # Returns the value of the attribute identified by +attr_name+ before
  # typecasting and deserialization.
  #
  #   class Task < ActiveRecord::Base
  #   end
  #
  #   task = Task.new(id: '1', completed_on: '2012-10-21')
  #   task.read_attribute('id')                            # => 1
  #   task.read_attribute_before_type_cast('id')           # => '1'
  #   task.read_attribute('completed_on')                  # => Sun, 21 Oct 2012
  #   task.read_attribute_before_type_cast('completed_on') # => "2012-10-21"
  #   task.read_attribute_before_type_cast(:completed_on)  # => "2012-10-21"
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#48
  def read_attribute_before_type_cast(attr_name); end

  # Returns the value of the attribute identified by +attr_name+ after
  # serialization.
  #
  #   class Book < ActiveRecord::Base
  #     enum :status, { draft: 1, published: 2 }
  #   end
  #
  #   book = Book.new(status: "published")
  #   book.read_attribute(:status)              # => "published"
  #   book.read_attribute_for_database(:status) # => 2
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#65
  def read_attribute_for_database(attr_name); end

  private

  # Dispatch target for <tt>*_before_type_cast</tt> attribute methods.
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#93
  def attribute_before_type_cast(attr_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#101
  def attribute_came_from_user?(attr_name); end

  # source://activerecord//lib/active_record/attribute_methods/before_type_cast.rb#97
  def attribute_for_database(attr_name); end
end

# source://activerecord//lib/active_record/attribute_methods.rb#42
module ActiveRecord::AttributeMethods::ClassMethods
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#255
  def _has_attribute?(attr_name); end

  # source://activerecord//lib/active_record/attribute_methods.rb#53
  def alias_attribute(new_name, old_name); end

  # source://activerecord//lib/active_record/attribute_methods.rb#85
  def alias_attribute_method_definition(code_generator, pattern, new_name, old_name); end

  # Returns +true+ if +attribute+ is an attribute method and table exists,
  # +false+ otherwise.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_method?('name')   # => true
  #   Person.attribute_method?(:age=)    # => true
  #   Person.attribute_method?(:nothing) # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#219
  def attribute_method?(attribute); end

  # Returns an array of column names as strings if it's not an abstract class and
  # table exists. Otherwise it returns an empty array.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   Person.attribute_names
  #   # => ["id", "created_at", "updated_at", "name", "age"]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#231
  def attribute_names; end

  # A method name is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'save' is.)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#178
  def dangerous_attribute_method?(name); end

  # A class method is 'dangerous' if it is already (re)defined by Active Record, but
  # not by any ancestors. (So 'puts' is not dangerous but 'new' is.)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#196
  def dangerous_class_method?(method_name); end

  # Generates all the attribute related methods for columns in the database
  # accessors, mutators and query methods.
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#126
  def define_attribute_methods; end

  # source://activerecord//lib/active_record/attribute_methods.rb#63
  def eagerly_generate_alias_attribute_methods(_new_name, _old_name); end

  # source://activerecord//lib/active_record/attribute_methods.rb#67
  def generate_alias_attributes; end

  # Returns true if the given attribute exists, otherwise false.
  #
  #   class Person < ActiveRecord::Base
  #     alias_attribute :new_name, :name
  #   end
  #
  #   Person.has_attribute?('name')     # => true
  #   Person.has_attribute?('new_name') # => true
  #   Person.has_attribute?(:age)       # => true
  #   Person.has_attribute?(:nothing)   # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#249
  def has_attribute?(attr_name); end

  # source://activerecord//lib/active_record/attribute_methods.rb#43
  def initialize_generated_modules; end

  # Raises an ActiveRecord::DangerousAttributeError exception when an
  # \Active \Record method is defined in the model, otherwise +false+.
  #
  #   class Person < ActiveRecord::Base
  #     def save
  #       'already defined by Active Record'
  #     end
  #   end
  #
  #   Person.instance_method_already_implemented?(:save)
  #   # => ActiveRecord::DangerousAttributeError: save is defined by Active Record. Check to make sure that you don't have an attribute or method with the same name.
  #
  #   Person.instance_method_already_implemented?(:name)
  #   # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#160
  def instance_method_already_implemented?(method_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods.rb#182
  def method_defined_within?(name, klass, superklass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/attribute_methods.rb#138
  def undefine_attribute_methods; end

  private

  # source://activerecord//lib/active_record/attribute_methods.rb#260
  def inherited(child_class); end
end

# = Active Record Attribute Methods \Dirty
#
# Provides a way to track changes in your Active Record models. It adds all
# methods from ActiveModel::Dirty and adds database-specific methods.
#
# A newly created +Person+ object is unchanged:
#
#   class Person < ActiveRecord::Base
#   end
#
#   person = Person.create(name: "Allison")
#   person.changed? # => false
#
# Change the name:
#
#   person.name = 'Alice'
#   person.name_in_database          # => "Allison"
#   person.will_save_change_to_name? # => true
#   person.name_change_to_be_saved   # => ["Allison", "Alice"]
#   person.changes_to_save           # => {"name"=>["Allison", "Alice"]}
#
# Save the changes:
#
#   person.save
#   person.name_in_database        # => "Alice"
#   person.saved_change_to_name?   # => true
#   person.saved_change_to_name    # => ["Allison", "Alice"]
#   person.name_before_last_change # => "Allison"
#
# Similar to ActiveModel::Dirty, methods can be invoked as
# +saved_change_to_name?+ or by passing an argument to the generic method
# <tt>saved_change_to_attribute?("name")</tt>.
#
# source://activerecord//lib/active_record/attribute_methods/dirty.rb#39
module ActiveRecord::AttributeMethods::Dirty
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::AttributeMethods
  include ::ActiveModel::Dirty

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::AttributeMethods::ClassMethods

  # Returns the original value of an attribute before the last save.
  #
  # This method is useful in after callbacks to get the original value of an
  # attribute before the save that triggered the callbacks to run. It can be
  # invoked as +name_before_last_save+ instead of
  # <tt>attribute_before_last_save("name")</tt>.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#108
  def attribute_before_last_save(attr_name); end

  # Returns the change to an attribute that will be persisted during the
  # next save.
  #
  # This method is useful in validations and before callbacks, to see the
  # change to an attribute that will occur when the record is saved. It can
  # be invoked as +name_change_to_be_saved+ instead of
  # <tt>attribute_change_to_be_saved("name")</tt>.
  #
  # If the attribute will change, the result will be an array containing the
  # original value and the new value about to be saved.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#152
  def attribute_change_to_be_saved(attr_name); end

  # Returns the value of an attribute in the database, as opposed to the
  # in-memory value that will be persisted the next time the record is
  # saved.
  #
  # This method is useful in validations and before callbacks, to see the
  # original value of an attribute prior to any changes about to be
  # saved. It can be invoked as +name_in_database+ instead of
  # <tt>attribute_in_database("name")</tt>.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#164
  def attribute_in_database(attr_name); end

  # Returns a hash of the attributes that will change when the record is
  # next saved.
  #
  # The hash keys are the attribute names, and the hash values are the
  # original attribute values in the database (as opposed to the in-memory
  # values about to be saved).
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#191
  def attributes_in_database; end

  # Returns an array of the names of any attributes that will change when
  # the record is next saved.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#181
  def changed_attribute_names_to_save; end

  # Returns a hash containing all the changes that will be persisted during
  # the next save.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#175
  def changes_to_save; end

  # Will the next call to +save+ have any changes to persist?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#169
  def has_changes_to_save?; end

  # <tt>reload</tt> the record and clears changed attributes.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#63
  def reload(*_arg0); end

  # Returns the change to an attribute during the last save. If the
  # attribute was changed, the result will be an array containing the
  # original value and the saved value.
  #
  # This method is useful in after callbacks, to see the change in an
  # attribute during the save that triggered the callbacks to run. It can be
  # invoked as +saved_change_to_name+ instead of
  # <tt>saved_change_to_attribute("name")</tt>.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#98
  def saved_change_to_attribute(attr_name); end

  # Did this attribute change when we last saved?
  #
  # This method is useful in after callbacks to determine if an attribute
  # was changed during the save that triggered the callbacks to run. It can
  # be invoked as +saved_change_to_name?+ instead of
  # <tt>saved_change_to_attribute?("name")</tt>.
  #
  # ==== Options
  #
  # [+from+]
  #   When specified, this method will return false unless the original
  #   value is equal to the given value.
  #
  # [+to+]
  #   When specified, this method will return false unless the value will be
  #   changed to the given value.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#86
  def saved_change_to_attribute?(attr_name, **options); end

  # Returns a hash containing all the changes that were just saved.
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#118
  def saved_changes; end

  # Did the last call to +save+ have any changes to change?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#113
  def saved_changes?; end

  # Will this attribute change the next time we save?
  #
  # This method is useful in validations and before callbacks to determine
  # if the next call to +save+ will change a particular attribute. It can be
  # invoked as +will_save_change_to_name?+ instead of
  # <tt>will_save_change_to_attribute?("name")</tt>.
  #
  # ==== Options
  #
  # [+from+]
  #   When specified, this method will return false unless the original
  #   value is equal to the given value.
  #
  # [+to+]
  #   When specified, this method will return false unless the value will be
  #   changed to the given value.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#138
  def will_save_change_to_attribute?(attr_name, **options); end

  private

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#239
  def _create_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#204
  def _touch_row(attribute_names, time); end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#233
  def _update_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#249
  def attribute_names_for_partial_inserts; end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#245
  def attribute_names_for_partial_updates; end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#196
  def init_internals; end

  module GeneratedClassMethods
    def attribute_aliases; end
    def attribute_aliases=(value); end
    def attribute_aliases?; end
    def attribute_method_patterns; end
    def attribute_method_patterns=(value); end
    def attribute_method_patterns?; end
    def partial_inserts; end
    def partial_inserts=(value); end
    def partial_inserts?; end
    def partial_updates; end
    def partial_updates=(value); end
    def partial_updates?; end
  end

  module GeneratedInstanceMethods
    def attribute_aliases; end
    def attribute_aliases?; end
    def attribute_method_patterns; end
    def attribute_method_patterns?; end
    def partial_inserts; end
    def partial_inserts?; end
    def partial_updates; end
    def partial_updates?; end
  end
end

# source://activerecord//lib/active_record/attribute_methods.rb#26
class ActiveRecord::AttributeMethods::GeneratedAttributeMethods < ::Module
  include ::Mutex_m

  # source://mutex_m/0.2.0/mutex_m.rb#91
  def lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#81
  def locked?; end

  # source://mutex_m/0.2.0/mutex_m.rb#76
  def synchronize(&block); end

  # source://mutex_m/0.2.0/mutex_m.rb#86
  def try_lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#96
  def unlock; end
end

# = Active Record Attribute Methods Primary Key
#
# source://activerecord//lib/active_record/attribute_methods/primary_key.rb#8
module ActiveRecord::AttributeMethods::PrimaryKey
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods

  # Returns the primary key column's value. If the primary key is composite,
  # returns an array of the primary key column values.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#20
  def id; end

  # Sets the primary key column's value. If the primary key is composite,
  # raises TypeError when the set value not enumerable.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#34
  def id=(value); end

  # Queries the primary key column's value. If the primary key is composite,
  # all primary key column values must be queryable.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#45
  def id?; end

  # Returns the primary key column's value before type cast. If the primary key is composite,
  # returns an array of primary key column values before type cast.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#55
  def id_before_type_cast; end

  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#83
  def id_for_database; end

  # Returns the primary key column's value from the database. If the primary key is composite,
  # returns an array of primary key column values from database.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#75
  def id_in_database; end

  # Returns the primary key column's previous value. If the primary key is composite,
  # returns an array of primary key column previous values.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#65
  def id_was; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#26
  def primary_key_values_present?; end

  # Returns this record's primary key value wrapped in an array if one is
  # available.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#13
  def to_key; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#92
  def attribute_method?(attr_name); end
end

# source://activerecord//lib/active_record/attribute_methods/primary_key.rb#96
module ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#118
  def composite_primary_key?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#104
  def dangerous_attribute_method?(method_name); end

  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#136
  def get_primary_key(base_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#100
  def instance_method_already_implemented?(method_name); end

  # Defines the primary key field -- can be overridden in subclasses.
  # Overwriting will negate any effect of the +primary_key_prefix_type+
  # setting, though.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#111
  def primary_key; end

  # Sets the name of the primary key column.
  #
  #   class Project < ActiveRecord::Base
  #     self.primary_key = 'sysid'
  #   end
  #
  # You can also define the #primary_key method yourself:
  #
  #   class Project < ActiveRecord::Base
  #     def self.primary_key
  #       'foo_' + super
  #     end
  #   end
  #
  #   Project.primary_key # => "foo_id"
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#165
  def primary_key=(value); end

  # Returns a quoted version of the primary key name, used to construct
  # SQL statements.
  #
  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#124
  def quoted_primary_key; end

  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#128
  def reset_primary_key; end

  private

  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#172
  def derive_primary_key(value); end

  # source://activerecord//lib/active_record/attribute_methods/primary_key.rb#180
  def inherited(base); end
end

# source://activerecord//lib/active_record/attribute_methods/primary_key.rb#97
ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods::ID_ATTRIBUTE_METHODS = T.let(T.unsafe(nil), Set)

# source://activerecord//lib/active_record/attribute_methods/primary_key.rb#98
ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods::PRIMARY_KEY_NOT_SET = T.let(T.unsafe(nil), BasicObject)

# = Active Record Attribute Methods \Query
#
# source://activerecord//lib/active_record/attribute_methods/query.rb#6
module ActiveRecord::AttributeMethods::Query
  extend ::ActiveSupport::Concern

  # source://activerecord//lib/active_record/attribute_methods/query.rb#19
  def _query_attribute(attr_name); end

  # source://activerecord//lib/active_record/attribute_methods/query.rb#13
  def query_attribute(attr_name); end

  private

  # source://activerecord//lib/active_record/attribute_methods/query.rb#13
  def attribute?(attr_name); end

  # source://activerecord//lib/active_record/attribute_methods/query.rb#29
  def query_cast_attribute(attr_name, value); end
end

# source://activerecord//lib/active_record/attribute_methods.rb#24
ActiveRecord::AttributeMethods::RESTRICTED_CLASS_METHODS = T.let(T.unsafe(nil), Array)

# = Active Record Attribute Methods \Read
#
# source://activerecord//lib/active_record/attribute_methods/read.rb#6
module ActiveRecord::AttributeMethods::Read
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Read::ClassMethods

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the read_attribute API
  #
  # source://activerecord//lib/active_record/attribute_methods/read.rb#50
  def _read_attribute(attr_name, &block); end

  # Returns the value of the attribute identified by +attr_name+ after it
  # has been type cast. For example, a date attribute will cast "2004-12-12"
  # to <tt>Date.new(2004, 12, 12)</tt>. (For information about specific type
  # casting behavior, see the types under ActiveModel::Type.)
  #
  # source://activerecord//lib/active_record/attribute_methods/read.rb#29
  def read_attribute(attr_name, &block); end

  private

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the read_attribute API
  #
  # source://activerecord//lib/active_record/attribute_methods/read.rb#50
  def attribute(attr_name, &block); end
end

# source://activerecord//lib/active_record/attribute_methods/read.rb#9
module ActiveRecord::AttributeMethods::Read::ClassMethods
  private

  # source://activerecord//lib/active_record/attribute_methods/read.rb#11
  def define_method_attribute(name, owner:); end
end

# = Active Record Attribute Methods \Serialization
#
# source://activerecord//lib/active_record/attribute_methods/serialization.rb#6
module ActiveRecord::AttributeMethods::Serialization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Serialization::ClassMethods

  module GeneratedClassMethods
    def default_column_serializer; end
    def default_column_serializer=(value); end
    def default_column_serializer?; end
  end

  module GeneratedInstanceMethods; end
end

# source://activerecord//lib/active_record/attribute_methods/serialization.rb#23
module ActiveRecord::AttributeMethods::Serialization::ClassMethods
  # If you have an attribute that needs to be saved to the database as a
  # serialized object, and retrieved by deserializing into the same object,
  # then specify the name of that attribute using this method and serialization
  # will be handled automatically.
  #
  # The serialization format may be YAML, JSON, or any custom format using a
  # custom coder class.
  #
  # Keep in mind that database adapters handle certain serialization tasks
  # for you. For instance: +json+ and +jsonb+ types in PostgreSQL will be
  # converted between JSON object/array syntax and Ruby +Hash+ or +Array+
  # objects transparently. There is no need to use #serialize in this
  # case.
  #
  # For more complex cases, such as conversion to or from your application
  # domain objects, consider using the ActiveRecord::Attributes API.
  #
  # ==== Parameters
  #
  # * +attr_name+ - The name of the attribute to serialize.
  # * +coder+ The serializer implementation to use, e.g. +JSON+.
  #   * The attribute value will be serialized
  #     using the coder's <tt>dump(value)</tt> method, and will be
  #     deserialized using the coder's <tt>load(string)</tt> method. The
  #     +dump+ method may return +nil+ to serialize the value as +NULL+.
  # * +type+ - Optional. What the type of the serialized object should be.
  #   * Attempting to serialize another type will raise an
  #     ActiveRecord::SerializationTypeMismatch error.
  #   * If the column is +NULL+ or starting from a new record, the default value
  #     will set to +type.new+
  # * +yaml+ - Optional. Yaml specific options. The allowed config is:
  #   * +:permitted_classes+ - +Array+ with the permitted classes.
  #   * +:unsafe_load+ - Unsafely load YAML blobs, allow YAML to load any class.
  #
  # ==== Options
  #
  # * +:default+ - The default value to use when no value is provided. If
  #   this option is not passed, the previous default value (if any) will
  #   be used. Otherwise, the default will be +nil+.
  #
  # ==== Choosing a serializer
  #
  # While any serialization format can be used, it is recommended to carefully
  # evaluate the properties of a serializer before using it, as migrating to
  # another format later on can be difficult.
  #
  # ===== Avoid accepting arbitrary types
  #
  # When serializing data in a column, it is heavily recommended to make sure
  # only expected types will be serialized. For instance some serializer like
  # +Marshal+ or +YAML+ are capable of serializing almost any Ruby object.
  #
  # This can lead to unexpected types being serialized, and it is important
  # that type serialization remains backward and forward compatible as long
  # as some database records still contain these serialized types.
  #
  #   class Address
  #     def initialize(line, city, country)
  #       @line, @city, @country = line, city, country
  #     end
  #   end
  #
  # In the above example, if any of the +Address+ attributes is renamed,
  # instances that were persisted before the change will be loaded with the
  # old attributes. This problem is even worse when the serialized type comes
  # from a dependency which doesn't expect to be serialized this way and may
  # change its internal representation without notice.
  #
  # As such, it is heavily recommended to instead convert these objects into
  # primitives of the serialization format, for example:
  #
  #   class Address
  #     attr_reader :line, :city, :country
  #
  #     def self.load(payload)
  #       data = YAML.safe_load(payload)
  #       new(data["line"], data["city"], data["country"])
  #     end
  #
  #     def self.dump(address)
  #       YAML.safe_dump(
  #         "line" => address.line,
  #         "city" => address.city,
  #         "country" => address.country,
  #       )
  #     end
  #
  #     def initialize(line, city, country)
  #       @line, @city, @country = line, city, country
  #     end
  #   end
  #
  #   class User < ActiveRecord::Base
  #     serialize :address, coder: Address
  #   end
  #
  # This pattern allows to be more deliberate about what is serialized, and
  # to evolve the format in a backward compatible way.
  #
  # ===== Ensure serialization stability
  #
  # Some serialization methods may accept some types they don't support by
  # silently casting them to other types. This can cause bugs when the
  # data is deserialized.
  #
  # For instance the +JSON+ serializer provided in the standard library will
  # silently cast unsupported types to +String+:
  #
  #   >> JSON.parse(JSON.dump(Struct.new(:foo)))
  #   => "#<Class:0x000000013090b4c0>"
  #
  # ==== Examples
  #
  # ===== Serialize the +preferences+ attribute using YAML
  #
  #   class User < ActiveRecord::Base
  #     serialize :preferences, coder: YAML
  #   end
  #
  # ===== Serialize the +preferences+ attribute using JSON
  #
  #   class User < ActiveRecord::Base
  #     serialize :preferences, coder: JSON
  #   end
  #
  # ===== Serialize the +preferences+ +Hash+ using YAML
  #
  #   class User < ActiveRecord::Base
  #     serialize :preferences, type: Hash, coder: YAML
  #   end
  #
  # ===== Serializes +preferences+ to YAML, permitting select classes
  #
  #   class User < ActiveRecord::Base
  #     serialize :preferences, coder: YAML, yaml: { permitted_classes: [Symbol, Time] }
  #   end
  #
  # ===== Serialize the +preferences+ attribute using a custom coder
  #
  #   class Rot13JSON
  #     def self.rot13(string)
  #       string.tr("a-zA-Z", "n-za-mN-ZA-M")
  #     end
  #
  #     # Serializes an attribute value to a string that will be stored in the database.
  #     def self.dump(value)
  #       rot13(ActiveSupport::JSON.dump(value))
  #     end
  #
  #     # Deserializes a string from the database to an attribute value.
  #     def self.load(string)
  #       ActiveSupport::JSON.load(rot13(string))
  #     end
  #   end
  #
  #   class User < ActiveRecord::Base
  #     serialize :preferences, coder: Rot13JSON
  #   end
  #
  # source://activerecord//lib/active_record/attribute_methods/serialization.rb#183
  def serialize(attr_name, class_name_or_coder = T.unsafe(nil), coder: T.unsafe(nil), type: T.unsafe(nil), yaml: T.unsafe(nil), **options); end

  private

  # source://activerecord//lib/active_record/attribute_methods/serialization.rb#228
  def build_column_serializer(attr_name, coder, type, yaml = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/serialization.rb#245
  def type_incompatible_with_serialize?(cast_type, coder, type); end
end

# source://activerecord//lib/active_record/attribute_methods/serialization.rb#9
class ActiveRecord::AttributeMethods::Serialization::ColumnNotSerializableError < ::StandardError
  # @return [ColumnNotSerializableError] a new instance of ColumnNotSerializableError
  #
  # source://activerecord//lib/active_record/attribute_methods/serialization.rb#10
  def initialize(name, type); end
end

# source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#7
module ActiveRecord::AttributeMethods::TimeZoneConversion
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods

  module GeneratedClassMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes=(value); end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes=(value); end
    def time_zone_aware_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types=(value); end
    def time_zone_aware_types?; end
  end

  module GeneratedInstanceMethods
    def skip_time_zone_conversion_for_attributes; end
    def skip_time_zone_conversion_for_attributes?; end
    def time_zone_aware_attributes; end
    def time_zone_aware_attributes?; end
    def time_zone_aware_types; end
    def time_zone_aware_types?; end
  end
end

# source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#71
module ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#72
  def define_attribute(name, cast_type, **_arg2); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#80
  def create_time_zone_conversion_attribute?(name, cast_type); end
end

# source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#8
class ActiveRecord::AttributeMethods::TimeZoneConversion::TimeZoneConverter
  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#17
  def cast(value); end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#13
  def deserialize(value); end

  private

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#36
  def convert_time_to_time_zone(value); end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#52
  def map_avoiding_infinite_recursion(value); end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#48
  def set_time_zone_without_conversion(value); end

  class << self
    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#9
    def new(subtype); end
  end
end

# = Active Record Attribute Methods \Write
#
# source://activerecord//lib/active_record/attribute_methods/write.rb#6
module ActiveRecord::AttributeMethods::Write
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AttributeMethods::Write::ClassMethods

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the write_attribute API
  #
  # source://activerecord//lib/active_record/attribute_methods/write.rb#41
  def _write_attribute(attr_name, value); end

  # Updates the attribute identified by +attr_name+ using the specified
  # +value+. The attribute value will be type cast upon being read.
  #
  # source://activerecord//lib/active_record/attribute_methods/write.rb#31
  def write_attribute(attr_name, value); end

  private

  # This method exists to avoid the expensive primary_key check internally, without
  # breaking compatibility with the write_attribute API
  #
  # source://activerecord//lib/active_record/attribute_methods/write.rb#41
  def attribute=(attr_name, value); end
end

# source://activerecord//lib/active_record/attribute_methods/write.rb#13
module ActiveRecord::AttributeMethods::Write::ClassMethods
  private

  # source://activerecord//lib/active_record/attribute_methods/write.rb#15
  def define_method_attribute=(name, owner:); end
end

# See ActiveRecord::Attributes::ClassMethods for documentation
#
# source://activerecord//lib/active_record/attributes.rb#7
module ActiveRecord::Attributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Attributes::ClassMethods

  module GeneratedClassMethods
    def attributes_to_define_after_schema_loads; end
    def attributes_to_define_after_schema_loads=(value); end
    def attributes_to_define_after_schema_loads?; end
  end

  module GeneratedInstanceMethods; end
end

# = Active Record \Attributes
#
# source://activerecord//lib/active_record/attributes.rb#14
module ActiveRecord::Attributes::ClassMethods
  # Defines an attribute with a type on this model. It will override the
  # type of existing attributes if needed. This allows control over how
  # values are converted to and from SQL when assigned to a model. It also
  # changes the behavior of values passed to
  # {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]. This will let you use
  # your domain objects across much of Active Record, without having to
  # rely on implementation details or monkey patching.
  #
  # +name+ The name of the methods to define attribute methods for, and the
  # column which this will persist to.
  #
  # +cast_type+ A symbol such as +:string+ or +:integer+, or a type object
  # to be used for this attribute. See the examples below for more
  # information about providing custom type objects.
  #
  # ==== Options
  #
  # The following options are accepted:
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+.
  #
  # +array+ (PostgreSQL only) specifies that the type should be an array (see the
  # examples below).
  #
  # +range+ (PostgreSQL only) specifies that the type should be a range (see the
  # examples below).
  #
  # When using a symbol for +cast_type+, extra options are forwarded to the
  # constructor of the type object.
  #
  # ==== Examples
  #
  # The type detected by Active Record can be overridden.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.decimal :price_in_cents
  #   end
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '10.1')
  #
  #   # before
  #   store_listing.price_in_cents # => BigDecimal(10.1)
  #
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :integer
  #   end
  #
  #   # after
  #   store_listing.price_in_cents # => 10
  #
  # A default can also be provided.
  #
  #   # db/schema.rb
  #   create_table :store_listings, force: true do |t|
  #     t.string :my_string, default: "original default"
  #   end
  #
  #   StoreListing.new.my_string # => "original default"
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :my_string, :string, default: "new default"
  #   end
  #
  #   StoreListing.new.my_string # => "new default"
  #
  #   class Product < ActiveRecord::Base
  #     attribute :my_default_proc, :datetime, default: -> { Time.now }
  #   end
  #
  #   Product.new.my_default_proc # => 2015-05-30 11:04:48 -0600
  #   sleep 1
  #   Product.new.my_default_proc # => 2015-05-30 11:04:49 -0600
  #
  # \Attributes do not need to be backed by a database column.
  #
  #   # app/models/my_model.rb
  #   class MyModel < ActiveRecord::Base
  #     attribute :my_string, :string
  #     attribute :my_int_array, :integer, array: true
  #     attribute :my_float_range, :float, range: true
  #   end
  #
  #   model = MyModel.new(
  #     my_string: "string",
  #     my_int_array: ["1", "2", "3"],
  #     my_float_range: "[1,3.5]",
  #   )
  #   model.attributes
  #   # =>
  #     {
  #       my_string: "string",
  #       my_int_array: [1, 2, 3],
  #       my_float_range: 1.0..3.5
  #     }
  #
  # Passing options to the type constructor
  #
  #   # app/models/my_model.rb
  #   class MyModel < ActiveRecord::Base
  #     attribute :small_int, :integer, limit: 2
  #   end
  #
  #   MyModel.create(small_int: 65537)
  #   # => Error: 65537 is out of range for the limit of two bytes
  #
  # ==== Creating Custom Types
  #
  # Users may also define their own custom types, as long as they respond
  # to the methods defined on the value type. The method +deserialize+ or
  # +cast+ will be called on your type object, with raw input from the
  # database or from your controllers. See ActiveModel::Type::Value for the
  # expected API. It is recommended that your type objects inherit from an
  # existing type, or from ActiveRecord::Type::Value
  #
  #   class MoneyType < ActiveRecord::Type::Integer
  #     def cast(value)
  #       if !value.kind_of?(Numeric) && value.include?('$')
  #         price_in_dollars = value.gsub(/\$/, '').to_f
  #         super(price_in_dollars * 100)
  #       else
  #         super
  #       end
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/store_listing.rb
  #   class StoreListing < ActiveRecord::Base
  #     attribute :price_in_cents, :money
  #   end
  #
  #   store_listing = StoreListing.new(price_in_cents: '$10.00')
  #   store_listing.price_in_cents # => 1000
  #
  # For more details on creating custom types, see the documentation for
  # ActiveModel::Type::Value. For more details on registering your types
  # to be referenced by a symbol, see ActiveRecord::Type.register. You can
  # also pass a type object directly, in place of a symbol.
  #
  # ==== \Querying
  #
  # When {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where] is called, it will
  # use the type defined by the model class to convert the value to SQL,
  # calling +serialize+ on your type object. For example:
  #
  #   class Money < Struct.new(:amount, :currency)
  #   end
  #
  #   class MoneyType < ActiveRecord::Type::Value
  #     def initialize(currency_converter:)
  #       @currency_converter = currency_converter
  #     end
  #
  #     # value will be the result of +deserialize+ or
  #     # +cast+. Assumed to be an instance of +Money+ in
  #     # this case.
  #     def serialize(value)
  #       value_in_bitcoins = @currency_converter.convert_to_bitcoins(value)
  #       value_in_bitcoins.amount
  #     end
  #   end
  #
  #   # config/initializers/types.rb
  #   ActiveRecord::Type.register(:money, MoneyType)
  #
  #   # app/models/product.rb
  #   class Product < ActiveRecord::Base
  #     currency_converter = ConversionRatesFromTheInternet.new
  #     attribute :price_in_bitcoins, :money, currency_converter: currency_converter
  #   end
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "USD"))
  #   # SELECT * FROM products WHERE price_in_bitcoins = 0.02230
  #
  #   Product.where(price_in_bitcoins: Money.new(5, "GBP"))
  #   # SELECT * FROM products WHERE price_in_bitcoins = 0.03412
  #
  # ==== Dirty Tracking
  #
  # The type of an attribute is given the opportunity to change how dirty
  # tracking is performed. The methods +changed?+ and +changed_in_place?+
  # will be called from ActiveModel::Dirty. See the documentation for those
  # methods in ActiveModel::Type::Value for more details.
  #
  # source://activerecord//lib/active_record/attributes.rb#208
  def attribute(name, cast_type = T.unsafe(nil), default: T.unsafe(nil), **options); end

  # This is the low level API which sits beneath +attribute+. It only
  # accepts type objects, and will do its work immediately instead of
  # waiting for the schema to load. Automatic schema detection and
  # ClassMethods#attribute both call this under the hood. While this method
  # is provided so it can be used by plugin authors, application code
  # should probably use ClassMethods#attribute.
  #
  # +name+ The name of the attribute being defined. Expected to be a +String+.
  #
  # +cast_type+ The type object to use for this attribute.
  #
  # +default+ The default value to use when no value is provided. If this option
  # is not passed, the previous default value (if any) will be used.
  # Otherwise, the default will be +nil+. A proc can also be passed, and
  # will be called once each time a new value is needed.
  #
  # +user_provided_default+ Whether the default value should be cast using
  # +cast+ or +deserialize+.
  #
  # source://activerecord//lib/active_record/attributes.rb#253
  def define_attribute(name, cast_type, default: T.unsafe(nil), user_provided_default: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/attributes.rb#263
  def load_schema!; end

  private

  # source://activerecord//lib/active_record/attributes.rb#275
  def define_default_attribute(name, value, type, from_user:); end
end

# source://activerecord//lib/active_record/attributes.rb#272
ActiveRecord::Attributes::ClassMethods::NO_DEFAULT_PROVIDED = T.let(T.unsafe(nil), Object)

# = Active Record Autosave Association
#
# AutosaveAssociation is a module that takes care of automatically saving
# associated records when their parent is saved. In addition to saving, it
# also destroys any associated records that were marked for destruction.
# (See #mark_for_destruction and #marked_for_destruction?).
#
# Saving of the parent, its associations, and the destruction of marked
# associations, all happen inside a transaction. This should never leave the
# database in an inconsistent state.
#
# If validations for any of the associations fail, their error messages will
# be applied to the parent.
#
# Note that it also means that associations marked for destruction won't
# be destroyed directly. They will however still be marked for destruction.
#
# Note that <tt>autosave: false</tt> is not same as not declaring <tt>:autosave</tt>.
# When the <tt>:autosave</tt> option is not present then new association records are
# saved but the updated association records are not saved.
#
# == Validation
#
# Child records are validated unless <tt>:validate</tt> is +false+.
#
# == \Callbacks
#
# Association with autosave option defines several callbacks on your
# model (around_save, before_save, after_create, after_update). Please note that
# callbacks are executed in the order they were defined in
# model. You should avoid modifying the association content before
# autosave callbacks are executed. Placing your callbacks after
# associations is usually a good practice.
#
# === One-to-one Example
#
#   class Post < ActiveRecord::Base
#     has_one :author, autosave: true
#   end
#
# Saving changes to the parent and its associated model can now be performed
# automatically _and_ atomically:
#
#   post = Post.find(1)
#   post.title       # => "The current global position of migrating ducks"
#   post.author.name # => "alloy"
#
#   post.title = "On the migration of ducks"
#   post.author.name = "Eloy Duran"
#
#   post.save
#   post.reload
#   post.title       # => "On the migration of ducks"
#   post.author.name # => "Eloy Duran"
#
# Destroying an associated model, as part of the parent's save action, is as
# simple as marking it for destruction:
#
#   post.author.mark_for_destruction
#   post.author.marked_for_destruction? # => true
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.author.id
#   Author.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.author # => nil
#
# Now it _is_ removed from the database:
#
#   Author.find_by(id: id).nil? # => true
#
# === One-to-many Example
#
# When <tt>:autosave</tt> is not declared new children are saved when their parent is saved:
#
#   class Post < ActiveRecord::Base
#     has_many :comments # :autosave option is not declared
#   end
#
#   post = Post.new(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   post.comments.build(body: 'hello world')
#   post.save # => saves both post and comment
#
#   post = Post.create(title: 'ruby rocks')
#   comment = post.comments.create(body: 'hello world')
#   comment.body = 'hi everyone'
#   post.save # => saves post, but not comment
#
# When <tt>:autosave</tt> is true all children are saved, no matter whether they
# are new records or not:
#
#   class Post < ActiveRecord::Base
#     has_many :comments, autosave: true
#   end
#
#   post = Post.create(title: 'ruby rocks')
#   comment = post.comments.create(body: 'hello world')
#   comment.body = 'hi everyone'
#   post.comments.build(body: "good morning.")
#   post.save # => saves post and both comments.
#
# Destroying one of the associated models as part of the parent's save action
# is as simple as marking it for destruction:
#
#   post.comments # => [#<Comment id: 1, ...>, #<Comment id: 2, ...]>
#   post.comments[1].mark_for_destruction
#   post.comments[1].marked_for_destruction? # => true
#   post.comments.length # => 2
#
# Note that the model is _not_ yet removed from the database:
#
#   id = post.comments.last.id
#   Comment.find_by(id: id).nil? # => false
#
#   post.save
#   post.reload.comments.length # => 1
#
# Now it _is_ removed from the database:
#
#   Comment.find_by(id: id).nil? # => true
#
# === Caveats
#
# Note that autosave will only trigger for already-persisted association records
# if the records themselves have been changed. This is to protect against
# <tt>SystemStackError</tt> caused by circular association validations. The one
# exception is if a custom validation context is used, in which case the validations
# will always fire on the associated records.
#
# source://activerecord//lib/active_record/autosave_association.rb#138
module ActiveRecord::AutosaveAssociation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::AutosaveAssociation::ClassMethods

  # Returns whether or not this record has been changed in any way (including whether
  # any of its nested autosave associations are likewise changed)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#271
  def changed_for_autosave?; end

  # Returns the association for the parent being destroyed.
  #
  # Used to avoid updating the counter cache unnecessarily.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#265
  def destroyed_by_association; end

  # Records the association that is being destroyed and destroying this
  # record in the process.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#258
  def destroyed_by_association=(reflection); end

  # Marks this record to be destroyed as part of the parent's save transaction.
  # This does _not_ actually destroy the record instantly, rather child record will be destroyed
  # when <tt>parent.save</tt> is called.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#245
  def mark_for_destruction; end

  # Returns whether or not this record will be destroyed as part of the parent's save transaction.
  #
  # Only useful if the <tt>:autosave</tt> option on the parent is enabled for this associated model.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#252
  def marked_for_destruction?; end

  # Reloads the attributes of the object as usual and clears <tt>marked_for_destruction</tt> flag.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#234
  def reload(options = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/autosave_association.rb#554
  def _ensure_no_duplicate_errors; end

  # If the record is new or it has changed, returns true.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#475
  def _record_changed?(reflection, record, key); end

  # Is used as an around_save callback to check while saving a collection
  # association whether or not the parent was a new record before saving.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#371
  def around_save_collection_association; end

  # Returns the record for an association collection that should be validated
  # or saved. If +autosave+ is +false+ only new records will be returned,
  # unless the parent is/was a new record itself.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#284
  def associated_records_to_validate_or_save(association, new_record, autosave); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#482
  def association_foreign_key_changed?(reflection, record, key); end

  # Returns whether or not the association is valid and applies any errors to
  # the parent, <tt>self</tt>, if it wasn't. Skips any <tt>:autosave</tt>
  # enabled records if they're marked_for_destruction? or destroyed.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#335
  def association_valid?(reflection, record, index = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/autosave_association.rb#534
  def compute_primary_key(reflection, record); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#550
  def custom_validation_context?; end

  # source://activerecord//lib/active_record/autosave_association.rb#276
  def init_internals; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#491
  def inverse_polymorphic_association_changed?(reflection, record); end

  # Go through nested autosave associations that are loaded in memory (without loading
  # any new ones), and return true if any are changed for autosave.
  # Returns false if already called to prevent an infinite loop.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/autosave_association.rb#297
  def nested_records_changed_for_autosave?; end

  # source://activerecord//lib/active_record/autosave_association.rb#361
  def normalize_reflection_attribute(indexed_attribute, reflection, index, attribute); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled.
  #
  # In addition, it will destroy the association if it was marked for destruction.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#502
  def save_belongs_to_association(reflection); end

  # Saves any new associated records, or all loaded autosave associations if
  # <tt>:autosave</tt> is enabled on the association.
  #
  # In addition, it destroys all children that were marked for destruction
  # with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#388
  def save_collection_association(reflection); end

  # Saves the associated record if it's new or <tt>:autosave</tt> is enabled
  # on the association.
  #
  # In addition, it will destroy the association if it was marked for
  # destruction with #mark_for_destruction.
  #
  # This all happens inside a transaction, _if_ the Transactions module is included into
  # ActiveRecord::Base after the AutosaveAssociation module, which it does by default.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#442
  def save_has_one_association(reflection); end

  # Validate the associated records if <tt>:validate</tt> or
  # <tt>:autosave</tt> is turned on for the association specified by
  # +reflection+.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#324
  def validate_collection_association(reflection); end

  # Validate the association if <tt>:validate</tt> or <tt>:autosave</tt> is
  # turned on for the association.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#315
  def validate_single_association(reflection); end
end

# source://activerecord//lib/active_record/autosave_association.rb#141
module ActiveRecord::AutosaveAssociation::AssociationBuilderExtension
  class << self
    # source://activerecord//lib/active_record/autosave_association.rb#142
    def build(model, reflection); end

    # source://activerecord//lib/active_record/autosave_association.rb#146
    def valid_options; end
  end
end

# source://activerecord//lib/active_record/autosave_association.rb#155
module ActiveRecord::AutosaveAssociation::ClassMethods
  private

  # Adds validation and save callbacks for the association as specified by
  # the +reflection+.
  #
  # For performance reasons, we don't check whether to validate at runtime.
  # However the validation and callback methods are lazy and those methods
  # get created when they are invoked for the very first time. However,
  # this can change, for instance, when using nested attributes, which is
  # called _after_ the association has been defined. Since we don't want
  # the callbacks to get defined multiple times, there are guards that
  # check if the save or validation methods have already been defined
  # before actually defining them.
  #
  # source://activerecord//lib/active_record/autosave_association.rb#187
  def add_autosave_association_callbacks(reflection); end

  # source://activerecord//lib/active_record/autosave_association.rb#217
  def define_autosave_validation_callbacks(reflection); end

  # source://activerecord//lib/active_record/autosave_association.rb#157
  def define_non_cyclic_method(name, &block); end
end

# = Active Record
#
# Active Record objects don't specify their attributes directly, but rather infer them from
# the table definition with which they're linked. Adding, removing, and changing attributes
# and their type is done directly in the database. Any change is instantly reflected in the
# Active Record objects. The mapping that binds a given Active Record class to a certain
# database table will happen automatically in most common cases, but can be overwritten for the uncommon ones.
#
# See the mapping rules in table_name and the full example in link:files/activerecord/README_rdoc.html for more insight.
#
# == Creation
#
# Active Records accept constructor parameters either in a hash or as a block. The hash
# method is especially useful when you're receiving the data from somewhere else, like an
# HTTP request. It works like this:
#
#   user = User.new(name: "David", occupation: "Code Artist")
#   user.name # => "David"
#
# You can also use block initialization:
#
#   user = User.new do |u|
#     u.name = "David"
#     u.occupation = "Code Artist"
#   end
#
# And of course you can just create a bare object and specify the attributes after the fact:
#
#   user = User.new
#   user.name = "David"
#   user.occupation = "Code Artist"
#
# == Conditions
#
# Conditions can either be specified as a string, array, or hash representing the WHERE-part of an SQL statement.
# The array form is to be used when the condition input is tainted and requires sanitization. The string form can
# be used for statements that don't involve tainted data. The hash form works much like the array form, except
# only equality and range is possible. Examples:
#
#   class User < ActiveRecord::Base
#     def self.authenticate_unsafely(user_name, password)
#       where("user_name = '#{user_name}' AND password = '#{password}'").first
#     end
#
#     def self.authenticate_safely(user_name, password)
#       where("user_name = ? AND password = ?", user_name, password).first
#     end
#
#     def self.authenticate_safely_simply(user_name, password)
#       where(user_name: user_name, password: password).first
#     end
#   end
#
# The <tt>authenticate_unsafely</tt> method inserts the parameters directly into the query
# and is thus susceptible to SQL-injection attacks if the <tt>user_name</tt> and +password+
# parameters come directly from an HTTP request. The <tt>authenticate_safely</tt> and
# <tt>authenticate_safely_simply</tt> both will sanitize the <tt>user_name</tt> and +password+
# before inserting them in the query, which will ensure that an attacker can't escape the
# query and fake the login (or worse).
#
# When using multiple parameters in the conditions, it can easily become hard to read exactly
# what the fourth or fifth question mark is supposed to represent. In those cases, you can
# resort to named bind variables instead. That's done by replacing the question marks with
# symbols and supplying a hash with values for the matching symbol keys:
#
#   Company.where(
#     "id = :id AND name = :name AND division = :division AND created_at > :accounting_date",
#     { id: 3, name: "37signals", division: "First", accounting_date: '2005-01-01' }
#   ).first
#
# Similarly, a simple hash without a statement will generate conditions based on equality with the SQL AND
# operator. For instance:
#
#   Student.where(first_name: "Harvey", status: 1)
#   Student.where(params[:student])
#
# A range may be used in the hash to use the SQL BETWEEN operator:
#
#   Student.where(grade: 9..12)
#
# An array may be used in the hash to use the SQL IN operator:
#
#   Student.where(grade: [9,11,12])
#
# When joining tables, nested hashes or keys written in the form 'table_name.column_name'
# can be used to qualify the table name of a particular condition. For instance:
#
#   Student.joins(:schools).where(schools: { category: 'public' })
#   Student.joins(:schools).where('schools.category' => 'public' )
#
# == Overwriting default accessors
#
# All column values are automatically available through basic accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling
# +super+ to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses an integer of seconds to hold the length of the song
#
#     def length=(minutes)
#       super(minutes.to_i * 60)
#     end
#
#     def length
#       super / 60
#     end
#   end
#
# == Attribute query methods
#
# In addition to the basic accessors, query methods are also automatically available on the Active Record object.
# Query methods allow you to test whether an attribute value is present.
# Additionally, when dealing with numeric values, a query method will return false if the value is zero.
#
# For example, an Active Record User with the <tt>name</tt> attribute has a <tt>name?</tt> method that you can call
# to determine whether the user has a name:
#
#   user = User.new(name: "David")
#   user.name? # => true
#
#   anonymous = User.new(name: "")
#   anonymous.name? # => false
#
# Query methods will also respect any overrides of default accessors:
#
#   class User
#     # Has admin boolean column
#     def admin
#       false
#     end
#   end
#
#   user.update(admin: true)
#
#   user.read_attribute(:admin)  # => true, gets the column value
#   user[:admin] # => true, also gets the column value
#
#   user.admin   # => false, due to the getter override
#   user.admin?  # => false, due to the getter override
#
# == Accessing attributes before they have been typecasted
#
# Sometimes you want to be able to read the raw attribute data without having the column-determined
# typecast run its course first. That can be done by using the <tt><attribute>_before_type_cast</tt>
# accessors that all attributes have. For example, if your Account model has a <tt>balance</tt> attribute,
# you can call <tt>account.balance_before_type_cast</tt> or <tt>account.id_before_type_cast</tt>.
#
# This is especially useful in validation situations where the user might supply a string for an
# integer field and you want to display the original string back in an error message. Accessing the
# attribute normally would typecast the string to 0, which isn't what you want.
#
# == Dynamic attribute-based finders
#
# Dynamic attribute-based finders are a mildly deprecated way of getting (and/or creating) objects
# by simple queries without turning to SQL. They work by appending the name of an attribute
# to <tt>find_by_</tt> like <tt>Person.find_by_user_name</tt>.
# Instead of writing <tt>Person.find_by(user_name: user_name)</tt>, you can use
# <tt>Person.find_by_user_name(user_name)</tt>.
#
# It's possible to add an exclamation point (!) on the end of the dynamic finders to get them to raise an
# ActiveRecord::RecordNotFound error if they do not return any records,
# like <tt>Person.find_by_last_name!</tt>.
#
# It's also possible to use multiple attributes in the same <tt>find_by_</tt> by separating them with
# "_and_".
#
#  Person.find_by(user_name: user_name, password: password)
#  Person.find_by_user_name_and_password(user_name, password) # with dynamic finder
#
# It's even possible to call these dynamic finder methods on relations and named scopes.
#
#   Payment.order("created_on").find_by_amount(50)
#
# == Saving arrays, hashes, and other non-mappable objects in text columns
#
# Active Record can serialize any object in text columns using YAML. To do so, you must
# specify this with a call to the class method
# {serialize}[rdoc-ref:AttributeMethods::Serialization::ClassMethods#serialize].
# This makes it possible to store arrays, hashes, and other non-mappable objects without doing
# any additional work.
#
#   class User < ActiveRecord::Base
#     serialize :preferences
#   end
#
#   user = User.create(preferences: { "background" => "black", "display" => large })
#   User.find(user.id).preferences # => { "background" => "black", "display" => large }
#
# You can also specify a class option as the second parameter that'll raise an exception
# if a serialized object is retrieved as a descendant of a class not in the hierarchy.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, Hash
#   end
#
#   user = User.create(preferences: %w( one two three ))
#   User.find(user.id).preferences    # raises SerializationTypeMismatch
#
# When you specify a class option, the default value for that attribute will be a new
# instance of that class.
#
#   class User < ActiveRecord::Base
#     serialize :preferences, OpenStruct
#   end
#
#   user = User.new
#   user.preferences.theme_color = "red"
#
#
# == Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a
# column that is named "type" by default. See ActiveRecord::Inheritance for
# more details.
#
# == Connection to multiple databases in different models
#
# Connections are usually created through
# {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] and retrieved
# by ActiveRecord::Base.connection. All classes inheriting from ActiveRecord::Base will use this
# connection. But you can also set a class-specific connection. For example, if Course is an
# ActiveRecord::Base, but resides in a different database, you can just say <tt>Course.establish_connection</tt>
# and Course and all of its subclasses will use this connection instead.
#
# This feature is implemented by keeping a connection pool in ActiveRecord::Base that is
# a hash indexed by the class. If a connection is requested, the
# {ActiveRecord::Base.retrieve_connection}[rdoc-ref:ConnectionHandling#retrieve_connection] method
# will go up the class-hierarchy until a connection is found in the connection pool.
#
# == Exceptions
#
# * ActiveRecordError - Generic error class and superclass of all other errors raised by Active Record.
# * AdapterNotSpecified - The configuration hash used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   didn't include an <tt>:adapter</tt> key.
# * AdapterNotFound - The <tt>:adapter</tt> key used in
#   {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection]
#   specified a non-existent adapter
#   (or a bad spelling of an existing one).
# * AssociationTypeMismatch - The object assigned to the association wasn't of the type
#   specified in the association definition.
# * AttributeAssignmentError - An error occurred while doing a mass assignment through the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   You can inspect the +attribute+ property of the exception object to determine which attribute
#   triggered the error.
# * ConnectionNotEstablished - No connection has been established.
#   Use {ActiveRecord::Base.establish_connection}[rdoc-ref:ConnectionHandling#establish_connection] before querying.
# * MultiparameterAssignmentErrors - Collection of errors that occurred during a mass assignment using the
#   {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=] method.
#   The +errors+ property of this exception contains an array of
#   AttributeAssignmentError
#   objects that should be inspected to determine which attributes triggered the errors.
# * RecordInvalid - raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
#   {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
#   when the record is invalid.
# * RecordNotFound - No record responded to the {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] method.
#   Either the row with the given ID doesn't exist or the row didn't meet the additional restrictions.
#   Some {ActiveRecord::Base.find}[rdoc-ref:FinderMethods#find] calls do not raise this exception to signal
#   nothing was found, please check its documentation for further details.
# * SerializationTypeMismatch - The serialized object wasn't of the class specified as the second parameter.
# * StatementInvalid - The database server rejected the SQL statement. The precise error is added in the message.
#
# *Note*: The attributes listed are class-level attributes (accessible from both the class and instance level).
# So it's possible to assign a logger to the class through <tt>Base.logger=</tt> which will then be used by all
# instances in the current object space.
#
# source://activerecord//lib/active_record/base.rb#282
class ActiveRecord::Base
  include ::ActionText::Encryption
  include ::ActiveModel::Access
  include ::ActiveRecord::Core
  include ::ActiveRecord::Persistence
  include ::ActiveRecord::ReadonlyAttributes
  include ::ActiveRecord::ModelSchema
  include ::ActiveRecord::Inheritance
  include ::ActiveRecord::Scoping
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named
  include ::ActiveRecord::Sanitization
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveModel::AttributeAssignment
  include ::ActiveRecord::AttributeAssignment
  include ::ActiveModel::Conversion
  include ::ActiveRecord::Integration
  include ::ActiveModel::Validations
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveRecord::Validations
  include ::ActiveRecord::CounterCache
  include ::ActiveRecord::Attributes
  include ::ActiveRecord::Locking::Optimistic
  include ::ActiveRecord::Locking::Pessimistic
  include ::ActiveRecord::Encryption::EncryptableRecord
  include ::ActiveModel::AttributeMethods
  include ::ActiveRecord::AttributeMethods
  include ::ActiveRecord::Base::GeneratedAttributeMethods
  include ::ActiveRecord::Base::GeneratedAssociationMethods
  include ::ActiveRecord::AttributeMethods::Read
  include ::ActiveRecord::AttributeMethods::Write
  include ::ActiveRecord::AttributeMethods::BeforeTypeCast
  include ::ActiveRecord::AttributeMethods::Query
  include ::ActiveRecord::AttributeMethods::PrimaryKey
  include ::ActiveRecord::AttributeMethods::TimeZoneConversion
  include ::ActiveModel::Dirty
  include ::ActiveRecord::AttributeMethods::Dirty
  include ::ActiveRecord::AttributeMethods::Serialization
  include ::ActiveRecord::Callbacks
  include ::ActiveModel::Validations::Callbacks
  include ::ActiveRecord::Timestamp
  include ::ActiveRecord::Associations
  include ::ActiveModel::SecurePassword
  include ::ActiveRecord::SecurePassword
  include ::ActiveRecord::AutosaveAssociation
  include ::ActiveRecord::NestedAttributes
  include ::ActiveRecord::Transactions
  include ::ActiveRecord::TouchLater
  include ::ActiveRecord::NoTouching
  include ::ActiveRecord::Reflection
  include ::ActiveModel::Serialization
  include ::ActiveModel::Serializers::JSON
  include ::ActiveRecord::Serialization
  include ::ActiveRecord::Store
  include ::ActiveRecord::SecureToken
  include ::ActiveRecord::TokenFor
  include ::ActiveRecord::SignedId
  include ::ActiveRecord::Suppressor
  include ::ActiveRecord::Normalization
  include ::ActiveRecord::Marshalling::Methods
  include ::ActiveStorage::Attached::Model
  include ::ActiveStorage::Reflection::ActiveRecordExtensions
  include ::ActionText::Attribute
  include ::Turbo::Broadcastable
  extend ::ActiveModel::Naming
  extend ::ActiveSupport::Benchmarkable
  extend ::ActiveSupport::DescendantsTracker
  extend ::ActiveRecord::ConnectionHandling
  extend ::ActiveRecord::QueryCache::ClassMethods
  extend ::ActiveRecord::Querying
  extend ::ActiveModel::Translation
  extend ::ActiveRecord::Translation
  extend ::ActiveRecord::DynamicMatchers
  extend ::ActiveRecord::DelegatedType
  extend ::ActiveRecord::Explain
  extend ::ActiveRecord::Enum
  extend ::ActiveRecord::Delegation::DelegateCache
  extend ::ActiveRecord::Aggregations::ClassMethods
  extend ::ActiveRecord::Core::ClassMethods
  extend ::ActiveRecord::Persistence::ClassMethods
  extend ::ActiveRecord::ReadonlyAttributes::ClassMethods
  extend ::ActiveRecord::ModelSchema::ClassMethods
  extend ::ActiveRecord::Inheritance::ClassMethods
  extend ::ActiveRecord::Scoping::ClassMethods
  extend ::ActiveRecord::Scoping::Default::ClassMethods
  extend ::ActiveRecord::Scoping::Named::ClassMethods
  extend ::ActiveRecord::Sanitization::ClassMethods
  extend ::ActiveModel::Conversion::ClassMethods
  extend ::ActiveRecord::Integration::ClassMethods
  extend ::ActiveModel::Validations::ClassMethods
  extend ::ActiveModel::Callbacks
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::HelperMethods
  extend ::ActiveRecord::Validations::ClassMethods
  extend ::ActiveRecord::CounterCache::ClassMethods
  extend ::ActiveRecord::Attributes::ClassMethods
  extend ::ActiveRecord::Locking::Optimistic::ClassMethods
  extend ::ActiveRecord::Encryption::EncryptableRecord::ClassMethods
  extend ::ActiveModel::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Read::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Write::ClassMethods
  extend ::ActiveRecord::AttributeMethods::PrimaryKey::ClassMethods
  extend ::ActiveRecord::AttributeMethods::TimeZoneConversion::ClassMethods
  extend ::ActiveRecord::AttributeMethods::Serialization::ClassMethods
  extend ::ActiveRecord::Callbacks::ClassMethods
  extend ::ActiveModel::Validations::Callbacks::ClassMethods
  extend ::ActiveRecord::Timestamp::ClassMethods
  extend ::ActiveRecord::Associations::ClassMethods
  extend ::ActiveModel::SecurePassword::ClassMethods
  extend ::ActiveRecord::SecurePassword::ClassMethods
  extend ::ActiveRecord::AutosaveAssociation::ClassMethods
  extend ::ActiveRecord::NestedAttributes::ClassMethods
  extend ::ActiveRecord::Transactions::ClassMethods
  extend ::ActiveRecord::NoTouching::ClassMethods
  extend ::ActiveRecord::Reflection::ClassMethods
  extend ::ActiveRecord::Store::ClassMethods
  extend ::ActiveRecord::SecureToken::ClassMethods
  extend ::ActiveRecord::TokenFor::ClassMethods
  extend ::ActiveRecord::SignedId::ClassMethods
  extend ::ActiveRecord::Suppressor::ClassMethods
  extend ::ActiveRecord::Normalization::ClassMethods
  extend ::OrmAdapter::ToAdapter
  extend ::ActiveStorage::Attached::Model::ClassMethods
  extend ::ActiveStorage::Reflection::ActiveRecordExtensions::ClassMethods
  extend ::ActionText::Attribute::ClassMethods
  extend ::Turbo::Broadcastable::ClassMethods

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _before_commit_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _commit_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _create_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _destroy_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _find_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _initialize_callbacks; end

  # source://activerecord//lib/active_record/reflection.rb#11
  def _reflections; end

  # source://activerecord//lib/active_record/reflection.rb#11
  def _reflections?; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _rollback_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_before_commit_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_commit_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_create_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_destroy_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_find_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_initialize_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_rollback_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_save_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_touch_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_update_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_validate_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_validation_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _save_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _touch_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _update_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _validate_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _validation_callbacks; end

  # source://activemodel/7.1.3.2/lib/active_model/validations.rb#71
  def _validators; end

  # source://activemodel/7.1.3.2/lib/active_model/validations.rb#71
  def _validators?; end

  # source://activerecord//lib/active_record/reflection.rb#12
  def aggregate_reflections; end

  # source://activerecord//lib/active_record/reflection.rb#12
  def aggregate_reflections?; end

  # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#53
  def attachment_reflections; end

  # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#53
  def attachment_reflections?; end

  # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#72
  def attribute_aliases; end

  # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#72
  def attribute_aliases?; end

  # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#73
  def attribute_method_patterns; end

  # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#73
  def attribute_method_patterns?; end

  # source://activerecord//lib/active_record/reflection.rb#13
  def automatic_scope_inversing; end

  # source://activerecord//lib/active_record/reflection.rb#13
  def automatic_scope_inversing?; end

  # source://activerecord//lib/active_record/integration.rb#16
  def cache_timestamp_format; end

  # source://activerecord//lib/active_record/integration.rb#16
  def cache_timestamp_format?; end

  # source://activerecord//lib/active_record/integration.rb#24
  def cache_versioning; end

  # source://activerecord//lib/active_record/integration.rb#24
  def cache_versioning?; end

  # source://activerecord//lib/active_record/integration.rb#32
  def collection_cache_versioning; end

  # source://activerecord//lib/active_record/integration.rb#32
  def collection_cache_versioning?; end

  # source://activerecord//lib/active_record/model_schema.rb#178
  def column_for_attribute(name, &block); end

  # source://activerecord//lib/active_record/core.rb#97
  def default_connection_handler; end

  # source://activerecord//lib/active_record/core.rb#97
  def default_connection_handler?; end

  # source://activerecord//lib/active_record/core.rb#99
  def default_role; end

  # source://activerecord//lib/active_record/core.rb#99
  def default_role?; end

  # source://activerecord//lib/active_record/scoping/default.rb#20
  def default_scope_override; end

  # source://activerecord//lib/active_record/scoping/default.rb#19
  def default_scopes; end

  # source://activerecord//lib/active_record/core.rb#101
  def default_shard; end

  # source://activerecord//lib/active_record/core.rb#101
  def default_shard?; end

  # source://activerecord//lib/active_record/enum.rb#167
  def defined_enums; end

  # source://activerecord//lib/active_record/enum.rb#167
  def defined_enums?; end

  # source://activerecord//lib/active_record/core.rb#47
  def destroy_association_async_batch_size; end

  # source://activerecord//lib/active_record/core.rb#37
  def destroy_association_async_job(&block); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
  def encrypted_attributes; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
  def encrypted_attributes=(_arg0); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
  def encrypted_attributes?; end

  # source://activemodel/7.1.3.2/lib/active_model/serializers/json.rb#15
  def include_root_in_json; end

  # source://activemodel/7.1.3.2/lib/active_model/serializers/json.rb#15
  def include_root_in_json?; end

  # source://activerecord//lib/active_record/locking/optimistic.rb#56
  def lock_optimistically; end

  # source://activerecord//lib/active_record/locking/optimistic.rb#56
  def lock_optimistically?; end

  # source://activerecord//lib/active_record/core.rb#22
  def logger; end

  # source://activerecord//lib/active_record/core.rb#22
  def logger?; end

  # source://activemodel/7.1.3.2/lib/active_model/naming.rb#255
  def model_name(&block); end

  # source://activerecord//lib/active_record/nested_attributes.rb#15
  def nested_attributes_options; end

  # source://activerecord//lib/active_record/nested_attributes.rb#15
  def nested_attributes_options?; end

  # source://activerecord//lib/active_record/normalization.rb#8
  def normalized_attributes; end

  # source://activerecord//lib/active_record/normalization.rb#8
  def normalized_attributes=(_arg0); end

  # source://activerecord//lib/active_record/normalization.rb#8
  def normalized_attributes?; end

  # source://activemodel/7.1.3.2/lib/active_model/conversion.rb#32
  def param_delimiter=(_arg0); end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#50
  def partial_inserts; end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#50
  def partial_inserts?; end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#49
  def partial_updates; end

  # source://activerecord//lib/active_record/attribute_methods/dirty.rb#49
  def partial_updates?; end

  # source://activerecord//lib/active_record/model_schema.rb#163
  def pluralize_table_names; end

  # source://activerecord//lib/active_record/model_schema.rb#163
  def pluralize_table_names?; end

  # source://activerecord//lib/active_record/model_schema.rb#158
  def primary_key_prefix_type; end

  # source://activerecord//lib/active_record/model_schema.rb#158
  def primary_key_prefix_type?; end

  # source://activerecord//lib/active_record/timestamp.rb#47
  def record_timestamps; end

  # source://activerecord//lib/active_record/timestamp.rb#47
  def record_timestamps=(_arg0); end

  # source://activerecord//lib/active_record/timestamp.rb#47
  def record_timestamps?; end

  # source://activerecord//lib/active_record/signed_id.rb#13
  def signed_id_verifier_secret; end

  # source://activerecord//lib/active_record/signed_id.rb#13
  def signed_id_verifier_secret?; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#67
  def skip_time_zone_conversion_for_attributes; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#67
  def skip_time_zone_conversion_for_attributes?; end

  # source://activerecord//lib/active_record/inheritance.rb#43
  def store_full_class_name; end

  # source://activerecord//lib/active_record/inheritance.rb#43
  def store_full_class_name?; end

  # source://activerecord//lib/active_record/inheritance.rb#47
  def store_full_sti_class; end

  # source://activerecord//lib/active_record/inheritance.rb#47
  def store_full_sti_class?; end

  def suppressed_turbo_broadcasts?(&block); end

  # source://activerecord//lib/active_record/model_schema.rb#159
  def table_name_prefix; end

  # source://activerecord//lib/active_record/model_schema.rb#159
  def table_name_prefix?; end

  # source://activerecord//lib/active_record/model_schema.rb#160
  def table_name_suffix; end

  # source://activerecord//lib/active_record/model_schema.rb#160
  def table_name_suffix?; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#66
  def time_zone_aware_attributes; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#66
  def time_zone_aware_attributes?; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#68
  def time_zone_aware_types; end

  # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#68
  def time_zone_aware_types?; end

  # source://activerecord//lib/active_record/model_schema.rb#178
  def type_for_attribute(attr_name, &block); end

  # source://activemodel/7.1.3.2/lib/active_model/validations.rb#67
  def validation_context; end

  private

  # source://activemodel/7.1.3.2/lib/active_model/validations.rb#67
  def validation_context=(_arg0); end

  class << self
    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activerecord//lib/active_record/readonly_attributes.rb#11
    def _attr_readonly; end

    # source://activerecord//lib/active_record/readonly_attributes.rb#11
    def _attr_readonly=(value); end

    # source://activerecord//lib/active_record/readonly_attributes.rb#11
    def _attr_readonly?; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _before_commit_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _before_commit_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _commit_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _commit_callbacks=(value); end

    # source://activerecord//lib/active_record/counter_cache.rb#9
    def _counter_cache_columns; end

    # source://activerecord//lib/active_record/counter_cache.rb#9
    def _counter_cache_columns=(value); end

    # source://activerecord//lib/active_record/counter_cache.rb#9
    def _counter_cache_columns?; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _create_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _create_callbacks=(value); end

    # source://activerecord//lib/active_record/core.rb#24
    def _destroy_association_async_job; end

    # source://activerecord//lib/active_record/core.rb#24
    def _destroy_association_async_job=(value); end

    # source://activerecord//lib/active_record/core.rb#24
    def _destroy_association_async_job?; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _destroy_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _destroy_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _find_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _find_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _initialize_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _initialize_callbacks=(value); end

    # source://activerecord//lib/active_record/reflection.rb#11
    def _reflections; end

    # source://activerecord//lib/active_record/reflection.rb#11
    def _reflections=(value); end

    # source://activerecord//lib/active_record/reflection.rb#11
    def _reflections?; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _rollback_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _rollback_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _save_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _save_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _touch_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _touch_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _update_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _update_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _validate_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _validate_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _validation_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _validation_callbacks=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/validations.rb#71
    def _validators; end

    # source://activemodel/7.1.3.2/lib/active_model/validations.rb#71
    def _validators=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/validations.rb#71
    def _validators?; end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_create(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_destroy(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_find(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_initialize(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_save(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_touch(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#144
    def after_update(*args, **options, &block); end

    # source://activerecord//lib/active_record/reflection.rb#12
    def aggregate_reflections; end

    # source://activerecord//lib/active_record/reflection.rb#12
    def aggregate_reflections=(value); end

    # source://activerecord//lib/active_record/reflection.rb#12
    def aggregate_reflections?; end

    # source://activerecord//lib/active_record/core.rb#105
    def application_record_class?; end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#137
    def around_create(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#137
    def around_destroy(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#137
    def around_save(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#137
    def around_update(*args, **options, &block); end

    # source://activerecord//lib/active_record/core.rb#125
    def asynchronous_queries_session; end

    # source://activerecord//lib/active_record/core.rb#129
    def asynchronous_queries_tracker; end

    # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#53
    def attachment_reflections; end

    # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#53
    def attachment_reflections=(value); end

    # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#53
    def attachment_reflections?; end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#72
    def attribute_aliases; end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#72
    def attribute_aliases=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#72
    def attribute_aliases?; end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#73
    def attribute_method_patterns; end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#73
    def attribute_method_patterns=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/attribute_methods.rb#73
    def attribute_method_patterns?; end

    # source://activerecord//lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads; end

    # source://activerecord//lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads=(value); end

    # source://activerecord//lib/active_record/attributes.rb#11
    def attributes_to_define_after_schema_loads?; end

    # source://activerecord//lib/active_record/reflection.rb#13
    def automatic_scope_inversing; end

    # source://activerecord//lib/active_record/reflection.rb#13
    def automatic_scope_inversing=(value); end

    # source://activerecord//lib/active_record/reflection.rb#13
    def automatic_scope_inversing?; end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#130
    def before_create(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#130
    def before_destroy(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#130
    def before_save(*args, **options, &block); end

    # source://activemodel/7.1.3.2/lib/active_model/callbacks.rb#130
    def before_update(*args, **options, &block); end

    # source://activerecord//lib/active_record/core.rb#89
    def belongs_to_required_by_default; end

    # source://activerecord//lib/active_record/core.rb#89
    def belongs_to_required_by_default=(value); end

    # source://activerecord//lib/active_record/core.rb#89
    def belongs_to_required_by_default?; end

    # source://activerecord//lib/active_record/integration.rb#16
    def cache_timestamp_format; end

    # source://activerecord//lib/active_record/integration.rb#16
    def cache_timestamp_format=(value); end

    # source://activerecord//lib/active_record/integration.rb#16
    def cache_timestamp_format?; end

    # source://activerecord//lib/active_record/integration.rb#24
    def cache_versioning; end

    # source://activerecord//lib/active_record/integration.rb#24
    def cache_versioning=(value); end

    # source://activerecord//lib/active_record/integration.rb#24
    def cache_versioning?; end

    # source://activerecord//lib/active_record/integration.rb#32
    def collection_cache_versioning; end

    # source://activerecord//lib/active_record/integration.rb#32
    def collection_cache_versioning=(value); end

    # source://activerecord//lib/active_record/integration.rb#32
    def collection_cache_versioning?; end

    # source://activerecord//lib/active_record/core.rb#77
    def configurations; end

    # source://activerecord//lib/active_record/core.rb#71
    def configurations=(config); end

    # source://activerecord//lib/active_record/core.rb#189
    def connected_to_stack; end

    # source://activerecord//lib/active_record/core.rb#203
    def connection_class; end

    # source://activerecord//lib/active_record/core.rb#199
    def connection_class=(b); end

    # source://activerecord//lib/active_record/core.rb#207
    def connection_class?; end

    # source://activerecord//lib/active_record/core.rb#211
    def connection_class_for_self; end

    # source://activerecord//lib/active_record/core.rb#117
    def connection_handler; end

    # source://activerecord//lib/active_record/core.rb#121
    def connection_handler=(handler); end

    # source://activerecord//lib/active_record/core.rb#180
    def current_preventing_writes; end

    # source://activerecord//lib/active_record/core.rb#143
    def current_role; end

    # source://activerecord//lib/active_record/core.rb#161
    def current_shard; end

    # source://activerecord//lib/active_record/attribute_methods/serialization.rb#20
    def default_column_serializer; end

    # source://activerecord//lib/active_record/attribute_methods/serialization.rb#20
    def default_column_serializer=(value); end

    # source://activerecord//lib/active_record/attribute_methods/serialization.rb#20
    def default_column_serializer?; end

    # source://activerecord//lib/active_record/core.rb#97
    def default_connection_handler; end

    # source://activerecord//lib/active_record/core.rb#97
    def default_connection_handler=(value); end

    # source://activerecord//lib/active_record/core.rb#97
    def default_connection_handler?; end

    # source://activerecord//lib/active_record/core.rb#99
    def default_role; end

    # source://activerecord//lib/active_record/core.rb#99
    def default_role=(value); end

    # source://activerecord//lib/active_record/core.rb#99
    def default_role?; end

    # source://activerecord//lib/active_record/scoping/default.rb#20
    def default_scope_override; end

    # source://activerecord//lib/active_record/scoping/default.rb#20
    def default_scope_override=(value); end

    # source://activerecord//lib/active_record/scoping/default.rb#19
    def default_scopes; end

    # source://activerecord//lib/active_record/scoping/default.rb#19
    def default_scopes=(value); end

    # source://activerecord//lib/active_record/core.rb#101
    def default_shard; end

    # source://activerecord//lib/active_record/core.rb#101
    def default_shard=(value); end

    # source://activerecord//lib/active_record/core.rb#101
    def default_shard?; end

    # source://activerecord//lib/active_record/enum.rb#167
    def defined_enums; end

    # source://activerecord//lib/active_record/enum.rb#167
    def defined_enums=(value); end

    # source://activerecord//lib/active_record/enum.rb#167
    def defined_enums?; end

    # source://activerecord//lib/active_record/core.rb#47
    def destroy_association_async_batch_size; end

    # source://activerecord//lib/active_record/core.rb#47
    def destroy_association_async_batch_size=(value); end

    # source://activerecord//lib/active_record/core.rb#27
    def destroy_association_async_job; end

    # source://activerecord//lib/active_record/core.rb#24
    def destroy_association_async_job=(value); end

    # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
    def encrypted_attributes; end

    # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
    def encrypted_attributes=(value); end

    # source://activerecord//lib/active_record/encryption/encryptable_record.rb#11
    def encrypted_attributes?; end

    # source://activerecord//lib/active_record/core.rb#87
    def enumerate_columns_in_select_statements; end

    # source://activerecord//lib/active_record/core.rb#87
    def enumerate_columns_in_select_statements=(value); end

    # source://activerecord//lib/active_record/core.rb#87
    def enumerate_columns_in_select_statements?; end

    # source://activerecord//lib/active_record/token_for.rb#11
    def generated_token_verifier; end

    # source://activerecord//lib/active_record/token_for.rb#11
    def generated_token_verifier=(value); end

    # source://activerecord//lib/active_record/core.rb#93
    def has_many_inversing; end

    # source://activerecord//lib/active_record/core.rb#93
    def has_many_inversing=(value); end

    # source://activerecord//lib/active_record/core.rb#93
    def has_many_inversing?; end

    # source://activerecord//lib/active_record/model_schema.rb#165
    def immutable_strings_by_default; end

    # source://activerecord//lib/active_record/model_schema.rb#165
    def immutable_strings_by_default=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#165
    def immutable_strings_by_default?; end

    # source://activerecord//lib/active_record/model_schema.rb#164
    def implicit_order_column; end

    # source://activerecord//lib/active_record/model_schema.rb#164
    def implicit_order_column=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#164
    def implicit_order_column?; end

    # source://activemodel/7.1.3.2/lib/active_model/serializers/json.rb#15
    def include_root_in_json; end

    # source://activemodel/7.1.3.2/lib/active_model/serializers/json.rb#15
    def include_root_in_json=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/serializers/json.rb#15
    def include_root_in_json?; end

    # source://activerecord//lib/active_record/model_schema.rb#167
    def inheritance_column; end

    # source://activerecord//lib/active_record/model_schema.rb#321
    def inheritance_column=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#167
    def inheritance_column?; end

    # source://activerecord//lib/active_record/model_schema.rb#162
    def internal_metadata_table_name; end

    # source://activerecord//lib/active_record/model_schema.rb#162
    def internal_metadata_table_name=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#162
    def internal_metadata_table_name?; end

    # source://activerecord//lib/active_record/store.rb#101
    def local_stored_attributes; end

    # source://activerecord//lib/active_record/store.rb#101
    def local_stored_attributes=(_arg0); end

    # source://activerecord//lib/active_record/locking/optimistic.rb#56
    def lock_optimistically; end

    # source://activerecord//lib/active_record/locking/optimistic.rb#56
    def lock_optimistically=(value); end

    # source://activerecord//lib/active_record/locking/optimistic.rb#56
    def lock_optimistically?; end

    # source://activerecord//lib/active_record/core.rb#22
    def logger; end

    # source://activerecord//lib/active_record/core.rb#22
    def logger=(value); end

    # source://activerecord//lib/active_record/core.rb#22
    def logger?; end

    # source://activerecord//lib/active_record/nested_attributes.rb#15
    def nested_attributes_options; end

    # source://activerecord//lib/active_record/nested_attributes.rb#15
    def nested_attributes_options=(value); end

    # source://activerecord//lib/active_record/nested_attributes.rb#15
    def nested_attributes_options?; end

    # source://activerecord//lib/active_record/normalization.rb#8
    def normalized_attributes; end

    # source://activerecord//lib/active_record/normalization.rb#8
    def normalized_attributes=(value); end

    # source://activerecord//lib/active_record/normalization.rb#8
    def normalized_attributes?; end

    # source://activemodel/7.1.3.2/lib/active_model/conversion.rb#32
    def param_delimiter; end

    # source://activemodel/7.1.3.2/lib/active_model/conversion.rb#32
    def param_delimiter=(value); end

    # source://activemodel/7.1.3.2/lib/active_model/conversion.rb#32
    def param_delimiter?; end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#50
    def partial_inserts; end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#50
    def partial_inserts=(value); end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#50
    def partial_inserts?; end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#49
    def partial_updates; end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#49
    def partial_updates=(value); end

    # source://activerecord//lib/active_record/attribute_methods/dirty.rb#49
    def partial_updates?; end

    # source://activerecord//lib/active_record/model_schema.rb#163
    def pluralize_table_names; end

    # source://activerecord//lib/active_record/model_schema.rb#163
    def pluralize_table_names=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#163
    def pluralize_table_names?; end

    # source://activerecord//lib/active_record/model_schema.rb#158
    def primary_key_prefix_type; end

    # source://activerecord//lib/active_record/model_schema.rb#158
    def primary_key_prefix_type=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#158
    def primary_key_prefix_type?; end

    # source://activerecord//lib/active_record/timestamp.rb#47
    def record_timestamps; end

    # source://activerecord//lib/active_record/timestamp.rb#47
    def record_timestamps=(value); end

    # source://activerecord//lib/active_record/timestamp.rb#47
    def record_timestamps?; end

    # source://activerecord//lib/active_record/core.rb#95
    def run_commit_callbacks_on_first_saved_instances_in_transaction; end

    # source://activerecord//lib/active_record/core.rb#95
    def run_commit_callbacks_on_first_saved_instances_in_transaction=(value); end

    # source://activerecord//lib/active_record/core.rb#95
    def run_commit_callbacks_on_first_saved_instances_in_transaction?; end

    # source://activerecord//lib/active_record/model_schema.rb#161
    def schema_migrations_table_name; end

    # source://activerecord//lib/active_record/model_schema.rb#161
    def schema_migrations_table_name=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#161
    def schema_migrations_table_name?; end

    # source://activerecord//lib/active_record/core.rb#103
    def shard_selector; end

    # source://activerecord//lib/active_record/core.rb#103
    def shard_selector=(value); end

    # source://activerecord//lib/active_record/core.rb#103
    def shard_selector?; end

    # source://activerecord//lib/active_record/signed_id.rb#13
    def signed_id_verifier_secret; end

    # source://activerecord//lib/active_record/signed_id.rb#13
    def signed_id_verifier_secret=(value); end

    # source://activerecord//lib/active_record/signed_id.rb#13
    def signed_id_verifier_secret?; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#67
    def skip_time_zone_conversion_for_attributes; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#67
    def skip_time_zone_conversion_for_attributes=(value); end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#67
    def skip_time_zone_conversion_for_attributes?; end

    # source://activerecord//lib/active_record/inheritance.rb#43
    def store_full_class_name; end

    # source://activerecord//lib/active_record/inheritance.rb#43
    def store_full_class_name=(value); end

    # source://activerecord//lib/active_record/inheritance.rb#43
    def store_full_class_name?; end

    # source://activerecord//lib/active_record/inheritance.rb#47
    def store_full_sti_class; end

    # source://activerecord//lib/active_record/inheritance.rb#47
    def store_full_sti_class=(value); end

    # source://activerecord//lib/active_record/inheritance.rb#47
    def store_full_sti_class?; end

    # source://activerecord//lib/active_record/core.rb#91
    def strict_loading_by_default; end

    # source://activerecord//lib/active_record/core.rb#91
    def strict_loading_by_default=(value); end

    # source://activerecord//lib/active_record/core.rb#91
    def strict_loading_by_default?; end

    # source://activerecord//lib/active_record/core.rb#226
    def strict_loading_violation!(owner:, reflection:); end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def suppressed_turbo_broadcasts; end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def suppressed_turbo_broadcasts=(obj); end

    # source://activerecord//lib/active_record/model_schema.rb#159
    def table_name_prefix; end

    # source://activerecord//lib/active_record/model_schema.rb#159
    def table_name_prefix=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#159
    def table_name_prefix?; end

    # source://activerecord//lib/active_record/model_schema.rb#160
    def table_name_suffix; end

    # source://activerecord//lib/active_record/model_schema.rb#160
    def table_name_suffix=(value); end

    # source://activerecord//lib/active_record/model_schema.rb#160
    def table_name_suffix?; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#66
    def time_zone_aware_attributes; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#66
    def time_zone_aware_attributes=(value); end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#66
    def time_zone_aware_attributes?; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#68
    def time_zone_aware_types; end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#68
    def time_zone_aware_types=(value); end

    # source://activerecord//lib/active_record/attribute_methods/time_zone_conversion.rb#68
    def time_zone_aware_types?; end

    # source://activerecord//lib/active_record/token_for.rb#10
    def token_definitions; end

    # source://activerecord//lib/active_record/token_for.rb#10
    def token_definitions=(value); end

    private

    # source://activerecord//lib/active_record/model_schema.rb#167
    def _inheritance_column=(value); end
  end
end

# source://activerecord//lib/active_record/base.rb#0
module ActiveRecord::Base::GeneratedAssociationMethods; end

# source://activerecord//lib/active_record/base.rb#0
module ActiveRecord::Base::GeneratedAttributeMethods; end

# = Active Record \Batches
#
# source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#4
module ActiveRecord::Batches
  # Looping through a collection of records from the database
  # (using the Scoping::Named::ClassMethods.all method, for example)
  # is very inefficient since it will try to instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work
  # with the records in batches, thereby greatly reducing memory consumption.
  #
  # The #find_each method uses #find_in_batches with a batch size of 1000 (or as
  # specified by the +:batch_size+ option).
  #
  #   Person.find_each do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").find_each do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #find_each, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_each.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be +:asc+ or +:desc+ or an array consisting
  #   of :asc or :desc). Defaults to +:asc+.
  #
  #     class Order < ActiveRecord::Base
  #       self.primary_key = [:id_1, :id_2]
  #     end
  #
  #     Order.find_each(order: [:asc, :desc])
  #
  #   In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size: it can be less than, equal to, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # In worker 1, let's process until 9999 records.
  #   Person.find_each(finish: 9_999) do |person|
  #     person.party_all_night!
  #   end
  #
  #   # In worker 2, let's process from record 10_000 and onwards.
  #   Person.find_each(start: 10_000) do |person|
  #     person.party_all_night!
  #   end
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  #
  # source://activerecord//lib/active_record/relation/batches.rb#79
  def find_each(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil), &block); end

  # Yields each batch of records that was found by the find options as
  # an array.
  #
  #   Person.where("age > 21").find_in_batches do |group|
  #     sleep(50) # Make sure it doesn't get too crowded in there!
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # If you do not provide a block to #find_in_batches, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.find_in_batches.with_index do |group, batch|
  #     puts "Processing group ##{batch}"
  #     group.each(&:recover_from_last_night!)
  #   end
  #
  # To be yielded each record one by one, use #find_each instead.
  #
  # ==== Options
  # * <tt>:batch_size</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be +:asc+ or +:desc+ or an array consisting
  #   of :asc or :desc). Defaults to +:asc+.
  #
  #     class Order < ActiveRecord::Base
  #       self.primary_key = [:id_1, :id_2]
  #     end
  #
  #     Order.find_in_batches(order: [:asc, :desc])
  #
  #   In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size: it can be less than, equal to, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # Let's process from record 10_000 on.
  #   Person.find_in_batches(start: 10_000) do |group|
  #     group.each { |person| person.party_all_night! }
  #   end
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  #
  # source://activerecord//lib/active_record/relation/batches.rb#148
  def find_in_batches(start: T.unsafe(nil), finish: T.unsafe(nil), batch_size: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil)); end

  # Yields ActiveRecord::Relation objects to work with a batch of records.
  #
  #   Person.where("age > 21").in_batches do |relation|
  #     relation.delete_all
  #     sleep(10) # Throttle the delete queries
  #   end
  #
  # If you do not provide a block to #in_batches, it will return a
  # BatchEnumerator which is enumerable.
  #
  #   Person.in_batches.each_with_index do |relation, batch_index|
  #     puts "Processing relation ##{batch_index}"
  #     relation.delete_all
  #   end
  #
  # Examples of calling methods on the returned BatchEnumerator object:
  #
  #   Person.in_batches.delete_all
  #   Person.in_batches.update_all(awesome: true)
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # ==== Options
  # * <tt>:of</tt> - Specifies the size of the batch. Defaults to 1000.
  # * <tt>:load</tt> - Specifies if the relation should be loaded. Defaults to false.
  # * <tt>:start</tt> - Specifies the primary key value to start from, inclusive of the value.
  # * <tt>:finish</tt> - Specifies the primary key value to end at, inclusive of the value.
  # * <tt>:error_on_ignore</tt> - Overrides the application config to specify if an error should be raised when
  #   an order is present in the relation.
  # * <tt>:order</tt> - Specifies the primary key order (can be +:asc+ or +:desc+ or an array consisting
  #   of :asc or :desc). Defaults to +:asc+.
  #
  #     class Order < ActiveRecord::Base
  #       self.primary_key = [:id_1, :id_2]
  #     end
  #
  #     Order.in_batches(order: [:asc, :desc])
  #
  #   In the above code, +id_1+ is sorted in ascending order and +id_2+ in descending order.
  #
  # * <tt>:use_ranges</tt> - Specifies whether to use range iteration (id >= x AND id <= y).
  #   It can make iterating over the whole or almost whole tables several times faster.
  #   Only whole table iterations use this style of iteration by default. You can disable this behavior by passing +false+.
  #   If you iterate over the table and the only condition is, e.g., <tt>archived_at: nil</tt> (and only a tiny fraction
  #   of the records are archived), it makes sense to opt in to this approach.
  #
  # Limits are honored, and if present there is no requirement for the batch
  # size, it can be less than, equal, or greater than the limit.
  #
  # The options +start+ and +finish+ are especially useful if you want
  # multiple workers dealing with the same processing queue. You can make
  # worker 1 handle all the records between id 1 and 9999 and worker 2
  # handle from 10000 and beyond by setting the +:start+ and +:finish+
  # option on each worker.
  #
  #   # Let's process from record 10_000 on.
  #   Person.in_batches(start: 10_000).update_all(awesome: true)
  #
  # An example of calling where query method on the relation:
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all('age = age + 1')
  #     relation.where('age > 21').update_all(should_party: true)
  #     relation.where('age <= 21').delete_all
  #   end
  #
  # NOTE: If you are going to iterate through each record, you should call
  # #each_record on the yielded BatchEnumerator:
  #
  #   Person.in_batches.each_record(&:party_all_night!)
  #
  # NOTE: Order can be ascending (:asc) or descending (:desc). It is automatically set to
  # ascending on the primary key ("id ASC").
  # This also means that this method only works when the primary key is
  # orderable (e.g. an integer or string).
  #
  # NOTE: By its nature, batch processing is subject to race conditions if
  # other processes are modifying the database.
  #
  # source://activerecord//lib/active_record/relation/batches.rb#239
  def in_batches(of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), load: T.unsafe(nil), error_on_ignore: T.unsafe(nil), order: T.unsafe(nil), use_ranges: T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/relation/batches.rb#325
  def act_on_ignored_order(error_on_ignore); end

  # source://activerecord//lib/active_record/relation/batches.rb#297
  def apply_finish_limit(relation, finish, batch_orders); end

  # source://activerecord//lib/active_record/relation/batches.rb#284
  def apply_limits(relation, start, finish, batch_orders); end

  # source://activerecord//lib/active_record/relation/batches.rb#290
  def apply_start_limit(relation, start, batch_orders); end

  # source://activerecord//lib/active_record/relation/batches.rb#304
  def batch_condition(relation, columns, values, operators); end

  # source://activerecord//lib/active_record/relation/batches.rb#339
  def batch_on_loaded_relation(relation:, start:, finish:, order:, batch_limit:); end

  # source://activerecord//lib/active_record/relation/batches.rb#364
  def batch_on_unloaded_relation(relation:, start:, finish:, load:, order:, use_ranges:, remaining:, batch_limit:); end

  # source://activerecord//lib/active_record/relation/batches.rb#319
  def build_batch_orders(order); end

  # source://activerecord//lib/active_record/relation/batches.rb#335
  def get_the_order_of_primary_key(order); end
end

# source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#5
class ActiveRecord::Batches::BatchEnumerator
  include ::Enumerable

  # @return [BatchEnumerator] a new instance of BatchEnumerator
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#8
  def initialize(relation:, of: T.unsafe(nil), start: T.unsafe(nil), finish: T.unsafe(nil), order: T.unsafe(nil), use_ranges: T.unsafe(nil)); end

  # The size of the batches yielded by the BatchEnumerator.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#27
  def batch_size; end

  # Deletes records in batches. Returns the total number of rows affected.
  #
  #   Person.in_batches.delete_all
  #
  # See Relation#delete_all for details of how each batch is deleted.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#65
  def delete_all; end

  # Destroys records in batches.
  #
  #   Person.where("age < 10").in_batches.destroy_all
  #
  # See Relation#destroy_all for details of how each batch is destroyed.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#85
  def destroy_all; end

  # Yields an ActiveRecord::Relation object for each batch of records.
  #
  #   Person.in_batches.each do |relation|
  #     relation.update_all(awesome: true)
  #   end
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#94
  def each(&block); end

  # Looping through a collection of records from the database (using the
  # +all+ method, for example) is very inefficient since it will try to
  # instantiate all the objects at once.
  #
  # In that case, batch processing methods allow you to work with the
  # records in batches, thereby greatly reducing memory consumption.
  #
  #   Person.in_batches.each_record do |person|
  #     person.do_awesome_stuff
  #   end
  #
  #   Person.where("age > 21").in_batches(of: 10).each_record do |person|
  #     person.party_all_night!
  #   end
  #
  # If you do not provide a block to #each_record, it will return an Enumerator
  # for chaining with other methods:
  #
  #   Person.in_batches.each_record.with_index do |person, index|
  #     person.award_trophy(index + 1)
  #   end
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#52
  def each_record(&block); end

  # The primary key value at which the BatchEnumerator ends, inclusive of the value.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#21
  def finish; end

  # The relation from which the BatchEnumerator yields batches.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#24
  def relation; end

  # The primary key value from which the BatchEnumerator starts, inclusive of the value.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#18
  def start; end

  # Updates records in batches. Returns the total number of rows affected.
  #
  #   Person.in_batches.update_all("age = age + 1")
  #
  # See Relation#update_all for details of how each batch is updated.
  #
  # source://activerecord//lib/active_record/relation/batches/batch_enumerator.rb#74
  def update_all(updates); end
end

# source://activerecord//lib/active_record/relation/batches.rb#9
ActiveRecord::Batches::DEFAULT_ORDER = T.let(T.unsafe(nil), Symbol)

# source://activerecord//lib/active_record/relation/batches.rb#8
ActiveRecord::Batches::ORDER_IGNORE_MESSAGE = T.let(T.unsafe(nil), String)

# = Active Record \Calculations
#
# source://activerecord//lib/active_record/relation/calculations.rb#7
module ActiveRecord::Calculations
  # Same as #average, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#122
  def async_average(column_name); end

  # Same as #count, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#108
  def async_count(column_name = T.unsafe(nil)); end

  # Same as #ids, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#397
  def async_ids; end

  # Same as #maximum, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#152
  def async_maximum(column_name); end

  # Same as #minimum, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#137
  def async_minimum(column_name); end

  # Same as #pick, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#353
  def async_pick(*column_names); end

  # Same as #pluck, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#324
  def async_pluck(*column_names); end

  # Same as #sum, but performs the query asynchronously and returns an
  # ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#182
  def async_sum(identity_or_column = T.unsafe(nil)); end

  # Calculates the average value on a given column. Returns +nil+ if there's
  # no row. See #calculate for examples with options.
  #
  #   Person.average(:age) # => 35.8
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#116
  def average(column_name); end

  # This calculates aggregate values in the given column. Methods for #count, #sum, #average,
  # #minimum, and #maximum have been added as shortcuts.
  #
  #   Person.calculate(:count, :all) # The same as Person.count
  #   Person.average(:age) # SELECT AVG(age) FROM people...
  #
  #   # Selects the minimum age for any family without any minors
  #   Person.group(:last_name).having("min(age) > 17").minimum(:age)
  #
  #   Person.sum("2 * age")
  #
  # There are two basic forms of output:
  #
  # * Single aggregate value: The single value is type cast to Integer for COUNT, Float
  #   for AVG, and the given column's type for everything else.
  #
  # * Grouped values: This returns an ordered hash of the values and groups them. It
  #   takes either a column name, or the name of a belongs_to association.
  #
  #      values = Person.group('last_name').maximum(:age)
  #      puts values["Drake"]
  #      # => 43
  #
  #      drake  = Family.find_by(last_name: 'Drake')
  #      values = Person.group(:family).maximum(:age) # Person belongs_to :family
  #      puts values[drake]
  #      # => 43
  #
  #      values.each do |family, max_age|
  #        ...
  #      end
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#217
  def calculate(operation, column_name); end

  # Count the records.
  #
  #   Person.count
  #   # => the total count of all people
  #
  #   Person.count(:age)
  #   # => returns the total count of all people whose age is present in database
  #
  #   Person.count(:all)
  #   # => performs a COUNT(*) (:all is an alias for '*')
  #
  #   Person.distinct.count(:age)
  #   # => counts the number of different age values
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group],
  # it returns a Hash whose keys represent the aggregated column,
  # and the values are the respective amounts:
  #
  #   Person.group(:city).count
  #   # => { 'Rome' => 5, 'Paris' => 3 }
  #
  # If #count is used with {Relation#group}[rdoc-ref:QueryMethods#group] for multiple columns, it returns a Hash whose
  # keys are an array containing the individual values of each column and the value
  # of each key would be the #count.
  #
  #   Article.group(:status, :category).count
  #   # =>  {["draft", "business"]=>10, ["draft", "technology"]=>4, ["published", "technology"]=>2}
  #
  # If #count is used with {Relation#select}[rdoc-ref:QueryMethods#select], it will count the selected columns:
  #
  #   Person.select(:age).count
  #   # => counts the number of different age values
  #
  # Note: not all valid {Relation#select}[rdoc-ref:QueryMethods#select] expressions are valid #count expressions. The specifics differ
  # between databases. In invalid cases, an error from the database is thrown.
  #
  # When given a block, loads all records in the relation, if the relation
  # hasn't been loaded yet. Calls the block with each record in the relation.
  # Returns the number of records for which the block returns a truthy value.
  #
  #   Person.count { |person| person.age > 21 }
  #   # => counts the number of people older that 21
  #
  # Note: If there are a lot of records in the relation, loading all records
  # could result in performance issues.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#94
  def count(column_name = T.unsafe(nil)); end

  # Returns the base model's ID's for the relation using the table's primary key
  #
  #   Person.ids # SELECT people.id FROM people
  #   Person.joins(:companies).ids # SELECT people.id FROM people INNER JOIN companies ON companies.id = people.company_id
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#361
  def ids; end

  # Calculates the maximum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.maximum(:age) # => 93
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#146
  def maximum(column_name); end

  # Calculates the minimum value on a given column. The value is returned
  # with the same data type of the column, or +nil+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.minimum(:age) # => 7
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#131
  def minimum(column_name); end

  # Pick the value(s) from the named column(s) in the current relation.
  # This is short-hand for <tt>relation.limit(1).pluck(*column_names).first</tt>, and is primarily useful
  # when you have a relation that's already narrowed down to a single row.
  #
  # Just like #pluck, #pick will only load the actual value, not the entire record object, so it's also
  # more efficient. The value is, again like with pluck, typecast by the column type.
  #
  #   Person.where(id: 1).pick(:name)
  #   # SELECT people.name FROM people WHERE id = 1 LIMIT 1
  #   # => 'David'
  #
  #   Person.where(id: 1).pick(:name, :email_address)
  #   # SELECT people.name, people.email_address FROM people WHERE id = 1 LIMIT 1
  #   # => [ 'David', 'david@loudthinking.com' ]
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#342
  def pick(*column_names); end

  # Use #pluck as a shortcut to select one or more attributes without
  # loading an entire record object per row.
  #
  #   Person.pluck(:name)
  #
  # instead of
  #
  #   Person.all.map(&:name)
  #
  # Pluck returns an Array of attribute values type-casted to match
  # the plucked column names, if they can be deduced. Plucking an SQL fragment
  # returns String values by default.
  #
  #   Person.pluck(:name)
  #   # SELECT people.name FROM people
  #   # => ['David', 'Jeremy', 'Jose']
  #
  #   Person.pluck(:id, :name)
  #   # SELECT people.id, people.name FROM people
  #   # => [[1, 'David'], [2, 'Jeremy'], [3, 'Jose']]
  #
  #   Person.distinct.pluck(:role)
  #   # SELECT DISTINCT role FROM people
  #   # => ['admin', 'member', 'guest']
  #
  #   Person.where(age: 21).limit(5).pluck(:id)
  #   # SELECT people.id FROM people WHERE people.age = 21 LIMIT 5
  #   # => [2, 3]
  #
  #   Person.pluck(Arel.sql('DATEDIFF(updated_at, created_at)'))
  #   # SELECT DATEDIFF(updated_at, created_at) FROM people
  #   # => ['0', '27761', '173']
  #
  # See also #ids.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#283
  def pluck(*column_names); end

  # Calculates the sum of values on a given column. The value is returned
  # with the same data type of the column, +0+ if there's no row. See
  # #calculate for examples with options.
  #
  #   Person.sum(:age) # => 4562
  #
  # When given a block, loads all records in the relation, if the relation
  # hasn't been loaded yet. Calls the block with each record in the relation.
  # Returns the sum of +initial_value_or_column+ and the block return
  # values:
  #
  #   Person.sum { |person| person.age } # => 4562
  #   Person.sum(1000) { |person| person.age } # => 5562
  #
  # Note: If there are a lot of records in the relation, loading all records
  # could result in performance issues.
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#172
  def sum(initial_value_or_column = T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/relation/calculations.rb#441
  def aggregate_column(column_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#402
  def all_attributes?(column_names); end

  # source://activerecord//lib/active_record/relation/calculations.rb#626
  def build_count_subquery(relation, column_name, distinct); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#437
  def distinct_select?(column_name); end

  # source://activerecord//lib/active_record/relation/calculations.rb#492
  def execute_grouped_calculation(operation, column_name, distinct); end

  # source://activerecord//lib/active_record/relation/calculations.rb#453
  def execute_simple_calculation(operation, column_name, distinct); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#406
  def has_include?(column_name); end

  # source://activerecord//lib/active_record/relation/calculations.rb#574
  def lookup_cast_type_from_join_dependencies(name, join_dependencies = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/calculations.rb#449
  def operation_over_aggregate_column(column, operation, distinct); end

  # source://activerecord//lib/active_record/relation/calculations.rb#410
  def perform_calculation(operation, column_name); end

  # source://activerecord//lib/active_record/relation/calculations.rb#617
  def select_for_count; end

  # source://activerecord//lib/active_record/relation/calculations.rb#599
  def type_cast_calculated_value(value, operation, type); end

  # source://activerecord//lib/active_record/relation/calculations.rb#582
  def type_cast_pluck_values(result, columns); end

  # source://activerecord//lib/active_record/relation/calculations.rb#569
  def type_for(field, &block); end
end

# source://activerecord//lib/active_record/relation/calculations.rb#8
class ActiveRecord::Calculations::ColumnAliasTracker
  # @return [ColumnAliasTracker] a new instance of ColumnAliasTracker
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#9
  def initialize(connection); end

  # source://activerecord//lib/active_record/relation/calculations.rb#14
  def alias_for(field); end

  private

  # Converts the given field to the value that the database adapter returns as
  # a usable column name:
  #
  #   column_alias_for("users.id")                 # => "users_id"
  #   column_alias_for("sum(id)")                  # => "sum_id"
  #   column_alias_for("count(distinct users.id)") # => "count_distinct_users_id"
  #   column_alias_for("count(*)")                 # => "count_all"
  #
  # source://activerecord//lib/active_record/relation/calculations.rb#35
  def column_alias_for(field); end

  # source://activerecord//lib/active_record/relation/calculations.rb#44
  def truncate(name); end
end

# = Active Record \Callbacks
#
# \Callbacks are hooks into the life cycle of an Active Record object that allow you to trigger logic
# before or after a change in the object state. This can be used to make sure that associated and
# dependent objects are deleted when {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] is called (by overwriting +before_destroy+) or
# to massage attributes before they're validated (by overwriting +before_validation+).
# As an example of the callbacks initiated, consider the {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] call for a new record:
#
# * (-) <tt>save</tt>
# * (-) <tt>valid</tt>
# * (1) <tt>before_validation</tt>
# * (-) <tt>validate</tt>
# * (2) <tt>after_validation</tt>
# * (3) <tt>before_save</tt>
# * (4) <tt>before_create</tt>
# * (-) <tt>create</tt>
# * (5) <tt>after_create</tt>
# * (6) <tt>after_save</tt>
# * (7) <tt>after_commit</tt>
#
# Also, an <tt>after_rollback</tt> callback can be configured to be triggered whenever a rollback is issued.
# Check out ActiveRecord::Transactions for more details about <tt>after_commit</tt> and
# <tt>after_rollback</tt>.
#
# Additionally, an <tt>after_touch</tt> callback is triggered whenever an
# object is touched.
#
# Lastly an <tt>after_find</tt> and <tt>after_initialize</tt> callback is triggered for each object that
# is found and instantiated by a finder, with <tt>after_initialize</tt> being triggered after new objects
# are instantiated as well.
#
# There are nineteen callbacks in total, which give a lot of control over how to react and prepare for each state in the
# Active Record life cycle. The sequence for calling {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] for an existing record is similar,
# except that each <tt>_create</tt> callback is replaced by the corresponding <tt>_update</tt> callback.
#
# Examples:
#   class CreditCard < ActiveRecord::Base
#     # Strip everything but digits, so the user can specify "555 234 34" or
#     # "5552-3434" and both will mean "55523434"
#     before_validation(on: :create) do
#       self.number = number.gsub(/[^0-9]/, "") if attribute_present?("number")
#     end
#   end
#
#   class Subscription < ActiveRecord::Base
#     before_create :record_signup
#
#     private
#       def record_signup
#         self.signed_up_on = Date.today
#       end
#   end
#
#   class Firm < ActiveRecord::Base
#     # Disables access to the system, for associated clients and people when the firm is destroyed
#     before_destroy { |record| Person.where(firm_id: record.id).update_all(access: 'disabled')   }
#     before_destroy { |record| Client.where(client_of: record.id).update_all(access: 'disabled') }
#   end
#
# == Inheritable callback queues
#
# Besides the overwritable callback methods, it's also possible to register callbacks through the
# use of the callback macros. Their main advantage is that the macros add behavior into a callback
# queue that is kept intact through an inheritance hierarchy.
#
#   class Topic < ActiveRecord::Base
#     before_destroy :destroy_author
#   end
#
#   class Reply < Topic
#     before_destroy :destroy_readers
#   end
#
# When <tt>Topic#destroy</tt> is run only +destroy_author+ is called. When <tt>Reply#destroy</tt> is
# run, both +destroy_author+ and +destroy_readers+ are called.
#
# *IMPORTANT:* In order for inheritance to work for the callback queues, you must specify the
# callbacks before specifying the associations. Otherwise, you might trigger the loading of a
# child before the parent has registered the callbacks and they won't be inherited.
#
# == Types of callbacks
#
# There are three types of callbacks accepted by the callback macros: method references (symbol), callback objects,
# inline methods (using a proc). \Method references and callback objects are the recommended approaches,
# inline methods using a proc are sometimes appropriate (such as for creating mix-ins).
#
# The method reference callbacks work by specifying a protected or private method available in the object, like this:
#
#   class Topic < ActiveRecord::Base
#     before_destroy :delete_parents
#
#     private
#       def delete_parents
#         self.class.delete_by(parent_id: id)
#       end
#   end
#
# The callback objects have methods named after the callback called with the record as the only parameter, such as:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new
#     after_save       EncryptionWrapper.new
#     after_initialize EncryptionWrapper.new
#   end
#
#   class EncryptionWrapper
#     def before_save(record)
#       record.credit_card_number = encrypt(record.credit_card_number)
#     end
#
#     def after_save(record)
#       record.credit_card_number = decrypt(record.credit_card_number)
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# So you specify the object you want to be messaged on a given callback. When that callback is triggered, the object has
# a method by the name of the callback messaged. You can make these callbacks more flexible by passing in other
# initialization data such as the name of the attribute to work with:
#
#   class BankAccount < ActiveRecord::Base
#     before_save      EncryptionWrapper.new("credit_card_number")
#     after_save       EncryptionWrapper.new("credit_card_number")
#     after_initialize EncryptionWrapper.new("credit_card_number")
#   end
#
#   class EncryptionWrapper
#     def initialize(attribute)
#       @attribute = attribute
#     end
#
#     def before_save(record)
#       record.send("#{@attribute}=", encrypt(record.send("#{@attribute}")))
#     end
#
#     def after_save(record)
#       record.send("#{@attribute}=", decrypt(record.send("#{@attribute}")))
#     end
#
#     alias_method :after_initialize, :after_save
#
#     private
#       def encrypt(value)
#         # Secrecy is committed
#       end
#
#       def decrypt(value)
#         # Secrecy is unveiled
#       end
#   end
#
# == <tt>before_validation*</tt> returning statements
#
# If the +before_validation+ callback throws +:abort+, the process will be
# aborted and {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will return +false+.
# If {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] is called it will raise an ActiveRecord::RecordInvalid exception.
# Nothing will be appended to the errors object.
#
# == Canceling callbacks
#
# If a <tt>before_*</tt> callback throws +:abort+, all the later callbacks and
# the associated action are cancelled.
# \Callbacks are generally run in the order they are defined, with the exception of callbacks defined as
# methods on the model, which are called last.
#
# == Ordering callbacks
#
# Sometimes application code requires that callbacks execute in a specific order. For example, a +before_destroy+
# callback (+log_children+ in this case) should be executed before records in the +children+ association are destroyed by the
# <tt>dependent: :destroy</tt> option.
#
# Let's look at the code below:
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# In this case, the problem is that when the +before_destroy+ callback is executed, records in the +children+ association no
# longer exist because the {ActiveRecord::Base#destroy}[rdoc-ref:Persistence#destroy] callback was executed first.
# You can use the +prepend+ option on the +before_destroy+ callback to avoid this.
#
#   class Topic < ActiveRecord::Base
#     has_many :children, dependent: :destroy
#
#     before_destroy :log_children, prepend: true
#
#     private
#       def log_children
#         # Child processing
#       end
#   end
#
# This way, the +before_destroy+ is executed before the <tt>dependent: :destroy</tt> is called, and the data is still available.
#
# Also, there are cases when you want several callbacks of the same type to
# be executed in order.
#
# For example:
#
#   class Topic < ActiveRecord::Base
#     has_many :children
#
#     after_save :log_children
#     after_save :do_something_else
#
#     private
#       def log_children
#         # Child processing
#       end
#
#       def do_something_else
#         # Something else
#       end
#   end
#
# In this case the +log_children+ is executed before +do_something_else+.
# This applies to all non-transactional callbacks, and to +before_commit+.
#
# For transactional +after_+ callbacks (+after_commit+, +after_rollback+, etc), the order
# can be set via configuration.
#
#   config.active_record.run_after_transaction_callbacks_in_order_defined = false
#
# When set to +true+ (the default from \Rails 7.1), callbacks are executed in the order they
# are defined, just like the example above. When set to +false+, the order is reversed, so
# +do_something_else+ is executed before +log_children+.
#
# == \Transactions
#
# The entire callback chain of a {#save}[rdoc-ref:Persistence#save], {#save!}[rdoc-ref:Persistence#save!],
# or {#destroy}[rdoc-ref:Persistence#destroy] call runs within a transaction. That includes <tt>after_*</tt> hooks.
# If everything goes fine a +COMMIT+ is executed once the chain has been completed.
#
# If a <tt>before_*</tt> callback cancels the action a +ROLLBACK+ is issued. You
# can also trigger a +ROLLBACK+ raising an exception in any of the callbacks,
# including <tt>after_*</tt> hooks. Note, however, that in that case the client
# needs to be aware of it because an ordinary {#save}[rdoc-ref:Persistence#save] will raise such exception
# instead of quietly returning +false+.
#
# == Debugging callbacks
#
# The callback chain is accessible via the <tt>_*_callbacks</tt> method on an object. Active Model \Callbacks support
# <tt>:before</tt>, <tt>:after</tt> and <tt>:around</tt> as values for the <tt>kind</tt> property. The <tt>kind</tt> property
# defines what part of the chain the callback runs in.
#
# To find all callbacks in the +before_save+ callback chain:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }
#
# Returns an array of callback objects that form the +before_save+ chain.
#
# To further check if the before_save chain contains a proc defined as <tt>rest_when_dead</tt> use the <tt>filter</tt> property of the callback object:
#
#   Topic._save_callbacks.select { |cb| cb.kind.eql?(:before) }.collect(&:filter).include?(:rest_when_dead)
#
# Returns true or false depending on whether the proc is contained in the +before_save+ callback chain on a Topic model.
#
# source://activerecord//lib/active_record/callbacks.rb#278
module ActiveRecord::Callbacks
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::Callbacks

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker

  # source://activerecord//lib/active_record/callbacks.rb#419
  def destroy; end

  # source://activerecord//lib/active_record/callbacks.rb#435
  def increment!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/callbacks.rb#431
  def touch(*_arg0, **_arg1); end

  private

  # source://activerecord//lib/active_record/callbacks.rb#444
  def _create_record; end

  # source://activerecord//lib/active_record/callbacks.rb#448
  def _update_record; end

  # source://activerecord//lib/active_record/callbacks.rb#440
  def create_or_update(**_arg0); end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
  end
end

# source://activerecord//lib/active_record/callbacks.rb#281
ActiveRecord::Callbacks::CALLBACKS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/callbacks.rb#288
module ActiveRecord::Callbacks::ClassMethods
  include ::ActiveModel::Callbacks
end

# source://activerecord//lib/active_record.rb#122
module ActiveRecord::Coders; end

# source://activerecord//lib/active_record/coders/column_serializer.rb#5
class ActiveRecord::Coders::ColumnSerializer
  # @return [ColumnSerializer] a new instance of ColumnSerializer
  #
  # source://activerecord//lib/active_record/coders/column_serializer.rb#9
  def initialize(attr_name, coder, object_class = T.unsafe(nil)); end

  # Public because it's called by Type::Serialized
  #
  # source://activerecord//lib/active_record/coders/column_serializer.rb#46
  def assert_valid_value(object, action:); end

  # Returns the value of attribute coder.
  #
  # source://activerecord//lib/active_record/coders/column_serializer.rb#7
  def coder; end

  # source://activerecord//lib/active_record/coders/column_serializer.rb#22
  def dump(object); end

  # source://activerecord//lib/active_record/coders/column_serializer.rb#16
  def init_with(coder); end

  # source://activerecord//lib/active_record/coders/column_serializer.rb#29
  def load(payload); end

  # Returns the value of attribute object_class.
  #
  # source://activerecord//lib/active_record/coders/column_serializer.rb#6
  def object_class; end

  private

  # source://activerecord//lib/active_record/coders/column_serializer.rb#54
  def check_arity_of_constructor; end
end

# source://activerecord//lib/active_record/coders/json.rb#5
module ActiveRecord::Coders::JSON
  class << self
    # source://activerecord//lib/active_record/coders/json.rb#6
    def dump(obj); end

    # source://activerecord//lib/active_record/coders/json.rb#10
    def load(json); end
  end
end

# source://activerecord//lib/active_record/coders/yaml_column.rb#7
class ActiveRecord::Coders::YAMLColumn < ::ActiveRecord::Coders::ColumnSerializer
  # @return [YAMLColumn] a new instance of YAMLColumn
  #
  # source://activerecord//lib/active_record/coders/yaml_column.rb#59
  def initialize(attr_name, object_class = T.unsafe(nil), permitted_classes: T.unsafe(nil), unsafe_load: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/coders/yaml_column.rb#77
  def coder; end

  # source://activerecord//lib/active_record/coders/yaml_column.rb#68
  def init_with(coder); end

  private

  # source://activerecord//lib/active_record/coders/yaml_column.rb#88
  def check_arity_of_constructor; end
end

# source://activerecord//lib/active_record/coders/yaml_column.rb#8
class ActiveRecord::Coders::YAMLColumn::SafeCoder
  # @return [SafeCoder] a new instance of SafeCoder
  #
  # source://activerecord//lib/active_record/coders/yaml_column.rb#9
  def initialize(permitted_classes: T.unsafe(nil), unsafe_load: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/coders/yaml_column.rb#15
  def dump(object); end

  # source://activerecord//lib/active_record/coders/yaml_column.rb#33
  def load(payload); end
end

# source://activerecord//lib/active_record/associations.rb#187
class ActiveRecord::CompositePrimaryKeyMismatchError < ::ActiveRecord::ActiveRecordError
  # @return [CompositePrimaryKeyMismatchError] a new instance of CompositePrimaryKeyMismatchError
  #
  # source://activerecord//lib/active_record/associations.rb#190
  def initialize(reflection = T.unsafe(nil)); end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations.rb#188
  def reflection; end
end

# source://activerecord//lib/active_record/migration.rb#175
class ActiveRecord::ConcurrentMigrationError < ::ActiveRecord::MigrationError
  # @return [ConcurrentMigrationError] a new instance of ConcurrentMigrationError
  #
  # source://activerecord//lib/active_record/migration.rb#179
  def initialize(message = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/migration.rb#176
ActiveRecord::ConcurrentMigrationError::DEFAULT_MESSAGE = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/migration.rb#177
ActiveRecord::ConcurrentMigrationError::RELEASE_LOCK_FAILED_MESSAGE = T.let(T.unsafe(nil), String)

# Raised when association is being configured improperly or user tries to use
# offset and limit together with
# {ActiveRecord::Base.has_many}[rdoc-ref:Associations::ClassMethods#has_many] or
# {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many]
# associations.
#
# source://activerecord//lib/active_record/errors.rb#369
class ActiveRecord::ConfigurationError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/connection_adapters.rb#4
module ActiveRecord::ConnectionAdapters
  extend ::ActiveSupport::Autoload
end

# = Active Record Abstract Adapter
#
# Active Record supports multiple database systems. AbstractAdapter and
# related classes form the abstraction layer which makes this possible.
# An AbstractAdapter represents a connection to a database, and provides an
# abstract interface for database-specific functionality such as establishing
# a connection, escaping values, building the right SQL fragments for +:offset+
# and +:limit+ options, etc.
#
# All the concrete database adapters follow the interface laid down in this class.
# {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling#connection] returns an AbstractAdapter object, which
# you can use.
#
# Most of the methods in the adapter are useful during migrations. Most
# notably, the instance methods provided by SchemaStatements are very useful.
#
# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#31
class ActiveRecord::ConnectionAdapters::AbstractAdapter
  include ::ActiveSupport::Callbacks
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::ConnectionAdapters::DatabaseStatements
  include ::ActiveRecord::ConnectionAdapters::Quoting
  include ::ActiveRecord::ConnectionAdapters::DatabaseLimits
  include ::ActiveRecord::ConnectionAdapters::QueryCache
  include ::ActiveRecord::ConnectionAdapters::Savepoints
  extend ::ActiveSupport::Callbacks::ClassMethods
  extend ::ActiveSupport::DescendantsTracker

  # @return [AbstractAdapter] a new instance of AbstractAdapter
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#128
  def initialize(config_or_deprecated_connection, deprecated_logger = T.unsafe(nil), deprecated_connection_options = T.unsafe(nil), deprecated_config = T.unsafe(nil)); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
  def __callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
  def __callbacks?; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _checkin_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#963
  def _checkout_callbacks; end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_checkin_callbacks(&block); end

  # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#951
  def _run_checkout_callbacks(&block); end

  # Checks whether the connection to the database is still active. This includes
  # checking whether the database is actually capable of responding, i.e. whether
  # the connection isn't stale.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#674
  def active?; end

  # Returns the human-readable name of the adapter. Use mixed case - one
  # can always use downcase if needed.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#377
  def adapter_name; end

  # This is meant to be implemented by the adapters that support custom enum types
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#612
  def add_enum_value(*_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#619
  def advisory_locks_enabled?; end

  # Override to check all foreign key constraints in a database.
  #
  # @return [Boolean]
  #
  # source://activesupport/7.1.3.2/lib/active_support/deprecation/method_wrappers.rb#46
  def all_foreign_keys_valid?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#586
  def async_enabled?; end

  # Called by ActiveRecord::InsertAll,
  # Passed an instance of ActiveRecord::InsertAll::Builder,
  # This method implements standard bulk inserts for all databases, but
  # should be overridden by adapters to implement common features with
  # non-standard syntax like handling duplicates or returning values.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#859
  def build_insert_sql(insert); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#830
  def case_insensitive_comparison(attribute, value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#826
  def case_sensitive_comparison(attribute, value); end

  # Override to check all foreign key constraints in a database.
  # The adapter should raise a +ActiveRecord::StatementInvalid+ if foreign key
  # constraints are not met.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#666
  def check_all_foreign_keys_valid!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#208
  def check_if_write_query(sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#874
  def check_version; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#799
  def clean!; end

  # Clear any caching the database adapter may be doing.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#754
  def clear_cache!(new_connection: T.unsafe(nil)); end

  # Check the connection back in to the connection pool
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#846
  def close; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#794
  def connect!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#313
  def connection_class; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#222
  def connection_retries; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def create(*_arg0, **_arg1, &_arg2); end

  # This is meant to be implemented by the adapters that support custom enum types
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#600
  def create_enum(*_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#386
  def database_exists?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#870
  def database_version; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#850
  def default_index_type?(index); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#234
  def default_timezone; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#822
  def default_uniqueness_comparison(attribute, value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def delete(*_arg0, **_arg1, &_arg2); end

  # This is meant to be implemented by the adapters that support extensions
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#592
  def disable_extension(name, **_arg1); end

  # Override to turn off referential integrity while executing <tt>&block</tt>.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#650
  def disable_referential_integrity; end

  # Immediately forget this connection ever existed. Unlike disconnect!,
  # this will not communicate with the server.
  #
  # After calling this method, the behavior of all other methods becomes
  # undefined. This is called internally just before a forked process gets
  # rid of a connection that belonged to its parent.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#729
  def discard!; end

  # Disconnects from the database if already connected. Otherwise, this
  # method does nothing.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#717
  def disconnect!; end

  # This is meant to be implemented by the adapters that support custom enum types
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#604
  def drop_enum(*_arg0); end

  # This is meant to be implemented by the adapters that support extensions
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#596
  def enable_extension(name, **_arg1); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def exec_insert_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def exec_query(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def execute(*_arg0, **_arg1, &_arg2); end

  # this method must only be called while holding connection pool's mutex
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#334
  def expire; end

  # A list of extensions, to be filled in by adapters that support them.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#638
  def extensions; end

  # This is meant to be implemented by the adapters that support advisory
  # locks
  #
  # Return true if we got the lock, otherwise false
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#627
  def get_advisory_lock(lock_id); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#867
  def get_database_version; end

  # Returns the value of attribute owner.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#45
  def in_use?; end

  # A list of index algorithms, to be filled by adapters that support them.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#643
  def index_algorithms; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def insert(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#261
  def internal_metadata; end

  # this method must only be called while holding connection pool's mutex
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#298
  def lease; end

  # Returns the value of attribute lock.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#45
  def lock; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#183
  def lock_thread=(lock_thread); end

  # Returns the value of attribute logger.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#45
  def logger; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#253
  def migration_context; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#249
  def migrations_paths; end

  # Returns the value of attribute owner.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#45
  def owner; end

  # Returns the value of attribute pool.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#44
  def pool; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#48
  def pool=(value); end

  # Should primary key values be selected from their corresponding
  # sequence before the insert statement? If true, next_sequence_value
  # is called before each insert to set the record's primary key.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#426
  def prefetch_primary_key?(table_name = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#265
  def prepared_statements; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#265
  def prepared_statements?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#270
  def prepared_statements_disabled_cache; end

  # Determines whether writes are currently being prevented.
  #
  # Returns true if the connection is a replica or returns
  # the value of +current_preventing_writes+.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#242
  def preventing_writes?; end

  # Provides access to the underlying database driver for this adapter. For
  # example, this method returns a Mysql2::Client object in case of Mysql2Adapter,
  # and a PG::Connection object in case of PostgreSQLAdapter.
  #
  # This is useful for when you need to call a proprietary method such as
  # PostgreSQL's lo_* methods.
  #
  # Active Record cannot track if the database is getting modified using
  # this client. If that is the case, generally you'll want to invalidate
  # the query cache using +ActiveRecord::Base.clear_query_cache+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#814
  def raw_connection; end

  # Disconnects from the database if already connected, and establishes a new
  # connection with the database. Implementors should define private #reconnect
  # instead.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#680
  def reconnect!(restore_transactions: T.unsafe(nil)); end

  # This is meant to be implemented by the adapters that support advisory
  # locks.
  #
  # Return true if we released the lock, otherwise false
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#634
  def release_advisory_lock(lock_id); end

  # This is meant to be implemented by the adapters that support custom enum types
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#608
  def rename_enum(*_arg0); end

  # This is meant to be implemented by the adapters that support custom enum types
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#616
  def rename_enum_value(*_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#214
  def replica?; end

  # Returns true if its required to reload the connection between requests for development mode.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#767
  def requires_reloading?; end

  # Reset the state of this connection, directing the DBMS to clear
  # transactions and other connection-related server-side state. Usually a
  # database-dependent operation.
  #
  # If a database driver or protocol does not support such a feature,
  # implementors may alias this to #reconnect!. Otherwise, implementors
  # should call super immediately after resetting the connection (and while
  # still holding @lock).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#741
  def reset!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def restart_db_transaction(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#226
  def retry_deadline; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#582
  def return_value_after_insert?(column); end

  # The role (e.g. +:writing+) for the current connection. In a
  # non-multi role application, +:writing+ is returned.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#319
  def role; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def rollback_db_transaction(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def rollback_to_savepoint(*_arg0, **_arg1, &_arg2); end

  # Do TransactionRollbackErrors on savepoints affect the parent
  # transaction?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#410
  def savepoint_errors_invalidate_transactions?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#329
  def schema_cache; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#257
  def schema_migration; end

  # Returns the version identifier of the schema currently available in
  # the database. This is generally equal to the number of the highest-
  # numbered migration that has been executed, or 0 if no schema
  # information is present / the database is empty.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#881
  def schema_version; end

  # Seconds since this connection was returned to the pool
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#363
  def seconds_idle; end

  # The shard (e.g. +:default+) for the current connection. In
  # a non-sharded application, +:default+ is returned.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#325
  def shard; end

  # this method must only be called while holding connection pool's mutex (and a desire for segfaults)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#350
  def steal!; end

  # Does this adapter support application-enforced advisory locking?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#419
  def supports_advisory_locks?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#399
  def supports_bulk_alter?; end

  # Does this adapter support creating check constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#491
  def supports_check_constraints?; end

  # Does this adapter support metadata comments on database objects (tables, columns, indexes)?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#526
  def supports_comments?; end

  # Can comments for tables, columns, and indexes be specified in create/alter table statements?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#531
  def supports_comments_in_create?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#550
  def supports_common_table_expressions?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#574
  def supports_concurrent_connections?; end

  # Does this adapter support datetime with precision?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#516
  def supports_datetime_with_precision?; end

  # Does this adapter support DDL rollbacks in transactions? That is, would
  # CREATE TABLE or ALTER TABLE get rolled back by a transaction?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#395
  def supports_ddl_transactions?; end

  # Does this adapter support creating deferrable constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#486
  def supports_deferrable_constraints?; end

  # Does this adapter support creating exclusion constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#496
  def supports_exclusion_constraints?; end

  # Does this adapter support explain?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#455
  def supports_explain?; end

  # Does this adapter support expression indices?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#450
  def supports_expression_index?; end

  # Does this adapter support database extensions?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#465
  def supports_extensions?; end

  # Does this adapter support creating foreign key constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#476
  def supports_foreign_keys?; end

  # Does this adapter support foreign/external tables?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#541
  def supports_foreign_tables?; end

  # Does this adapter support including non-key columns?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#445
  def supports_index_include?; end

  # Does this adapter support index sort order?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#435
  def supports_index_sort_order?; end

  # Does this adapter support creating indexes in the same statement as
  # creating the table?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#471
  def supports_indexes_in_create?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#570
  def supports_insert_conflict_target?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#562
  def supports_insert_on_duplicate_skip?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#566
  def supports_insert_on_duplicate_update?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#558
  def supports_insert_returning?; end

  # Does this adapter support JSON data type?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#521
  def supports_json?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#554
  def supports_lazy_transactions?; end

  # Does this adapter support materialized views?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#511
  def supports_materialized_views?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#578
  def supports_nulls_not_distinct?; end

  # Does this adapter support optimizer hints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#546
  def supports_optimizer_hints?; end

  # Does this adapter support partial indices?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#440
  def supports_partial_index?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#430
  def supports_partitioned_indexes?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#414
  def supports_restart_db_transaction?; end

  # Does this adapter support savepoints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#404
  def supports_savepoints?; end

  # Does this adapter support setting the isolation level for a transaction?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#460
  def supports_transaction_isolation?; end

  # Does this adapter support creating unique constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#501
  def supports_unique_constraints?; end

  # Does this adapter support creating invalid constraints?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#481
  def supports_validate_constraints?; end

  # Does this adapter support views?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#506
  def supports_views?; end

  # Does this adapter support virtual columns?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#536
  def supports_virtual_columns?; end

  # Removes the connection from the pool and disconnect it.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#748
  def throw_away!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def truncate(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def truncate_tables(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#368
  def unprepared_statement; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#23
  def update(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#218
  def use_metadata_table?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#293
  def valid_type?(type); end

  # Checks whether the connection to the database is still active (i.e. not stale).
  # This is done under the hood by calling #active?. If the connection
  # is no longer active, then this method will reconnect to the database.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#774
  def verify!; end

  # Returns the value of attribute visitor.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#45
  def visitor; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#198
  def with_instrumenter(instrumenter, &block); end

  private

  # Returns a raw connection for internal use with methods that are known
  # to both be thread-safe and not rely upon actual server communication.
  # This is useful for e.g. string escaping methods.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1099
  def any_raw_connection; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1204
  def arel_visitor; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1088
  def backoff(counter); end

  # Builds the result object.
  #
  # This is an internal hook to make possible connection adapters to build
  # custom result objects with connection-specific data.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1215
  def build_result(columns:, rows:, column_types: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1208
  def build_statement_pool; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#840
  def can_perform_case_insensitive_comparison_for?(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1190
  def collector; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1179
  def column_for(table_name, column_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1185
  def column_for_attribute(attribute); end

  # Perform any necessary initialization upon the newly-established
  # connection settings, run queries to configure any application-global
  # "session" variables, etc.
  #
  # Implementations may assume this method will only be called while
  # holding @lock (or from #initialize).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1226
  def configure_connection; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1229
  def default_prepared_statements; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1116
  def extended_type_map_key; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1074
  def invalidate_transaction(exception); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1142
  def log(sql, name = T.unsafe(nil), binds = T.unsafe(nil), type_casted_binds = T.unsafe(nil), statement_name = T.unsafe(nil), async: T.unsafe(nil), &block); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1092
  def reconnect; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#962
  def reconnect_can_restore_state?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1070
  def retryable_connection_error?(exception); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1081
  def retryable_query_error?(exception); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1158
  def transform_query(sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1165
  def translate_exception(exception, message:, sql:, binds:); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1132
  def translate_exception_class(e, sql, binds); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1122
  def type_map; end

  # Similar to any_raw_connection, but ensures it is validated and
  # connected. Any method called on this result still needs to be
  # independently thread-safe, so it probably shouldn't talk to the
  # server... but some drivers fail if they know the connection has gone
  # away.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1108
  def valid_raw_connection; end

  # Mark the connection as verified. Call this inside a
  # `with_raw_connection` block only when the block is guaranteed to
  # exercise the raw connection.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1066
  def verified!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1233
  def warning_ignored?(warning); end

  # Lock the monitor, ensure we're properly connected and
  # transactions are materialized, and then yield the underlying
  # raw connection object.
  #
  # If +allow_retry+ is true, a connection-related exception will
  # cause an automatic reconnect and re-run of the block, up to
  # the connection's configured +connection_retries+ setting
  # and the configured +retry_deadline+ limit. (Note that when
  # +allow_retry+ is true, it's possible to return without having marked
  # the connection as verified. If the block is guaranteed to exercise the
  # connection, consider calling `verified!` to avoid needless
  # verification queries in subsequent calls.)
  #
  # If +materialize_transactions+ is false, the block will be run without
  # ensuring virtual transactions have been materialized in the DB
  # server's state. The active transaction will also remain clean
  # (if it is not already dirty), meaning it's able to be restored
  # by reconnecting and opening an equivalent-depth set of new
  # transactions. This should only be used by transaction control
  # methods, and internal transaction-agnostic queries.
  #
  #
  #
  # It's not the primary use case, so not something to optimize
  # for, but note that this method does need to be re-entrant:
  # +materialize_transactions+ will re-enter if it has work to do,
  # and the yield block can also do so under some circumstances.
  #
  # In the latter case, we really ought to guarantee the inner
  # call will not reconnect (which would interfere with the
  # still-yielded connection in the outer block), but we currently
  # provide no special enforcement there.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#999
  def with_raw_connection(allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#1175
  def without_prepared_statement?(binds); end

  class << self
    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#70
    def __callbacks?; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _checkin_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _checkin_callbacks=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#955
    def _checkout_callbacks; end

    # source://activesupport/7.1.3.2/lib/active_support/callbacks.rb#959
    def _checkout_callbacks=(value); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#89
    def build_read_query_regexp(*parts); end

    # Does the database for this adapter exist?
    #
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#382
    def database_exists?(config); end

    # Opens a database console session.
    #
    # @raise [NotImplementedError]
    #
    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#124
    def dbconsole(config, options = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#893
    def extended_type_map(default_timezone:); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#95
    def find_cmd_and_exec(commands, *args); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#886
    def register_class_with_precision(mapping, key, klass, **kwargs); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#68
    def type_cast_config_to_boolean(config); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#58
    def type_cast_config_to_integer(config); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#76
    def validate_default_timezone(config); end

    private

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#953
    def extract_limit(sql_type); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#949
    def extract_precision(sql_type); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#942
    def extract_scale(sql_type); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#902
    def initialize_type_map(m); end

    # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#935
    def register_class_with_limit(mapping, key, klass); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#32
ActiveRecord::ConnectionAdapters::AbstractAdapter::ADAPTER_NAME = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#42
ActiveRecord::ConnectionAdapters::AbstractAdapter::COMMENT_REGEX = T.let(T.unsafe(nil), Regexp)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#86
ActiveRecord::ConnectionAdapters::AbstractAdapter::DEFAULT_READ_QUERY = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#196
ActiveRecord::ConnectionAdapters::AbstractAdapter::EXCEPTION_IMMEDIATE = T.let(T.unsafe(nil), Hash)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#195
ActiveRecord::ConnectionAdapters::AbstractAdapter::EXCEPTION_NEVER = T.let(T.unsafe(nil), Hash)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#959
ActiveRecord::ConnectionAdapters::AbstractAdapter::EXTENDED_TYPE_MAPS = T.let(T.unsafe(nil), Concurrent::Map)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#180
ActiveRecord::ConnectionAdapters::AbstractAdapter::FIBER_LOCK = T.let(T.unsafe(nil), ActiveSupport::Concurrency::LoadInterlockAwareMonitor)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#41
ActiveRecord::ConnectionAdapters::AbstractAdapter::SIMPLE_INT = T.let(T.unsafe(nil), Regexp)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#177
ActiveRecord::ConnectionAdapters::AbstractAdapter::THREAD_LOCK = T.let(T.unsafe(nil), ActiveSupport::Concurrency::ThreadLoadInterlockAwareMonitor)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#958
ActiveRecord::ConnectionAdapters::AbstractAdapter::TYPE_MAP = T.let(T.unsafe(nil), ActiveRecord::Type::TypeMap)

# source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#274
class ActiveRecord::ConnectionAdapters::AbstractAdapter::Version
  include ::Comparable

  # @return [Version] a new instance of Version
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#279
  def initialize(version_string, full_version_string = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#284
  def <=>(version_string); end

  # Returns the value of attribute full_version_string.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#277
  def full_version_string; end

  # source://activerecord//lib/active_record/connection_adapters/abstract_adapter.rb#288
  def to_s; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#12
module ActiveRecord::ConnectionAdapters::AbstractPool; end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#114
class ActiveRecord::ConnectionAdapters::AddColumnDefinition < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#621
class ActiveRecord::ConnectionAdapters::AlterTable
  # @return [AlterTable] a new instance of AlterTable
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#626
  def initialize(td); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#645
  def add_check_constraint(expression, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#653
  def add_column(name, type, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#637
  def add_foreign_key(to_table, options); end

  # Returns the value of attribute adds.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#622
  def adds; end

  # Returns the value of attribute check_constraint_adds.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#624
  def check_constraint_adds; end

  # Returns the value of attribute check_constraint_drops.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#624
  def check_constraint_drops; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#649
  def drop_check_constraint(constraint_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#641
  def drop_foreign_key(name); end

  # Returns the value of attribute foreign_key_adds.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#623
  def foreign_key_adds; end

  # Returns the value of attribute foreign_key_drops.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#623
  def foreign_key_drops; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#635
  def name; end
end

# source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#149
class ActiveRecord::ConnectionAdapters::BoundSchemaReflection
  # @return [BoundSchemaReflection] a new instance of BoundSchemaReflection
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#150
  def initialize(abstract_schema_reflection, connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#175
  def add(name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#163
  def cached?(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#155
  def clear!; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#211
  def clear_data_source_cache!(name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#183
  def columns(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#187
  def columns_hash(table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#191
  def columns_hash?(table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#171
  def data_source_exists?(name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#179
  def data_sources(name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#199
  def database_version; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#215
  def dump_to(filename); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#195
  def indexes(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#159
  def load!; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#167
  def primary_keys(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#207
  def size; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#203
  def version; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#118
class ActiveRecord::ConnectionAdapters::ChangeColumnDefaultDefinition < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute default
  #
  # @return [Object] the current value of default
  def default; end

  # Sets the attribute default
  #
  # @param value [Object] the value to set the attribute default to.
  # @return [Object] the newly set value
  def default=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#116
class ActiveRecord::ConnectionAdapters::ChangeColumnDefinition < ::Struct
  # Returns the value of attribute column
  #
  # @return [Object] the current value of column
  def column; end

  # Sets the attribute column
  #
  # @param value [Object] the value to set the attribute column to.
  # @return [Object] the newly set value
  def column=(_); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#174
class ActiveRecord::ConnectionAdapters::CheckConstraintDefinition < ::Struct
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#188
  def defined_for?(name:, expression: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#184
  def export_name_on_schema_dump?; end

  # Returns the value of attribute expression
  #
  # @return [Object] the current value of expression
  def expression; end

  # Sets the attribute expression
  #
  # @param value [Object] the value to set the attribute expression to.
  # @return [Object] the newly set value
  def expression=(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#175
  def name; end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # Returns the value of attribute table_name
  #
  # @return [Object] the current value of table_name
  def table_name; end

  # Sets the attribute table_name
  #
  # @param value [Object] the value to set the attribute table_name to.
  # @return [Object] the newly set value
  def table_name=(_); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#179
  def validate?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#179
  def validated?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# An abstract definition of a column in a table.
#
# source://activerecord//lib/active_record/connection_adapters/column.rb#7
class ActiveRecord::ConnectionAdapters::Column
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # Instantiates a new column in the table.
  #
  # +name+ is the column's name, such as <tt>supplier_id</tt> in <tt>supplier_id bigint</tt>.
  # +default+ is the type-casted default value, such as +new+ in <tt>sales_stage varchar(20) default 'new'</tt>.
  # +sql_type_metadata+ is various information about the type of the column
  # +null+ determines if this column allows +NULL+ values.
  #
  # @return [Column] a new instance of Column
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#20
  def initialize(name, default, sql_type_metadata = T.unsafe(nil), null = T.unsafe(nil), default_function = T.unsafe(nil), collation: T.unsafe(nil), comment: T.unsafe(nil), **_arg7); end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#75
  def ==(other); end

  # whether the column is auto-populated by the database using a sequence
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#67
  def auto_incremented_by_db?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#71
  def auto_populated?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#34
  def bigint?; end

  # Returns the value of attribute collation.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def collation; end

  # Returns the value of attribute comment.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def comment; end

  # Returns the value of attribute default.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def default; end

  # Returns the value of attribute default_function.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def default_function; end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#56
  def encode_with(coder); end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#75
  def eql?(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#30
  def has_default?; end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#87
  def hash; end

  # Returns the human name of the column name.
  #
  # ===== Examples
  #  Column.new('sales_stage', ...).human_name # => 'Sales stage'
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#42
  def human_name; end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#46
  def init_with(coder); end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#12
  def limit(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def name; end

  # Returns the value of attribute null.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def null; end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#12
  def precision(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#12
  def scale(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#12
  def sql_type(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute sql_type_metadata.
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#10
  def sql_type_metadata; end

  # source://activerecord//lib/active_record/connection_adapters/column.rb#12
  def type(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#99
  def virtual?; end

  private

  # source://activerecord//lib/active_record/connection_adapters/column.rb#104
  def deduplicated; end
end

# Abstract representation of a column definition. Instances of this type
# are typically created by methods in TableDefinition, and added to the
# +columns+ attribute of said TableDefinition object, in order to be used
# for generating a number of table creation or table changing SQL statements.
#
# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#79
class ActiveRecord::ConnectionAdapters::ColumnDefinition < ::Struct
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#109
  def aliased_types(name, fallback); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def collation; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def collation=(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def comment; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def comment=(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def default; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def default=(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def if_exists; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def if_exists=(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def if_not_exists; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def if_not_exists=(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def limit; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def limit=(value); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def null; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def null=(value); end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def precision; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def precision=(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#93
  def primary_key?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#99
  def scale; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#103
  def scale=(value); end

  # Returns the value of attribute sql_type
  #
  # @return [Object] the current value of sql_type
  def sql_type; end

  # Sets the attribute sql_type
  #
  # @param value [Object] the value to set the attribute sql_type to.
  # @return [Object] the newly set value
  def sql_type=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#80
ActiveRecord::ConnectionAdapters::ColumnDefinition::OPTION_NAMES = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#300
module ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # Appends a primary key definition to the table definition.
  # Can be called multiple times, but this is probably not a good idea.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#305
  def primary_key(name, type = T.unsafe(nil), **options); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#0
module ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods
  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#329
  def define_column_methods(*column_types); end
end

# = Active Record Connection Handler
#
# ConnectionHandler is a collection of ConnectionPool objects. It is used
# for keeping separate connection pools that connect to different databases.
#
# For example, suppose that you have 5 models, with the following hierarchy:
#
#   class Author < ActiveRecord::Base
#   end
#
#   class BankAccount < ActiveRecord::Base
#   end
#
#   class Book < ActiveRecord::Base
#     establish_connection :library_db
#   end
#
#   class ScaryBook < Book
#   end
#
#   class GoodBook < Book
#   end
#
# And a database.yml that looked like this:
#
#   development:
#     database: my_application
#     host: localhost
#
#   library_db:
#     database: library
#     host: some.library.org
#
# Your primary database in the development environment is "my_application"
# but the Book model connects to a separate database called "library_db"
# (this can even be a database on a different machine).
#
# Book, ScaryBook, and GoodBook will all use the same connection pool to
# "library_db" while Author, BankAccount, and any other models you create
# will use the default connection pool to "my_application".
#
# The various connection pools are managed by a single instance of
# ConnectionHandler accessible via ActiveRecord::Base.connection_handler.
# All Active Record models use this handler to determine the connection pool that they
# should use.
#
# The ConnectionHandler class is not coupled with the Active models, as it has no knowledge
# about the model. The model needs to pass a connection specification name to the handler,
# in order to look up the correct connection pool.
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#57
class ActiveRecord::ConnectionAdapters::ConnectionHandler
  # @return [ConnectionHandler] a new instance of ConnectionHandler
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#77
  def initialize; end

  # Returns true if there are any active connections among the connection
  # pools that the ConnectionHandler is managing.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#173
  def active_connections?(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#97
  def all_connection_pools; end

  # Returns any connections in use by the current thread back to the pool,
  # and also returns connections to the pool cached by threads that are no
  # longer alive.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#185
  def clear_active_connections!(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#206
  def clear_all_connections!(role = T.unsafe(nil)); end

  # Clears the cache which maps classes.
  #
  # See ConnectionPool#clear_reloadable_connections! for details.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#197
  def clear_reloadable_connections!(role = T.unsafe(nil)); end

  # Returns true if a connection that's accessible to this class has
  # already been opened.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#251
  def connected?(connection_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Returns the pools for a connection handler and  given role. If +:all+ is passed,
  # all pools belonging to the connection handler will be returned.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#107
  def connection_pool_list(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#93
  def connection_pool_names; end

  # Returns the pools for a connection handler and  given role. If +:all+ is passed,
  # all pools belonging to the connection handler will be returned.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#107
  def connection_pools(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#120
  def each_connection_pool(role = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#131
  def establish_connection(config, owner_name: T.unsafe(nil), role: T.unsafe(nil), shard: T.unsafe(nil), clobber: T.unsafe(nil)); end

  # Disconnects all currently idle connections.
  #
  # See ConnectionPool#flush! for details.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#218
  def flush_idle_connections!(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#85
  def prevent_writes; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#89
  def prevent_writes=(prevent_writes); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#256
  def remove_connection_pool(connection_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Locate the connection of the nearest super class. This can be an
  # active or defined connection: if it is the latter, it will be
  # opened and set as the active connection for the class it was defined
  # for (not necessarily the current class).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#231
  def retrieve_connection(connection_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  # Retrieving the connection pool happens a lot, so we cache it in @connection_name_to_pool_manager.
  # This makes retrieving the connection pool O(1) once the process is warm.
  # When a connection is established or removed, we invalidate the cache.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#265
  def retrieve_connection_pool(connection_name, role: T.unsafe(nil), shard: T.unsafe(nil)); end

  private

  # Returns the value of attribute connection_name_to_pool_manager.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#271
  def connection_name_to_pool_manager; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#287
  def deprecation_for_pool_handling(method); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#356
  def determine_owner_name(owner_name, config); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#304
  def disconnect_pool_from_pool_manager(pool_manager, role, shard); end

  # Returns the pool manager for a connection name / identifier.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#274
  def get_pool_manager(connection_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#283
  def pool_managers; end

  # Returns an instance of PoolConfig for a given adapter.
  # Accepts a hash one layer deep that contains all connection information.
  #
  # == Example
  #
  #   config = { "production" => { "host" => "localhost", "database" => "foo", "adapter" => "sqlite3" } }
  #   pool_config = Base.configurations.resolve_pool_config(:production)
  #   pool_config.db_config.configuration_hash
  #   # => { host: "localhost", database: "foo", adapter: "sqlite3" }
  #
  # @raise [AdapterNotSpecified]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#323
  def resolve_pool_config(config, connection_name, role, shard); end

  # Get the existing pool manager or initialize and assign a new one.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#279
  def set_pool_manager(connection_name); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#58
ActiveRecord::ConnectionAdapters::ConnectionHandler::FINALIZER = T.let(T.unsafe(nil), Proc)

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#61
class ActiveRecord::ConnectionAdapters::ConnectionHandler::StringConnectionName
  # @return [StringConnectionName] a new instance of StringConnectionName
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#64
  def initialize(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#72
  def current_preventing_writes; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#62
  def name; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_handler.rb#68
  def primary_class?; end
end

# = Active Record Connection Pool
#
# Connection pool base class for managing Active Record database
# connections.
#
# == Introduction
#
# A connection pool synchronizes thread access to a limited number of
# database connections. The basic idea is that each thread checks out a
# database connection from the pool, uses that connection, and checks the
# connection back in. ConnectionPool is completely thread-safe, and will
# ensure that a connection cannot be used by two threads at the same time,
# as long as ConnectionPool's contract is correctly followed. It will also
# handle cases in which there are more threads than connections: if all
# connections have been checked out, and a thread tries to checkout a
# connection anyway, then ConnectionPool will wait until some other thread
# has checked in a connection, or the +checkout_timeout+ has expired.
#
# == Obtaining (checking out) a connection
#
# Connections can be obtained and used from a connection pool in several
# ways:
#
# 1. Simply use {ActiveRecord::Base.connection}[rdoc-ref:ConnectionHandling.connection].
#    When you're done with the connection(s) and wish it to be returned to the pool, you call
#    {ActiveRecord::Base.connection_handler.clear_active_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_active_connections!].
#    This is the default behavior for Active Record when used in conjunction with
#    Action Pack's request handling cycle.
# 2. Manually check out a connection from the pool with
#    {ActiveRecord::Base.connection_pool.checkout}[rdoc-ref:#checkout]. You are responsible for
#    returning this connection to the pool when finished by calling
#    {ActiveRecord::Base.connection_pool.checkin(connection)}[rdoc-ref:#checkin].
# 3. Use {ActiveRecord::Base.connection_pool.with_connection(&block)}[rdoc-ref:#with_connection], which
#    obtains a connection, yields it as the sole argument to the block,
#    and returns it to the pool after the block completes.
#
# Connections in the pool are actually AbstractAdapter objects (or objects
# compatible with AbstractAdapter's interface).
#
# While a thread has a connection checked out from the pool using one of the
# above three methods, that connection will automatically be the one used
# by ActiveRecord queries executing on that thread. It is not required to
# explicitly pass the checked out connection to \Rails models or queries, for
# example.
#
# == Options
#
# There are several connection-pooling-related options that you can add to
# your database connection configuration:
#
# * +pool+: maximum number of connections the pool may manage (default 5).
# * +idle_timeout+: number of seconds that a connection will be kept
#   unused in the pool before it is automatically disconnected (default
#   300 seconds). Set this to zero to keep connections forever.
# * +checkout_timeout+: number of seconds to wait for a connection to
#   become available before giving up and raising a timeout error (default
#   5 seconds).
#
# --
# Synchronization policy:
# * all public methods can be called outside +synchronize+
# * access to these instance variables needs to be in +synchronize+:
#   * @connections
#   * @now_connecting
# * private methods that require being called in a +synchronize+ blocks
#   are now explicitly documented
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#8
class ActiveRecord::ConnectionAdapters::ConnectionPool
  include ::MonitorMixin
  include ::ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  include ::ActiveRecord::ConnectionAdapters::AbstractPool

  # Creates a new ConnectionPool object. +pool_config+ is a PoolConfig
  # object which describes database connection information (e.g. adapter,
  # host name, username, password, etc), as well as the maximum size for
  # this ConnectionPool.
  #
  # The default ConnectionPool maximum size is 5.
  #
  # @return [ConnectionPool] a new instance of ConnectionPool
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#120
  def initialize(pool_config); end

  # Returns true if there is an open connection being used for the current thread.
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods. Connections obtained through
  # #checkout will not be detected by #active_connection?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#196
  def active_connection?; end

  # Returns the value of attribute async_executor.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def async_executor; end

  # Returns the value of attribute automatic_reconnect.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#109
  def automatic_reconnect; end

  # Sets the attribute automatic_reconnect
  #
  # @param value the value to set the attribute automatic_reconnect to.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#109
  def automatic_reconnect=(_arg0); end

  # Check-in a database connection back into the pool, indicating that you
  # no longer need this connection.
  #
  # +conn+: an AbstractAdapter object, which was obtained by earlier by
  # calling #checkout on this pool.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#363
  def checkin(conn); end

  # Check-out a database connection from the pool, indicating that you want
  # to use it. You should call #checkin when you no longer need this.
  #
  # This is done by either returning and leasing existing connection, or by
  # creating a new connection and leasing it.
  #
  # If all connections are leased and the pool is at capacity (meaning the
  # number of currently leased connections is greater than or equal to the
  # size limit set), an ActiveRecord::ConnectionTimeoutError exception will be raised.
  #
  # Returns: an AbstractAdapter object.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError no connection can be obtained from the pool.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#352
  def checkout(checkout_timeout = T.unsafe(nil)); end

  # Returns the value of attribute checkout_timeout.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#109
  def checkout_timeout; end

  # Sets the attribute checkout_timeout
  #
  # @param value the value to set the attribute checkout_timeout to.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#109
  def checkout_timeout=(_arg0); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.db_config.checkout_timeout * 2</tt> seconds).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#310
  def clear_reloadable_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Clears the cache which maps classes and re-connects connections that
  # require reloading.
  #
  # The pool first tries to gain ownership of all connections. If unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool forcefully
  # clears the cache and reloads connections without any regard for other
  # connection owning threads.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#334
  def clear_reloadable_connections!; end

  # Returns true if a connection has already been opened.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#233
  def connected?; end

  # Retrieve the connection associated with the current thread, or call
  # #checkout to obtain one if necessary.
  #
  # #connection can be called any number of times; the connection is
  # held in a cache keyed by a thread.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#181
  def connection; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#185
  def connection_class; end

  # source://activesupport/7.1.3.2/lib/active_support/deprecation/method_wrappers.rb#46
  def connection_klass(*args, **_arg1, &block); end

  # Returns an array containing the connections currently in the pool.
  # Access to the array does not require synchronization on the pool because
  # the array is newly created and not retained by the pool.
  #
  # However; this method bypasses the ConnectionPool's thread-safe connection
  # access pattern. A returned connection may be owned by another thread,
  # unowned, or by happen-stance owned by the calling thread.
  #
  # Calling methods on a connection without ownership is subject to the
  # thread-safety guarantees of the underlying method. Many of the methods
  # on connection adapter classes are inherently multi-thread unsafe.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#248
  def connections; end

  # Returns the value of attribute db_config.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def db_config; end

  # Discards all connections in the pool (even if they're currently
  # leased!), along with the pool itself. Any further interaction with the
  # pool (except #spec and #schema_cache) is undefined.
  #
  # See AbstractAdapter#discard!
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#289
  def discard!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#299
  def discarded?; end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # Raises:
  # - ActiveRecord::ExclusiveConnectionTimeoutError if unable to gain ownership of all
  #   connections in the pool within a timeout interval (default duration is
  #   <tt>spec.db_config.checkout_timeout * 2</tt> seconds).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#258
  def disconnect(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # Disconnects all connections in the pool, and clears the pool.
  #
  # The pool first tries to gain ownership of all connections. If unable to
  # do so within a timeout interval (default duration is
  # <tt>spec.db_config.checkout_timeout * 2</tt> seconds), then the pool is forcefully
  # disconnected without any regard for other connection owning threads.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#280
  def disconnect!; end

  # Disconnect all connections that have been idle for at least
  # +minimum_idle+ seconds. Connections currently checked out, or that were
  # checked in less than +minimum_idle+ seconds ago, are unaffected.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#435
  def flush(minimum_idle = T.unsafe(nil)); end

  # Disconnect all currently idle connections. Connections currently checked
  # out are unaffected.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#457
  def flush!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#164
  def lock_thread=(lock_thread); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#462
  def num_waiting_in_queue; end

  # Returns the value of attribute pool_config.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def pool_config; end

  # Recover lost connections for the pool. A lost connection can occur if
  # a programmer forgets to checkin a connection at the end of a thread
  # or a thread dies unexpectedly.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#412
  def reap; end

  # Returns the value of attribute reaper.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def reaper; end

  # Signal that the thread is finished with the current connection.
  # #release_connection releases the connection-thread association
  # and returns the connection to the pool.
  #
  # This method only works for connections that have been obtained through
  # #connection or #with_connection methods, connections obtained through
  # #checkout will not be automatically released.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#207
  def release_connection(owner_thread = T.unsafe(nil)); end

  # Remove a connection from the connection pool. The connection will
  # remain open and active but will no longer be managed by this pool.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#380
  def remove(conn); end

  # Returns the value of attribute role.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def role; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#483
  def schedule_query(future_result); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#112
  def schema_reflection(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#112
  def schema_reflection=(arg); end

  # Returns the value of attribute shard.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def shard; end

  # Returns the value of attribute size.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#110
  def size; end

  # Returns the connection pool's usage statistic.
  #
  #    ActiveRecord::Base.connection_pool.stat # => { size: 15, connections: 1, busy: 1, dead: 0, idle: 0, waiting: 0, checkout_timeout: 5 }
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#469
  def stat; end

  # Yields a connection from the connection pool to the block. If no connection
  # is already checked out by the current thread, a connection will be checked
  # out from the pool, yielded to the block, and then returned to the pool when
  # the block is finished. If a connection has already been checked out on the
  # current thread, such as via #connection or #with_connection, that existing
  # connection will be the one yielded and it will not be returned to the pool
  # automatically at the end of the block; it is expected that such an existing
  # connection will be properly returned to the pool by the code that checked
  # it out.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#222
  def with_connection; end

  private

  # Acquire a connection by one of 1) immediately removing one
  # from the queue of available connections, 2) creating a new
  # connection if the pool is not at capacity, 3) waiting on the
  # queue for a connection to become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if a connection could not be acquired
  #
  # --
  # Implementation detail: the connection returned by +acquire_connection+
  # will already be "+connection.lease+ -ed" to the current thread.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#647
  def acquire_connection(checkout_timeout); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#716
  def adopt_connection(conn); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#541
  def attempt_to_checkout_all_existing_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#489
  def build_async_executor; end

  # --
  # this is unfortunately not concurrent
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#507
  def bulk_make_new_connections(num_new_conns_needed); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#726
  def checkout_and_verify(c); end

  # --
  # Must be called in a synchronize block.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#587
  def checkout_for_exclusive_access(checkout_timeout); end

  # @raise [ConnectionNotEstablished]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#721
  def checkout_new_connection; end

  # --
  # From the discussion on GitHub:
  #  https://github.com/rails/rails/pull/14938#commitcomment-6601951
  # This hook-in method allows for easier monkey-patching fixes needed by
  # JRuby users that use Fibers.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#522
  def connection_cache_key(thread); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#526
  def current_thread; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#675
  def new_connection; end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#670
  def release(conn, owner_thread = T.unsafe(nil)); end

  # --
  # if owner_thread param is omitted, this must be called in synchronize block
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#670
  def remove_connection_from_thread_cache(conn, owner_thread = T.unsafe(nil)); end

  # If the pool is not at a <tt>@size</tt> limit, establish new connection. Connecting
  # to the DB is done outside main synchronized section.
  # --
  # Implementation constraint: a newly established connection returned by this
  # method must be in the +.leased+ state.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#689
  def try_to_checkout_new_connection; end

  # Take control of all existing connections so a "group" action such as
  # reload/disconnect can be performed safely. It is no longer enough to
  # wrap it in +synchronize+ because some pool's actions are allowed
  # to be performed outside of the main +synchronize+ block.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#534
  def with_exclusively_acquired_all_connections(raise_on_acquisition_timeout = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#607
  def with_new_connections_blocked; end
end

# Adds the ability to turn a basic fair FIFO queue into one
# biased to some thread.
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#138
module ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#178
  def with_a_bias_for(thread); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#139
class ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue::BiasedConditionVariable
  # semantics of condition variables guarantee that +broadcast+, +broadcast_on_biased+,
  # +signal+ and +wait+ methods are only called while holding a lock
  #
  # @return [BiasedConditionVariable] a new instance of BiasedConditionVariable
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#142
  def initialize(lock, other_cond, preferred_thread); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#149
  def broadcast; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#154
  def broadcast_on_biased; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#159
  def signal; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#168
  def wait(timeout); end
end

# Connections must be leased while holding the main pool mutex. This is
# an internal subclass that also +.leases+ returned connections while
# still in queue's critical section (queue synchronizes with the same
# <tt>@lock</tt> as the main pool) so that a returned connection is already
# leased and there is no need to re-enter synchronized block.
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#199
class ActiveRecord::ConnectionAdapters::ConnectionPool::ConnectionLeasingQueue < ::ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  include ::ActiveRecord::ConnectionAdapters::ConnectionPool::BiasableQueue

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#203
  def internal_poll(timeout); end
end

# = Active Record Connection Pool \Queue
#
# Threadsafe, fair, LIFO queue.  Meant to be used by ConnectionPool
# with which it shares a Monitor.
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#13
class ActiveRecord::ConnectionAdapters::ConnectionPool::Queue
  # @return [Queue] a new instance of Queue
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#14
  def initialize(lock = T.unsafe(nil)); end

  # Add +element+ to the queue.  Never blocks.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#37
  def add(element); end

  # Test if any threads are currently waiting on the queue.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#22
  def any_waiting?; end

  # Remove all elements from the queue.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#52
  def clear; end

  # If +element+ is in the queue, remove and return it, or +nil+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#45
  def delete(element); end

  # Returns the number of threads currently waiting on this
  # queue.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#30
  def num_waiting; end

  # Remove the head of the queue.
  #
  # If +timeout+ is not given, remove and return the head of the
  # queue if the number of available elements is strictly
  # greater than the number of threads currently waiting (that
  # is, don't jump ahead in line).  Otherwise, return +nil+.
  #
  # If +timeout+ is given, block if there is no element
  # available, waiting up to +timeout+ seconds for an element to
  # become available.
  #
  # Raises:
  # - ActiveRecord::ConnectionTimeoutError if +timeout+ is given and no element
  # becomes available within +timeout+ seconds,
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#72
  def poll(timeout = T.unsafe(nil)); end

  private

  # Test if the queue currently contains any elements.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#86
  def any?; end

  # A thread can remove an element from the queue without
  # waiting if and only if the number of currently available
  # connections is strictly greater than the number of waiting
  # threads.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#94
  def can_remove_no_wait?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#77
  def internal_poll(timeout); end

  # Remove and return the head of the queue if the number of
  # available elements is strictly greater than the number of
  # threads currently waiting.  Otherwise, return +nil+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#106
  def no_wait_poll; end

  # Removes and returns the head of the queue if possible, or +nil+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#99
  def remove; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#81
  def synchronize(&block); end

  # Waits on the queue up to +timeout+ seconds, then removes and
  # returns the head of the queue.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/queue.rb#112
  def wait_poll(timeout); end
end

# = Active Record Connection Pool \Reaper
#
# Every +frequency+ seconds, the reaper will call +reap+ and +flush+ on
# +pool+. A reaper instantiated with a zero frequency will never reap
# the connection pool.
#
# Configure the frequency by setting +reaping_frequency+ in your database
# YAML file (default 60 seconds).
#
# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#17
class ActiveRecord::ConnectionAdapters::ConnectionPool::Reaper
  # @return [Reaper] a new instance of Reaper
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#20
  def initialize(pool, frequency); end

  # Returns the value of attribute frequency.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#18
  def frequency; end

  # Returns the value of attribute pool.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#18
  def pool; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#71
  def run; end

  class << self
    # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#30
    def register_pool(pool, frequency); end

    private

    # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool/reaper.rb#41
    def spawn_thread(frequency); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#120
class ActiveRecord::ConnectionAdapters::CreateIndexDefinition < ::Struct
  # Returns the value of attribute algorithm
  #
  # @return [Object] the current value of algorithm
  def algorithm; end

  # Sets the attribute algorithm
  #
  # @param value [Object] the value to set the attribute algorithm to.
  # @return [Object] the newly set value
  def algorithm=(_); end

  # Returns the value of attribute if_not_exists
  #
  # @return [Object] the current value of if_not_exists
  def if_not_exists; end

  # Sets the attribute if_not_exists
  #
  # @param value [Object] the value to set the attribute if_not_exists to.
  # @return [Object] the newly set value
  def if_not_exists=(_); end

  # Returns the value of attribute index
  #
  # @return [Object] the current value of index
  def index; end

  # Sets the attribute index
  #
  # @param value [Object] the value to set the attribute index to.
  # @return [Object] the newly set value
  def index=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#5
module ActiveRecord::ConnectionAdapters::DatabaseLimits
  # Returns the maximum length of an index name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#21
  def index_name_length; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#6
  def max_identifier_length; end

  # Returns the maximum length of a table alias.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#16
  def table_alias_length; end

  # Returns the maximum length of a table name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#11
  def table_name_length; end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_limits.rb#26
  def bind_params_length; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#5
module ActiveRecord::ConnectionAdapters::DatabaseStatements
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#6
  def initialize; end

  # Register a record with the current transaction so that its after_commit and after_rollback callbacks
  # can be called.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#390
  def add_transaction_record(record, ensure_finalize = T.unsafe(nil)); end

  # Begins the transaction (and turns off auto-committing).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#395
  def begin_db_transaction; end

  # Begins the transaction with the isolation level set. Raises an error by
  # default; adapters that support setting the isolation level should implement
  # this method.
  #
  # @raise [ActiveRecord::TransactionIsolationError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#409
  def begin_isolated_db_transaction(isolation); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def begin_transaction(*_arg0, **_arg1, &_arg2); end

  # This is used in the StatementCache object. It returns an object that
  # can be used to query the database repeatedly.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#54
  def cacheable_query(klass, arel); end

  # Commits the transaction (and turns on auto-committing).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#414
  def commit_db_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def commit_transaction(*_arg0, **_arg1, &_arg2); end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is +nil+, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  # Some adapters support the `returning` keyword argument which allows defining the return value of the method:
  # `nil` is the default value and maintains default behavior. If an array of column names is passed -
  # an array of is returned from the method representing values of the specified columns from the inserted row.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#189
  def create(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil), returning: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def current_transaction(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#436
  def default_sequence_name(table, column); end

  # Executes the delete statement and returns the number of rows affected.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#206
  def delete(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def dirty_current_transaction(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def disable_lazy_transactions!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#468
  def empty_insert_statement_value(primary_key = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def enable_lazy_transactions!(*_arg0, **_arg1, &_arg2); end

  # Executes delete +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#159
  def exec_delete(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes insert +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  # Some adapters support the `returning` keyword argument which allows to control the result of the query:
  # `nil` is the default value and maintains default behavior. If an array of column names is passed -
  # the result will contain values of the specified columns from the inserted row.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#151
  def exec_insert(sql, name = T.unsafe(nil), binds = T.unsafe(nil), pk = T.unsafe(nil), sequence_name = T.unsafe(nil), returning: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#170
  def exec_insert_all(sql, name); end

  # Executes +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  #
  # Note: the query is assumed to have side effects and the query cache
  # will be cleared. If the query is read-only, consider using #select_all
  # instead.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#141
  def exec_query(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#430
  def exec_restart_db_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#424
  def exec_rollback_db_transaction; end

  # Executes update +sql+ statement in the context of this connection using
  # +binds+ as the bind substitutes. +name+ is logged along with
  # the executed +sql+ statement.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#166
  def exec_update(sql, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Executes the SQL statement in the context of this connection and returns
  # the raw result from the connection adapter.
  #
  # Setting +allow_retry+ to true causes the db to reconnect and retry
  # executing the SQL statement in case of a connection-related exception.
  # This option should only be enabled for known idempotent queries.
  #
  # Note: the query is assumed to have side effects and the query cache
  # will be cleared. If the query is read-only, consider using #select_all
  # instead.
  #
  # Note: depending on your database connector, the result returned by this
  # method may be manually memory managed. Consider using #exec_query
  # wrapper instead.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#130
  def execute(sql, name = T.unsafe(nil), allow_retry: T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#174
  def explain(arel, binds = T.unsafe(nil), options = T.unsafe(nil)); end

  # Returns an Arel SQL literal for the CURRENT_TIMESTAMP for usage with
  # arbitrary precision date/time columns.
  #
  # Adapters supporting datetime with precision should override this to
  # provide as much precision as is available.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#506
  def high_precision_current_timestamp; end

  # Executes an INSERT query and returns the new record's ID
  #
  # +id_value+ will be returned unless the value is +nil+, in
  # which case the database will attempt to calculate the last inserted
  # id and return that value.
  #
  # If the next id was calculated in advance (as in Oracle), it should be
  # passed in as +id_value+.
  # Some adapters support the `returning` keyword argument which allows defining the return value of the method:
  # `nil` is the default value and maintains default behavior. If an array of column names is passed -
  # an array of is returned from the method representing values of the specified columns from the inserted row.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#189
  def insert(arel, name = T.unsafe(nil), pk = T.unsafe(nil), id_value = T.unsafe(nil), sequence_name = T.unsafe(nil), binds = T.unsafe(nil), returning: T.unsafe(nil)); end

  # Inserts the given fixture into the table. Overridden in adapters that require
  # something beyond a simple insert (e.g. Oracle).
  # Most of adapters should implement +insert_fixtures_set+ that leverages bulk SQL insert.
  # We keep this method to provide fallback
  # for databases like SQLite that do not support bulk inserts.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#450
  def insert_fixture(fixture, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#454
  def insert_fixtures_set(fixture_set, tables_to_delete = T.unsafe(nil)); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#510
  def internal_exec_query(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#357
  def mark_transaction_written_if_write(sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def materialize_transactions(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def open_transactions(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#107
  def query(sql, name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#99
  def query_value(sql, name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#103
  def query_values(sql, name = T.unsafe(nil)); end

  # Set the sequence to the max value of the table's column.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#441
  def reset_sequence!(table, column, sequence = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#368
  def reset_transaction(restore: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#426
  def restart_db_transaction; end

  # Rolls back the transaction (and turns on auto-committing). Must be
  # done if the transaction block raises an exception or returns false.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#418
  def rollback_db_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#432
  def rollback_to_savepoint(name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def rollback_transaction(*_arg0, **_arg1, &_arg2); end

  # Sanitizes the given LIMIT parameter in order to prevent SQL injection.
  #
  # The +limit+ may be anything that can evaluate to a string via #to_s. It
  # should look like an integer, or an Arel SQL literal.
  #
  # Returns Integer and Arel::Nodes::SqlLiteral limits as is.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#478
  def sanitize_limit(limit); end

  # Returns an ActiveRecord::Result instance.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#67
  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  # Returns a record hash with the column names as keys and column values
  # as values.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#78
  def select_one(arel, name = T.unsafe(nil), binds = T.unsafe(nil), async: T.unsafe(nil)); end

  # Returns an array of arrays containing the field values.
  # Order is the same as that returned by +columns+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#95
  def select_rows(arel, name = T.unsafe(nil), binds = T.unsafe(nil), async: T.unsafe(nil)); end

  # Returns a single value from a record
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#83
  def select_value(arel, name = T.unsafe(nil), binds = T.unsafe(nil), async: T.unsafe(nil)); end

  # Returns an array of the values of the first column in a select:
  #   select_values("SELECT id FROM companies LIMIT 3") => [1,2,3]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#89
  def select_values(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Converts an arel AST to SQL
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#12
  def to_sql(arel_or_sql_string, binds = T.unsafe(nil)); end

  # Runs the given block in a database transaction, and returns the result
  # of the block.
  #
  # == Nested transactions support
  #
  # #transaction calls can be nested. By default, this makes all database
  # statements in the nested transaction block become part of the parent
  # transaction. For example, the following behavior may be surprising:
  #
  #   ActiveRecord::Base.transaction do
  #     Post.create(title: 'first')
  #     ActiveRecord::Base.transaction do
  #       Post.create(title: 'second')
  #       raise ActiveRecord::Rollback
  #     end
  #   end
  #
  # This creates both "first" and "second" posts. Reason is the
  # ActiveRecord::Rollback exception in the nested block does not issue a
  # ROLLBACK. Since these exceptions are captured in transaction blocks,
  # the parent block does not see it and the real transaction is committed.
  #
  # Most databases don't support true nested transactions. At the time of
  # writing, the only database that supports true nested transactions that
  # we're aware of, is MS-SQL.
  #
  # In order to get around this problem, #transaction will emulate the effect
  # of nested transactions, by using savepoints:
  # https://dev.mysql.com/doc/refman/en/savepoint.html.
  #
  # It is safe to call this method if a database transaction is already open,
  # i.e. if #transaction is called within another #transaction block. In case
  # of a nested call, #transaction will behave as follows:
  #
  # - The block will be run without doing anything. All database statements
  #   that happen within the block are effectively appended to the already
  #   open database transaction.
  # - However, if +:requires_new+ is set, the block will be wrapped in a
  #   database savepoint acting as a sub-transaction.
  #
  # In order to get a ROLLBACK for the nested transaction you may ask for a
  # real sub-transaction by passing <tt>requires_new: true</tt>.
  # If anything goes wrong, the database rolls back to the beginning of
  # the sub-transaction without rolling back the parent transaction.
  # If we add it to the previous example:
  #
  #   ActiveRecord::Base.transaction do
  #     Post.create(title: 'first')
  #     ActiveRecord::Base.transaction(requires_new: true) do
  #       Post.create(title: 'second')
  #       raise ActiveRecord::Rollback
  #     end
  #   end
  #
  # only post with title "first" is created.
  #
  # See ActiveRecord::Transactions to learn more.
  #
  # === Caveats
  #
  # MySQL doesn't support DDL transactions. If you perform a DDL operation,
  # then any created savepoints will be automatically released. For example,
  # if you've created a savepoint, then you execute a CREATE TABLE statement,
  # then the savepoint that was created will be automatically released.
  #
  # This means that, on MySQL, you shouldn't execute DDL operations inside
  # a #transaction call that you know might create a savepoint. Otherwise,
  # #transaction will raise exceptions when it tries to release the
  # already-automatically-released savepoints:
  #
  #   Model.connection.transaction do  # BEGIN
  #     Model.connection.transaction(requires_new: true) do  # CREATE SAVEPOINT active_record_1
  #       Model.connection.create_table(...)
  #       # active_record_1 now automatically released
  #     end  # RELEASE SAVEPOINT active_record_1  <--- BOOM! database error!
  #   end
  #
  # == Transaction isolation
  #
  # If your database supports setting the isolation level for a transaction, you can set
  # it like so:
  #
  #   Post.transaction(isolation: :serializable) do
  #     # ...
  #   end
  #
  # Valid isolation levels are:
  #
  # * <tt>:read_uncommitted</tt>
  # * <tt>:read_committed</tt>
  # * <tt>:repeatable_read</tt>
  # * <tt>:serializable</tt>
  #
  # You should consult the documentation for your database to understand the
  # semantics of these different levels:
  #
  # * https://www.postgresql.org/docs/current/static/transaction-iso.html
  # * https://dev.mysql.com/doc/refman/en/set-transaction.html
  #
  # An ActiveRecord::TransactionIsolationError will be raised if:
  #
  # * The adapter does not support setting the isolation level
  # * You are joining an existing open transaction
  # * You are creating a nested (savepoint) transaction
  #
  # The mysql2, trilogy, and postgresql adapters support setting the transaction
  # isolation level.
  #  :args: (requires_new: nil, isolation: nil, &block)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#337
  def transaction(requires_new: T.unsafe(nil), isolation: T.unsafe(nil), joinable: T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#397
  def transaction_isolation_levels; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#350
  def transaction_manager; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#364
  def transaction_open?; end

  # Executes the truncate statement.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#212
  def truncate(table_name, name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#216
  def truncate_tables(*table_names); end

  # Executes the update statement and returns the number of rows affected.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#200
  def update(arel, name = T.unsafe(nil), binds = T.unsafe(nil)); end

  # Fixture value is quoted by Arel, however scalar values
  # are not quotable. In this case we want to convert
  # the column value to YAML.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#489
  def with_yaml_fallback(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#352
  def within_new_transaction(*_arg0, **_arg1, &_arg2); end

  # Determines whether the SQL statement is a write query.
  #
  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#112
  def write_query?(sql); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#668
  def arel_from_relation(relation); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#541
  def build_fixture_sql(fixtures, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#583
  def build_fixture_statements(fixture_set); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#590
  def build_truncate_statement(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#594
  def build_truncate_statements(table_names); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#604
  def combine_multi_statements(total_sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#537
  def default_insert_value(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#524
  def execute_batch(statements, name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#676
  def extract_table_ref_from_insert_sql(sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#515
  def internal_execute(sql, name = T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#655
  def last_inserted_id(result); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#530
  def raw_execute(sql, name, async: T.unsafe(nil), allow_retry: T.unsafe(nil), materialize_transactions: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#659
  def returning_column_values(result); end

  # Returns an ActiveRecord::Result instance.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#609
  def select(sql, name = T.unsafe(nil), binds = T.unsafe(nil), prepare: T.unsafe(nil), async: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#663
  def single_value_from_rows(rows); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#638
  def sql_for_insert(sql, pk, binds, returning); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#17
  def to_sql_and_binds(arel_or_sql_string, binds = T.unsafe(nil), preparable = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#600
  def with_multi_statements; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#534
ActiveRecord::ConnectionAdapters::DatabaseStatements::DEFAULT_INSERT_VALUE = T.let(T.unsafe(nil), Arel::Nodes::SqlLiteral)

# This is a safe default, even if not high precision on all databases
#
# source://activerecord//lib/active_record/connection_adapters/abstract/database_statements.rb#498
ActiveRecord::ConnectionAdapters::DatabaseStatements::HIGH_PRECISION_CURRENT_TIMESTAMP = T.let(T.unsafe(nil), Arel::Nodes::SqlLiteral)

# source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#5
module ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#18
  def -@; end

  # source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#18
  def deduplicate; end

  private

  # source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#24
  def deduplicated; end
end

# source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#8
module ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods
  # source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#13
  def new(*_arg0, **_arg1); end

  # source://activerecord//lib/active_record/connection_adapters/deduplicable.rb#9
  def registry; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#124
class ActiveRecord::ConnectionAdapters::ForeignKeyDefinition < ::Struct
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#129
  def column; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#149
  def custom_primary_key?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#145
  def deferrable; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#162
  def defined_for?(to_table: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#158
  def export_name_on_schema_dump?; end

  # Returns the value of attribute from_table
  #
  # @return [Object] the current value of from_table
  def from_table; end

  # Sets the attribute from_table
  #
  # @param value [Object] the value to set the attribute from_table to.
  # @return [Object] the newly set value
  def from_table=(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#125
  def name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#137
  def on_delete; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#141
  def on_update; end

  # Returns the value of attribute options
  #
  # @return [Object] the current value of options
  def options; end

  # Sets the attribute options
  #
  # @param value [Object] the value to set the attribute options to.
  # @return [Object] the newly set value
  def options=(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#133
  def primary_key; end

  # Returns the value of attribute to_table
  #
  # @return [Object] the current value of to_table
  def to_table; end

  # Sets the attribute to_table
  #
  # @param value [Object] the value to set the attribute to_table to.
  # @return [Object] the newly set value
  def to_table=(_); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#153
  def validate?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#153
  def validated?; end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#169
  def default_primary_key; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Abstract representation of an index definition on a table. Instances of
# this type are typically created and returned by methods in database
# adapters. e.g. ActiveRecord::ConnectionAdapters::MySQL::SchemaStatements#indexes
#
# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#9
class ActiveRecord::ConnectionAdapters::IndexDefinition
  # @return [IndexDefinition] a new instance of IndexDefinition
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#12
  def initialize(table, name, unique = T.unsafe(nil), columns = T.unsafe(nil), lengths: T.unsafe(nil), orders: T.unsafe(nil), opclasses: T.unsafe(nil), where: T.unsafe(nil), type: T.unsafe(nil), using: T.unsafe(nil), include: T.unsafe(nil), nulls_not_distinct: T.unsafe(nil), comment: T.unsafe(nil), valid: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#47
  def column_options; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def columns; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def comment; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#55
  def defined_for?(columns = T.unsafe(nil), name: T.unsafe(nil), unique: T.unsafe(nil), valid: T.unsafe(nil), include: T.unsafe(nil), nulls_not_distinct: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def include; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def lengths; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def nulls_not_distinct; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def opclasses; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def orders; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def table; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def type; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def unique; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def using; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def valid; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#43
  def valid?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#10
  def where; end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#66
  def concise_options(options); end
end

# source://activerecord//lib/active_record/connection_adapters/column.rb#115
class ActiveRecord::ConnectionAdapters::NullColumn < ::ActiveRecord::ConnectionAdapters::Column
  # @return [NullColumn] a new instance of NullColumn
  #
  # source://activerecord//lib/active_record/connection_adapters/column.rb#116
  def initialize(name, **_arg1); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#15
class ActiveRecord::ConnectionAdapters::NullPool
  include ::ActiveRecord::ConnectionAdapters::AbstractPool

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#32
  def async_executor; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#30
  def checkin(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#29
  def connection_class; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#33
  def db_config; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#31
  def remove(_); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#25
  def schema_reflection; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#23
ActiveRecord::ConnectionAdapters::NullPool::NULL_CONFIG = T.let(T.unsafe(nil), ActiveRecord::ConnectionAdapters::NullPool::NullConfig)

# source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#18
class ActiveRecord::ConnectionAdapters::NullPool::NullConfig
  # source://activerecord//lib/active_record/connection_adapters/abstract/connection_pool.rb#19
  def method_missing(*_arg0); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#106
class ActiveRecord::ConnectionAdapters::NullTransaction
  # @return [NullTransaction] a new instance of NullTransaction
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#107
  def initialize; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#112
  def add_record(record, _ = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#109
  def closed?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#115
  def dirty!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#114
  def dirty?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#117
  def invalidate!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#116
  def invalidated?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#111
  def joinable?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#110
  def open?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#113
  def restartable?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#108
  def state; end
end

# source://activerecord//lib/active_record/connection_adapters/pool_config.rb#5
class ActiveRecord::ConnectionAdapters::PoolConfig
  include ::Mutex_m

  # @return [PoolConfig] a new instance of PoolConfig
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#29
  def initialize(connection_class, db_config, role, shard); end

  # Returns the value of attribute connection_class.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#10
  def connection_class; end

  # Sets the attribute connection_class
  #
  # @param value the value to set the attribute connection_class to.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#10
  def connection_class=(_arg0); end

  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#39
  def connection_name; end

  # Returns the value of attribute db_config.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#8
  def db_config; end

  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#68
  def discard_pool!; end

  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#47
  def disconnect!(automatic_reconnect: T.unsafe(nil)); end

  # source://mutex_m/0.2.0/mutex_m.rb#91
  def lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#81
  def locked?; end

  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#62
  def pool; end

  # Returns the value of attribute role.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#8
  def role; end

  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#12
  def schema_reflection; end

  # Sets the attribute schema_reflection
  #
  # @param value the value to set the attribute schema_reflection to.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#9
  def schema_reflection=(_arg0); end

  # Returns the value of attribute shard.
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#8
  def shard; end

  # source://mutex_m/0.2.0/mutex_m.rb#76
  def synchronize(&block); end

  # source://mutex_m/0.2.0/mutex_m.rb#86
  def try_lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#96
  def unlock; end

  class << self
    # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#20
    def discard_pools!; end

    # source://activerecord//lib/active_record/connection_adapters/pool_config.rb#24
    def disconnect_all!; end
  end
end

# source://activerecord//lib/active_record/connection_adapters/pool_config.rb#16
ActiveRecord::ConnectionAdapters::PoolConfig::INSTANCES = T.let(T.unsafe(nil), ObjectSpace::WeakMap)

# source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#5
class ActiveRecord::ConnectionAdapters::PoolManager
  # @return [PoolManager] a new instance of PoolManager
  #
  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#6
  def initialize; end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#26
  def each_pool_config(role = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#44
  def get_pool_config(role, shard); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#18
  def pool_configs(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#40
  def remove_pool_config(role, shard); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#36
  def remove_role(role); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#14
  def role_names; end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#48
  def set_pool_config(role, shard, pool_config); end

  # source://activerecord//lib/active_record/connection_adapters/pool_manager.rb#10
  def shard_names; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#122
class ActiveRecord::ConnectionAdapters::PrimaryKeyDefinition < ::Struct
  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#7
module ActiveRecord::ConnectionAdapters::QueryCache
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#55
  def initialize(*_arg0); end

  # Enable the query cache within the block.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#63
  def cache; end

  # Clears the query cache.
  #
  # One reason you may wish to call this method explicitly is between queries
  # that ask the database to randomize results. Otherwise the cache would see
  # the same SQL query and repeatedly return the same result each time, silently
  # undermining the randomness you were expecting.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#94
  def clear_query_cache; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#75
  def disable_query_cache!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#71
  def enable_query_cache!; end

  # Returns the value of attribute query_cache.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#53
  def query_cache; end

  # Returns the value of attribute query_cache_enabled.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#53
  def query_cache_enabled; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#100
  def select_all(arel, name = T.unsafe(nil), binds = T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  # Disable the query cache within the block.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#81
  def uncached; end

  private

  # Database adapters can override this method to
  # provide custom cache information.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#171
  def cache_notification_info(sql, name, binds); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#142
  def cache_sql(sql, name, binds); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#182
  def configure_query_cache!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#120
  def lookup_sql_cache(sql, name, binds); end

  class << self
    # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#20
    def dirties_query_cache(base, *method_names); end

    # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#11
    def included(base); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#32
module ActiveRecord::ConnectionAdapters::QueryCache::ConnectionPoolConfiguration
  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#33
  def initialize(*_arg0); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#43
  def disable_query_cache!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#38
  def enable_query_cache!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#48
  def query_cache_enabled; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/query_cache.rb#8
ActiveRecord::ConnectionAdapters::QueryCache::DEFAULT_SIZE = T.let(T.unsafe(nil), Integer)

# = Active Record Connection Adapters \Quoting
#
# source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#9
module ActiveRecord::ConnectionAdapters::Quoting
  # Cast a value to be used as a bound parameter of unknown type. For example,
  # MySQL might perform dangerous castings when comparing a string to a number,
  # so this method will cast numbers to string.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#69
  def cast_bound_value(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#180
  def column_name_matcher; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#184
  def column_name_with_order_matcher; end

  # If you are having to call this function, you are likely doing something
  # wrong. The column does not have sufficient type information if the user
  # provided a custom type on the class level either explicitly (via
  # Attributes::ClassMethods#attribute) or implicitly (via
  # AttributeMethods::Serialization::ClassMethods#serialize, +time_zone_aware_attributes+).
  # In almost all cases, the sql type should only be used to change quoting behavior, when the primitive to
  # represent the type doesn't sufficiently reflect the differences
  # (varchar vs binary) for example. The type used to get this primitive
  # should have been provided before reaching the connection adapter.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#82
  def lookup_cast_type_from_column(column); end

  # Quotes the column value to help prevent
  # {SQL injection attacks}[https://en.wikipedia.org/wiki/SQL_injection].
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#12
  def quote(value); end

  # Quote a value to be used as a bound parameter of unknown type. For example,
  # MySQL might perform dangerous castings when comparing a string to a number,
  # so this method will cast numbers to string.
  #
  # Deprecated: Consider `Arel.sql("... ? ...", value)` or
  # +sanitize_sql+ instead.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#57
  def quote_bound_value(value); end

  # Quotes the column name. Defaults to no quoting.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#93
  def quote_column_name(column_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#114
  def quote_default_expression(value, column); end

  # Quotes a string, escaping any ' (single quote) and \ (backslash)
  # characters.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#88
  def quote_string(s); end

  # Quotes the table name. Defaults to column name quoting.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#98
  def quote_table_name(table_name); end

  # Override to return the quoted table name for assignment. Defaults to
  # table quoting.
  #
  # This works for MySQL where table.column can be used to
  # resolve ambiguity.
  #
  # We override this in the sqlite3 and postgresql adapters to use only
  # the column name (as per syntax requirements).
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#110
  def quote_table_name_for_assignment(table, attr); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#163
  def quoted_binary(value); end

  # Quote date/time values for use in SQL input. Includes microseconds
  # if the value is a Time responding to usec.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#141
  def quoted_date(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#131
  def quoted_false; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#158
  def quoted_time(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#123
  def quoted_true; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#167
  def sanitize_as_sql_comment(value); end

  # Cast a +value+ to a type that the database understands. For example,
  # SQLite does not understand dates, so this method will convert a Date
  # to a String.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#36
  def type_cast(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#135
  def unquoted_false; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#127
  def unquoted_true; end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#244
  def lookup_cast_type(sql_type); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#234
  def type_casted_binds(binds); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#248
  def warn_quote_duration_deprecated; end
end

# Regexp for column names (with or without a table name prefix).
# Matches the following:
#
#   "#{table_name}.#{column_name}"
#   "#{column_name}"
#
# source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#193
ActiveRecord::ConnectionAdapters::Quoting::COLUMN_NAME = T.let(T.unsafe(nil), Regexp)

# Regexp for column names with order (with or without a table name prefix,
# with or without various order modifiers). Matches the following:
#
#   "#{table_name}.#{column_name}"
#   "#{table_name}.#{column_name} #{direction}"
#   "#{table_name}.#{column_name} #{direction} NULLS FIRST"
#   "#{table_name}.#{column_name} NULLS LAST"
#   "#{column_name}"
#   "#{column_name} #{direction}"
#   "#{column_name} #{direction} NULLS FIRST"
#   "#{column_name} NULLS LAST"
#
# source://activerecord//lib/active_record/connection_adapters/abstract/quoting.rb#217
ActiveRecord::ConnectionAdapters::Quoting::COLUMN_NAME_WITH_ORDER = T.let(T.unsafe(nil), Regexp)

# = Active Record Real \Transaction
#
# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#368
class ActiveRecord::ConnectionAdapters::RealTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#399
  def commit; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#369
  def materialize!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#379
  def restart; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#393
  def rollback; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#195
class ActiveRecord::ConnectionAdapters::ReferenceDefinition
  # @return [ReferenceDefinition] a new instance of ReferenceDefinition
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#196
  def initialize(name, polymorphic: T.unsafe(nil), index: T.unsafe(nil), foreign_key: T.unsafe(nil), type: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#216
  def add(table_name, connection); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#230
  def add_to(table); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#247
  def as_options(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#285
  def column_name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#289
  def column_names; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#277
  def columns; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#251
  def conditional_options; end

  # Returns the value of attribute foreign_key.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def foreign_key; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#273
  def foreign_key_options; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#293
  def foreign_table_name; end

  # Returns the value of attribute index.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def index; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#263
  def index_options(table_name); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def name; end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def options; end

  # Returns the value of attribute polymorphic.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def polymorphic; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#259
  def polymorphic_index_name(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#255
  def polymorphic_options; end

  # Returns the value of attribute type.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#245
  def type; end
end

# = Active Record Restart Parent \Transaction
#
# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#295
class ActiveRecord::ConnectionAdapters::RestartParentTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # @return [RestartParentTransaction] a new instance of RestartParentTransaction
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#296
  def initialize(connection, parent_transaction, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#315
  def commit; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#319
  def full_rollback?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#308
  def materialize!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#308
  def materialized?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#308
  def restart(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#310
  def rollback; end
end

# = Active Record Savepoint \Transaction
#
# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#323
class ActiveRecord::ConnectionAdapters::SavepointTransaction < ::ActiveRecord::ConnectionAdapters::Transaction
  # @return [SavepointTransaction] a new instance of SavepointTransaction
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#324
  def initialize(connection, savepoint_name, parent_transaction, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#358
  def commit; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#364
  def full_rollback?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#336
  def materialize!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#341
  def restart; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#350
  def rollback; end
end

# = Active Record Connection Adapters \Savepoints
#
# source://activerecord//lib/active_record/connection_adapters/abstract/savepoints.rb#6
module ActiveRecord::ConnectionAdapters::Savepoints
  # source://activerecord//lib/active_record/connection_adapters/abstract/savepoints.rb#11
  def create_savepoint(name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/savepoints.rb#7
  def current_savepoint_name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/savepoints.rb#15
  def exec_rollback_to_savepoint(name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/savepoints.rb#19
  def release_savepoint(name = T.unsafe(nil)); end
end

# = Active Record Connection Adapters Schema Cache
#
# source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#221
class ActiveRecord::ConnectionAdapters::SchemaCache
  # @return [SchemaCache] a new instance of SchemaCache
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#261
  def initialize; end

  # Add internal cache for table with +table_name+.
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#325
  def add(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#398
  def add_all(connection); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#303
  def cached?(table_name); end

  # Clear out internal caches for the data source +name+.
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#390
  def clear_data_source_cache!(_connection, name); end

  # Get the columns for a table
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#340
  def columns(connection, table_name); end

  # Get the columns for a table as a hash, key is the column name
  # value is the column object.
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#352
  def columns_hash(connection, table_name); end

  # Checks whether the columns hash is already cached for a table.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#359
  def columns_hash?(connection, table_name); end

  # A cached lookup for table existence.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#316
  def data_source_exists?(connection, name); end

  # source://activesupport/7.1.3.2/lib/active_support/deprecation/method_wrappers.rb#46
  def data_sources(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#373
  def database_version(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#407
  def dump_to(filename); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#280
  def encode_with(coder); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#363
  def indexes(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#289
  def init_with(coder); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#417
  def marshal_dump; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#421
  def marshal_load(array); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#307
  def primary_keys(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#381
  def schema_version; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#385
  def size; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#377
  def version(connection); end

  private

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#449
  def deep_deduplicate(value); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#441
  def derive_columns_hash_and_deduplicate_values; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#435
  def ignored_table?(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#271
  def initialize_dup(other); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#468
  def open(filename); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#462
  def prepare_data_sources(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#429
  def tables_to_cache(connection); end

  class << self
    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#234
    def _load_from(filename); end

    # source://activesupport/7.1.3.2/lib/active_support/deprecation/method_wrappers.rb#46
    def load_from(*args, **_arg1, &block); end

    # source://activesupport/7.1.3.2/lib/active_support/deprecation/method_wrappers.rb#46
    def new(*args, **_arg1, &block); end

    private

    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#250
    def read(filename, &block); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#5
class ActiveRecord::ConnectionAdapters::SchemaCreation
  # @return [SchemaCreation] a new instance of SchemaCreation
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#6
  def initialize(conn); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#11
  def accept(o); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#176
  def action_sql(action, dependency); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#151
  def add_column_options!(sql, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#142
  def add_table_options!(create_sql, o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#147
  def column_options(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def options_include_default?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def quote_column_name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def quote_default_expression(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def quote_table_name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#134
  def quoted_columns(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def quoted_columns_for_index(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_check_constraints?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_exclusion_constraints?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_index_include?(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#138
  def supports_index_using?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_indexes_in_create?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_nulls_not_distinct?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_partial_index?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def supports_unique_constraints?(*_arg0, **_arg1, &_arg2); end

  # Returns any SQL string to go between CREATE and TABLE. May be nil.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#172
  def table_modifier_in_create(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#166
  def to_sql(sql); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def type_to_sql(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#16
  def use_foreign_keys?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#126
  def visit_AddCheckConstraint(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#40
  def visit_AddColumnDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#95
  def visit_AddForeignKey(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#24
  def visit_AlterTable(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#122
  def visit_CheckConstraintDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#33
  def visit_ColumnDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#103
  def visit_CreateIndexDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#130
  def visit_DropCheckConstraint(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#99
  def visit_DropForeignKey(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#82
  def visit_ForeignKeyDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#78
  def visit_PrimaryKeyDefinition(o); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_creation.rb#44
  def visit_TableDefinition(o); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#5
class ActiveRecord::ConnectionAdapters::SchemaDumper < ::ActiveRecord::SchemaDumper
  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#13
  def column_spec(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#17
  def column_spec_for_primary_key(column); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#38
  def default_primary_key?(column); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#42
  def explicit_primary_key_default?(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#25
  def prepare_column_options(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#101
  def schema_collation(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#86
  def schema_default(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#97
  def schema_expression(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#62
  def schema_limit(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#67
  def schema_precision(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#82
  def schema_scale(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#54
  def schema_type(column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#46
  def schema_type_with_virtual(column); end

  class << self
    # source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#8
    def create(connection, options); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_dumper.rb#6
ActiveRecord::ConnectionAdapters::SchemaDumper::DEFAULT_DATETIME_PRECISION = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#7
class ActiveRecord::ConnectionAdapters::SchemaReflection
  # @return [SchemaReflection] a new instance of SchemaReflection
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#16
  def initialize(cache_path, cache = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#45
  def add(connection, name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#87
  def cached?(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#25
  def clear!; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#81
  def clear_data_source_cache!(connection, name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#53
  def columns(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#57
  def columns_hash(connection, table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#61
  def columns_hash?(connection, table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#41
  def data_source_exists?(connection, name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#49
  def data_sources(connection, name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#69
  def database_version(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#99
  def dump_to(connection, filename); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#65
  def indexes(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#31
  def load!(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#37
  def primary_keys(connection, table_name); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#21
  def set_schema_cache(cache); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#77
  def size(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#73
  def version(connection); end

  private

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#114
  def cache(connection); end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#108
  def empty_cache; end

  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#124
  def load_cache(connection); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#118
  def possible_cache_available?; end

  class << self
    # Returns the value of attribute check_schema_cache_dump_version.
    #
    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#10
    def check_schema_cache_dump_version; end

    # Sets the attribute check_schema_cache_dump_version
    #
    # @param value the value to set the attribute check_schema_cache_dump_version to.
    #
    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#10
    def check_schema_cache_dump_version=(_arg0); end

    # Returns the value of attribute use_schema_cache_dump.
    #
    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#9
    def use_schema_cache_dump; end

    # Sets the attribute use_schema_cache_dump
    #
    # @param value the value to set the attribute use_schema_cache_dump to.
    #
    # source://activerecord//lib/active_record/connection_adapters/schema_cache.rb#9
    def use_schema_cache_dump=(_arg0); end
  end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#8
module ActiveRecord::ConnectionAdapters::SchemaStatements
  include ::ActiveRecord::Migration::JoinTable

  # Adds a reference. The reference column is a bigint by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:bigint+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false, pass true
  #   to add. In case the join table can't be inferred from the association
  #   pass <tt>:to_table</tt> with the appropriate table name.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id bigint column without an index
  #
  #   add_reference(:products, :user, index: false)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns
  #
  #   add_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: { to_table: :firms })
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1030
  def add_belongs_to(table_name, ref_name, **options); end

  # Adds a new check constraint to the table. +expression+ is a String
  # representation of verifiable boolean condition.
  #
  #   add_check_constraint :products, "price > 0", name: "price_check"
  #
  # generates:
  #
  #   ALTER TABLE "products" ADD CONSTRAINT price_check CHECK (price > 0)
  #
  # The +options+ hash can include the following keys:
  # [<tt>:name</tt>]
  #   The constraint name. Defaults to <tt>chk_rails_<identifier></tt>.
  # [<tt>:if_not_exists</tt>]
  #   Silently ignore if the constraint already exists, rather than raise an error.
  # [<tt>:validate</tt>]
  #   (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1260
  def add_check_constraint(table_name, expression, if_not_exists: T.unsafe(nil), **options); end

  # Add a new +type+ column named +column_name+ to +table_name+.
  #
  # See {ActiveRecord::ConnectionAdapters::TableDefinition.column}[rdoc-ref:ActiveRecord::ConnectionAdapters::TableDefinition#column].
  #
  # The +type+ parameter is normally one of the migrations native types,
  # which is one of the following:
  # <tt>:primary_key</tt>, <tt>:string</tt>, <tt>:text</tt>,
  # <tt>:integer</tt>, <tt>:bigint</tt>, <tt>:float</tt>, <tt>:decimal</tt>, <tt>:numeric</tt>,
  # <tt>:datetime</tt>, <tt>:time</tt>, <tt>:date</tt>,
  # <tt>:binary</tt>, <tt>:blob</tt>, <tt>:boolean</tt>.
  #
  # You may use a type not in this list as long as it is supported by your
  # database (for example, "polygon" in MySQL), but this will not be database
  # agnostic and should usually be avoided.
  #
  # Available options are (none of these exists by default):
  # * <tt>:comment</tt> -
  #   Specifies the comment for the column. This option is ignored by some backends.
  # * <tt>:collation</tt> -
  #   Specifies the collation for a <tt>:string</tt> or <tt>:text</tt> column.
  #   If not specified, the column will have the same collation as the table.
  # * <tt>:default</tt> -
  #   The column's default value. Use +nil+ for +NULL+.
  # * <tt>:limit</tt> -
  #   Requests a maximum column length. This is the number of characters for a <tt>:string</tt> column
  #   and number of bytes for <tt>:text</tt>, <tt>:binary</tt>, <tt>:blob</tt>, and <tt>:integer</tt> columns.
  #   This option is ignored by some backends.
  # * <tt>:null</tt> -
  #   Allows or disallows +NULL+ values in the column.
  # * <tt>:precision</tt> -
  #   Specifies the precision for the <tt>:decimal</tt>, <tt>:numeric</tt>,
  #   <tt>:datetime</tt>, and <tt>:time</tt> columns.
  # * <tt>:scale</tt> -
  #   Specifies the scale for the <tt>:decimal</tt> and <tt>:numeric</tt> columns.
  # * <tt>:if_not_exists</tt> -
  #   Specifies if the column already exists to not try to re-add it. This will avoid
  #   duplicate column errors.
  #
  # Note: The precision is the total number of significant digits,
  # and the scale is the number of digits that can be stored following
  # the decimal point. For example, the number 123.45 has a precision of 5
  # and a scale of 2. A decimal with a precision of 5 and a scale of 2 can
  # range from -999.99 to 999.99.
  #
  # Please be aware of different RDBMS implementations behavior with
  # <tt>:decimal</tt> columns:
  # * The SQL standard says the default scale should be 0, <tt>:scale</tt> <=
  #   <tt>:precision</tt>, and makes no comments about the requirements of
  #   <tt>:precision</tt>.
  # * MySQL: <tt>:precision</tt> [1..65], <tt>:scale</tt> [0..30].
  #   Default is (10,0).
  # * PostgreSQL: <tt>:precision</tt> [1..infinity],
  #   <tt>:scale</tt> [0..infinity]. No default.
  # * SQLite3: No restrictions on <tt>:precision</tt> and <tt>:scale</tt>,
  #   but the maximum supported <tt>:precision</tt> is 16. No default.
  # * Oracle: <tt>:precision</tt> [1..38], <tt>:scale</tt> [-84..127].
  #   Default is (38,0).
  # * SqlServer: <tt>:precision</tt> [1..38], <tt>:scale</tt> [0..38].
  #   Default (38,0).
  #
  # == Examples
  #
  #  add_column(:users, :picture, :binary, limit: 2.megabytes)
  #  # ALTER TABLE "users" ADD "picture" blob(2097152)
  #
  #  add_column(:articles, :status, :string, limit: 20, default: 'draft', null: false)
  #  # ALTER TABLE "articles" ADD "status" varchar(20) DEFAULT 'draft' NOT NULL
  #
  #  add_column(:answers, :bill_gates_money, :decimal, precision: 15, scale: 2)
  #  # ALTER TABLE "answers" ADD "bill_gates_money" decimal(15,2)
  #
  #  add_column(:measurements, :sensor_reading, :decimal, precision: 30, scale: 20)
  #  # ALTER TABLE "measurements" ADD "sensor_reading" decimal(30,20)
  #
  #  # While :scale defaults to zero on most databases, it
  #  # probably wouldn't hurt to include it.
  #  add_column(:measurements, :huge_integer, :decimal, precision: 30)
  #  # ALTER TABLE "measurements" ADD "huge_integer" decimal(30)
  #
  #  # Defines a column that stores an array of a type.
  #  add_column(:users, :skills, :text, array: true)
  #  # ALTER TABLE "users" ADD "skills" text[]
  #
  #  # Defines a column with a database-specific type.
  #  add_column(:shapes, :triangle, 'polygon')
  #  # ALTER TABLE "shapes" ADD "triangle" polygon
  #
  #  # Ignores the method call if the column exists
  #  add_column(:shapes, :triangle, 'polygon', if_not_exists: true)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#620
  def add_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#627
  def add_columns(table_name, *column_names, type:, **options); end

  # Adds a new foreign key. +from_table+ is the table with the key column,
  # +to_table+ contains the referenced primary key.
  #
  # The foreign key will be named after the following pattern: <tt>fk_rails_<identifier></tt>.
  # +identifier+ is a 10 character long string which is deterministically generated from the
  # +from_table+ and +column+. A custom name can be specified with the <tt>:name</tt> option.
  #
  # ====== Creating a simple foreign key
  #
  #   add_foreign_key :articles, :authors
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id")
  #
  # ====== Creating a foreign key, ignoring method call if the foreign key exists
  #
  #  add_foreign_key(:articles, :authors, if_not_exists: true)
  #
  # ====== Creating a foreign key on a specific column
  #
  #   add_foreign_key :articles, :users, column: :author_id, primary_key: "lng_id"
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_58ca3d3a82 FOREIGN KEY ("author_id") REFERENCES "users" ("lng_id")
  #
  # ====== Creating a composite foreign key
  #
  #   Assuming "carts" table has "(shop_id, user_id)" as a primary key.
  #
  #   add_foreign_key :orders, :carts, primary_key: [:shop_id, :user_id]
  #
  # generates:
  #
  #   ALTER TABLE "orders" ADD CONSTRAINT fk_rails_6f5e4cb3a4 FOREIGN KEY ("cart_shop_id", "cart_user_id") REFERENCES "carts" ("shop_id", "user_id")
  #
  # ====== Creating a cascading foreign key
  #
  #   add_foreign_key :articles, :authors, on_delete: :cascade
  #
  # generates:
  #
  #   ALTER TABLE "articles" ADD CONSTRAINT fk_rails_e74ce85cbc FOREIGN KEY ("author_id") REFERENCES "authors" ("id") ON DELETE CASCADE
  #
  # The +options+ hash can include the following keys:
  # [<tt>:column</tt>]
  #   The foreign key column name on +from_table+. Defaults to <tt>to_table.singularize + "_id"</tt>.
  #   Pass an array to create a composite foreign key.
  # [<tt>:primary_key</tt>]
  #   The primary key column name on +to_table+. Defaults to +id+.
  #   Pass an array to create a composite foreign key.
  # [<tt>:name</tt>]
  #   The constraint name. Defaults to <tt>fk_rails_<identifier></tt>.
  # [<tt>:on_delete</tt>]
  #   Action that happens <tt>ON DELETE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+
  # [<tt>:on_update</tt>]
  #   Action that happens <tt>ON UPDATE</tt>. Valid values are +:nullify+, +:cascade+, and +:restrict+
  # [<tt>:if_not_exists</tt>]
  #   Specifies if the foreign key already exists to not try to re-add it. This will avoid
  #   duplicate column errors.
  # [<tt>:validate</tt>]
  #   (PostgreSQL only) Specify whether or not the constraint should be validated. Defaults to +true+.
  # [<tt>:deferrable</tt>]
  #   (PostgreSQL only) Specify whether or not the foreign key should be deferrable. Valid values are booleans or
  #   +:deferred+ or +:immediate+ to specify the default behavior. Defaults to +false+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1140
  def add_foreign_key(from_table, to_table, **options); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  # The index will be named after the table and the column name(s), unless
  # you pass <tt>:name</tt> as an option.
  #
  # ====== Creating a simple index
  #
  #   add_index(:suppliers, :name)
  #
  # generates:
  #
  #   CREATE INDEX index_suppliers_on_name ON suppliers(name)
  #
  # ====== Creating a index which already exists
  #
  #   add_index(:suppliers, :name, if_not_exists: true)
  #
  # generates:
  #
  #   CREATE INDEX IF NOT EXISTS index_suppliers_on_name ON suppliers(name)
  #
  # Note: Not supported by MySQL.
  #
  # ====== Creating a unique index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true)
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id)
  #
  # ====== Creating a named index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # generates:
  #
  #  CREATE UNIQUE INDEX by_branch_party ON accounts(branch_id, party_id)
  #
  # ====== Creating an index with specific key length
  #
  #   add_index(:accounts, :name, name: 'by_name', length: 10)
  #
  # generates:
  #
  #   CREATE INDEX by_name ON accounts(name(10))
  #
  # ====== Creating an index with specific key lengths for multiple keys
  #
  #   add_index(:accounts, [:name, :surname], name: 'by_name_surname', length: {name: 10, surname: 15})
  #
  # generates:
  #
  #   CREATE INDEX by_name_surname ON accounts(name(10), surname(15))
  #
  # Note: only supported by MySQL
  #
  # ====== Creating an index with a sort order (desc or asc, asc is the default)
  #
  #   add_index(:accounts, [:branch_id, :party_id, :surname], name: 'by_branch_desc_party', order: {branch_id: :desc, party_id: :asc})
  #
  # generates:
  #
  #   CREATE INDEX by_branch_desc_party ON accounts(branch_id DESC, party_id ASC, surname)
  #
  # Note: MySQL only supports index order from 8.0.1 onwards (earlier versions accepted the syntax but ignored it).
  #
  # ====== Creating a partial index
  #
  #   add_index(:accounts, [:branch_id, :party_id], unique: true, where: "active")
  #
  # generates:
  #
  #   CREATE UNIQUE INDEX index_accounts_on_branch_id_and_party_id ON accounts(branch_id, party_id) WHERE active
  #
  # Note: Partial indexes are only supported for PostgreSQL and SQLite.
  #
  # ====== Creating an index that includes additional columns
  #
  #   add_index(:accounts, :branch_id,  include: :party_id)
  #
  # generates:
  #
  #   CREATE INDEX index_accounts_on_branch_id ON accounts USING btree(branch_id) INCLUDE (party_id)
  #
  # Note: only supported by PostgreSQL.
  #
  # ====== Creating an index with a specific method
  #
  #   add_index(:developers, :name, using: 'btree')
  #
  # generates:
  #
  #   CREATE INDEX index_developers_on_name ON developers USING btree (name) -- PostgreSQL
  #   CREATE INDEX index_developers_on_name USING btree ON developers (name) -- MySQL
  #
  # Note: only supported by PostgreSQL and MySQL
  #
  # ====== Creating an index with a specific operator class
  #
  #   add_index(:developers, :name, using: 'gist', opclass: :gist_trgm_ops)
  #   # CREATE INDEX developers_on_name ON developers USING gist (name gist_trgm_ops) -- PostgreSQL
  #
  #   add_index(:developers, [:name, :city], using: 'gist', opclass: { city: :gist_trgm_ops })
  #   # CREATE INDEX developers_on_name_and_city ON developers USING gist (name, city gist_trgm_ops) -- PostgreSQL
  #
  #   add_index(:developers, [:name, :city], using: 'gist', opclass: :gist_trgm_ops)
  #   # CREATE INDEX developers_on_name_and_city ON developers USING gist (name gist_trgm_ops, city gist_trgm_ops) -- PostgreSQL
  #
  # Note: only supported by PostgreSQL
  #
  # ====== Creating an index with a specific type
  #
  #   add_index(:developers, :name, type: :fulltext)
  #
  # generates:
  #
  #   CREATE FULLTEXT INDEX index_developers_on_name ON developers (name) -- MySQL
  #
  # Note: only supported by MySQL.
  #
  # ====== Creating an index with a specific algorithm
  #
  #  add_index(:developers, :name, algorithm: :concurrently)
  #  # CREATE INDEX CONCURRENTLY developers_on_name on developers (name)
  #
  # Note: only supported by PostgreSQL.
  #
  # Concurrently adding an index is not supported in a transaction.
  #
  # For more information see the {"Transactional Migrations" section}[rdoc-ref:Migration].
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#886
  def add_index(table_name, column_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1436
  def add_index_options(table_name, column_name, name: T.unsafe(nil), if_not_exists: T.unsafe(nil), internal: T.unsafe(nil), **options); end

  # Adds a reference. The reference column is a bigint by default,
  # the <tt>:type</tt> option can be used to specify a different type.
  # Optionally adds a +_type+ column, if <tt>:polymorphic</tt> option is provided.
  #
  # The +options+ hash can include the following keys:
  # [<tt>:type</tt>]
  #   The reference column type. Defaults to +:bigint+.
  # [<tt>:index</tt>]
  #   Add an appropriate index. Defaults to true.
  #   See #add_index for usage of this option.
  # [<tt>:foreign_key</tt>]
  #   Add an appropriate foreign key constraint. Defaults to false, pass true
  #   to add. In case the join table can't be inferred from the association
  #   pass <tt>:to_table</tt> with the appropriate table name.
  # [<tt>:polymorphic</tt>]
  #   Whether an additional +_type+ column should be added. Defaults to false.
  # [<tt>:null</tt>]
  #   Whether the column allows nulls. Defaults to true.
  #
  # ====== Create a user_id bigint column without an index
  #
  #   add_reference(:products, :user, index: false)
  #
  # ====== Create a user_id string column
  #
  #   add_reference(:products, :user, type: :string)
  #
  # ====== Create supplier_id, supplier_type columns
  #
  #   add_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Create a supplier_id column with a unique index
  #
  #   add_reference(:products, :supplier, index: { unique: true })
  #
  # ====== Create a supplier_id column with a named index
  #
  #   add_reference(:products, :supplier, index: { name: "my_supplier_index" })
  #
  # ====== Create a supplier_id column and appropriate foreign key
  #
  #   add_reference(:products, :supplier, foreign_key: true)
  #
  # ====== Create a supplier_id column and a foreign key to the firms table
  #
  #   add_reference(:products, :supplier, foreign_key: { to_table: :firms })
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1030
  def add_reference(table_name, ref_name, **options); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to +table_name+.
  # Additional options (like +:null+) are forwarded to #add_column.
  #
  #   add_timestamps(:suppliers, null: true)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1419
  def add_timestamps(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1325
  def assume_migrated_upto_version(version); end

  # Builds an AlterTable object for adding a column to a table.
  #
  # This definition object contains information about the column that would be created
  # if the same arguments were passed to #add_column. See #add_column for information about
  # passing a +table_name+, +column_name+, +type+ and other options that can be passed.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#638
  def build_add_column_definition(table_name, column_name, type, **options); end

  # Builds a ChangeColumnDefaultDefinition object.
  #
  # This definition object contains information about the column change that would occur
  # if the same arguments were passed to #change_column_default. See #change_column_default for
  # information about passing a +table_name+, +column_name+, +type+ and other options that can be passed.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#722
  def build_change_column_default_definition(table_name, column_name, default_or_changes); end

  # Builds a CreateIndexDefinition object.
  #
  # This definition object contains information about the index that would be created
  # if the same arguments were passed to #add_index. See #add_index for information about
  # passing a +table_name+, +column_name+, and other additional options that can be passed.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#896
  def build_create_index_definition(table_name, column_name, **options); end

  # Builds a TableDefinition object for a join table.
  #
  # This definition object contains information about the table that would be created
  # if the same arguments were passed to #create_join_table. See #create_join_table for
  # information about what arguments should be passed.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#394
  def build_create_join_table_definition(table_1, table_2, column_options: T.unsafe(nil), **options); end

  # Returns a TableDefinition object containing information about the table that would be created
  # if the same arguments were passed to #create_table. See #create_table for information about
  # passing a +table_name+, and other additional options that can be passed.
  #
  # @yield [table_definition]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#328
  def build_create_table_definition(table_name, id: T.unsafe(nil), primary_key: T.unsafe(nil), force: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1515
  def bulk_change_table(table_name, operations); end

  # Changes the column's definition according to the new options.
  # See TableDefinition#column for details of the options you can use.
  #
  #   change_column(:suppliers, :name, :string, limit: 80)
  #   change_column(:accounts, :description, :text)
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#695
  def change_column(table_name, column_name, type, **options); end

  # Changes the comment for a column or removes it if +nil+.
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_column_comment(:posts, :state, from: "old_comment", to: "new_comment")
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1497
  def change_column_comment(table_name, column_name, comment_or_changes); end

  # Sets a new default value for a column:
  #
  #   change_column_default(:suppliers, :qualification, 'new')
  #   change_column_default(:accounts, :authorized, 1)
  #
  # Setting the default to +nil+ effectively drops the default:
  #
  #   change_column_default(:users, :email, nil)
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_column_default(:posts, :state, from: nil, to: "draft")
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#713
  def change_column_default(table_name, column_name, default_or_changes); end

  # Sets or removes a <tt>NOT NULL</tt> constraint on a column. The +null+ flag
  # indicates whether the value can be +NULL+. For example
  #
  #   change_column_null(:users, :nickname, false)
  #
  # says nicknames cannot be +NULL+ (adds the constraint), whereas
  #
  #   change_column_null(:users, :nickname, true)
  #
  # allows them to be +NULL+ (drops the constraint).
  #
  # The method accepts an optional fourth argument to replace existing
  # <tt>NULL</tt>s with some other value. Use that one when enabling the
  # constraint if needed, since otherwise those rows would not be valid.
  #
  # Please note the fourth argument does not set a column's default.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#742
  def change_column_null(table_name, column_name, null, default = T.unsafe(nil)); end

  # A block for changing columns in +table+.
  #
  #   # change_table() yields a Table instance
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other column alterations here
  #   end
  #
  # The +options+ hash can include the following keys:
  # [<tt>:bulk</tt>]
  #   Set this to true to make this a bulk alter query, such as
  #
  #     ALTER TABLE `users` ADD COLUMN age INT, ADD COLUMN birthdate DATETIME ...
  #
  #   Defaults to false.
  #
  #   Only supported on the MySQL and PostgreSQL adapter, ignored elsewhere.
  #
  # ====== Add a column
  #
  #   change_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #   end
  #
  # ====== Change type of a column
  #
  #   change_table(:suppliers) do |t|
  #     t.change :metadata, :json
  #   end
  #
  # ====== Add 2 integer columns
  #
  #   change_table(:suppliers) do |t|
  #     t.integer :width, :height, null: false, default: 0
  #   end
  #
  # ====== Add created_at/updated_at columns
  #
  #   change_table(:suppliers) do |t|
  #     t.timestamps
  #   end
  #
  # ====== Add a foreign key column
  #
  #   change_table(:suppliers) do |t|
  #     t.references :company
  #   end
  #
  # Creates a <tt>company_id(bigint)</tt> column.
  #
  # ====== Add a polymorphic foreign key column
  #
  #  change_table(:suppliers) do |t|
  #    t.belongs_to :company, polymorphic: true
  #  end
  #
  # Creates <tt>company_type(varchar)</tt> and <tt>company_id(bigint)</tt> columns.
  #
  # ====== Remove a column
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company
  #  end
  #
  # ====== Remove several columns
  #
  #  change_table(:suppliers) do |t|
  #    t.remove :company_id
  #    t.remove :width, :height
  #  end
  #
  # ====== Remove an index
  #
  #  change_table(:suppliers) do |t|
  #    t.remove_index :company_id
  #  end
  #
  # See also Table for details on all of the various column transformations.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#496
  def change_table(table_name, base = T.unsafe(nil), **options); end

  # Changes the comment for a table or removes it if +nil+.
  #
  # Passing a hash containing +:from+ and +:to+ will make this change
  # reversible in migration:
  #
  #   change_table_comment(:posts, from: "old_comment", to: "new_comment")
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1487
  def change_table_comment(table_name, comment_or_changes); end

  # Checks to see if a check constraint exists on a table for a given check constraint definition.
  #
  #   check_constraint_exists?(:products, name: "price_check")
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1309
  def check_constraint_exists?(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1272
  def check_constraint_options(table_name, expression, options); end

  # Returns an array of check constraints for the given table.
  # The check constraints are represented as CheckConstraintDefinition objects.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1240
  def check_constraints(table_name); end

  # Checks to see if a column exists in a given table.
  #
  #   # Check a column exists
  #   column_exists?(:suppliers, :name)
  #
  #   # Check a column exists of a particular type
  #   #
  #   # This works for standard non-casted types (eg. string) but is unreliable
  #   # for types that may get cast to something else (eg. char, bigint).
  #   column_exists?(:suppliers, :name, :string)
  #
  #   # Check a column exists with a specific definition
  #   column_exists?(:suppliers, :name, :string, limit: 100)
  #   column_exists?(:suppliers, :name, :string, default: 'default')
  #   column_exists?(:suppliers, :name, :string, null: false)
  #   column_exists?(:suppliers, :tax, :decimal, precision: 8, scale: 2)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#132
  def column_exists?(table_name, column_name, type = T.unsafe(nil), **options); end

  # Returns an array of +Column+ objects for the table specified by +table_name+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#107
  def columns(table_name); end

  # Given a set of columns and an ORDER BY clause, returns the columns for a SELECT DISTINCT.
  # PostgreSQL, MySQL, and Oracle override this for custom DISTINCT syntax - they
  # require the order columns appear in the SELECT.
  #
  #   columns_for_distinct("posts.id", ["posts.created_at desc"])
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1385
  def columns_for_distinct(columns, orders); end

  # Creates a new join table with the name created using the lexical order of the first two
  # arguments. These arguments can be a String or a Symbol.
  #
  #   # Creates a table called 'assemblies_parts' with no id.
  #   create_join_table(:assemblies, :parts)
  #
  # You can pass an +options+ hash which can include the following keys:
  # [<tt>:table_name</tt>]
  #   Sets the table name, overriding the default.
  # [<tt>:column_options</tt>]
  #   Any extra options you want appended to the columns definition.
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Defaults to false.
  #
  # Note that #create_join_table does not create any indices by default; you can use
  # its block form to do so yourself:
  #
  #   create_join_table :products, :categories do |t|
  #     t.index :product_id
  #     t.index :category_id
  #   end
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_join_table(:assemblies, :parts, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8')
  #
  # generates:
  #
  #   CREATE TABLE assemblies_parts (
  #     assembly_id bigint NOT NULL,
  #     part_id bigint NOT NULL,
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#375
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1501
  def create_schema_dumper(options); end

  # Creates a new table with the name +table_name+. +table_name+ may either
  # be a String or a Symbol.
  #
  # There are two ways to work with #create_table. You can use the block
  # form or the regular form, like this:
  #
  # === Block form
  #
  #   # create_table() passes a TableDefinition object to the block.
  #   # This form will not only create the table, but also columns for the
  #   # table.
  #
  #   create_table(:suppliers) do |t|
  #     t.column :name, :string, limit: 60
  #     # Other fields here
  #   end
  #
  # === Block form, with shorthand
  #
  #   # You can also use the column types as method calls, rather than calling the column method.
  #   create_table(:suppliers) do |t|
  #     t.string :name, limit: 60
  #     # Other fields here
  #   end
  #
  # === Regular form
  #
  #   # Creates a table called 'suppliers' with no columns.
  #   create_table(:suppliers)
  #   # Add a column to 'suppliers'.
  #   add_column(:suppliers, :name, :string, {limit: 60})
  #
  # The +options+ hash can include the following keys:
  # [<tt>:id</tt>]
  #   Whether to automatically add a primary key column. Defaults to true.
  #   Join tables for {ActiveRecord::Base.has_and_belongs_to_many}[rdoc-ref:Associations::ClassMethods#has_and_belongs_to_many] should set it to false.
  #
  #   A Symbol can be used to specify the type of the generated primary key column.
  # [<tt>:primary_key</tt>]
  #   The name of the primary key, if one is to be added automatically.
  #   Defaults to +id+. If <tt>:id</tt> is false, then this option is ignored.
  #
  #   If an array is passed, a composite primary key will be created.
  #
  #   Note that Active Record models will automatically detect their
  #   primary key. This can be avoided by using
  #   {self.primary_key=}[rdoc-ref:AttributeMethods::PrimaryKey::ClassMethods#primary_key=] on the model
  #   to define the key explicitly.
  #
  # [<tt>:options</tt>]
  #   Any extra options you want appended to the table definition.
  # [<tt>:temporary</tt>]
  #   Make a temporary table.
  # [<tt>:force</tt>]
  #   Set to true to drop the table before creating it.
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:if_not_exists</tt>]
  #   Set to true to avoid raising an error when the table already exists.
  #   Defaults to false.
  # [<tt>:as</tt>]
  #   SQL to use to generate the table. When this option is used, the block is
  #   ignored, as are the <tt>:id</tt> and <tt>:primary_key</tt> options.
  #
  # ====== Add a backend specific option to the generated SQL (MySQL)
  #
  #   create_table(:suppliers, options: 'ENGINE=InnoDB DEFAULT CHARSET=utf8mb4')
  #
  # generates:
  #
  #   CREATE TABLE suppliers (
  #     id bigint auto_increment PRIMARY KEY
  #   ) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4
  #
  # ====== Rename the primary key column
  #
  #   create_table(:objects, primary_key: 'guid') do |t|
  #     t.column :name, :string, limit: 80
  #   end
  #
  # generates:
  #
  #   CREATE TABLE objects (
  #     guid bigint auto_increment PRIMARY KEY,
  #     name varchar(80)
  #   )
  #
  # ====== Change the primary key column type
  #
  #   create_table(:tags, id: :string) do |t|
  #     t.column :label, :string
  #   end
  #
  # generates:
  #
  #   CREATE TABLE tags (
  #     id varchar PRIMARY KEY,
  #     label varchar
  #   )
  #
  # ====== Create a composite primary key
  #
  #   create_table(:orders, primary_key: [:product_id, :client_id]) do |t|
  #     t.belongs_to :product
  #     t.belongs_to :client
  #   end
  #
  # generates:
  #
  #   CREATE TABLE orders (
  #       product_id bigint NOT NULL,
  #       client_id bigint NOT NULL
  #   );
  #
  #   ALTER TABLE ONLY "orders"
  #     ADD CONSTRAINT orders_pkey PRIMARY KEY (product_id, client_id);
  #
  # ====== Do not add a primary key column
  #
  #   create_table(:categories_suppliers, id: false) do |t|
  #     t.column :category_id, :bigint
  #     t.column :supplier_id, :bigint
  #   end
  #
  # generates:
  #
  #   CREATE TABLE categories_suppliers (
  #     category_id bigint,
  #     supplier_id bigint
  #   )
  #
  # ====== Create a temporary table based on a query
  #
  #   create_table(:long_query, temporary: true,
  #     as: "SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id")
  #
  # generates:
  #
  #   CREATE TEMPORARY TABLE long_query AS
  #     SELECT * FROM orders INNER JOIN line_items ON order_id=orders.id
  #
  # See also TableDefinition#column for details on how to create columns.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#293
  def create_table(table_name, id: T.unsafe(nil), primary_key: T.unsafe(nil), force: T.unsafe(nil), **options, &block); end

  # Checks to see if the data source +name+ exists on the database.
  #
  #   data_source_exists?(:ebooks)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#44
  def data_source_exists?(name); end

  # Returns the relation names usable to back Active Record models.
  # For most adapters this means all #tables and #views.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#34
  def data_sources; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1389
  def distinct_relation_for_primary_key(relation); end

  # Drops the join table specified by the given arguments.
  # See #create_join_table and #drop_table for details.
  #
  # Although this command ignores the block if one is given, it can be helpful
  # to provide one in a migration's +change+ method so it can be reverted.
  # In that case, the block will be used by #create_join_table.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#413
  def drop_join_table(table_1, table_2, **options); end

  # Drops a table from the database.
  #
  # [<tt>:force</tt>]
  #   Set to +:cascade+ to drop dependent objects as well.
  #   Defaults to false.
  # [<tt>:if_exists</tt>]
  #   Set to +true+ to only drop the table if it exists.
  #   Defaults to false.
  #
  # Although this command ignores most +options+ and the block if one is given,
  # it can be helpful to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +options+ and the block will be used by #create_table.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#526
  def drop_table(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1316
  def dump_schema_information; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1208
  def foreign_key_column_for(table_name, column_name); end

  # Checks to see if a foreign key exists on a table for a given foreign key definition.
  #
  #   # Checks to see if a foreign key exists.
  #   foreign_key_exists?(:accounts, :branches)
  #
  #   # Checks to see if a foreign key on a specified column exists.
  #   foreign_key_exists?(:accounts, column: :owner_id)
  #
  #   # Checks to see if a foreign key with a custom name exists.
  #   foreign_key_exists?(:accounts, name: "special_fk_name")
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1204
  def foreign_key_exists?(from_table, to_table = T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1213
  def foreign_key_options(from_table, to_table, options); end

  # Returns an array of foreign keys for the given table.
  # The foreign keys are represented as ForeignKeyDefinition objects.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1070
  def foreign_keys(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1464
  def index_algorithm(algorithm); end

  # Checks to see if an index exists on a table for a given index definition.
  #
  #   # Check an index exists
  #   index_exists?(:suppliers, :company_id)
  #
  #   # Check an index on multiple columns exists
  #   index_exists?(:suppliers, [:company_id, :company_type])
  #
  #   # Check a unique index exists
  #   index_exists?(:suppliers, :company_id, unique: true)
  #
  #   # Check an index with a custom name exists
  #   index_exists?(:suppliers, :company_id, name: "idx_company_id")
  #
  #   # Check a valid index exists (PostgreSQL only)
  #   index_exists?(:suppliers, :company_id, valid: true)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#102
  def index_exists?(table_name, column_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#963
  def index_name(table_name, options); end

  # Verifies the existence of an index with a given name.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#978
  def index_name_exists?(table_name, index_name); end

  # Returns an array of indexes for the given table.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#81
  def indexes(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1321
  def internal_string_options_for_primary_key; end

  # Returns the maximum length of an index name in bytes.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1553
  def max_index_name_size; end

  # Returns a hash of mappings from the abstract data types to the native
  # database types. See TableDefinition#column for details on the recognized
  # abstract data types.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#14
  def native_database_types; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1477
  def options_include_default?(options); end

  # Returns just a table's primary key
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#145
  def primary_key(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1470
  def quoted_columns_for_index(column_names, options); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: false)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, foreign_key: true)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1049
  def remove_belongs_to(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the given check constraint from the table. Removing a check constraint
  # that does not exist will raise an error.
  #
  #   remove_check_constraint :products, name: "price_check"
  #
  # To silently ignore a non-existent check constraint rather than raise an error,
  # use the +if_exists+ option.
  #
  #   remove_check_constraint :products, name: "price_check", if_exists: true
  #
  # The +expression+ parameter will be ignored if present. It can be helpful
  # to provide this in a migration's +change+ method so it can be reverted.
  # In that case, +expression+ will be used by #add_check_constraint.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1291
  def remove_check_constraint(table_name, expression = T.unsafe(nil), if_exists: T.unsafe(nil), **options); end

  # Removes the column from the table definition.
  #
  #   remove_column(:suppliers, :qualification)
  #
  # The +type+ and +options+ parameters will be ignored if present. It can be helpful
  # to provide these in a migration's +change+ method so it can be reverted.
  # In that case, +type+ and +options+ will be used by #add_column.
  # Depending on the database you're using, indexes using this column may be
  # automatically removed or modified to remove this column from the index.
  #
  # If the options provided include an +if_exists+ key, it will be used to check if the
  # column does not exist. This will silently ignore the migration rather than raising
  # if the column was already used.
  #
  #   remove_column(:suppliers, :qualification, if_exists: true)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#683
  def remove_column(table_name, column_name, type = T.unsafe(nil), **options); end

  # Removes the given columns from the table definition.
  #
  #   remove_columns(:suppliers, :qualification, :experience)
  #
  # +type+ and other column options can be passed to make migration reversible.
  #
  #    remove_columns(:suppliers, :qualification, :experience, type: :string, null: false)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#659
  def remove_columns(table_name, *column_names, type: T.unsafe(nil), **options); end

  # Removes the given foreign key from the table. Any option parameters provided
  # will be used to re-add the foreign key in case of a migration rollback.
  # It is recommended that you provide any options used when creating the foreign
  # key so that the migration can be reverted properly.
  #
  # Removes the foreign key on +accounts.branch_id+.
  #
  #   remove_foreign_key :accounts, :branches
  #
  # Removes the foreign key on +accounts.owner_id+.
  #
  #   remove_foreign_key :accounts, column: :owner_id
  #
  # Removes the foreign key on +accounts.owner_id+.
  #
  #   remove_foreign_key :accounts, to_table: :owners
  #
  # Removes the foreign key named +special_fk_name+ on the +accounts+ table.
  #
  #   remove_foreign_key :accounts, name: :special_fk_name
  #
  # Checks if the foreign key exists before trying to remove it. Will silently ignore indexes that
  # don't exist.
  #
  #   remove_foreign_key :accounts, :branches, if_exists: true
  #
  # The +options+ hash accepts the same keys as SchemaStatements#add_foreign_key
  # with an addition of
  # [<tt>:to_table</tt>]
  #   The name of the table that contains the referenced primary key.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1181
  def remove_foreign_key(from_table, to_table = T.unsafe(nil), **options); end

  # Removes the given index from the table.
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, :branch_id
  #
  # Removes the index on +branch_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: :branch_id
  #
  # Removes the index on +branch_id+ and +party_id+ in the +accounts+ table if exactly one such index exists.
  #
  #   remove_index :accounts, column: [:branch_id, :party_id]
  #
  # Removes the index named +by_branch_party+ in the +accounts+ table.
  #
  #   remove_index :accounts, name: :by_branch_party
  #
  # Removes the index on +branch_id+ named +by_branch_party+ in the +accounts+ table.
  #
  #   remove_index :accounts, :branch_id, name: :by_branch_party
  #
  # Checks if the index exists before trying to remove it. Will silently ignore indexes that
  # don't exist.
  #
  #   remove_index :accounts, if_exists: true
  #
  # Removes the index named +by_branch_party+ in the +accounts+ table +concurrently+.
  #
  #   remove_index :accounts, name: :by_branch_party, algorithm: :concurrently
  #
  # Note: only supported by PostgreSQL.
  #
  # Concurrently removing an index is not supported in a transaction.
  #
  # For more information see the {"Transactional Migrations" section}[rdoc-ref:Migration].
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#937
  def remove_index(table_name, column_name = T.unsafe(nil), **options); end

  # Removes the reference(s). Also removes a +type+ column if one exists.
  #
  # ====== Remove the reference
  #
  #   remove_reference(:products, :user, index: false)
  #
  # ====== Remove polymorphic reference
  #
  #   remove_reference(:products, :supplier, polymorphic: true)
  #
  # ====== Remove the reference with a foreign key
  #
  #   remove_reference(:products, :user, foreign_key: true)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1049
  def remove_reference(table_name, ref_name, foreign_key: T.unsafe(nil), polymorphic: T.unsafe(nil), **options); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table definition.
  #
  #  remove_timestamps(:suppliers)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1428
  def remove_timestamps(table_name, **options); end

  # Renames a column.
  #
  #   rename_column(:suppliers, :description, :name)
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#750
  def rename_column(table_name, column_name, new_column_name); end

  # Renames an index.
  #
  # Rename the +index_people_on_last_name+ index to +index_users_on_last_name+:
  #
  #   rename_index :people, 'index_people_on_last_name', 'index_users_on_last_name'
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#951
  def rename_index(table_name, old_name, new_name); end

  # Renames a table.
  #
  #   rename_table('octopuses', 'octopi')
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#510
  def rename_table(table_name, new_name, **_arg2); end

  # Returns an instance of SchemaCreation, which can be used to visit a schema definition
  # object and return DDL.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1511
  def schema_creation; end

  # Truncates a table alias according to the limits of the current adapter.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#28
  def table_alias_for(table_name); end

  # Returns the table comment that's stored in database metadata.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#23
  def table_comment(table_name); end

  # Checks to see if the table +table_name+ exists on the database.
  #
  #   table_exists?(:developers)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#59
  def table_exists?(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#18
  def table_options(table_name); end

  # Returns an array of table names defined in the database.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#51
  def tables; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1345
  def type_to_sql(type, limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil), **_arg4); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1432
  def update_table_definition(table_name, base); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1505
  def use_foreign_keys?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1544
  def valid_column_definition_options; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1548
  def valid_primary_key_options; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1540
  def valid_table_definition_options; end

  # Checks to see if the view +view_name+ exists on the database.
  #
  #   view_exists?(:ebooks)
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#74
  def view_exists?(view_name); end

  # Returns an array of view names defined in the database.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#66
  def views; end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1797
  def add_column_for_alter(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1582
  def add_index_sort_order(quoted_columns, **options); end

  # Overridden by the MySQL adapter for supporting index lengths and by
  # the PostgreSQL adapter for supporting operator classes.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1599
  def add_options_for_index_columns(quoted_columns, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1820
  def add_timestamps_for_alter(table_name, **options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1789
  def can_remove_index_by_name?(column_name, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1803
  def change_column_default_for_alter(table_name, column_name, default_or_changes); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1757
  def check_constraint_for(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1763
  def check_constraint_for!(table_name, expression: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1747
  def check_constraint_name(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1578
  def column_options_keys; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1665
  def create_alter_table(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1661
  def create_table_definition(name, **options); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1850
  def data_source_sql(name = T.unsafe(nil), type: T.unsafe(nil)); end

  # Try to identify whether the given column name is an expression
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1705
  def expression_column_name?(column_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1735
  def extract_foreign_key_action(specifier); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1780
  def extract_new_comment_value(default_or_changes); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1780
  def extract_new_default_value(default_or_changes); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1677
  def fetch_type_metadata(sql_type); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1725
  def foreign_key_for(from_table, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1730
  def foreign_key_for!(from_table, to_table: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1715
  def foreign_key_name(table_name, options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1743
  def foreign_keys_enabled?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1558
  def generate_index_name(table_name, column); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1688
  def index_column_names(column_names); end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1607
  def index_name_for_remove(table_name, column_name, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1696
  def index_name_options(column_names); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1837
  def insert_versions_sql(versions); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1589
  def options_for_index_columns(options); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1854
  def quoted_scope(name = T.unsafe(nil), type: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1793
  def reference_name_for_table(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1812
  def remove_column_for_alter(table_name, column_name, type = T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1816
  def remove_columns_for_alter(table_name, *column_names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1833
  def remove_timestamps_for_alter(table_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1648
  def rename_column_indexes(table_name, column_name, new_column_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1808
  def rename_column_sql(table_name, column_name, new_column_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1639
  def rename_table_indexes(table_name, new_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1709
  def strip_table_name_prefix_and_suffix(table_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1572
  def validate_change_column_null_argument!(value); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1669
  def validate_create_table_options!(options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1768
  def validate_index_length!(table_name, new_name, internal = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_statements.rb#1774
  def validate_table_length!(table_name); end
end

# source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#6
class ActiveRecord::ConnectionAdapters::SqlTypeMetadata
  include ::ActiveRecord::ConnectionAdapters::Deduplicable
  extend ::ActiveRecord::ConnectionAdapters::Deduplicable::ClassMethods

  # @return [SqlTypeMetadata] a new instance of SqlTypeMetadata
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#11
  def initialize(sql_type: T.unsafe(nil), type: T.unsafe(nil), limit: T.unsafe(nil), precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#19
  def ==(other); end

  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#19
  def eql?(other); end

  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#29
  def hash; end

  # Returns the value of attribute limit.
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#9
  def limit; end

  # Returns the value of attribute precision.
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#9
  def precision; end

  # Returns the value of attribute scale.
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#9
  def scale; end

  # Returns the value of attribute sql_type.
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#9
  def sql_type; end

  # Returns the value of attribute type.
  #
  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#9
  def type; end

  private

  # source://activerecord//lib/active_record/connection_adapters/sql_type_metadata.rb#39
  def deduplicated; end
end

# = Active Record Connection Adapters \Table
#
# Represents an SQL table in an abstract way for updating a table.
# Also see TableDefinition and {connection.create_table}[rdoc-ref:SchemaStatements#create_table]
#
# Available transformations are:
#
#   change_table :table do |t|
#     t.primary_key
#     t.column
#     t.index
#     t.rename_index
#     t.timestamps
#     t.change
#     t.change_default
#     t.change_null
#     t.rename
#     t.references
#     t.belongs_to
#     t.check_constraint
#     t.string
#     t.text
#     t.integer
#     t.bigint
#     t.float
#     t.decimal
#     t.numeric
#     t.datetime
#     t.timestamp
#     t.time
#     t.date
#     t.binary
#     t.blob
#     t.boolean
#     t.foreign_key
#     t.json
#     t.virtual
#     t.remove
#     t.remove_foreign_key
#     t.remove_references
#     t.remove_belongs_to
#     t.remove_index
#     t.remove_check_constraint
#     t.remove_timestamps
#   end
#
# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#706
class ActiveRecord::ConnectionAdapters::Table
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # @return [Table] a new instance of Table
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#711
  def initialize(table_name, base); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#862
  def belongs_to(*args, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def bigint(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def binary(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def blob(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def boolean(*names, **options); end

  # Changes the column's definition according to the new options.
  #
  #  t.change(:name, :string, limit: 80)
  #  t.change(:description, :text)
  #
  # See TableDefinition#column for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#788
  def change(column_name, type, **options); end

  # Sets a new default value for a column.
  #
  #  t.change_default(:qualification, 'new')
  #  t.change_default(:authorized, 1)
  #  t.change_default(:status, from: nil, to: "draft")
  #
  # See {connection.change_column_default}[rdoc-ref:SchemaStatements#change_column_default]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#800
  def change_default(column_name, default_or_changes); end

  # Sets or removes a NOT NULL constraint on a column.
  #
  #  t.change_null(:qualification, true)
  #  t.change_null(:qualification, false, 0)
  #
  # See {connection.change_column_null}[rdoc-ref:SchemaStatements#change_column_null]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#810
  def change_null(column_name, null, default = T.unsafe(nil)); end

  # Adds a check constraint.
  #
  #  t.check_constraint("price > 0", name: "price_check")
  #
  # See {connection.add_check_constraint}[rdoc-ref:SchemaStatements#add_check_constraint]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#920
  def check_constraint(*args, **options); end

  # Checks if a check_constraint exists on a table.
  #
  #  unless t.check_constraint_exists?(name: "price_check")
  #    t.check_constraint("price > 0", name: "price_check")
  #  end
  #
  # See {connection.check_constraint_exists?}[rdoc-ref:SchemaStatements#check_constraint_exists?]
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#940
  def check_constraint_exists?(*args, **options); end

  # Adds a new column to the named table.
  #
  #  t.column(:name, :string)
  #
  # See TableDefinition#column for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#721
  def column(column_name, type, index: T.unsafe(nil), **options); end

  # Checks to see if a column exists.
  #
  #  t.string(:name) unless t.column_exists?(:name, :string)
  #
  # See {connection.column_exists?}[rdoc-ref:SchemaStatements#column_exists?]
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#735
  def column_exists?(column_name, type = T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def date(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def datetime(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def decimal(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def float(*names, **options); end

  # Adds a foreign key to the table using a supplied table name.
  #
  #  t.foreign_key(:authors)
  #  t.foreign_key(:authors, column: :author_id, primary_key: "id")
  #
  # See {connection.add_foreign_key}[rdoc-ref:SchemaStatements#add_foreign_key]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#890
  def foreign_key(*args, **options); end

  # Checks to see if a foreign key exists.
  #
  #  t.foreign_key(:authors) unless t.foreign_key_exists?(:authors)
  #
  # See {connection.foreign_key_exists?}[rdoc-ref:SchemaStatements#foreign_key_exists?]
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#911
  def foreign_key_exists?(*args, **options); end

  # Adds a new index to the table. +column_name+ can be a single Symbol, or
  # an Array of Symbols.
  #
  #  t.index(:name)
  #  t.index([:branch_id, :party_id], unique: true)
  #  t.index([:branch_id, :party_id], unique: true, name: 'by_branch_party')
  #
  # See {connection.add_index}[rdoc-ref:SchemaStatements#add_index] for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#747
  def index(column_name, **options); end

  # Checks to see if an index exists.
  #
  #  unless t.index_exists?(:branch_id)
  #    t.index(:branch_id)
  #  end
  #
  # See {connection.index_exists?}[rdoc-ref:SchemaStatements#index_exists?]
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#759
  def index_exists?(column_name, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def integer(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def json(*names, **options); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#709
  def name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def numeric(*names, **options); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#862
  def references(*args, **options); end

  # Removes the column(s) from the table definition.
  #
  #  t.remove(:qualification)
  #  t.remove(:qualification, :experience)
  #
  # See {connection.remove_columns}[rdoc-ref:SchemaStatements#remove_columns]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#820
  def remove(*column_names, **options); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#876
  def remove_belongs_to(*args, **options); end

  # Removes the given check constraint from the table.
  #
  #  t.remove_check_constraint(name: "price_check")
  #
  # See {connection.remove_check_constraint}[rdoc-ref:SchemaStatements#remove_check_constraint]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#929
  def remove_check_constraint(*args, **options); end

  # Removes the given foreign key from the table.
  #
  #  t.remove_foreign_key(:authors)
  #  t.remove_foreign_key(column: :author_id)
  #
  # See {connection.remove_foreign_key}[rdoc-ref:SchemaStatements#remove_foreign_key]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#901
  def remove_foreign_key(*args, **options); end

  # Removes the given index from the table.
  #
  #   t.remove_index(:branch_id)
  #   t.remove_index(column: [:branch_id, :party_id])
  #   t.remove_index(name: :by_branch_party)
  #   t.remove_index(:branch_id, name: :by_branch_party)
  #
  # See {connection.remove_index}[rdoc-ref:SchemaStatements#remove_index]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#833
  def remove_index(column_name = T.unsafe(nil), **options); end

  # Removes a reference. Optionally removes a +type+ column.
  #
  #  t.remove_references(:user)
  #  t.remove_belongs_to(:supplier, polymorphic: true)
  #
  # See {connection.remove_reference}[rdoc-ref:SchemaStatements#remove_reference]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#876
  def remove_references(*args, **options); end

  # Removes the timestamp columns (+created_at+ and +updated_at+) from the table.
  #
  #  t.remove_timestamps
  #
  # See {connection.remove_timestamps}[rdoc-ref:SchemaStatements#remove_timestamps]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#843
  def remove_timestamps(**options); end

  # Renames a column.
  #
  #  t.rename(:description, :name)
  #
  # See {connection.rename_column}[rdoc-ref:SchemaStatements#rename_column]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#852
  def rename(column_name, new_column_name); end

  # Renames the given index on the table.
  #
  #  t.rename_index(:user_id, :account_id)
  #
  # See {connection.rename_index}[rdoc-ref:SchemaStatements#rename_index]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#768
  def rename_index(index_name, new_index_name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def string(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def text(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def time(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def timestamp(*names, **options); end

  # Adds timestamps (+created_at+ and +updated_at+) columns to the table.
  #
  #  t.timestamps(null: false)
  #
  # See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#777
  def timestamps(**options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def virtual(*names, **options); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#945
  def raise_on_if_exist_options(options); end
end

# = Active Record Connection Adapters \Table \Definition
#
# Represents the schema of an SQL table in an abstract way. This class
# provides methods for manipulating the schema representation.
#
# Inside migration files, the +t+ object in {create_table}[rdoc-ref:SchemaStatements#create_table]
# is actually of this type:
#
#   class SomeMigration < ActiveRecord::Migration[7.1]
#     def up
#       create_table :foo do |t|
#         puts t.class  # => "ActiveRecord::ConnectionAdapters::TableDefinition"
#       end
#     end
#
#     def down
#       ...
#     end
#   end
#
# source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#363
class ActiveRecord::ConnectionAdapters::TableDefinition
  include ::ActiveRecord::ConnectionAdapters::ColumnMethods
  extend ::ActiveRecord::ConnectionAdapters::ColumnMethods::ClassMethods

  # @return [TableDefinition] a new instance of TableDefinition
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#368
  def initialize(conn, name, temporary: T.unsafe(nil), if_not_exists: T.unsafe(nil), options: T.unsafe(nil), as: T.unsafe(nil), comment: T.unsafe(nil), **_arg7); end

  # Returns a ColumnDefinition for the column with name +name+.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#418
  def [](name); end

  # Returns the value of attribute as.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def as; end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #  t.belongs_to(:supplier, foreign_key: true, type: :integer)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#548
  def belongs_to(*args, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def bigint(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def binary(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def blob(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def boolean(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#522
  def check_constraint(expression, **options); end

  # Returns the value of attribute check_constraints.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def check_constraints; end

  # Instantiates a new column for the table.
  # See {connection.add_column}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_column]
  # for available options.
  #
  # Additional options are:
  # * <tt>:index</tt> -
  #   Create an index for the column. Can be either <tt>true</tt> or an options hash.
  #
  # This method returns <tt>self</tt>.
  #
  # == Examples
  #
  #  # Assuming +td+ is an instance of TableDefinition
  #  td.column(:granted, :boolean, index: true)
  #
  # == Short-hand examples
  #
  # Instead of calling #column directly, you can also work with the short-hand definitions for the default types.
  # They use the type as the method name instead of as a parameter and allow for multiple columns to be defined
  # in a single statement.
  #
  # What can be written like this with the regular calls to column:
  #
  #   create_table :products do |t|
  #     t.column :shop_id,     :integer
  #     t.column :creator_id,  :integer
  #     t.column :item_number, :string
  #     t.column :name,        :string, default: "Untitled"
  #     t.column :value,       :string, default: "Untitled"
  #     t.column :created_at,  :datetime
  #     t.column :updated_at,  :datetime
  #   end
  #   add_index :products, :item_number
  #
  # can also be written as follows using the short-hand:
  #
  #   create_table :products do |t|
  #     t.integer :shop_id, :creator_id
  #     t.string  :item_number, index: true
  #     t.string  :name, :value, default: "Untitled"
  #     t.timestamps null: false
  #   end
  #
  # There's a short-hand method for each of the type values declared at the top. And then there's
  # TableDefinition#timestamps that'll add +created_at+ and +updated_at+ as datetimes.
  #
  # TableDefinition#references will add an appropriately-named _id column, plus a corresponding _type
  # column if the <tt>:polymorphic</tt> option is supplied. If <tt>:polymorphic</tt> is a hash of
  # options, these will be used when creating the <tt>_type</tt> column. The <tt>:index</tt> option
  # will also create an index, similar to calling {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # So what can be written like this:
  #
  #   create_table :taggings do |t|
  #     t.integer :tag_id, :tagger_id, :taggable_id
  #     t.string  :tagger_type
  #     t.string  :taggable_type, default: 'Photo'
  #   end
  #   add_index :taggings, :tag_id, name: 'index_taggings_on_tag_id'
  #   add_index :taggings, [:tagger_id, :tagger_type]
  #
  # Can also be written as follows using references:
  #
  #   create_table :taggings do |t|
  #     t.references :tag, index: { name: 'index_taggings_on_tag_id' }
  #     t.references :tagger, polymorphic: true
  #     t.references :taggable, polymorphic: { default: 'Photo' }, index: false
  #   end
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#489
  def column(name, type, index: T.unsafe(nil), **options); end

  # Returns an array of ColumnDefinition objects for the columns of the table.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#415
  def columns; end

  # Returns the value of attribute comment.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def comment; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def date(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def datetime(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def decimal(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def float(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#518
  def foreign_key(to_table, **options); end

  # Returns the value of attribute foreign_keys.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def foreign_keys; end

  # Returns the value of attribute if_not_exists.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def if_not_exists; end

  # Adds index options to the indexes hash, keyed by column name
  # This is primarily used to track indexes that need to be created after the table
  #
  #   index(:account_id, name: 'index_projects_on_account_id')
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#514
  def index(column_name, **options); end

  # Returns the value of attribute indexes.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def indexes; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def integer(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def json(*names, **options); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def name; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#580
  def new_check_constraint_definition(expression, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#555
  def new_column_definition(name, type, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#572
  def new_foreign_key_definition(to_table, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def numeric(*names, **options); end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def options; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#409
  def primary_keys(name = T.unsafe(nil)); end

  # Adds a reference.
  #
  #  t.references(:user)
  #  t.belongs_to(:supplier, foreign_key: true)
  #  t.belongs_to(:supplier, foreign_key: true, type: :integer)
  #
  # See {connection.add_reference}[rdoc-ref:SchemaStatements#add_reference] for details of the options you can use.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#548
  def references(*args, **options); end

  # remove the column +name+ from the table.
  #   remove_column(:account_id)
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#506
  def remove_column(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#392
  def set_primary_key(table_name, id, primary_key, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def string(*names, **options); end

  # Returns the value of attribute temporary.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#366
  def temporary; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def text(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def time(*names, **options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def timestamp(*names, **options); end

  # Appends <tt>:datetime</tt> columns <tt>:created_at</tt> and
  # <tt>:updated_at</tt> to the table. See {connection.add_timestamps}[rdoc-ref:SchemaStatements#add_timestamps]
  #
  #   t.timestamps null: false
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#530
  def timestamps(**options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#332
  def virtual(*names, **options); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#598
  def aliased_types(name, fallback); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#590
  def create_column_definition(name, type, options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#602
  def integer_like_primary_key?(type, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#606
  def integer_like_primary_key_type(type, options); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#610
  def raise_on_duplicate_column(name); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/schema_definitions.rb#586
  def valid_column_definition_options; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#120
class ActiveRecord::ConnectionAdapters::Transaction
  # @return [Transaction] a new instance of Transaction
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#126
  def initialize(connection, isolation: T.unsafe(nil), joinable: T.unsafe(nil), run_commit_callbacks: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#147
  def add_record(record, ensure_finalize = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#208
  def before_commit_records; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#251
  def closed?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#228
  def commit_records; end

  # Returns the value of attribute connection.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#121
  def connection; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#139
  def dirty!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#143
  def dirty?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#249
  def full_rollback?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#171
  def incomplete!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#124
  def invalidate!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#124
  def invalidated?(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute isolation_level.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#121
  def isolation_level; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#250
  def joinable?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#175
  def materialize!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#180
  def materialized?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#252
  def open?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#157
  def records; end

  # Can this transaction's current state be recreated by
  # rollback+begin ?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#167
  def restartable?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#184
  def restore!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#192
  def rollback_records; end

  # Returns the value of attribute savepoint_name.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#121
  def savepoint_name; end

  # Returns the value of attribute state.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#121
  def state; end

  # Returns the value of attribute written.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#122
  def written; end

  # Sets the attribute written
  #
  # @param value the value to set the attribute written to.
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#122
  def written=(_arg0); end

  private

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#267
  def prepare_instances_to_run_callbacks_on(records); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#259
  def run_action_on_records(records, instances_to_run_callbacks_on); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#255
  def unique_records; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#77
class ActiveRecord::ConnectionAdapters::TransactionInstrumenter
  # @return [TransactionInstrumenter] a new instance of TransactionInstrumenter
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#78
  def initialize(payload = T.unsafe(nil)); end

  # @raise [InstrumentationNotStartedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#97
  def finish(outcome); end

  # @raise [InstrumentationAlreadyStartedError]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#88
  def start; end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#86
class ActiveRecord::ConnectionAdapters::TransactionInstrumenter::InstrumentationAlreadyStartedError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#85
class ActiveRecord::ConnectionAdapters::TransactionInstrumenter::InstrumentationNotStartedError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#406
class ActiveRecord::ConnectionAdapters::TransactionManager
  # @return [TransactionManager] a new instance of TransactionManager
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#407
  def initialize(connection); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#415
  def begin_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil), _lazy: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#502
  def commit_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#588
  def current_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#470
  def dirty_current_transaction; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#457
  def disable_lazy_transactions!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#462
  def enable_lazy_transactions!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#466
  def lazy_transactions_enabled?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#486
  def materialize_transactions; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#584
  def open_transactions; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#482
  def restorable?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#474
  def restore_transactions; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#519
  def rollback_transaction(transaction = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#531
  def within_new_transaction(isolation: T.unsafe(nil), joinable: T.unsafe(nil)); end

  private

  # Deallocate invalidated prepared statements outside of the transaction
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#596
  def after_failure_actions(transaction, error); end
end

# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#593
ActiveRecord::ConnectionAdapters::TransactionManager::NULL_TRANSACTION = T.let(T.unsafe(nil), ActiveRecord::ConnectionAdapters::NullTransaction)

# = Active Record Connection Adapters Transaction State
#
# source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#6
class ActiveRecord::ConnectionAdapters::TransactionState
  # @return [TransactionState] a new instance of TransactionState
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#7
  def initialize(state = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#12
  def add_child(state); end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#64
  def commit!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#21
  def committed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#45
  def completed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#17
  def finalized?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#68
  def full_commit!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#54
  def full_rollback!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#25
  def fully_committed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#41
  def fully_completed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#33
  def fully_rolledback?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#59
  def invalidate!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#37
  def invalidated?; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#72
  def nullify!; end

  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#49
  def rollback!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_adapters/abstract/transaction.rb#29
  def rolledback?; end
end

# ConnectionFailed will be raised when the network connection to the
# database fails while sending a query or waiting for its result.
#
# source://activerecord//lib/active_record/errors.rb#555
class ActiveRecord::ConnectionFailed < ::ActiveRecord::QueryAborted; end

# = Active Record Connection Handling
#
# source://activerecord//lib/active_record/connection_handling.rb#5
module ActiveRecord::ConnectionHandling
  # source://activerecord//lib/active_record/connection_handling.rb#319
  def clear_active_connections!(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_handling.rb#329
  def clear_all_connections!(role = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_handling.rb#315
  def clear_cache!; end

  # Clears the query cache for all connections associated with the current thread.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#244
  def clear_query_caches_for_current_thread; end

  # source://activerecord//lib/active_record/connection_handling.rb#324
  def clear_reloadable_connections!(role = T.unsafe(nil)); end

  # Returns +true+ if Active Record is connected.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_handling.rb#291
  def connected?; end

  # Connects to a role (e.g. writing, reading, or a custom role) and/or
  # shard for the duration of the block. At the end of the block the
  # connection will be returned to the original role / shard.
  #
  # If only a role is passed, Active Record will look up the connection
  # based on the requested role. If a non-established role is requested
  # an +ActiveRecord::ConnectionNotEstablished+ error will be raised:
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     Dog.create! # creates dog using dog writing connection
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading) do
  #     Dog.create! # throws exception because we're on a replica
  #   end
  #
  # When swapping to a shard, the role must be passed as well. If a non-existent
  # shard is passed, an +ActiveRecord::ConnectionNotEstablished+ error will be
  # raised.
  #
  # When a shard and role is passed, Active Record will first lookup the role,
  # and then look up the connection by shard key.
  #
  #   ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one_replica) do
  #     Dog.first # finds first Dog record stored on the shard one replica
  #   end
  #
  # source://activerecord//lib/active_record/connection_handling.rb#134
  def connected_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil), &blk); end

  # Returns true if role is the current connected role and/or
  # current connected shard. If no shard is passed, the default will be
  # used.
  #
  #   ActiveRecord::Base.connected_to(role: :writing) do
  #     ActiveRecord::Base.connected_to?(role: :writing) #=> true
  #     ActiveRecord::Base.connected_to?(role: :reading) #=> false
  #   end
  #
  #   ActiveRecord::Base.connected_to(role: :reading, shard: :shard_one) do
  #     ActiveRecord::Base.connected_to?(role: :reading, shard: :shard_one) #=> true
  #     ActiveRecord::Base.connected_to?(role: :reading, shard: :default) #=> false
  #     ActiveRecord::Base.connected_to?(role: :writing, shard: :shard_one) #=> true
  #   end
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_handling.rb#239
  def connected_to?(role:, shard: T.unsafe(nil)); end

  # Connects a role and/or shard to the provided connection names. Optionally +prevent_writes+
  # can be passed to block writes on a connection. +reading+ will automatically set
  # +prevent_writes+ to true.
  #
  # +connected_to_many+ is an alternative to deeply nested +connected_to+ blocks.
  #
  # Usage:
  #
  #   ActiveRecord::Base.connected_to_many(AnimalsRecord, MealsRecord, role: :reading) do
  #     Dog.first # Read from animals replica
  #     Dinner.first # Read from meals replica
  #     Person.first # Read from primary writer
  #   end
  #
  # source://activerecord//lib/active_record/connection_handling.rb#163
  def connected_to_many(*classes, role:, shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  # Use a specified connection.
  #
  # This method is useful for ensuring that a specific connection is
  # being used. For example, when booting a console in readonly mode.
  #
  # It is not recommended to use this method in a request since it
  # does not yield to a block like +connected_to+.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#185
  def connecting_to(role: T.unsafe(nil), shard: T.unsafe(nil), prevent_writes: T.unsafe(nil)); end

  # Returns the connection currently associated with the class. This can
  # also be used to "borrow" the connection to do database work unrelated
  # to any of the specific Active Records.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#253
  def connection; end

  # Returns the db_config object from the associated connection:
  #
  #  ActiveRecord::Base.connection_db_config
  #    #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10 @env_name="development",
  #      @name="primary", @config={pool: 5, timeout: 5000, database: "storage/development.sqlite3", adapter: "sqlite3"}>
  #
  # Use only for reading.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#278
  def connection_db_config; end

  # source://activerecord//lib/active_record/connection_handling.rb#282
  def connection_pool; end

  # Returns the connection specification name from the current class or its parent.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#260
  def connection_specification_name; end

  # Sets the attribute connection_specification_name
  #
  # @param value the value to set the attribute connection_specification_name to.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#257
  def connection_specification_name=(_arg0); end

  # Connects a model to the databases specified. The +database+ keyword
  # takes a hash consisting of a +role+ and a +database_key+.
  #
  # This will look up the database config using the +database_key+ and
  # establish a connection to that config.
  #
  #   class AnimalsModel < ApplicationRecord
  #     self.abstract_class = true
  #
  #     connects_to database: { writing: :primary, reading: :primary_replica }
  #   end
  #
  # +connects_to+ also supports horizontal sharding. The horizontal sharding API
  # supports read replicas as well. You can connect a model to a list of shards like this:
  #
  #   class AnimalsModel < ApplicationRecord
  #     self.abstract_class = true
  #
  #     connects_to shards: {
  #       default: { writing: :primary, reading: :primary_replica },
  #       shard_two: { writing: :primary_shard_two, reading: :primary_shard_replica_two }
  #     }
  #   end
  #
  # Returns an array of database connections.
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/connection_handling.rb#81
  def connects_to(database: T.unsafe(nil), shards: T.unsafe(nil)); end

  # Establishes the connection to the database. Accepts a hash as input where
  # the <tt>:adapter</tt> key must be specified with the name of a database adapter (in lower-case)
  # example for regular databases (MySQL, PostgreSQL, etc):
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "mysql2",
  #     host:     "localhost",
  #     username: "myuser",
  #     password: "mypass",
  #     database: "somedatabase"
  #   )
  #
  # Example for SQLite database:
  #
  #   ActiveRecord::Base.establish_connection(
  #     adapter:  "sqlite3",
  #     database: "path/to/dbfile"
  #   )
  #
  # Also accepts keys as strings (for parsing from YAML for example):
  #
  #   ActiveRecord::Base.establish_connection(
  #     "adapter"  => "sqlite3",
  #     "database" => "path/to/dbfile"
  #   )
  #
  # Or a URL:
  #
  #   ActiveRecord::Base.establish_connection(
  #     "postgres://myuser:mypass@localhost/somedatabase"
  #   )
  #
  # In case {ActiveRecord::Base.configurations}[rdoc-ref:Core.configurations]
  # is set (\Rails automatically loads the contents of config/database.yml into it),
  # a symbol can also be given as argument, representing a key in the
  # configuration hash:
  #
  #   ActiveRecord::Base.establish_connection(:production)
  #
  # The exceptions AdapterNotSpecified, AdapterNotFound, and +ArgumentError+
  # may be returned on an error.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#50
  def establish_connection(config_or_env = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_handling.rb#334
  def flush_idle_connections!(role = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_handling.rb#267
  def primary_class?; end

  # Prohibit swapping shards while inside of the passed block.
  #
  # In some cases you may want to be able to swap shards but not allow a
  # nested call to connected_to or connected_to_many to swap again. This
  # is useful in cases you're using sharding to provide per-request
  # database isolation.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#197
  def prohibit_shard_swapping(enabled = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_handling.rb#295
  def remove_connection(name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/connection_handling.rb#286
  def retrieve_connection; end

  # Determine whether or not shard swapping is currently prohibited
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/connection_handling.rb#206
  def shard_swapping_prohibited?; end

  # Prevent writing to the database regardless of role.
  #
  # In some cases you may want to prevent writes to the database
  # even if you are on a database that can write. +while_preventing_writes+
  # will prevent writes to the database for the duration of the block.
  #
  # This method does not provide the same protection as a readonly
  # user and is meant to be a safeguard against accidental writes.
  #
  # See +READ_QUERY+ for the queries that are blocked by this
  # method.
  #
  # source://activerecord//lib/active_record/connection_handling.rb#221
  def while_preventing_writes(enabled = T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/connection_handling.rb#368
  def append_to_connected_to_stack(entry); end

  # source://activerecord//lib/active_record/connection_handling.rb#340
  def deprecation_for_delegation(method); end

  # source://activerecord//lib/active_record/connection_handling.rb#348
  def resolve_config_for_connection(config_or_env); end

  # source://activerecord//lib/active_record/connection_handling.rb#357
  def with_role_and_shard(role, shard, prevent_writes); end
end

# source://activerecord//lib/active_record/connection_handling.rb#7
ActiveRecord::ConnectionHandling::DEFAULT_ENV = T.let(T.unsafe(nil), Proc)

# source://activerecord//lib/active_record/connection_handling.rb#6
ActiveRecord::ConnectionHandling::RAILS_ENV = T.let(T.unsafe(nil), Proc)

# Raised when connection to the database could not been established (for example when
# {ActiveRecord::Base.connection=}[rdoc-ref:ConnectionHandling#connection]
# is given a +nil+ object).
#
# source://activerecord//lib/active_record/errors.rb#71
class ActiveRecord::ConnectionNotEstablished < ::ActiveRecord::AdapterError
  # @return [ConnectionNotEstablished] a new instance of ConnectionNotEstablished
  #
  # source://activerecord//lib/active_record/errors.rb#72
  def initialize(message = T.unsafe(nil), connection_pool: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/errors.rb#76
  def set_pool(connection_pool); end
end

# Raised when a connection could not be obtained within the connection
# acquisition timeout period: because max connections in pool
# are in use.
#
# source://activerecord//lib/active_record/errors.rb#88
class ActiveRecord::ConnectionTimeoutError < ::ActiveRecord::ConnectionNotEstablished; end

# = Active Record \Core
#
# source://activerecord//lib/active_record/core.rb#10
module ActiveRecord::Core
  include ::ActiveModel::Access
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Core::ClassMethods

  # New objects can be instantiated as either empty (pass no construction parameter) or pre-set with
  # attributes but not yet saved (pass a hash with key names matching the associated table column names).
  # In both instances, valid attribute keys are determined by the column names of the associated table --
  # hence you can't have attributes that aren't part of the table columns.
  #
  # ==== Example
  #   # Instantiates a single new object
  #   User.new(first_name: 'Jamie')
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  #
  # source://activerecord//lib/active_record/core.rb#446
  def initialize(attributes = T.unsafe(nil)); end

  # Allows sort on objects
  #
  # source://activerecord//lib/active_record/core.rb#633
  def <=>(other_object); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  #
  # source://activerecord//lib/active_record/core.rb#599
  def ==(comparison_object); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#645
  def blank?; end

  # source://activerecord//lib/active_record/core.rb#713
  def connection_handler; end

  # Populate +coder+ with attributes about this record that should be
  # serialized. The structure of +coder+ defined in this method is
  # guaranteed to match the structure of +coder+ passed to the #init_with
  # method.
  #
  # Example:
  #
  #   class Post < ActiveRecord::Base
  #   end
  #   coder = {}
  #   Post.new.encode_with(coder)
  #   coder # => {"attributes" => {"id" => nil, ... }}
  #
  # source://activerecord//lib/active_record/core.rb#555
  def encode_with(coder); end

  # Returns true if +comparison_object+ is the same exact object, or +comparison_object+
  # is of the same type and +self+ has an ID and it is equal to +comparison_object.id+.
  #
  # Note that new records are different from any other record by definition, unless the
  # other record is the receiver itself. Besides, if you fetch existing records with
  # +select+ and leave the ID out, you're on your own, this predicate will return false.
  #
  # Note also that destroying a record preserves its ID in the model instance, so deleted
  # models are still comparable.
  #
  # source://activerecord//lib/active_record/core.rb#599
  def eql?(comparison_object); end

  # Clone and freeze the attributes hash such that associations are still
  # accessible, even on destroyed records, but cloned models will not be
  # frozen.
  #
  # source://activerecord//lib/active_record/core.rb#622
  def freeze; end

  # Returns +true+ if the attributes hash has been frozen.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#628
  def frozen?; end

  # Delegates to id in order to allow two records of the same type and id to work with something like:
  #   [ Person.find(1), Person.find(2), Person.find(3) ] & [ Person.find(1), Person.find(4) ] # => [ Person.find(1) ]
  #
  # source://activerecord//lib/active_record/core.rb#609
  def hash; end

  # Initialize an empty model object from +coder+. +coder+ should be
  # the result of previously encoding an Active Record model, using
  # #encode_with.
  #
  #   class Post < ActiveRecord::Base
  #   end
  #
  #   old_post = Post.new(title: "hello world")
  #   coder = {}
  #   old_post.encode_with(coder)
  #
  #   post = Post.allocate
  #   post.init_with(coder)
  #   post.title # => 'hello world'
  #
  # source://activerecord//lib/active_record/core.rb#473
  def init_with(coder, &block); end

  # Initialize an empty model object from +attributes+.
  # +attributes+ should be an attributes object, and unlike the
  # `initialize` method, no assignment calls are made per attribute.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Core] the object that the method was called on
  #
  # source://activerecord//lib/active_record/core.rb#483
  def init_with_attributes(attributes, new_record = T.unsafe(nil)); end

  # Returns the contents of the record as a nicely formatted string.
  #
  # source://activerecord//lib/active_record/core.rb#718
  def inspect; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#641
  def present?; end

  # Takes a PP and prettily prints this record to it, allowing you to get a nice result from <tt>pp record</tt>
  # when pp is required.
  #
  # source://activerecord//lib/active_record/core.rb#736
  def pretty_print(pp); end

  # Marks this record as read only.
  #
  #   customer = Customer.first
  #   customer.readonly!
  #   customer.save # Raises an ActiveRecord::ReadOnlyRecord
  #
  # source://activerecord//lib/active_record/core.rb#709
  def readonly!; end

  # Returns +true+ if the record is read only.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#650
  def readonly?; end

  # Sets the record to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.first
  #   user.strict_loading! # => true
  #   user.address.city
  #   => ActiveRecord::StrictLoadingViolationError
  #   user.comments.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  #
  # ==== Parameters
  #
  # * +value+ - Boolean specifying whether to enable or disable strict loading.
  # * <tt>:mode</tt> - Symbol specifying strict loading mode. Defaults to :all. Using
  #   :n_plus_one_only mode will only raise an error if an association that
  #   will lead to an n plus one query is lazily loaded.
  #
  # ==== Examples
  #
  #   user = User.first
  #   user.strict_loading!(false) # => false
  #   user.address.city # => "Tatooine"
  #   user.comments.to_a # => [#<Comment:0x00...]
  #
  #   user.strict_loading!(mode: :n_plus_one_only)
  #   user.address.city # => "Tatooine"
  #   user.comments.to_a # => [#<Comment:0x00...]
  #   user.comments.first.ratings.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  #
  # source://activerecord//lib/active_record/core.rb#688
  def strict_loading!(value = T.unsafe(nil), mode: T.unsafe(nil)); end

  # Returns +true+ if the record is in strict_loading mode.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#655
  def strict_loading?; end

  # Returns the value of attribute strict_loading_mode.
  #
  # source://activerecord//lib/active_record/core.rb#697
  def strict_loading_mode; end

  # Returns +true+ if the record uses strict_loading with +:n_plus_one_only+ mode enabled.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#700
  def strict_loading_n_plus_one_only?; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/core.rb#793
  def custom_inspect_method_defined?; end

  # source://activerecord//lib/active_record/core.rb#772
  def init_internals; end

  # source://activerecord//lib/active_record/core.rb#525
  def initialize_dup(other); end

  # source://activerecord//lib/active_record/core.rb#790
  def initialize_internals_callback; end

  # source://activerecord//lib/active_record/core.rb#804
  def inspection_filter; end

  # +Array#flatten+ will call +#to_ary+ (recursively) on each of the elements of
  # the array, and then rescues from the possible +NoMethodError+. If those elements are
  # +ActiveRecord::Base+'s, then this triggers the various +method_missing+'s that we have,
  # which significantly impacts upon performance.
  #
  # So we can avoid the +method_missing+ hit by explicitly defining +#to_ary+ as +nil+ here.
  #
  # See also https://tenderlovemaking.com/2011/06/28/til-its-ok-to-return-nil-from-to_ary.html
  #
  # source://activerecord//lib/active_record/core.rb#768
  def to_ary; end

  module GeneratedClassMethods
    def _destroy_association_async_job; end
    def _destroy_association_async_job=(value); end
    def _destroy_association_async_job?; end
    def belongs_to_required_by_default; end
    def belongs_to_required_by_default=(value); end
    def belongs_to_required_by_default?; end
    def default_connection_handler; end
    def default_connection_handler=(value); end
    def default_connection_handler?; end
    def default_role; end
    def default_role=(value); end
    def default_role?; end
    def default_shard; end
    def default_shard=(value); end
    def default_shard?; end
    def destroy_association_async_batch_size; end
    def destroy_association_async_batch_size=(value); end
    def enumerate_columns_in_select_statements; end
    def enumerate_columns_in_select_statements=(value); end
    def enumerate_columns_in_select_statements?; end
    def has_many_inversing; end
    def has_many_inversing=(value); end
    def has_many_inversing?; end
    def logger; end
    def logger=(value); end
    def logger?; end
    def run_commit_callbacks_on_first_saved_instances_in_transaction; end
    def run_commit_callbacks_on_first_saved_instances_in_transaction=(value); end
    def run_commit_callbacks_on_first_saved_instances_in_transaction?; end
    def shard_selector; end
    def shard_selector=(value); end
    def shard_selector?; end
    def strict_loading_by_default; end
    def strict_loading_by_default=(value); end
    def strict_loading_by_default?; end
  end

  module GeneratedInstanceMethods
    def default_connection_handler; end
    def default_connection_handler?; end
    def default_role; end
    def default_role?; end
    def default_shard; end
    def default_shard?; end
    def destroy_association_async_batch_size; end
    def logger; end
    def logger?; end
  end
end

# source://activerecord//lib/active_record/core.rb#238
module ActiveRecord::Core::ClassMethods
  # Returns an instance of +Arel::Table+ loaded with the current table name.
  #
  # source://activerecord//lib/active_record/core.rb#364
  def arel_table; end

  # source://activerecord//lib/active_record/core.rb#376
  def cached_find_by_statement(key, &block); end

  # Returns columns which shouldn't be exposed while calling +#inspect+.
  #
  # source://activerecord//lib/active_record/core.rb#322
  def filter_attributes; end

  # Specifies columns which shouldn't be exposed while calling +#inspect+.
  #
  # source://activerecord//lib/active_record/core.rb#331
  def filter_attributes=(filter_attributes); end

  # source://activerecord//lib/active_record/core.rb#243
  def find(*ids); end

  # source://activerecord//lib/active_record/core.rb#256
  def find_by(*args); end

  # source://activerecord//lib/active_record/core.rb#303
  def find_by!(*args); end

  # source://activerecord//lib/active_record/core.rb#311
  def generated_association_methods; end

  # source://activerecord//lib/active_record/core.rb#239
  def initialize_find_by_cache; end

  # source://activerecord//lib/active_record/core.rb#307
  def initialize_generated_modules; end

  # Returns a string like 'Post(id:integer, title:string, body:text)'
  #
  # source://activerecord//lib/active_record/core.rb#348
  def inspect; end

  # source://activerecord//lib/active_record/core.rb#336
  def inspection_filter; end

  # source://activerecord//lib/active_record/core.rb#368
  def predicate_builder; end

  # source://activerecord//lib/active_record/core.rb#372
  def type_caster; end

  private

  # source://activerecord//lib/active_record/core.rb#418
  def cached_find_by(keys, values); end

  # source://activerecord//lib/active_record/core.rb#382
  def inherited(subclass); end

  # source://activerecord//lib/active_record/core.rb#404
  def relation; end

  # source://activerecord//lib/active_record/core.rb#414
  def table_metadata; end
end

# source://activerecord//lib/active_record/core.rb#797
class ActiveRecord::Core::InspectionMask
  # source://activerecord//lib/active_record/core.rb#798
  def pretty_print(pp); end
end

# = Active Record Counter Cache
#
# source://activerecord//lib/active_record/counter_cache.rb#5
module ActiveRecord::CounterCache
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::CounterCache::ClassMethods

  private

  # source://activerecord//lib/active_record/counter_cache.rb#186
  def _create_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/counter_cache.rb#196
  def destroy_row; end

  # source://activerecord//lib/active_record/counter_cache.rb#211
  def each_counter_cached_associations; end

  module GeneratedClassMethods
    def _counter_cache_columns; end
    def _counter_cache_columns=(value); end
    def _counter_cache_columns?; end
  end

  module GeneratedInstanceMethods; end
end

# source://activerecord//lib/active_record/counter_cache.rb#12
module ActiveRecord::CounterCache::ClassMethods
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/counter_cache.rb#180
  def counter_cache_column?(name); end

  # Decrement a numeric field by one, via a direct SQL update.
  #
  # This works the same as #increment_counter but reduces the column value by
  # 1 instead of increasing it.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be decremented.
  # * +id+ - The id of the object that should be decremented or an array of ids.
  # * <tt>:by</tt> - The amount by which to decrement the value. Defaults to +1+.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   DiscussionBoard.decrement_counter(:posts_count, 5)
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   by a specific amount.
  #   DiscussionBoard.decrement_counter(:posts_count, 5, by: 3)
  #
  #   # Decrement the posts_count column for the record with an id of 5
  #   # and update the updated_at value.
  #   DiscussionBoard.decrement_counter(:posts_count, 5, touch: true)
  #
  # source://activerecord//lib/active_record/counter_cache.rb#176
  def decrement_counter(counter_name, id, by: T.unsafe(nil), touch: T.unsafe(nil)); end

  # Increment a numeric field by one, via a direct SQL update.
  #
  # This method is used primarily for maintaining counter_cache columns that are
  # used to store aggregate values. For example, a +DiscussionBoard+ may cache
  # posts_count and comments_count to avoid running an SQL query to calculate the
  # number of posts and comments there are, each time it is displayed.
  #
  # ==== Parameters
  #
  # * +counter_name+ - The name of the field that should be incremented.
  # * +id+ - The id of the object that should be incremented or an array of ids.
  # * <tt>:by</tt> - The amount by which to increment the value. Defaults to +1+.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   DiscussionBoard.increment_counter(:posts_count, 5)
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   # by a specific amount.
  #   DiscussionBoard.increment_counter(:posts_count, 5, by: 3)
  #
  #   # Increment the posts_count column for the record with an id of 5
  #   # and update the updated_at value.
  #   DiscussionBoard.increment_counter(:posts_count, 5, touch: true)
  #
  # source://activerecord//lib/active_record/counter_cache.rb#146
  def increment_counter(counter_name, id, by: T.unsafe(nil), touch: T.unsafe(nil)); end

  # Resets one or more counter caches to their correct value using an SQL
  # count query. This is useful when adding new counter caches, or if the
  # counter has been corrupted or modified directly by SQL.
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to reset a counter on.
  # * +counters+ - One or more association counters to reset. Association name or counter name can be given.
  # * <tt>:touch</tt> - Touch timestamp columns when updating.
  #   Pass +true+ to touch +updated_at+ and/or +updated_on+. Pass a symbol to
  #   touch that column or an array of symbols to touch just those ones.
  #
  # ==== Examples
  #
  #   # For the Post with id #1, reset the comments_count
  #   Post.reset_counters(1, :comments)
  #
  #   # Like above, but also touch the +updated_at+ and/or +updated_on+
  #   # attributes.
  #   Post.reset_counters(1, :comments, touch: true)
  #
  # source://activerecord//lib/active_record/counter_cache.rb#33
  def reset_counters(id, *counters, touch: T.unsafe(nil)); end

  # A generic "counter updater" implementation, intended primarily to be
  # used by #increment_counter and #decrement_counter, but which may also
  # be useful on its own. It simply does a direct SQL update for the record
  # with the given ID, altering the given hash of counters by the amount
  # given by the corresponding value:
  #
  # ==== Parameters
  #
  # * +id+ - The id of the object you wish to update a counter on or an array of ids.
  # * +counters+ - A Hash containing the names of the fields
  #   to update as keys and the amount to update the field by as values.
  # * <tt>:touch</tt> option - Touch timestamp columns when updating.
  #   If attribute names are passed, they are updated along with updated_at/on
  #   attributes.
  #
  # ==== Examples
  #
  #   # For the Post with id of 5, decrement the comments_count by 1, and
  #   # increment the actions_count by 1
  #   Post.update_counters 5, comments_count: -1, actions_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comments_count = COALESCE(comments_count, 0) - 1,
  #   #        actions_count = COALESCE(actions_count, 0) + 1
  #   #  WHERE id = 5
  #
  #   # For the Posts with id of 10 and 15, increment the comments_count by 1
  #   Post.update_counters [10, 15], comments_count: 1
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comments_count = COALESCE(comments_count, 0) + 1
  #   #  WHERE id IN (10, 15)
  #
  #   # For the Posts with id of 10 and 15, increment the comments_count by 1
  #   # and update the updated_at value for each counter.
  #   Post.update_counters [10, 15], comments_count: 1, touch: true
  #   # Executes the following SQL:
  #   # UPDATE posts
  #   #    SET comments_count = COALESCE(comments_count, 0) + 1,
  #   #    `updated_at` = '2016-10-13T09:59:23-05:00'
  #   #  WHERE id IN (10, 15)
  #
  # source://activerecord//lib/active_record/counter_cache.rb#114
  def update_counters(id, counters); end
end

# Raised when attribute has a name reserved by Active Record (when attribute
# has name of one of Active Record instance methods).
#
# source://activerecord//lib/active_record/errors.rb#413
class ActiveRecord::DangerousAttributeError < ::ActiveRecord::ActiveRecordError; end

# Raised when creating a database if it exists.
#
# source://activerecord//lib/active_record/errors.rb#336
class ActiveRecord::DatabaseAlreadyExists < ::ActiveRecord::StatementInvalid; end

# = Active Record Database Configurations
#
# +ActiveRecord::DatabaseConfigurations+ returns an array of +DatabaseConfig+
# objects that are constructed from the application's database
# configuration hash or URL string.
#
# The array of +DatabaseConfig+ objects in an application default to either a
# HashConfig or UrlConfig. You can retrieve your application's config by using
# ActiveRecord::Base.configurations.
#
# If you register a custom handler, objects will be created according to the
# conditions of the handler. See ::register_db_config_handler for more on
# registering custom handlers.
#
# source://activerecord//lib/active_record/database_configurations/database_config.rb#4
class ActiveRecord::DatabaseConfigurations
  # @return [DatabaseConfigurations] a new instance of DatabaseConfigurations
  #
  # source://activerecord//lib/active_record/database_configurations.rb#73
  def initialize(configurations = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/database_configurations.rb#27
  def any?(*_arg0, **_arg1, &_arg2); end

  # Checks if the application's configurations are empty.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations.rb#150
  def blank?; end

  # Collects the configs for the environment and optionally the specification
  # name passed in. To include replica configurations pass <tt>include_hidden: true</tt>.
  #
  # If a name is provided a single +DatabaseConfig+ object will be
  # returned, otherwise an array of +DatabaseConfig+ objects will be
  # returned that corresponds with the environment and type requested.
  #
  # ==== Options
  #
  # * <tt>env_name:</tt> The environment name. Defaults to +nil+ which will collect
  #   configs for all environments.
  # * <tt>name:</tt> The db config name (i.e. primary, animals, etc.). Defaults
  #   to +nil+. If no +env_name+ is specified the config for the default env and the
  #   passed +name+ will be returned.
  # * <tt>config_key:</tt> Selects configs that contain a particular key in the configuration
  #   hash. Useful for selecting configs that use a custom db config handler or finding
  #   configs with hashes that contain a particular key.
  # * <tt>include_hidden:</tt> Determines whether to include replicas and configurations
  #   hidden by <tt>database_tasks: false</tt> in the returned list. Most of the time we're only
  #   iterating over the primary connections (i.e. migrations don't need to run for the
  #   write and read connection). Defaults to +false+.
  #
  # source://activerecord//lib/active_record/database_configurations.rb#98
  def configs_for(env_name: T.unsafe(nil), name: T.unsafe(nil), config_key: T.unsafe(nil), include_hidden: T.unsafe(nil)); end

  # Returns the value of attribute configurations.
  #
  # source://activerecord//lib/active_record/database_configurations.rb#26
  def configurations; end

  # Checks if the application's configurations are empty.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations.rb#150
  def empty?; end

  # Returns a single +DatabaseConfig+ object based on the requested environment.
  #
  # If the application has multiple databases +find_db_config+ will return
  # the first +DatabaseConfig+ for the environment.
  #
  # source://activerecord//lib/active_record/database_configurations.rb#127
  def find_db_config(env); end

  # A primary configuration is one that is named primary or if there is
  # no primary, the first configuration for an environment will be treated
  # as primary. This is used as the "default" configuration and is used
  # when the application needs to treat one configuration differently. For
  # example, when Rails dumps the schema, the primary configuration's schema
  # file will be named `schema.rb` instead of `primary_schema.rb`.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations.rb#142
  def primary?(name); end

  # Returns fully resolved connection, accepts hash, string or symbol.
  # Always returns a DatabaseConfiguration::DatabaseConfig
  #
  # == Examples
  #
  # Symbol representing current environment.
  #
  #   DatabaseConfigurations.new("production" => {}).resolve(:production)
  #   # => DatabaseConfigurations::HashConfig.new(env_name: "production", config: {})
  #
  # One layer deep hash of connection values.
  #
  #   DatabaseConfigurations.new({}).resolve("adapter" => "sqlite3")
  #   # => DatabaseConfigurations::HashConfig.new(config: {"adapter" => "sqlite3"})
  #
  # Connection URL.
  #
  #   DatabaseConfigurations.new({}).resolve("postgresql://localhost/foo")
  #   # => DatabaseConfigurations::UrlConfig.new(config: {"adapter" => "postgresql", "host" => "localhost", "database" => "foo"})
  #
  # source://activerecord//lib/active_record/database_configurations.rb#174
  def resolve(config); end

  private

  # source://activerecord//lib/active_record/database_configurations.rb#200
  def build_configs(configs); end

  # source://activerecord//lib/active_record/database_configurations.rb#239
  def build_configuration_sentence; end

  # source://activerecord//lib/active_record/database_configurations.rb#273
  def build_db_config_from_hash(env_name, name, config); end

  # source://activerecord//lib/active_record/database_configurations.rb#252
  def build_db_config_from_raw_config(env_name, name, config); end

  # source://activerecord//lib/active_record/database_configurations.rb#263
  def build_db_config_from_string(env_name, name, config); end

  # source://activerecord//lib/active_record/database_configurations.rb#188
  def default_env; end

  # source://activerecord//lib/active_record/database_configurations.rb#192
  def env_with_configs(env = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/database_configurations.rb#295
  def environment_url_config(env, name, config); end

  # source://activerecord//lib/active_record/database_configurations.rb#302
  def environment_value_for(name); end

  # source://activerecord//lib/active_record/database_configurations.rb#286
  def merge_db_environment_variables(current_env, configs); end

  # source://activerecord//lib/active_record/database_configurations.rb#225
  def resolve_symbol_connection(name); end

  # source://activerecord//lib/active_record/database_configurations.rb#219
  def walk_configs(env_name, config); end

  class << self
    # source://activerecord//lib/active_record/database_configurations.rb#29
    def db_config_handlers; end

    # source://activerecord//lib/active_record/database_configurations.rb#29
    def db_config_handlers=(_arg0); end

    # Allows an application to register a custom handler for database configuration
    # objects. This is useful for creating a custom handler that responds to
    # methods your application needs but Active Record doesn't implement. For
    # example if you are using Vitess, you may want your Vitess configurations
    # to respond to `sharded?`. To implement this define the following in an
    # initializer:
    #
    #   ActiveRecord::DatabaseConfigurations.register_db_config_handler do |env_name, name, url, config|
    #     next unless config.key?(:vitess)
    #     VitessConfig.new(env_name, name, config)
    #   end
    #
    # Note: applications must handle the condition in which custom config should be
    # created in your handler registration otherwise all objects will use the custom
    # handler.
    #
    # Then define your +VitessConfig+ to respond to the methods your application
    # needs. It is recommended that you inherit from one of the existing
    # database config classes to avoid having to reimplement all methods. Custom
    # config handlers should only implement methods Active Record does not.
    #
    #   class VitessConfig < ActiveRecord::DatabaseConfigurations::UrlConfig
    #     def sharded?
    #       configuration_hash.fetch("sharded", false)
    #     end
    #   end
    #
    # For configs that have a +:vitess+ key, a +VitessConfig+ object will be
    # created instead of a +UrlConfig+.
    #
    # source://activerecord//lib/active_record/database_configurations.rb#61
    def register_db_config_handler(&block); end
  end
end

# Expands a connection string into a hash.
#
# source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#10
class ActiveRecord::DatabaseConfigurations::ConnectionUrlResolver
  # == Example
  #
  #   url = "postgresql://foo:bar@localhost:9000/foo_test?pool=5&timeout=3000"
  #   ConnectionUrlResolver.new(url).to_hash
  #   # => {
  #     adapter:  "postgresql",
  #     host:     "localhost",
  #     port:     9000,
  #     database: "foo_test",
  #     username: "foo",
  #     password: "bar",
  #     pool:     "5",
  #     timeout:  "3000"
  #   }
  #
  # @return [ConnectionUrlResolver] a new instance of ConnectionUrlResolver
  #
  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#25
  def initialize(url); end

  # Converts the given URL to a full connection hash.
  #
  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#39
  def to_hash; end

  private

  # Returns name of the database.
  #
  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#84
  def database_from_path; end

  # Converts the query parameters of the URI into a hash.
  #
  #   "localhost?pool=5&reaping_frequency=2"
  #   # => { pool: "5", reaping_frequency: "2" }
  #
  # returns empty hash if no query present.
  #
  #   "localhost"
  #   # => {}
  #
  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#61
  def query_hash; end

  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#65
  def raw_config; end

  # Returns the value of attribute uri.
  #
  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#46
  def uri; end

  # source://activerecord//lib/active_record/database_configurations/connection_url_resolver.rb#48
  def uri_parser; end
end

# ActiveRecord::Base.configurations will return either a HashConfig or
# UrlConfig respectively. It will never return a +DatabaseConfig+ object,
# as this is the parent class for the types of database configuration objects.
#
# source://activerecord//lib/active_record/database_configurations/database_config.rb#8
class ActiveRecord::DatabaseConfigurations::DatabaseConfig
  # @return [DatabaseConfig] a new instance of DatabaseConfig
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#11
  def initialize(env_name, name); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#32
  def _database=(database); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#36
  def adapter; end

  # source://activerecord//lib/active_record/database_configurations/database_config.rb#20
  def adapter_class_method; end

  # source://activerecord//lib/active_record/database_configurations/database_config.rb#16
  def adapter_method; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#60
  def checkout_timeout; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#28
  def database; end

  # source://activerecord//lib/active_record/database_configurations/database_config.rb#9
  def env_name; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#80
  def for_current_env?; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#24
  def host; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#68
  def idle_timeout; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#52
  def max_queue; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#48
  def max_threads; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#76
  def migrations_paths; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#44
  def min_threads; end

  # source://activerecord//lib/active_record/database_configurations/database_config.rb#9
  def name; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#40
  def pool; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#56
  def query_cache; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#64
  def reaping_frequency; end

  # @raise [NotImplementedError]
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#72
  def replica?; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/database_configurations/database_config.rb#84
  def schema_cache_path; end
end

# = Active Record Database Hash Config
#
# A +HashConfig+ object is created for each database configuration entry that
# is created from a hash.
#
# A hash config:
#
#   { "development" => { "database" => "db_name" } }
#
# Becomes:
#
#   #<ActiveRecord::DatabaseConfigurations::HashConfig:0x00007fd1acbded10
#     @env_name="development", @name="primary", @config={database: "db_name"}>
#
# See ActiveRecord::DatabaseConfigurations for more info.
#
# source://activerecord//lib/active_record/database_configurations/hash_config.rb#20
class ActiveRecord::DatabaseConfigurations::HashConfig < ::ActiveRecord::DatabaseConfigurations::DatabaseConfig
  # Initialize a new +HashConfig+ object
  #
  # ==== Options
  #
  # * <tt>:env_name</tt> - The \Rails environment, i.e. "development".
  # * <tt>:name</tt> - The db config name. In a standard two-tier
  #   database configuration this will default to "primary". In a multiple
  #   database three-tier database configuration this corresponds to the name
  #   used in the second tier, for example "primary_readonly".
  # * <tt>:config</tt> - The config hash. This is the hash that contains the
  #   database adapter, name, and other important information for database
  #   connections.
  #
  # @return [HashConfig] a new instance of HashConfig
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#36
  def initialize(env_name, name, configuration_hash); end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#67
  def _database=(database); end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#106
  def adapter; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#91
  def checkout_timeout; end

  # Returns the value of attribute configuration_hash.
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#21
  def configuration_hash; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#63
  def database; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#149
  def database_tasks?; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#117
  def default_schema_cache_path; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#55
  def host; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#101
  def idle_timeout; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#121
  def lazy_schema_cache_path; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#87
  def max_queue; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#79
  def max_threads; end

  # The migrations paths for a database configuration. If the
  # +migrations_paths+ key is present in the config, +migrations_paths+
  # will return its value.
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#51
  def migrations_paths; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#75
  def min_threads; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#71
  def pool; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#125
  def primary?; end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#83
  def query_cache; end

  # +reaping_frequency+ is configurable mostly for historical reasons, but it could
  # also be useful if someone wants a very low +idle_timeout+.
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#97
  def reaping_frequency; end

  # Determines whether a database configuration is for a replica / readonly
  # connection. If the +replica+ key is present in the config, +replica?+ will
  # return +true+.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#44
  def replica?; end

  # The path to the schema cache dump file for a database.
  # If omitted, the filename will be read from ENV or a
  # default will be derived.
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#113
  def schema_cache_path; end

  # Determines whether to dump the schema/structure files and the
  # filename that should be used.
  #
  # If +configuration_hash[:schema_dump]+ is set to +false+ or +nil+
  # the schema will not be dumped.
  #
  # If the config option is set that will be used. Otherwise \Rails
  # will generate the filename from the database config name.
  #
  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#137
  def schema_dump(format = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#59
  def socket; end

  private

  # source://activerecord//lib/active_record/database_configurations/hash_config.rb#154
  def schema_file_type(format); end
end

# source://activerecord//lib/active_record/database_configurations.rb#24
class ActiveRecord::DatabaseConfigurations::InvalidConfigurationError < ::StandardError; end

# = Active Record Database Url Config
#
# A +UrlConfig+ object is created for each database configuration
# entry that is created from a URL. This can either be a URL string
# or a hash with a URL in place of the config hash.
#
# A URL config:
#
#   postgres://localhost/foo
#
# Becomes:
#
#   #<ActiveRecord::DatabaseConfigurations::UrlConfig:0x00007fdc3238f340
#     @env_name="default_env", @name="primary",
#     @config={adapter: "postgresql", database: "foo", host: "localhost"},
#     @url="postgres://localhost/foo">
#
# See ActiveRecord::DatabaseConfigurations for more info.
#
# source://activerecord//lib/active_record/database_configurations/url_config.rb#24
class ActiveRecord::DatabaseConfigurations::UrlConfig < ::ActiveRecord::DatabaseConfigurations::HashConfig
  # Initialize a new +UrlConfig+ object
  #
  # ==== Options
  #
  # * <tt>:env_name</tt> - The \Rails environment, i.e. "development".
  # * <tt>:name</tt> - The db config name. In a standard two-tier
  #   database configuration this will default to "primary". In a multiple
  #   database three-tier database configuration this corresponds to the name
  #   used in the second tier, for example "primary_readonly".
  # * <tt>:url</tt> - The database URL.
  # * <tt>:config</tt> - The config hash. This is the hash that contains the
  #   database adapter, name, and other important information for database
  #   connections.
  #
  # @return [UrlConfig] a new instance of UrlConfig
  #
  # source://activerecord//lib/active_record/database_configurations/url_config.rb#40
  def initialize(env_name, name, url, configuration_hash = T.unsafe(nil)); end

  # Returns the value of attribute url.
  #
  # source://activerecord//lib/active_record/database_configurations/url_config.rb#25
  def url; end

  private

  # Return a Hash that can be merged into the main config that represents
  # the passed in url
  #
  # source://activerecord//lib/active_record/database_configurations/url_config.rb#50
  def build_url_hash; end
end

# Raised when connection to the database could not been established because it was not
# able to connect to the host or when the authorization failed.
#
# source://activerecord//lib/active_record/errors.rb#93
class ActiveRecord::DatabaseConnectionError < ::ActiveRecord::ConnectionNotEstablished
  # @return [DatabaseConnectionError] a new instance of DatabaseConnectionError
  #
  # source://activerecord//lib/active_record/errors.rb#94
  def initialize(message = T.unsafe(nil)); end

  class << self
    # source://activerecord//lib/active_record/errors.rb#99
    def hostname_error(hostname); end

    # source://activerecord//lib/active_record/errors.rb#106
    def username_error(username); end
  end
end

# Deadlocked will be raised when a transaction is rolled
# back by the database when a deadlock is encountered.
#
# This is a subclass of TransactionRollbackError, please make sure to check
# its documentation to be aware of its caveats.
#
# source://activerecord//lib/active_record/errors.rb#525
class ActiveRecord::Deadlocked < ::ActiveRecord::TransactionRollbackError; end

# = Delegated types
#
# Class hierarchies can map to relational database tables in many ways. Active Record, for example, offers
# purely abstract classes, where the superclass doesn't persist any attributes, and single-table inheritance,
# where all attributes from all levels of the hierarchy are represented in a single table. Both have their
# places, but neither are without their drawbacks.
#
# The problem with purely abstract classes is that all concrete subclasses must persist all the shared
# attributes themselves in their own tables (also known as class-table inheritance). This makes it hard to
# do queries across the hierarchy. For example, imagine you have the following hierarchy:
#
#   Entry < ApplicationRecord
#   Message < Entry
#   Comment < Entry
#
# How do you show a feed that has both +Message+ and +Comment+ records, which can be easily paginated?
# Well, you can't! Messages are backed by a messages table and comments by a comments table. You can't
# pull from both tables at once and use a consistent OFFSET/LIMIT scheme.
#
# You can get around the pagination problem by using single-table inheritance, but now you're forced into
# a single mega table with all the attributes from all subclasses. No matter how divergent. If a Message
# has a subject, but the comment does not, well, now the comment does anyway! So STI works best when there's
# little divergence between the subclasses and their attributes.
#
# But there's a third way: Delegated types. With this approach, the "superclass" is a concrete class
# that is represented by its own table, where all the superclass attributes that are shared amongst all the
# "subclasses" are stored. And then each of the subclasses have their own individual tables for additional
# attributes that are particular to their implementation. This is similar to what's called multi-table
# inheritance in Django, but instead of actual inheritance, this approach uses delegation to form the
# hierarchy and share responsibilities.
#
# Let's look at that entry/message/comment example using delegated types:
#
#   # Schema: entries[ id, account_id, creator_id, created_at, updated_at, entryable_type, entryable_id ]
#   class Entry < ApplicationRecord
#     belongs_to :account
#     belongs_to :creator
#     delegated_type :entryable, types: %w[ Message Comment ]
#   end
#
#   module Entryable
#     extend ActiveSupport::Concern
#
#     included do
#       has_one :entry, as: :entryable, touch: true
#     end
#   end
#
#   # Schema: messages[ id, subject, body ]
#   class Message < ApplicationRecord
#     include Entryable
#   end
#
#   # Schema: comments[ id, content ]
#   class Comment < ApplicationRecord
#     include Entryable
#   end
#
# As you can see, neither +Message+ nor +Comment+ are meant to stand alone. Crucial metadata for both classes
# resides in the +Entry+ "superclass". But the +Entry+ absolutely can stand alone in terms of querying capacity
# in particular. You can now easily do things like:
#
#   Account.find(1).entries.order(created_at: :desc).limit(50)
#
# Which is exactly what you want when displaying both comments and messages together. The entry itself can
# be rendered as its delegated type easily, like so:
#
#   # entries/_entry.html.erb
#   <%= render "entries/entryables/#{entry.entryable_name}", entry: entry %>
#
#   # entries/entryables/_message.html.erb
#   <div class="message">
#     <div class="subject"><%= entry.message.subject %></div>
#     <p><%= entry.message.body %></p>
#     <i>Posted on <%= entry.created_at %> by <%= entry.creator.name %></i>
#   </div>
#
#   # entries/entryables/_comment.html.erb
#   <div class="comment">
#     <%= entry.creator.name %> said: <%= entry.comment.content %>
#   </div>
#
# == Sharing behavior with concerns and controllers
#
# The entry "superclass" also serves as a perfect place to put all that shared logic that applies to both
# messages and comments, and which acts primarily on the shared attributes. Imagine:
#
#   class Entry < ApplicationRecord
#     include Eventable, Forwardable, Redeliverable
#   end
#
# Which allows you to have controllers for things like +ForwardsController+ and +RedeliverableController+
# that both act on entries, and thus provide the shared functionality to both messages and comments.
#
# == Creating new records
#
# You create a new record that uses delegated typing by creating the delegator and delegatee at the same time,
# like so:
#
#   Entry.create! entryable: Comment.new(content: "Hello!"), creator: Current.user
#
# If you need more complicated composition, or you need to perform dependent validation, you should build a factory
# method or class to take care of the complicated needs. This could be as simple as:
#
#   class Entry < ApplicationRecord
#     def self.create_with_comment(content, creator: Current.user)
#       create! entryable: Comment.new(content: content), creator: creator
#     end
#   end
#
# == Adding further delegation
#
# The delegated type shouldn't just answer the question of what the underlying class is called. In fact, that's
# an anti-pattern most of the time. The reason you're building this hierarchy is to take advantage of polymorphism.
# So here's a simple example of that:
#
#   class Entry < ApplicationRecord
#     delegated_type :entryable, types: %w[ Message Comment ]
#     delegate :title, to: :entryable
#   end
#
#   class Message < ApplicationRecord
#     def title
#       subject
#     end
#   end
#
#   class Comment < ApplicationRecord
#     def title
#       content.truncate(20)
#     end
#   end
#
# Now you can list a bunch of entries, call <tt>Entry#title</tt>, and polymorphism will provide you with the answer.
#
# == Nested \Attributes
#
# Enabling nested attributes on a delegated_type association allows you to
# create the entry and message in one go:
#
#   class Entry < ApplicationRecord
#     delegated_type :entryable, types: %w[ Message Comment ]
#     accepts_nested_attributes_for :entryable
#   end
#
#   params = { entry: { entryable_type: 'Message', entryable_attributes: { subject: 'Smiling' } } }
#   entry = Entry.create(params[:entry])
#   entry.entryable.id # => 2
#   entry.entryable.subject # => 'Smiling'
#
# source://activerecord//lib/active_record/delegated_type.rb#155
module ActiveRecord::DelegatedType
  # Defines this as a class that'll delegate its type for the passed +role+ to the class references in +types+.
  # That'll create a polymorphic +belongs_to+ relationship to that +role+, and it'll add all the delegated
  # type convenience methods:
  #
  #   class Entry < ApplicationRecord
  #     delegated_type :entryable, types: %w[ Message Comment ], dependent: :destroy
  #   end
  #
  #   Entry#entryable_class # => +Message+ or +Comment+
  #   Entry#entryable_name  # => "message" or "comment"
  #   Entry.messages        # => Entry.where(entryable_type: "Message")
  #   Entry#message?        # => true when entryable_type == "Message"
  #   Entry#message         # => returns the message record, when entryable_type == "Message", otherwise nil
  #   Entry#message_id      # => returns entryable_id, when entryable_type == "Message", otherwise nil
  #   Entry.comments        # => Entry.where(entryable_type: "Comment")
  #   Entry#comment?        # => true when entryable_type == "Comment"
  #   Entry#comment         # => returns the comment record, when entryable_type == "Comment", otherwise nil
  #   Entry#comment_id      # => returns entryable_id, when entryable_type == "Comment", otherwise nil
  #
  # You can also declare namespaced types:
  #
  #   class Entry < ApplicationRecord
  #     delegated_type :entryable, types: %w[ Message Comment Access::NoticeMessage ], dependent: :destroy
  #   end
  #
  #   Entry.access_notice_messages
  #   entry.access_notice_message
  #   entry.access_notice_message?
  #
  # === Options
  #
  # The +options+ are passed directly to the +belongs_to+ call, so this is where you declare +dependent+ etc.
  # The following options can be included to specialize the behavior of the delegated type convenience methods.
  #
  # [:foreign_key]
  #   Specify the foreign key used for the convenience methods. By default this is guessed to be the passed
  #   +role+ with an "_id" suffix. So a class that defines a
  #   <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use "entryable_id" as
  #   the default <tt>:foreign_key</tt>.
  # [:foreign_type]
  #   Specify the column used to store the associated object's type. By default this is inferred to be the passed
  #   +role+ with a "_type" suffix. A class that defines a
  #   <tt>delegated_type :entryable, types: %w[ Message Comment ]</tt> association will use "entryable_type" as
  #   the default <tt>:foreign_type</tt>.
  # [:primary_key]
  #   Specify the method that returns the primary key of associated object used for the convenience methods.
  #   By default this is +id+.
  #
  # Option examples:
  #   class Entry < ApplicationRecord
  #     delegated_type :entryable, types: %w[ Message Comment ], primary_key: :uuid, foreign_key: :entryable_uuid
  #   end
  #
  #   Entry#message_uuid      # => returns entryable_uuid, when entryable_type == "Message", otherwise nil
  #   Entry#comment_uuid      # => returns entryable_uuid, when entryable_type == "Comment", otherwise nil
  #
  # source://activerecord//lib/active_record/delegated_type.rb#211
  def delegated_type(role, types:, **options); end

  private

  # source://activerecord//lib/active_record/delegated_type.rb#217
  def define_delegated_type_methods(role, types:, options:); end
end

# source://activerecord//lib/active_record/relation/delegation.rb#7
module ActiveRecord::Delegation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassMethods

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def &(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def +(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def -(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def [](*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def as_json(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def compact(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#105
  def connection(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def each(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def encode_with(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def in_groups(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def in_groups_of(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def index(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def intersect?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def join(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def length(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#105
  def primary_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def reverse(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def rindex(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def rotate(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def sample(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def shuffle(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def slice(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def split(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def to_formatted_s(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def to_fs(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def to_sentence(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def to_xml(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#105
  def transaction(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/delegation.rb#100
  def |(*_arg0, **_arg1, &_arg2); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/delegation.rb#142
  def respond_to_missing?(method, _); end

  class << self
    # source://activerecord//lib/active_record/relation/delegation.rb#9
    def delegated_classes; end

    # source://activerecord//lib/active_record/relation/delegation.rb#18
    def uncacheable_methods; end
  end
end

# source://activerecord//lib/active_record/relation/delegation.rb#130
module ActiveRecord::Delegation::ClassMethods
  # source://activerecord//lib/active_record/relation/delegation.rb#131
  def create(klass, *args, **kwargs); end

  private

  # source://activerecord//lib/active_record/relation/delegation.rb#136
  def relation_class_for(klass); end
end

# source://activerecord//lib/active_record/relation/delegation.rb#107
module ActiveRecord::Delegation::ClassSpecificRelation
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods

  private

  # source://activerecord//lib/active_record/relation/delegation.rb#117
  def method_missing(method, *args, **_arg2, &block); end
end

# source://activerecord//lib/active_record/relation/delegation.rb#110
module ActiveRecord::Delegation::ClassSpecificRelation::ClassMethods
  # source://activerecord//lib/active_record/relation/delegation.rb#111
  def name; end
end

# source://activerecord//lib/active_record/relation/delegation.rb#25
module ActiveRecord::Delegation::DelegateCache
  # source://activerecord//lib/active_record/relation/delegation.rb#50
  def generate_relation_method(method); end

  # source://activerecord//lib/active_record/relation/delegation.rb#45
  def inherited(child_class); end

  # source://activerecord//lib/active_record/relation/delegation.rb#30
  def initialize_relation_delegate_cache; end

  # source://activerecord//lib/active_record/relation/delegation.rb#26
  def relation_delegate_class(klass); end

  protected

  # source://activerecord//lib/active_record/relation/delegation.rb#55
  def include_relation_methods(delegate); end

  private

  # source://activerecord//lib/active_record/relation/delegation.rb#61
  def generated_relation_methods; end
end

# source://activerecord//lib/active_record/relation/delegation.rb#69
class ActiveRecord::Delegation::GeneratedRelationMethods < ::Module
  include ::Mutex_m

  # source://activerecord//lib/active_record/relation/delegation.rb#72
  def generate_method(method); end

  # source://mutex_m/0.2.0/mutex_m.rb#91
  def lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#81
  def locked?; end

  # source://mutex_m/0.2.0/mutex_m.rb#76
  def synchronize(&block); end

  # source://mutex_m/0.2.0/mutex_m.rb#86
  def try_lock; end

  # source://mutex_m/0.2.0/mutex_m.rb#96
  def unlock; end
end

# This error is raised when trying to destroy a parent instance in N:1 or 1:1 associations
# (has_many, has_one) when there is at least 1 child associated instance.
# ex: if @project.tasks.size > 0, DeleteRestrictionError will be raised when trying to destroy @project
#
# source://activerecord//lib/active_record/associations.rb#256
class ActiveRecord::DeleteRestrictionError < ::ActiveRecord::ActiveRecordError
  # @return [DeleteRestrictionError] a new instance of DeleteRestrictionError
  #
  # source://activerecord//lib/active_record/associations.rb#257
  def initialize(name = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/errors.rb#13
class ActiveRecord::DeprecatedActiveJobRequiredError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/destroy_association_async_job.rb#4
class ActiveRecord::DestroyAssociationAsyncError < ::StandardError; end

# = Active Record Destroy Association Async Job
#
# Job to destroy the records associated with a destroyed record in background.
#
# source://activerecord//lib/active_record/destroy_association_async_job.rb#10
class ActiveRecord::DestroyAssociationAsyncJob < ::ActiveJob::Base
  # source://activerecord//lib/active_record/destroy_association_async_job.rb#15
  def perform(owner_model_name: T.unsafe(nil), owner_id: T.unsafe(nil), association_class: T.unsafe(nil), association_ids: T.unsafe(nil), association_primary_key_column: T.unsafe(nil), ensuring_owner_was_method: T.unsafe(nil)); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/destroy_association_async_job.rb#34
  def owner_destroyed?(owner, ensuring_owner_was_method); end

  class << self
    # source://activejob/7.1.3.2/lib/active_job/queue_name.rb#55
    def queue_name; end

    # source://activesupport/7.1.3.2/lib/active_support/rescuable.rb#15
    def rescue_handlers; end
  end
end

# source://activerecord//lib/active_record/disable_joins_association_relation.rb#4
class ActiveRecord::DisableJoinsAssociationRelation < ::ActiveRecord::Relation
  # @return [DisableJoinsAssociationRelation] a new instance of DisableJoinsAssociationRelation
  #
  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#7
  def initialize(klass, key, ids); end

  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#17
  def first(limit = T.unsafe(nil)); end

  # Returns the value of attribute ids.
  #
  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#5
  def ids; end

  # Returns the value of attribute key.
  #
  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#5
  def key; end

  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#13
  def limit(value); end

  # source://activerecord//lib/active_record/disable_joins_association_relation.rb#25
  def load; end
end

# source://activerecord//lib/active_record/migration.rb#104
class ActiveRecord::DuplicateMigrationNameError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationNameError] a new instance of DuplicateMigrationNameError
  #
  # source://activerecord//lib/active_record/migration.rb#105
  def initialize(name = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/migration.rb#94
class ActiveRecord::DuplicateMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [DuplicateMigrationVersionError] a new instance of DuplicateMigrationVersionError
  #
  # source://activerecord//lib/active_record/migration.rb#95
  def initialize(version = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/dynamic_matchers.rb#4
module ActiveRecord::DynamicMatchers
  private

  # source://activerecord//lib/active_record/dynamic_matchers.rb#15
  def method_missing(name, *arguments, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#6
  def respond_to_missing?(name, _); end
end

# source://activerecord//lib/active_record/dynamic_matchers.rb#93
class ActiveRecord::DynamicMatchers::FindBy < ::ActiveRecord::DynamicMatchers::Method
  # source://activerecord//lib/active_record/dynamic_matchers.rb#100
  def finder; end

  class << self
    # source://activerecord//lib/active_record/dynamic_matchers.rb#96
    def prefix; end
  end
end

# source://activerecord//lib/active_record/dynamic_matchers.rb#105
class ActiveRecord::DynamicMatchers::FindByBang < ::ActiveRecord::DynamicMatchers::Method
  # source://activerecord//lib/active_record/dynamic_matchers.rb#116
  def finder; end

  class << self
    # source://activerecord//lib/active_record/dynamic_matchers.rb#108
    def prefix; end

    # source://activerecord//lib/active_record/dynamic_matchers.rb#112
    def suffix; end
  end
end

# source://activerecord//lib/active_record/dynamic_matchers.rb#26
class ActiveRecord::DynamicMatchers::Method
  # @return [Method] a new instance of Method
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#52
  def initialize(model, method_name); end

  # Returns the value of attribute attribute_names.
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#50
  def attribute_names; end

  # source://activerecord//lib/active_record/dynamic_matchers.rb#63
  def define; end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#50
  def model; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#50
  def name; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#59
  def valid?; end

  private

  # Given that the parameters starts with `_`, the finder needs to use the
  # same parameter name.
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#84
  def attributes_hash; end

  # source://activerecord//lib/active_record/dynamic_matchers.rb#72
  def body; end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#88
  def finder; end

  # The parameters in the signature may have reserved Ruby words, in order
  # to prevent errors, we start each param name with `_`.
  #
  # source://activerecord//lib/active_record/dynamic_matchers.rb#78
  def signature; end

  class << self
    # source://activerecord//lib/active_record/dynamic_matchers.rb#32
    def match(model, name); end

    # Returns the value of attribute matchers.
    #
    # source://activerecord//lib/active_record/dynamic_matchers.rb#30
    def matchers; end

    # source://activerecord//lib/active_record/dynamic_matchers.rb#37
    def pattern; end

    # @raise [NotImplementedError]
    #
    # source://activerecord//lib/active_record/dynamic_matchers.rb#41
    def prefix; end

    # source://activerecord//lib/active_record/dynamic_matchers.rb#45
    def suffix; end
  end
end

# This error is raised when trying to eager load a polymorphic association using a JOIN.
# Eager loading polymorphic associations is only possible with
# {ActiveRecord::Relation#preload}[rdoc-ref:QueryMethods#preload].
#
# source://activerecord//lib/active_record/associations.rb#243
class ActiveRecord::EagerLoadPolymorphicError < ::ActiveRecord::ActiveRecordError
  # @return [EagerLoadPolymorphicError] a new instance of EagerLoadPolymorphicError
  #
  # source://activerecord//lib/active_record/associations.rb#244
  def initialize(reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/encryption.rb#7
module ActiveRecord::Encryption
  include ::ActiveRecord::Encryption::Configurable
  include ::ActiveRecord::Encryption::Contexts
  extend ::ActiveSupport::Autoload
  extend ::ActiveRecord::Encryption::Configurable::ClassMethods
  extend ::ActiveRecord::Encryption::Contexts::ClassMethods

  # source://activerecord//lib/active_record/encryption/configurable.rb#10
  def config; end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#74
  def custom_contexts; end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#116
  def custom_contexts=(obj); end

  # source://activerecord//lib/active_record/encryption/contexts.rb#17
  def default_context; end

  # source://activerecord//lib/active_record/encryption/contexts.rb#17
  def default_context=(val); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#11
  def encrypted_attribute_declaration_listeners; end

  # source://activerecord//lib/active_record/encryption/configurable.rb#11
  def encrypted_attribute_declaration_listeners=(val); end

  class << self
    # source://activerecord//lib/active_record/encryption/configurable.rb#10
    def config; end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def custom_contexts; end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def custom_contexts=(obj); end

    # source://activerecord//lib/active_record/encryption/contexts.rb#17
    def default_context; end

    # source://activerecord//lib/active_record/encryption/contexts.rb#17
    def default_context=(val); end

    # source://activerecord//lib/active_record/encryption.rb#50
    def eager_load!; end

    # source://activerecord//lib/active_record/encryption/configurable.rb#11
    def encrypted_attribute_declaration_listeners; end

    # source://activerecord//lib/active_record/encryption/configurable.rb#11
    def encrypted_attribute_declaration_listeners=(val); end
  end
end

# source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#5
class ActiveRecord::Encryption::AutoFilteredParameters
  # @return [AutoFilteredParameters] a new instance of AutoFilteredParameters
  #
  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#6
  def initialize(app); end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#14
  def enable; end

  private

  # Returns the value of attribute app.
  #
  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#20
  def app; end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#36
  def apply_collected_attributes; end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#53
  def apply_filter(klass, attribute); end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#28
  def attribute_was_declared(klass, attribute); end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#48
  def collect_for_later(klass, attribute); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#44
  def collecting?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#61
  def excluded_from_filter_parameters?(filter_parameter); end

  # source://activerecord//lib/active_record/encryption/auto_filtered_parameters.rb#22
  def install_collecting_hook; end
end

# The algorithm used for encrypting and decrypting +Message+ objects.
#
# It uses AES-256-GCM. It will generate a random IV for non deterministic encryption (default)
# or derive an initialization vector from the encrypted content for deterministic encryption.
#
# See +Cipher::Aes256Gcm+.
#
# source://activerecord//lib/active_record/encryption/cipher.rb#11
class ActiveRecord::Encryption::Cipher
  extend ::ActiveSupport::Autoload

  # Decrypt the provided +Message+.
  #
  # When +key+ is an Array, it will try all the keys raising a
  # +ActiveRecord::Encryption::Errors::Decryption+ if none works.
  #
  # source://activerecord//lib/active_record/encryption/cipher.rb#25
  def decrypt(encrypted_message, key:); end

  # Encrypts the provided text and return an encrypted +Message+.
  #
  # source://activerecord//lib/active_record/encryption/cipher.rb#15
  def encrypt(clean_text, key:, deterministic: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/cipher.rb#35
  def iv_length; end

  # source://activerecord//lib/active_record/encryption/cipher.rb#31
  def key_length; end

  private

  # source://activerecord//lib/active_record/encryption/cipher.rb#48
  def cipher_for(secret, deterministic: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/cipher.rb#40
  def try_to_decrypt_with_each(encrypted_text, keys:); end
end

# A 256-GCM cipher.
#
# By default it will use random initialization vectors. For deterministic encryption, it will use a SHA-256 hash of
# the text to encrypt and the secret.
#
# See +Encryptor+
#
# source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#14
class ActiveRecord::Encryption::Cipher::Aes256Gcm
  # When iv not provided, it will generate a random iv on each encryption operation (default and
  # recommended operation)
  #
  # @return [Aes256Gcm] a new instance of Aes256Gcm
  #
  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#29
  def initialize(secret, deterministic: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#55
  def decrypt(encrypted_message); end

  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#34
  def encrypt(clear_text); end

  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#82
  def inspect; end

  private

  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#95
  def generate_deterministic_iv(clear_text); end

  # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#87
  def generate_iv(cipher, clear_text); end

  class << self
    # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#22
    def iv_length; end

    # source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#18
    def key_length; end
  end
end

# source://activerecord//lib/active_record/encryption/cipher/aes256_gcm.rb#15
ActiveRecord::Encryption::Cipher::Aes256Gcm::CIPHER_TYPE = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/encryption/cipher.rb#12
ActiveRecord::Encryption::Cipher::DEFAULT_ENCODING = T.let(T.unsafe(nil), Encoding)

# Container of configuration options
#
# source://activerecord//lib/active_record/encryption/config.rb#8
class ActiveRecord::Encryption::Config
  # @return [Config] a new instance of Config
  #
  # source://activerecord//lib/active_record/encryption/config.rb#13
  def initialize; end

  # Returns the value of attribute add_to_filter_parameters.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def add_to_filter_parameters; end

  # Sets the attribute add_to_filter_parameters
  #
  # @param value the value to set the attribute add_to_filter_parameters to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def add_to_filter_parameters=(_arg0); end

  # Returns the value of attribute deterministic_key.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#41
  def deterministic_key; end

  # Sets the attribute deterministic_key
  #
  # @param value the value to set the attribute deterministic_key to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def deterministic_key=(_arg0); end

  # Returns the value of attribute encrypt_fixtures.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def encrypt_fixtures; end

  # Sets the attribute encrypt_fixtures
  #
  # @param value the value to set the attribute encrypt_fixtures to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def encrypt_fixtures=(_arg0); end

  # Returns the value of attribute excluded_from_filter_parameters.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def excluded_from_filter_parameters; end

  # Sets the attribute excluded_from_filter_parameters
  #
  # @param value the value to set the attribute excluded_from_filter_parameters to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def excluded_from_filter_parameters=(_arg0); end

  # Returns the value of attribute extend_queries.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def extend_queries; end

  # Sets the attribute extend_queries
  #
  # @param value the value to set the attribute extend_queries to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def extend_queries=(_arg0); end

  # Returns the value of attribute forced_encoding_for_deterministic_encryption.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def forced_encoding_for_deterministic_encryption; end

  # Sets the attribute forced_encoding_for_deterministic_encryption
  #
  # @param value the value to set the attribute forced_encoding_for_deterministic_encryption to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def forced_encoding_for_deterministic_encryption=(_arg0); end

  # source://activerecord//lib/active_record/encryption/config.rb#36
  def has_deterministic_key?; end

  # source://activerecord//lib/active_record/encryption/config.rb#36
  def has_key_derivation_salt?; end

  # source://activerecord//lib/active_record/encryption/config.rb#36
  def has_primary_key?; end

  # Returns the value of attribute hash_digest_class.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def hash_digest_class; end

  # Sets the attribute hash_digest_class
  #
  # @param value the value to set the attribute hash_digest_class to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def hash_digest_class=(_arg0); end

  # Returns the value of attribute key_derivation_salt.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#41
  def key_derivation_salt; end

  # Sets the attribute key_derivation_salt
  #
  # @param value the value to set the attribute key_derivation_salt to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def key_derivation_salt=(_arg0); end

  # Configure previous encryption schemes.
  #
  #   config.active_record.encryption.previous = [ { key_provider: MyOldKeyProvider.new } ]
  #
  # source://activerecord//lib/active_record/encryption/config.rb#20
  def previous=(previous_schemes_properties); end

  # Returns the value of attribute previous_schemes.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def previous_schemes; end

  # Sets the attribute previous_schemes
  #
  # @param value the value to set the attribute previous_schemes to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def previous_schemes=(_arg0); end

  # Returns the value of attribute primary_key.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#41
  def primary_key; end

  # Sets the attribute primary_key
  #
  # @param value the value to set the attribute primary_key to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def primary_key=(_arg0); end

  # Returns the value of attribute store_key_references.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def store_key_references; end

  # Sets the attribute store_key_references
  #
  # @param value the value to set the attribute store_key_references to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def store_key_references=(_arg0); end

  # source://activerecord//lib/active_record/encryption/config.rb#26
  def support_sha1_for_non_deterministic_encryption=(value); end

  # Returns the value of attribute support_unencrypted_data.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def support_unencrypted_data; end

  # Sets the attribute support_unencrypted_data
  #
  # @param value the value to set the attribute support_unencrypted_data to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def support_unencrypted_data=(_arg0); end

  # Returns the value of attribute validate_column_size.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def validate_column_size; end

  # Sets the attribute validate_column_size
  #
  # @param value the value to set the attribute validate_column_size to.
  #
  # source://activerecord//lib/active_record/encryption/config.rb#9
  def validate_column_size=(_arg0); end

  private

  # source://activerecord//lib/active_record/encryption/config.rb#63
  def add_previous_scheme(**properties); end

  # source://activerecord//lib/active_record/encryption/config.rb#48
  def set_defaults; end
end

# Configuration API for ActiveRecord::Encryption
#
# source://activerecord//lib/active_record/encryption/configurable.rb#6
module ActiveRecord::Encryption::Configurable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Encryption::Configurable::ClassMethods
end

# source://activerecord//lib/active_record/encryption/configurable.rb#0
module ActiveRecord::Encryption::Configurable::ClassMethods
  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def cipher(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#20
  def configure(primary_key: T.unsafe(nil), deterministic_key: T.unsafe(nil), key_derivation_salt: T.unsafe(nil), **properties); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#52
  def encrypted_attribute_was_declared(klass, name); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def encryptor(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def frozen_encryption(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def key_generator(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def key_provider(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#17
  def message_serializer(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/configurable.rb#47
  def on_encrypted_attribute_declared(&block); end
end

# An encryption context configures the different entities used to perform encryption:
#
# * A key provider
# * A key generator
# * An encryptor, the facade to encrypt data
# * A cipher, the encryption algorithm
# * A message serializer
#
# source://activerecord//lib/active_record/encryption/context.rb#12
class ActiveRecord::Encryption::Context
  # @return [Context] a new instance of Context
  #
  # source://activerecord//lib/active_record/encryption/context.rb#17
  def initialize; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def cipher; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def cipher=(_arg0); end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def encryptor; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def encryptor=(_arg0); end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def frozen_encryption; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def frozen_encryption=(_arg0); end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def frozen_encryption?; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def key_generator; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def key_generator=(_arg0); end

  # source://activerecord//lib/active_record/encryption/context.rb#24
  def key_provider; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def key_provider=(_arg0); end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def message_serializer; end

  # source://activerecord//lib/active_record/encryption/context.rb#15
  def message_serializer=(_arg0); end

  private

  # source://activerecord//lib/active_record/encryption/context.rb#37
  def build_default_key_provider; end

  # source://activerecord//lib/active_record/encryption/context.rb#29
  def set_defaults; end
end

# source://activerecord//lib/active_record/encryption/context.rb#13
ActiveRecord::Encryption::Context::PROPERTIES = T.let(T.unsafe(nil), Array)

# ActiveRecord::Encryption uses encryption contexts to configure the different entities used to
# encrypt/decrypt at a given moment in time.
#
# By default, the library uses a default encryption context. This is the Context that gets configured
# initially via +config.active_record.encryption+ options. Library users can define nested encryption contexts
# when running blocks of code.
#
# See Context.
#
# source://activerecord//lib/active_record/encryption/contexts.rb#13
module ActiveRecord::Encryption::Contexts
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Encryption::Contexts::ClassMethods
end

# source://activerecord//lib/active_record/encryption/contexts.rb#0
module ActiveRecord::Encryption::Contexts::ClassMethods
  # source://activerecord//lib/active_record/encryption/contexts.rb#62
  def context; end

  # source://activerecord//lib/active_record/encryption/contexts.rb#66
  def current_custom_context; end

  # source://activerecord//lib/active_record/encryption/contexts.rb#57
  def protecting_encrypted_data(&block); end

  # source://activerecord//lib/active_record/encryption/contexts.rb#70
  def reset_default_context; end

  # source://activerecord//lib/active_record/encryption/contexts.rb#33
  def with_encryption_context(properties); end

  # source://activerecord//lib/active_record/encryption/contexts.rb#49
  def without_encryption(&block); end
end

# A KeyProvider that derives keys from passwords.
#
# source://activerecord//lib/active_record/encryption/derived_secret_key_provider.rb#6
class ActiveRecord::Encryption::DerivedSecretKeyProvider < ::ActiveRecord::Encryption::KeyProvider
  # @return [DerivedSecretKeyProvider] a new instance of DerivedSecretKeyProvider
  #
  # source://activerecord//lib/active_record/encryption/derived_secret_key_provider.rb#7
  def initialize(passwords, key_generator: T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/encryption/derived_secret_key_provider.rb#12
  def derive_key_from(password, using: T.unsafe(nil)); end
end

# A KeyProvider that derives keys from passwords.
#
# source://activerecord//lib/active_record/encryption/deterministic_key_provider.rb#6
class ActiveRecord::Encryption::DeterministicKeyProvider < ::ActiveRecord::Encryption::DerivedSecretKeyProvider
  # @raise [ActiveRecord::Encryption::Errors::Configuration]
  # @return [DeterministicKeyProvider] a new instance of DeterministicKeyProvider
  #
  # source://activerecord//lib/active_record/encryption/deterministic_key_provider.rb#7
  def initialize(password); end
end

# This is the concern mixed in Active Record models to make them encryptable. It adds the +encrypts+
# attribute declaration, as well as the API to encrypt and decrypt records.
#
# source://activerecord//lib/active_record/encryption/encryptable_record.rb#7
module ActiveRecord::Encryption::EncryptableRecord
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Encryption::EncryptableRecord::ClassMethods

  # Returns the ciphertext for +attribute_name+.
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#157
  def ciphertext_for(attribute_name); end

  # Decrypts all the encryptable attributes and saves the changes.
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#171
  def decrypt; end

  # Encrypts all the encryptable attributes and saves the changes.
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#166
  def encrypt; end

  # Returns whether a given attribute is encrypted or not.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#146
  def encrypted_attribute?(attribute_name); end

  private

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#178
  def _create_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#214
  def build_decrypt_attribute_assignments; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#208
  def build_encrypt_attribute_assignments; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#223
  def cant_modify_encrypted_attributes_when_frozen; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#193
  def decrypt_attributes; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#187
  def encrypt_attributes; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#204
  def has_encrypted_attributes?; end

  # @raise [ActiveRecord::Encryption::Errors::Configuration]
  #
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#200
  def validate_encryption_allowed; end

  module GeneratedClassMethods
    def encrypted_attributes; end
    def encrypted_attributes=(value); end
    def encrypted_attributes?; end
  end

  module GeneratedInstanceMethods
    def encrypted_attributes; end
    def encrypted_attributes=(value); end
    def encrypted_attributes?; end
  end
end

# source://activerecord//lib/active_record/encryption/encryptable_record.rb#0
module ActiveRecord::Encryption::EncryptableRecord::ClassMethods
  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#58
  def deterministic_encrypted_attributes; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#49
  def encrypts(*names, key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), support_unencrypted_data: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous: T.unsafe(nil), **context_properties); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#65
  def source_attribute_from_preserved_attribute(attribute_name); end

  private

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#132
  def add_length_validation_for_encrypted_columns; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#84
  def encrypt_attribute(name, key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), support_unencrypted_data: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous: T.unsafe(nil), **context_properties); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#78
  def global_previous_schemes_for(scheme); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#126
  def load_schema!; end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#109
  def override_accessors_to_preserve_original(name, original_attribute_name); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#98
  def preserve_original_encrypted(name); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#70
  def scheme_for(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), support_unencrypted_data: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous: T.unsafe(nil), **context_properties); end

  # source://activerecord//lib/active_record/encryption/encryptable_record.rb#138
  def validate_column_size(attribute_name); end
end

# source://activerecord//lib/active_record/encryption/encryptable_record.rb#176
ActiveRecord::Encryption::EncryptableRecord::ORIGINAL_ATTRIBUTE_PREFIX = T.let(T.unsafe(nil), String)

# An ActiveModel::Type::Value that encrypts/decrypts strings of text.
#
# This is the central piece that connects the encryption system with +encrypts+ declarations in the
# model classes. Whenever you declare an attribute as encrypted, it configures an +EncryptedAttributeType+
# for that attribute.
#
# source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#10
class ActiveRecord::Encryption::EncryptedAttributeType < ::ActiveRecord::Type::Text
  include ::ActiveModel::Type::Helpers::Mutable

  # === Options
  #
  # * <tt>:scheme</tt> - A +Scheme+ with the encryption properties for this attribute.
  # * <tt>:cast_type</tt> - A type that will be used to serialize (before encrypting) and deserialize
  #   (after decrypting). ActiveModel::Type::String by default.
  #
  # @return [EncryptedAttributeType] a new instance of EncryptedAttributeType
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#23
  def initialize(scheme:, cast_type: T.unsafe(nil), previous_type: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#16
  def accessor(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#31
  def cast(value); end

  # Returns the value of attribute cast_type.
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#13
  def cast_type; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#51
  def changed_in_place?(raw_old_value, new_value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#35
  def deserialize(value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def deterministic?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def downcase?(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#47
  def encrypted?(value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def fixed?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def key_provider(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def previous_schemes(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#56
  def previous_types; end

  # Returns the value of attribute scheme.
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#13
  def scheme; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#39
  def serialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#61
  def support_unencrypted_data?; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#15
  def with_context(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#74
  def build_previous_types_for(schemes); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#150
  def clean_text_scheme; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#84
  def decrypt(value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#146
  def decryption_options; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#132
  def encrypt(value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#142
  def encryption_options; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#138
  def encryptor; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#110
  def handle_deserialize_error(error, value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#66
  def previous_schemes_including_clean_text; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#80
  def previous_type?; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#70
  def previous_types_without_clean_text; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#126
  def serialize_with_current(value); end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#122
  def serialize_with_oldest(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#118
  def serialize_with_oldest?; end

  # source://activerecord//lib/active_record/encryption/encrypted_attribute_type.rb#102
  def try_to_deserialize_with_previous_encrypted_types(value); end
end

# source://activerecord//lib/active_record/encryption/encrypted_fixtures.rb#5
module ActiveRecord::Encryption::EncryptedFixtures
  # source://activerecord//lib/active_record/encryption/encrypted_fixtures.rb#6
  def initialize(fixture, model_class); end

  private

  # source://activerecord//lib/active_record/encryption/encrypted_fixtures.rb#14
  def encrypt_fixture_data(fixture, model_class); end

  # source://activerecord//lib/active_record/encryption/encrypted_fixtures.rb#26
  def process_preserved_original_columns(fixture, model_class); end
end

# An encryptor that can encrypt data but can't decrypt it.
#
# source://activerecord//lib/active_record/encryption/encrypting_only_encryptor.rb#6
class ActiveRecord::Encryption::EncryptingOnlyEncryptor < ::ActiveRecord::Encryption::Encryptor
  # source://activerecord//lib/active_record/encryption/encrypting_only_encryptor.rb#7
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end
end

# An encryptor exposes the encryption API that ActiveRecord::Encryption::EncryptedAttributeType
# uses for encrypting and decrypting attribute values.
#
# It interacts with a KeyProvider for getting the keys, and delegate to
# ActiveRecord::Encryption::Cipher the actual encryption algorithm.
#
# source://activerecord//lib/active_record/encryption/encryptor.rb#14
class ActiveRecord::Encryption::Encryptor
  # Decrypts a +clean_text+ and returns the result as clean text
  #
  # === Options
  #
  # [:key_provider]
  #   Key provider to use for the encryption operation. It will default to
  #   +ActiveRecord::Encryption.key_provider+ when not provided
  #
  # [:cipher_options]
  #   Cipher-specific options that will be passed to the Cipher configured in
  #   +ActiveRecord::Encryption.cipher+
  #
  # source://activerecord//lib/active_record/encryption/encryptor.rb#52
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # Encrypts +clean_text+ and returns the encrypted result
  #
  # Internally, it will:
  #
  # 1. Create a new ActiveRecord::Encryption::Message
  # 2. Compress and encrypt +clean_text+ as the message payload
  # 3. Serialize it with +ActiveRecord::Encryption.message_serializer+ (+ActiveRecord::Encryption::SafeMarshal+
  #    by default)
  # 4. Encode the result with Base 64
  #
  # === Options
  #
  # [:key_provider]
  #   Key provider to use for the encryption operation. It will default to
  #   +ActiveRecord::Encryption.key_provider+ when not provided.
  #
  # [:cipher_options]
  #   Cipher-specific options that will be passed to the Cipher configured in
  #   +ActiveRecord::Encryption.cipher+
  #
  # source://activerecord//lib/active_record/encryption/encryptor.rb#34
  def encrypt(clear_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # Returns whether the text is encrypted or not
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/encryptor.rb#62
  def encrypted?(text); end

  private

  # source://activerecord//lib/active_record/encryption/encryptor.rb#88
  def build_encrypted_message(clear_text, key_provider:, cipher_options:); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#84
  def cipher; end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#122
  def compress(data); end

  # Under certain threshold, ZIP compression is actually worse that not compressing
  #
  # source://activerecord//lib/active_record/encryption/encryptor.rb#114
  def compress_if_worth_it(string); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#74
  def default_key_provider; end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#102
  def deserialize_message(message); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#142
  def force_encoding_if_needed(value); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#150
  def forced_encoding_for_deterministic_encryption; end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#98
  def serialize_message(message); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#109
  def serializer; end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#136
  def uncompress(data); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#128
  def uncompress_if_needed(data, compressed); end

  # source://activerecord//lib/active_record/encryption/encryptor.rb#78
  def validate_payload_type(clear_text); end
end

# source://activerecord//lib/active_record/encryption/encryptor.rb#70
ActiveRecord::Encryption::Encryptor::DECRYPT_ERRORS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/encryption/encryptor.rb#71
ActiveRecord::Encryption::Encryptor::ENCODING_ERRORS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/encryption/encryptor.rb#72
ActiveRecord::Encryption::Encryptor::THRESHOLD_TO_JUSTIFY_COMPRESSION = T.let(T.unsafe(nil), Integer)

# Implements a simple envelope encryption approach where:
#
# * It generates a random data-encryption key for each encryption operation.
# * It stores the generated key along with the encrypted payload. It encrypts this key
#   with the master key provided in the +active_record_encryption.primary_key+ credential.
#
# This provider can work with multiple master keys. It will use the last one for encrypting.
#
# When +config.active_record.encryption.store_key_references+ is true, it will also store a reference to
# the specific master key that was used to encrypt the data-encryption key. When not set,
# it will try all the configured master keys looking for the right one, in order to
# return the right decryption key.
#
# source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#17
class ActiveRecord::Encryption::EnvelopeEncryptionKeyProvider
  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#31
  def active_primary_key; end

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#26
  def decryption_keys(encrypted_message); end

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#18
  def encryption_key; end

  private

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#40
  def decrypt_data_key(encrypted_message); end

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#36
  def encrypt_data_key(random_secret); end

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#50
  def generate_random_secret; end

  # source://activerecord//lib/active_record/encryption/envelope_encryption_key_provider.rb#46
  def primary_key_provider; end
end

# source://activerecord//lib/active_record/encryption/errors.rb#5
module ActiveRecord::Encryption::Errors; end

# source://activerecord//lib/active_record/encryption/errors.rb#6
class ActiveRecord::Encryption::Errors::Base < ::StandardError; end

# source://activerecord//lib/active_record/encryption/errors.rb#10
class ActiveRecord::Encryption::Errors::Configuration < ::ActiveRecord::Encryption::Errors::Base; end

# source://activerecord//lib/active_record/encryption/errors.rb#8
class ActiveRecord::Encryption::Errors::Decryption < ::ActiveRecord::Encryption::Errors::Base; end

# source://activerecord//lib/active_record/encryption/errors.rb#7
class ActiveRecord::Encryption::Errors::Encoding < ::ActiveRecord::Encryption::Errors::Base; end

# source://activerecord//lib/active_record/encryption/errors.rb#12
class ActiveRecord::Encryption::Errors::EncryptedContentIntegrity < ::ActiveRecord::Encryption::Errors::Base; end

# source://activerecord//lib/active_record/encryption/errors.rb#9
class ActiveRecord::Encryption::Errors::Encryption < ::ActiveRecord::Encryption::Errors::Base; end

# source://activerecord//lib/active_record/encryption/errors.rb#11
class ActiveRecord::Encryption::Errors::ForbiddenClass < ::ActiveRecord::Encryption::Errors::Base; end

# Automatically expand encrypted arguments to support querying both encrypted and unencrypted data
#
# Active Record \Encryption supports querying the db using deterministic attributes. For example:
#
#   Contact.find_by(email_address: "jorge@hey.com")
#
# The value "jorge@hey.com" will get encrypted automatically to perform the query. But there is
# a problem while the data is being encrypted. This won't work. During that time, you need these
# queries to be:
#
#   Contact.find_by(email_address: [ "jorge@hey.com", "<encrypted jorge@hey.com>" ])
#
# This patches ActiveRecord to support this automatically. It addresses both:
#
# * ActiveRecord::Base - Used in <tt>Contact.find_by_email_address(...)</tt>
# * ActiveRecord::Relation - Used in <tt>Contact.internal.find_by_email_address(...)</tt>
#
# This module is included if `config.active_record.encryption.extend_queries` is `true`.
#
# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#23
module ActiveRecord::Encryption::ExtendedDeterministicQueries
  class << self
    # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#24
    def install_support; end
  end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#132
class ActiveRecord::Encryption::ExtendedDeterministicQueries::AdditionalValue
  # @return [AdditionalValue] a new instance of AdditionalValue
  #
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#135
  def initialize(value, type); end

  # Returns the value of attribute type.
  #
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#133
  def type; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#133
  def value; end

  private

  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#141
  def process(value); end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#122
module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#0
module ActiveRecord::Encryption::ExtendedDeterministicQueries::CoreQueries::ClassMethods
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#126
  def find_by(*args); end
end

# When modifying this file run performance tests in
# +activerecord/test/cases/encryption/performance/extended_deterministic_queries_performance_test.rb+
# to make sure performance overhead is acceptable.
#
# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#41
module ActiveRecord::Encryption::ExtendedDeterministicQueries::EncryptedQuery
  class << self
    # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#43
    def process_arguments(owner, args, check_for_additional_values); end

    private

    # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#87
    def additional_values_for(value, type); end

    # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#69
    def process_encrypted_query_argument(value, check_for_additional_values, type); end
  end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#146
module ActiveRecord::Encryption::ExtendedDeterministicQueries::ExtendedEncryptableType
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#147
  def serialize(data); end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#95
module ActiveRecord::Encryption::ExtendedDeterministicQueries::RelationQueries
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#100
  def exists?(*args); end

  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#104
  def scope_for_create; end

  # source://activerecord//lib/active_record/encryption/extended_deterministic_queries.rb#96
  def where(*args); end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_uniqueness_validator.rb#5
module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator
  class << self
    # source://activerecord//lib/active_record/encryption/extended_deterministic_uniqueness_validator.rb#6
    def install_support; end
  end
end

# source://activerecord//lib/active_record/encryption/extended_deterministic_uniqueness_validator.rb#10
module ActiveRecord::Encryption::ExtendedDeterministicUniquenessValidator::EncryptedUniquenessValidator
  # source://activerecord//lib/active_record/encryption/extended_deterministic_uniqueness_validator.rb#11
  def validate_each(record, attribute, value); end
end

# A key is a container for a given +secret+
#
# Optionally, it can include +public_tags+. These tags are meant to be stored
# in clean (public) and can be used, for example, to include information that
# references the key for a future retrieval operation.
#
# source://activerecord//lib/active_record/encryption/key.rb#10
class ActiveRecord::Encryption::Key
  # @return [Key] a new instance of Key
  #
  # source://activerecord//lib/active_record/encryption/key.rb#13
  def initialize(secret); end

  # source://activerecord//lib/active_record/encryption/key.rb#23
  def id; end

  # Returns the value of attribute public_tags.
  #
  # source://activerecord//lib/active_record/encryption/key.rb#11
  def public_tags; end

  # Returns the value of attribute secret.
  #
  # source://activerecord//lib/active_record/encryption/key.rb#11
  def secret; end

  class << self
    # source://activerecord//lib/active_record/encryption/key.rb#18
    def derive_from(password); end
  end
end

# Utility for generating and deriving random keys.
#
# source://activerecord//lib/active_record/encryption/key_generator.rb#8
class ActiveRecord::Encryption::KeyGenerator
  # @return [KeyGenerator] a new instance of KeyGenerator
  #
  # source://activerecord//lib/active_record/encryption/key_generator.rb#11
  def initialize(hash_digest_class: T.unsafe(nil)); end

  # Derives a key from the given password. The key will have a size in bytes of +:length+ (configured +Cipher+'s length
  # by default)
  #
  # The generated key will be salted with the value of +ActiveRecord::Encryption.key_derivation_salt+
  #
  # source://activerecord//lib/active_record/encryption/key_generator.rb#38
  def derive_key_from(password, length: T.unsafe(nil)); end

  # Returns a random key in hexadecimal format. The key will have a size in bytes of +:length+ (configured +Cipher+'s
  # length by default)
  #
  # Hexadecimal format is handy for representing keys as printable text. To maximize the space of characters used, it is
  # good practice including not printable characters. Hexadecimal format ensures that generated keys are representable with
  # plain text
  #
  # To convert back to the original string with the desired length:
  #
  #   [ value ].pack("H*")
  #
  # source://activerecord//lib/active_record/encryption/key_generator.rb#30
  def generate_random_hex_key(length: T.unsafe(nil)); end

  # Returns a random key. The key will have a size in bytes of +:length+ (configured +Cipher+'s length by default)
  #
  # source://activerecord//lib/active_record/encryption/key_generator.rb#16
  def generate_random_key(length: T.unsafe(nil)); end

  # Returns the value of attribute hash_digest_class.
  #
  # source://activerecord//lib/active_record/encryption/key_generator.rb#9
  def hash_digest_class; end

  private

  # source://activerecord//lib/active_record/encryption/key_generator.rb#44
  def key_derivation_salt; end

  # source://activerecord//lib/active_record/encryption/key_generator.rb#48
  def key_length; end
end

# A +KeyProvider+ serves keys:
#
# * An encryption key
# * A list of potential decryption keys. Serving multiple decryption keys supports rotation-schemes
#   where new keys are added but old keys need to continue working
#
# source://activerecord//lib/active_record/encryption/key_provider.rb#10
class ActiveRecord::Encryption::KeyProvider
  # @return [KeyProvider] a new instance of KeyProvider
  #
  # source://activerecord//lib/active_record/encryption/key_provider.rb#11
  def initialize(keys); end

  # Returns the list of decryption keys
  #
  # When the message holds a reference to its encryption key, it will return an array
  # with that key. If not, it will return the list of keys.
  #
  # source://activerecord//lib/active_record/encryption/key_provider.rb#32
  def decryption_keys(encrypted_message); end

  # Returns the first key in the list as the active key to perform encryptions
  #
  # When +ActiveRecord::Encryption.config.store_key_references+ is true, the key will include
  # a public tag referencing the key itself. That key will be stored in the public
  # headers of the encrypted message
  #
  # source://activerecord//lib/active_record/encryption/key_provider.rb#20
  def encryption_key; end

  private

  # source://activerecord//lib/active_record/encryption/key_provider.rb#41
  def keys_grouped_by_id; end
end

# A message defines the structure of the data we store in encrypted attributes. It contains:
#
# * An encrypted payload
# * A list of unencrypted headers
#
# See Encryptor#encrypt
#
# source://activerecord//lib/active_record/encryption/message.rb#11
class ActiveRecord::Encryption::Message
  # @return [Message] a new instance of Message
  #
  # source://activerecord//lib/active_record/encryption/message.rb#14
  def initialize(payload: T.unsafe(nil), headers: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/message.rb#21
  def ==(other_message); end

  # Returns the value of attribute headers.
  #
  # source://activerecord//lib/active_record/encryption/message.rb#12
  def headers; end

  # Sets the attribute headers
  #
  # @param value the value to set the attribute headers to.
  #
  # source://activerecord//lib/active_record/encryption/message.rb#12
  def headers=(_arg0); end

  # Returns the value of attribute payload.
  #
  # source://activerecord//lib/active_record/encryption/message.rb#12
  def payload; end

  # Sets the attribute payload
  #
  # @param value the value to set the attribute payload to.
  #
  # source://activerecord//lib/active_record/encryption/message.rb#12
  def payload=(_arg0); end

  private

  # source://activerecord//lib/active_record/encryption/message.rb#26
  def validate_payload_type(payload); end
end

# A message serializer that serializes +Messages+ with JSON.
#
# The generated structure is pretty simple:
#
#   {
#     p: <payload>,
#     h: {
#       header1: value1,
#       header2: value2,
#       ...
#     }
#   }
#
# Both the payload and the header values are encoded with Base64
# to prevent JSON parsing errors and encoding issues when
# storing the resulting serialized data.
#
# source://activerecord//lib/active_record/encryption/message_serializer.rb#23
class ActiveRecord::Encryption::MessageSerializer
  # @raise [ActiveRecord::Encryption::Errors::ForbiddenClass]
  #
  # source://activerecord//lib/active_record/encryption/message_serializer.rb#31
  def dump(message); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#24
  def load(serialized_content); end

  private

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#81
  def decode_if_needed(value); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#73
  def encode_if_needed(value); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#67
  def headers_to_json(headers); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#60
  def message_to_json(message); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#37
  def parse_message(data, level); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#52
  def parse_properties(headers, level); end

  # source://activerecord//lib/active_record/encryption/message_serializer.rb#42
  def validate_message_data_format(data, level); end
end

# An encryptor that won't decrypt or encrypt. It will just return the passed
# values
#
# source://activerecord//lib/active_record/encryption/null_encryptor.rb#7
class ActiveRecord::Encryption::NullEncryptor
  # source://activerecord//lib/active_record/encryption/null_encryptor.rb#12
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/null_encryptor.rb#8
  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/null_encryptor.rb#16
  def encrypted?(text); end
end

# This is a wrapper for a hash of encryption properties. It is used by
# +Key+ (public tags) and +Message+ (headers).
#
# Since properties are serialized in messages, it is important for storage
# efficiency to keep their keys as short as possible. It defines accessors
# for common properties that will keep these keys very short while exposing
# a readable name.
#
#   message.headers.encrypted_data_key # instead of message.headers[:k]
#
# See +Properties::DEFAULT_PROPERTIES+, Key, Message
#
# source://activerecord//lib/active_record/encryption/properties.rb#16
class ActiveRecord::Encryption::Properties
  # @return [Properties] a new instance of Properties
  #
  # source://activerecord//lib/active_record/encryption/properties.rb#42
  def initialize(initial_properties = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/encryption/properties.rb#20
  def ==(arg); end

  # source://activerecord//lib/active_record/encryption/properties.rb#20
  def [](*_arg0, **_arg1, &_arg2); end

  # Set a value for a given key
  #
  # It will raise an +EncryptedContentIntegrity+ if the value exists
  #
  # @raise [Errors::EncryptedContentIntegrity]
  #
  # source://activerecord//lib/active_record/encryption/properties.rb#50
  def []=(key, value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#62
  def add(other_properties); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def auth_tag; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def auth_tag=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def compressed; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def compressed=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#20
  def each(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def encoding; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def encoding=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def encrypted_data_key; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def encrypted_data_key=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def encrypted_data_key_id; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def encrypted_data_key_id=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#33
  def iv; end

  # source://activerecord//lib/active_record/encryption/properties.rb#37
  def iv=(value); end

  # source://activerecord//lib/active_record/encryption/properties.rb#20
  def key?(*_arg0, **_arg1, &_arg2); end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/delegation.rb#331
  def method_missing(method, *args, **_arg2, &block); end

  # source://activerecord//lib/active_record/encryption/properties.rb#68
  def to_h; end

  # source://activerecord//lib/active_record/encryption/properties.rb#56
  def validate_value_type(value); end

  private

  # Returns the value of attribute data.
  #
  # source://activerecord//lib/active_record/encryption/properties.rb#73
  def data; end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/delegation.rb#323
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/encryption/properties.rb#17
ActiveRecord::Encryption::Properties::ALLOWED_VALUE_CLASSES = T.let(T.unsafe(nil), Array)

# For each entry it generates an accessor exposing the full name
#
# source://activerecord//lib/active_record/encryption/properties.rb#23
ActiveRecord::Encryption::Properties::DEFAULT_PROPERTIES = T.let(T.unsafe(nil), Hash)

# A +NullEncryptor+ that will raise an error when trying to encrypt data
#
# This is useful when you want to reveal ciphertexts for debugging purposes
# and you want to make sure you won't overwrite any encryptable attribute with
# the wrong content.
#
# source://activerecord//lib/active_record/encryption/read_only_null_encryptor.rb#10
class ActiveRecord::Encryption::ReadOnlyNullEncryptor
  # source://activerecord//lib/active_record/encryption/read_only_null_encryptor.rb#15
  def decrypt(encrypted_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # @raise [Errors::Encryption]
  #
  # source://activerecord//lib/active_record/encryption/read_only_null_encryptor.rb#11
  def encrypt(clean_text, key_provider: T.unsafe(nil), cipher_options: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/read_only_null_encryptor.rb#19
  def encrypted?(text); end
end

# A container of attribute encryption options.
#
# It validates and serves attribute encryption options.
#
# See EncryptedAttributeType, Context
#
# source://activerecord//lib/active_record/encryption/scheme.rb#10
class ActiveRecord::Encryption::Scheme
  # @return [Scheme] a new instance of Scheme
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#13
  def initialize(key_provider: T.unsafe(nil), key: T.unsafe(nil), deterministic: T.unsafe(nil), support_unencrypted_data: T.unsafe(nil), downcase: T.unsafe(nil), ignore_case: T.unsafe(nil), previous_schemes: T.unsafe(nil), **context_properties); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#73
  def compatible_with?(other_scheme); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#39
  def deterministic?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#35
  def downcase?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#47
  def fixed?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#31
  def ignore_case?; end

  # source://activerecord//lib/active_record/encryption/scheme.rb#52
  def key_provider; end

  # source://activerecord//lib/active_record/encryption/scheme.rb#56
  def merge(other_scheme); end

  # Returns the value of attribute previous_schemes.
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#11
  def previous_schemes; end

  # Sets the attribute previous_schemes
  #
  # @param value the value to set the attribute previous_schemes to.
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#11
  def previous_schemes=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#43
  def support_unencrypted_data?; end

  # source://activerecord//lib/active_record/encryption/scheme.rb#60
  def to_h; end

  # source://activerecord//lib/active_record/encryption/scheme.rb#65
  def with_context(&block); end

  private

  # source://activerecord//lib/active_record/encryption/scheme.rb#83
  def build_key_provider; end

  # source://activerecord//lib/active_record/encryption/scheme.rb#91
  def default_key_provider; end

  # @raise [Errors::Configuration]
  #
  # source://activerecord//lib/active_record/encryption/scheme.rb#78
  def validate_config!; end
end

# Declare an enum attribute where the values map to integers in the database,
# but can be queried by name. Example:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ]
#   end
#
#   # conversation.update! status: 0
#   conversation.active!
#   conversation.active? # => true
#   conversation.status  # => "active"
#
#   # conversation.update! status: 1
#   conversation.archived!
#   conversation.archived? # => true
#   conversation.status    # => "archived"
#
#   # conversation.status = 1
#   conversation.status = "archived"
#
#   conversation.status = nil
#   conversation.status.nil? # => true
#   conversation.status      # => nil
#
# Scopes based on the allowed values of the enum field will be provided
# as well. With the above example:
#
#   Conversation.active
#   Conversation.not_active
#   Conversation.archived
#   Conversation.not_archived
#
# Of course, you can also query them directly if the scopes don't fit your
# needs:
#
#   Conversation.where(status: [:active, :archived])
#   Conversation.where.not(status: :active)
#
# Defining scopes can be disabled by setting +:scopes+ to +false+.
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], scopes: false
#   end
#
# You can set the default enum value by setting +:default+, like:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], default: :active
#   end
#
#   conversation = Conversation.new
#   conversation.status # => "active"
#
# It's possible to explicitly map the relation between attribute and
# database integer with a hash:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, active: 0, archived: 1
#   end
#
# Finally it's also possible to use a string column to persist the enumerated value.
# Note that this will likely lead to slower database queries:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, active: "active", archived: "archived"
#   end
#
# Note that when an array is used, the implicit mapping from the values to database
# integers is derived from the order the values appear in the array. In the example,
# <tt>:active</tt> is mapped to +0+ as it's the first element, and <tt>:archived</tt>
# is mapped to +1+. In general, the +i+-th element is mapped to <tt>i-1</tt> in the
# database.
#
# Therefore, once a value is added to the enum array, its position in the array must
# be maintained, and new values should only be added to the end of the array. To
# remove unused values, the explicit hash syntax should be used.
#
# In rare circumstances you might need to access the mapping directly.
# The mappings are exposed through a class method with the pluralized attribute
# name, which return the mapping in a ActiveSupport::HashWithIndifferentAccess :
#
#   Conversation.statuses[:active]    # => 0
#   Conversation.statuses["archived"] # => 1
#
# Use that class method when you need to know the ordinal value of an enum.
# For example, you can use that when manually building SQL strings:
#
#   Conversation.where("status <> ?", Conversation.statuses[:archived])
#
# You can use the +:prefix+ or +:suffix+ options when you need to define
# multiple enums with same values. If the passed value is +true+, the methods
# are prefixed/suffixed with the name of the enum. It is also possible to
# supply a custom value:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], suffix: true
#     enum :comments_status, [ :active, :inactive ], prefix: :comments
#   end
#
# With the above example, the bang and predicate methods along with the
# associated scopes are now prefixed and/or suffixed accordingly:
#
#   conversation.active_status!
#   conversation.archived_status? # => false
#
#   conversation.comments_inactive!
#   conversation.comments_active? # => false
#
# If you want to disable the auto-generated methods on the model, you can do
# so by setting the +:instance_methods+ option to false:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], instance_methods: false
#   end
#
# If you want the enum value to be validated before saving, use the option +:validate+:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], validate: true
#   end
#
#   conversation = Conversation.new
#
#   conversation.status = :unknown
#   conversation.valid? # => false
#
#   conversation.status = nil
#   conversation.valid? # => false
#
#   conversation.status = :active
#   conversation.valid? # => true
#
# It is also possible to pass additional validation options:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ], validate: { allow_nil: true }
#   end
#
#   conversation = Conversation.new
#
#   conversation.status = :unknown
#   conversation.valid? # => false
#
#   conversation.status = nil
#   conversation.valid? # => true
#
#   conversation.status = :active
#   conversation.valid? # => true
#
# Otherwise +ArgumentError+ will raise:
#
#   class Conversation < ActiveRecord::Base
#     enum :status, [ :active, :archived ]
#   end
#
#   conversation = Conversation.new
#
#   conversation.status = :unknown # 'unknown' is not a valid status (ArgumentError)
#
# source://activerecord//lib/active_record/enum.rb#165
module ActiveRecord::Enum
  # source://activerecord//lib/active_record/enum.rb#216
  def enum(name = T.unsafe(nil), values = T.unsafe(nil), **options); end

  private

  # source://activerecord//lib/active_record/enum.rb#234
  def _enum(name, values, prefix: T.unsafe(nil), suffix: T.unsafe(nil), scopes: T.unsafe(nil), instance_methods: T.unsafe(nil), validate: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/enum.rb#329
  def _enum_methods_module; end

  # source://activerecord//lib/active_record/enum.rb#337
  def assert_valid_enum_definition_values(values); end

  # source://activerecord//lib/active_record/enum.rb#370
  def detect_enum_conflict!(enum_name, method_name, klass_method = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/enum.rb#394
  def detect_negative_enum_conditions!(method_names); end

  # source://activerecord//lib/active_record/enum.rb#229
  def inherited(base); end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/enum.rb#384
  def raise_conflict_error(enum_name, method_name, type: T.unsafe(nil), source: T.unsafe(nil)); end

  class << self
    # source://activerecord//lib/active_record/enum.rb#166
    def extended(base); end
  end
end

# source://activerecord//lib/active_record/enum.rb#364
ActiveRecord::Enum::ENUM_CONFLICT_MESSAGE = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/enum.rb#297
class ActiveRecord::Enum::EnumMethods < ::Module
  # @return [EnumMethods] a new instance of EnumMethods
  #
  # source://activerecord//lib/active_record/enum.rb#298
  def initialize(klass); end

  private

  # source://activerecord//lib/active_record/enum.rb#305
  def define_enum_methods(name, value_method_name, value, scopes, instance_methods); end

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/enum.rb#303
  def klass; end
end

# source://activerecord//lib/active_record/enum.rb#170
class ActiveRecord::Enum::EnumType < ::ActiveModel::Type::Value
  # @return [EnumType] a new instance of EnumType
  #
  # source://activerecord//lib/active_record/enum.rb#173
  def initialize(name, mapping, subtype, raise_on_invalid_values: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/enum.rb#202
  def assert_valid_value(value); end

  # source://activerecord//lib/active_record/enum.rb#180
  def cast(value); end

  # source://activerecord//lib/active_record/enum.rb#190
  def deserialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/enum.rb#198
  def serializable?(value, &block); end

  # source://activerecord//lib/active_record/enum.rb#194
  def serialize(value); end

  # Returns the value of attribute subtype.
  #
  # source://activerecord//lib/active_record/enum.rb#210
  def subtype; end

  # source://activerecord//lib/active_record/enum.rb#171
  def type(*_arg0, **_arg1, &_arg2); end

  private

  # Returns the value of attribute mapping.
  #
  # source://activerecord//lib/active_record/enum.rb#213
  def mapping; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/enum.rb#213
  def name; end
end

# source://activerecord//lib/active_record/migration.rb#204
class ActiveRecord::EnvironmentMismatchError < ::ActiveRecord::ActiveRecordError
  # @return [EnvironmentMismatchError] a new instance of EnvironmentMismatchError
  #
  # source://activerecord//lib/active_record/migration.rb#205
  def initialize(current: T.unsafe(nil), stored: T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/migration.rb#218
class ActiveRecord::EnvironmentStorageError < ::ActiveRecord::ActiveRecordError
  # @return [EnvironmentStorageError] a new instance of EnvironmentStorageError
  #
  # source://activerecord//lib/active_record/migration.rb#219
  def initialize; end
end

# Raised when a pool was unable to get ahold of all its connections
# to perform a "group" action such as
# {ActiveRecord::Base.connection_pool.disconnect!}[rdoc-ref:ConnectionAdapters::ConnectionPool#disconnect!]
# or {ActiveRecord::Base.connection_handler.clear_reloadable_connections!}[rdoc-ref:ConnectionAdapters::ConnectionHandler#clear_reloadable_connections!].
#
# source://activerecord//lib/active_record/errors.rb#119
class ActiveRecord::ExclusiveConnectionTimeoutError < ::ActiveRecord::ConnectionTimeoutError; end

# source://activerecord//lib/active_record/explain.rb#6
module ActiveRecord::Explain
  # Executes the block with the collect flag enabled. Queries are collected
  # asynchronously by the subscriber and returned.
  #
  # source://activerecord//lib/active_record/explain.rb#9
  def collecting_queries_for_explain; end

  # Makes the adapter execute EXPLAIN for the tuples of queries and bindings.
  # Returns a formatted string ready to be logged.
  #
  # source://activerecord//lib/active_record/explain.rb#19
  def exec_explain(queries, options = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/explain.rb#54
  def build_explain_clause(options = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/explain.rb#62
  def connection_explain(sql, binds, options); end

  # source://activerecord//lib/active_record/explain.rb#39
  def render_bind(attr); end
end

# This is a thread locals registry for EXPLAIN. For example
#
#   ActiveRecord::ExplainRegistry.queries
#
# returns the collected queries local to the current thread.
#
# source://activerecord//lib/active_record/explain_registry.rb#11
class ActiveRecord::ExplainRegistry
  # @return [ExplainRegistry] a new instance of ExplainRegistry
  #
  # source://activerecord//lib/active_record/explain_registry.rb#24
  def initialize; end

  # Returns the value of attribute collect.
  #
  # source://activerecord//lib/active_record/explain_registry.rb#21
  def collect; end

  # Sets the attribute collect
  #
  # @param value the value to set the attribute collect to.
  #
  # source://activerecord//lib/active_record/explain_registry.rb#21
  def collect=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/explain_registry.rb#28
  def collect?; end

  # Returns the value of attribute queries.
  #
  # source://activerecord//lib/active_record/explain_registry.rb#22
  def queries; end

  # source://activerecord//lib/active_record/explain_registry.rb#32
  def reset; end

  class << self
    # source://activerecord//lib/active_record/explain_registry.rb#13
    def collect(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/explain_registry.rb#13
    def collect=(arg); end

    # source://activerecord//lib/active_record/explain_registry.rb#13
    def collect?(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/explain_registry.rb#13
    def queries(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/explain_registry.rb#13
    def reset(*_arg0, **_arg1, &_arg2); end

    private

    # source://activerecord//lib/active_record/explain_registry.rb#16
    def instance; end
  end
end

# source://activerecord//lib/active_record/explain_subscriber.rb#7
class ActiveRecord::ExplainSubscriber
  # source://activerecord//lib/active_record/explain_subscriber.rb#12
  def finish(name, id, payload); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/explain_subscriber.rb#25
  def ignore_payload?(payload); end

  # source://activerecord//lib/active_record/explain_subscriber.rb#8
  def start(name, id, payload); end
end

# source://activerecord//lib/active_record/explain_subscriber.rb#24
ActiveRecord::ExplainSubscriber::EXPLAINED_SQLS = T.let(T.unsafe(nil), Regexp)

# SCHEMA queries cannot be EXPLAINed, also we do not want to run EXPLAIN on
# our own EXPLAINs no matter how loopingly beautiful that would be.
#
# On the other hand, we want to monitor the performance of our real database
# queries, not the performance of the access to the query cache.
#
# source://activerecord//lib/active_record/explain_subscriber.rb#23
ActiveRecord::ExplainSubscriber::IGNORED_PAYLOADS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/finder_methods.rb#6
module ActiveRecord::FinderMethods
  # Returns true if a record exists in the table that matches the +id+ or
  # conditions given, or false otherwise. The argument can take six forms:
  #
  # * Integer - Finds the record with this primary key.
  # * String - Finds the record with a primary key corresponding to this
  #   string (such as <tt>'5'</tt>).
  # * Array - Finds the record that matches these +where+-style conditions
  #   (such as <tt>['name LIKE ?', "%#{query}%"]</tt>).
  # * Hash - Finds the record that matches these +where+-style conditions
  #   (such as <tt>{name: 'David'}</tt>).
  # * +false+ - Returns always +false+.
  # * No args - Returns +false+ if the relation is empty, +true+ otherwise.
  #
  # For more information about specifying conditions as a hash or array,
  # see the Conditions section in the introduction to ActiveRecord::Base.
  #
  # Note: You can't pass in a condition as a string (like <tt>name =
  # 'Jamie'</tt>), since it would be sanitized and then queried against
  # the primary key column, like <tt>id = 'name = \'Jamie\''</tt>.
  #
  #   Person.exists?(5)
  #   Person.exists?('5')
  #   Person.exists?(['name LIKE ?', "%#{query}%"])
  #   Person.exists?(id: [1, 4, 8])
  #   Person.exists?(name: 'David')
  #   Person.exists?(false)
  #   Person.exists?
  #   Person.where(name: 'Spartacus', rating: 4).exists?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#349
  def exists?(conditions = T.unsafe(nil)); end

  # Find the fifth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fifth # returns the fifth object fetched by SELECT * FROM people
  #   Person.offset(3).fifth # returns the fifth object from OFFSET 3 (which is OFFSET 7)
  #   Person.where(["user_name = :u", { u: user_name }]).fifth
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#263
  def fifth; end

  # Same as #fifth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#269
  def fifth!; end

  # Find by id - This can either be a specific id (ID), a list of ids (ID, ID, ID), or an array of ids ([ID, ID, ID]).
  # `ID` refers to an "identifier". For models with a single-column primary key, `ID` will be a single value,
  # and for models with a composite primary key, it will be an array of values.
  # If one or more records cannot be found for the requested ids, then ActiveRecord::RecordNotFound will be raised.
  # If the primary key is an integer, find by id coerces its arguments by using +to_i+.
  #
  #   Person.find(1)          # returns the object for ID = 1
  #   Person.find("1")        # returns the object for ID = 1
  #   Person.find("31-sarah") # returns the object for ID = 31
  #   Person.find(1, 2, 6)    # returns an array for objects with IDs in (1, 2, 6)
  #   Person.find([7, 17])    # returns an array for objects with IDs in (7, 17), or with composite primary key [7, 17]
  #   Person.find([1])        # returns an array for the object with ID = 1
  #   Person.where("administrator = 1").order("created_on DESC").find(1)
  #
  # ==== Find a record for a composite primary key model
  #   TravelRoute.primary_key = [:origin, :destination]
  #
  #   TravelRoute.find(["Ottawa", "London"])
  #   => #<TravelRoute origin: "Ottawa", destination: "London">
  #
  #   TravelRoute.find([["Paris", "Montreal"]])
  #   => [#<TravelRoute origin: "Paris", destination: "Montreal">]
  #
  #   TravelRoute.find(["New York", "Las Vegas"], ["New York", "Portland"])
  #   => [
  #        #<TravelRoute origin: "New York", destination: "Las Vegas">,
  #        #<TravelRoute origin: "New York", destination: "Portland">
  #      ]
  #
  #   TravelRoute.find([["Berlin", "London"], ["Barcelona", "Lisbon"]])
  #   => [
  #        #<TravelRoute origin: "Berlin", destination: "London">,
  #        #<TravelRoute origin: "Barcelona", destination: "Lisbon">
  #      ]
  #
  # NOTE: The returned records are in the same order as the ids you provide.
  # If you want the results to be sorted by database, you can use ActiveRecord::QueryMethods#where
  # method and provide an explicit ActiveRecord::QueryMethods#order option.
  # But ActiveRecord::QueryMethods#where method doesn't raise ActiveRecord::RecordNotFound.
  #
  # ==== Find with lock
  #
  # Example for find with a lock: Imagine two concurrent transactions:
  # each will read <tt>person.visits == 2</tt>, add 1 to it, and save, resulting
  # in two saves of <tt>person.visits = 3</tt>. By locking the row, the second
  # transaction has to wait until the first is finished; we get the
  # expected <tt>person.visits == 4</tt>.
  #
  #   Person.transaction do
  #     person = Person.lock(true).find(1)
  #     person.visits += 1
  #     person.save!
  #   end
  #
  # ==== Variations of #find
  #
  #   Person.where(name: 'Spartacus', rating: 4)
  #   # returns a chainable list (which can be empty).
  #
  #   Person.find_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or nil.
  #
  #   Person.find_or_initialize_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or returns a new instance (requires you call .save to persist against the database).
  #
  #   Person.find_or_create_by(name: 'Spartacus', rating: 4)
  #   # returns the first item or creates it and returns it.
  #
  # ==== Alternatives for #find
  #
  #   Person.where(name: 'Spartacus', rating: 4).exists?(conditions = :none)
  #   # returns a boolean indicating if any record with the given conditions exist.
  #
  #   Person.where(name: 'Spartacus', rating: 4).select("field1, field2, field3")
  #   # returns a chainable list of instances with only the mentioned fields.
  #
  #   Person.where(name: 'Spartacus', rating: 4).ids
  #   # returns an Array of ids.
  #
  #   Person.where(name: 'Spartacus', rating: 4).pluck(:field1, :field2)
  #   # returns an Array of the required fields.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#90
  def find(*args); end

  # Finds the first record matching the specified conditions. There
  # is no implied ordering so if order matters, you should specify it
  # yourself.
  #
  # If no record is found, returns <tt>nil</tt>.
  #
  #   Post.find_by name: 'Spartacus', rating: 4
  #   Post.find_by "published_at < ?", 2.weeks.ago
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#103
  def find_by(arg, *args); end

  # Like #find_by, except that if no record is found, raises
  # an ActiveRecord::RecordNotFound error.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#109
  def find_by!(arg, *args); end

  # Finds the sole matching record. Raises ActiveRecord::RecordNotFound if no
  # record is found. Raises ActiveRecord::SoleRecordExceeded if more than one
  # record is found.
  #
  #   Product.find_sole_by(["price = %?", price])
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#152
  def find_sole_by(arg, *args); end

  # Find the first record (or first N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.first # returns the first object fetched by SELECT * FROM people ORDER BY people.id LIMIT 1
  #   Person.where(["user_name = ?", user_name]).first
  #   Person.where(["user_name = :u", { u: user_name }]).first
  #   Person.order("created_on DESC").offset(5).first
  #   Person.first(3) # returns the first three objects fetched by SELECT * FROM people ORDER BY people.id LIMIT 3
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#165
  def first(limit = T.unsafe(nil)); end

  # Same as #first but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #first! accepts no arguments.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#175
  def first!; end

  # Find the forty-second record. Also known as accessing "the reddit".
  # If no order is defined it will order by primary key.
  #
  #   Person.forty_two # returns the forty-second object fetched by SELECT * FROM people
  #   Person.offset(3).forty_two # returns the forty-second object from OFFSET 3 (which is OFFSET 44)
  #   Person.where(["user_name = :u", { u: user_name }]).forty_two
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#279
  def forty_two; end

  # Same as #forty_two but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#285
  def forty_two!; end

  # Find the fourth record.
  # If no order is defined it will order by primary key.
  #
  #   Person.fourth # returns the fourth object fetched by SELECT * FROM people
  #   Person.offset(3).fourth # returns the fourth object from OFFSET 3 (which is OFFSET 6)
  #   Person.where(["user_name = :u", { u: user_name }]).fourth
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#247
  def fourth; end

  # Same as #fourth but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#253
  def fourth!; end

  # Returns true if the relation contains the given record or false otherwise.
  #
  # No query is performed if the relation is loaded; the given record is
  # compared to the records in memory. If the relation is unloaded, an
  # efficient existence query is performed, as in #exists?.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#377
  def include?(record); end

  # Find the last record (or last N records if a parameter is supplied).
  # If no order is defined it will order by primary key.
  #
  #   Person.last # returns the last object fetched by SELECT * FROM people
  #   Person.where(["user_name = ?", user_name]).last
  #   Person.order("created_on DESC").offset(5).last
  #   Person.last(3) # returns the last three objects fetched by SELECT * FROM people.
  #
  # Take note that in that last case, the results are sorted in ascending order:
  #
  #   [#<Person id:2>, #<Person id:3>, #<Person id:4>]
  #
  # and not:
  #
  #   [#<Person id:4>, #<Person id:3>, #<Person id:2>]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#194
  def last(limit = T.unsafe(nil)); end

  # Same as #last but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #last! accepts no arguments.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#205
  def last!; end

  # Returns true if the relation contains the given record or false otherwise.
  #
  # No query is performed if the relation is loaded; the given record is
  # compared to the records in memory. If the relation is unloaded, an
  # efficient existence query is performed, as in #exists?.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#377
  def member?(record); end

  # This method is called whenever no records are found with either a single
  # id or multiple ids and raises an ActiveRecord::RecordNotFound exception.
  #
  # The error message is different depending on whether a single id or
  # multiple ids are provided. If multiple ids are provided, then the number
  # of results obtained should be provided in the +result_size+ argument and
  # the expected number of results should be provided in the +expected_size+
  # argument.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#405
  def raise_record_not_found_exception!(ids = T.unsafe(nil), result_size = T.unsafe(nil), expected_size = T.unsafe(nil), key = T.unsafe(nil), not_found_ids = T.unsafe(nil)); end

  # Find the second record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second # returns the second object fetched by SELECT * FROM people
  #   Person.offset(3).second # returns the second object from OFFSET 3 (which is OFFSET 4)
  #   Person.where(["user_name = :u", { u: user_name }]).second
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#215
  def second; end

  # Same as #second but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#221
  def second!; end

  # Find the second-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.second_to_last # returns the second-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).second_to_last # returns the second-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).second_to_last
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#311
  def second_to_last; end

  # Same as #second_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#317
  def second_to_last!; end

  # Finds the sole matching record. Raises ActiveRecord::RecordNotFound if no
  # record is found. Raises ActiveRecord::SoleRecordExceeded if more than one
  # record is found.
  #
  #   Product.where(["price = %?", price]).sole
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#135
  def sole; end

  # Gives a record (or N records if a parameter is supplied) without any implied
  # order. The order will depend on the database implementation.
  # If an order is supplied it will be respected.
  #
  #   Person.take # returns an object fetched by SELECT * FROM people LIMIT 1
  #   Person.take(5) # returns 5 objects fetched by SELECT * FROM people LIMIT 5
  #   Person.where(["name LIKE '%?'", name]).take
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#120
  def take(limit = T.unsafe(nil)); end

  # Same as #take but raises ActiveRecord::RecordNotFound if no record
  # is found. Note that #take! accepts no arguments.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#126
  def take!; end

  # Find the third record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third # returns the third object fetched by SELECT * FROM people
  #   Person.offset(3).third # returns the third object from OFFSET 3 (which is OFFSET 5)
  #   Person.where(["user_name = :u", { u: user_name }]).third
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#231
  def third; end

  # Same as #third but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#237
  def third!; end

  # Find the third-to-last record.
  # If no order is defined it will order by primary key.
  #
  #   Person.third_to_last # returns the third-to-last object fetched by SELECT * FROM people
  #   Person.offset(3).third_to_last # returns the third-to-last object from OFFSET 3
  #   Person.where(["user_name = :u", { u: user_name }]).third_to_last
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#295
  def third_to_last; end

  # Same as #third_to_last but raises ActiveRecord::RecordNotFound if no record
  # is found.
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#301
  def third_to_last!; end

  private

  # source://activerecord//lib/active_record/relation/finder_methods.rb#634
  def _order_columns; end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#445
  def apply_join_dependency(eager_loading: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#426
  def construct_relation_for_exists(conditions); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#622
  def find_last(limit); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#584
  def find_nth(index); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#608
  def find_nth_from_last(index); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#589
  def find_nth_with_limit(index, limit); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#506
  def find_one(id); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#527
  def find_some(ids); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#553
  def find_some_ordered(ids); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#568
  def find_take; end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#576
  def find_take_with_limit(limit); end

  # @raise [UnknownPrimaryKey]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#477
  def find_with_ids(*ids); end

  # source://activerecord//lib/active_record/relation/finder_methods.rb#626
  def ordered_relation; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/finder_methods.rb#473
  def using_limitable_reflections?(reflections); end
end

# source://activerecord//lib/active_record/relation/finder_methods.rb#7
ActiveRecord::FinderMethods::ONE_AS_ONE = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/fixtures.rb#802
class ActiveRecord::Fixture
  include ::Enumerable

  # @return [Fixture] a new instance of Fixture
  #
  # source://activerecord//lib/active_record/fixtures.rb#813
  def initialize(fixture, model_class); end

  # source://activerecord//lib/active_record/fixtures.rb#826
  def [](key); end

  # source://activerecord//lib/active_record/fixtures.rb#818
  def class_name; end

  # source://activerecord//lib/active_record/fixtures.rb#822
  def each(&block); end

  # @raise [FixtureClassNotFound]
  #
  # source://activerecord//lib/active_record/fixtures.rb#832
  def find; end

  # Returns the value of attribute fixture.
  #
  # source://activerecord//lib/active_record/fixtures.rb#811
  def fixture; end

  # Returns the value of attribute model_class.
  #
  # source://activerecord//lib/active_record/fixtures.rb#811
  def model_class; end

  # Returns the value of attribute fixture.
  #
  # source://activerecord//lib/active_record/fixtures.rb#811
  def to_hash; end
end

# source://activerecord//lib/active_record/fixtures.rb#805
class ActiveRecord::Fixture::FixtureError < ::StandardError; end

# source://activerecord//lib/active_record/fixtures.rb#808
class ActiveRecord::Fixture::FormatError < ::ActiveRecord::Fixture::FixtureError; end

# source://activerecord//lib/active_record/fixtures.rb#12
class ActiveRecord::FixtureClassNotFound < ::ActiveRecord::ActiveRecordError; end

# = Active Record \Fixtures
#
# \Fixtures are a way of organizing data that you want to test against; in short, sample data.
#
# They are stored in YAML files, one file per model, which are by default placed in either
# <tt><your-rails-app>/test/fixtures/</tt> or in the <tt>test/fixtures</tt>
# folder under any of your application's engines.
#
# The location can also be changed with ActiveSupport::TestCase.fixture_paths=,
# once you have <tt>require "rails/test_help"</tt> in your +test_helper.rb+.
#
# The fixture file ends with the +.yml+ file extension, for example:
# <tt><your-rails-app>/test/fixtures/web_sites.yml</tt>).
#
# The format of a fixture file looks like this:
#
#   rubyonrails:
#     id: 1
#     name: Ruby on Rails
#     url: http://www.rubyonrails.org
#
#   google:
#     id: 2
#     name: Google
#     url: http://www.google.com
#
# This fixture file includes two fixtures. Each YAML fixture (i.e. record) is given a name and
# is followed by an indented list of key/value pairs in the "key: value" format. Records are
# separated by a blank line for your viewing pleasure.
#
# == Ordering
#
# Fixtures by default are unordered. This is because the maps in YAML are unordered.
#
# If you want ordered fixtures, use the omap YAML type.
# See https://yaml.org/type/omap.html for the specification.
#
# You will need ordered fixtures when you have foreign key constraints
# on keys in the same table. This is commonly needed for tree structures.
#
# For example:
#
#    --- !omap
#    - parent:
#        id:         1
#        parent_id:  NULL
#        title:      Parent
#    - child:
#        id:         2
#        parent_id:  1
#        title:      Child
#
# == Using Fixtures in Test Cases
#
# Since fixtures are a testing construct, we use them in our unit and functional tests. There
# are two ways to use the fixtures, but first let's take a look at a sample unit test:
#
#   require "test_helper"
#
#   class WebSiteTest < ActiveSupport::TestCase
#     test "web_site_count" do
#       assert_equal 2, WebSite.count
#     end
#   end
#
# By default, +test_helper.rb+ will load all of your fixtures into your test
# database, so this test will succeed.
#
# The testing environment will automatically load all the fixtures into the database before each
# test. To ensure consistent data, the environment deletes the fixtures before running the load.
#
# In addition to being available in the database, the fixture's data may also be accessed by
# using a special dynamic method, which has the same name as the model.
#
# Passing in a fixture name to this dynamic method returns the fixture matching this name:
#
#   test "find one" do
#     assert_equal "Ruby on Rails", web_sites(:rubyonrails).name
#   end
#
# Passing in multiple fixture names returns all fixtures matching these names:
#
#   test "find all by name" do
#     assert_equal 2, web_sites(:rubyonrails, :google).length
#   end
#
# Passing in no arguments returns all fixtures:
#
#   test "find all" do
#     assert_equal 2, web_sites.length
#   end
#
# Passing in any fixture name that does not exist will raise <tt>StandardError</tt>:
#
#   test "find by name that does not exist" do
#     assert_raise(StandardError) { web_sites(:reddit) }
#   end
#
# Alternatively, you may enable auto-instantiation of the fixture data. For instance, take the
# following tests:
#
#   test "find_alt_method_1" do
#     assert_equal "Ruby on Rails", @web_sites['rubyonrails']['name']
#   end
#
#   test "find_alt_method_2" do
#     assert_equal "Ruby on Rails", @rubyonrails.name
#   end
#
# In order to use these methods to access fixtured data within your test cases, you must specify one of the
# following in your ActiveSupport::TestCase-derived class:
#
# - to fully enable instantiated fixtures (enable alternate methods #1 and #2 above)
#     self.use_instantiated_fixtures = true
#
# - create only the hash for the fixtures, do not 'find' each instance (enable alternate method #1 only)
#     self.use_instantiated_fixtures = :no_instances
#
# Using either of these alternate methods incurs a performance hit, as the fixtured data must be fully
# traversed in the database to create the fixture hash and/or instance variables. This is expensive for
# large sets of fixtured data.
#
# == Dynamic fixtures with \ERB
#
# Sometimes you don't care about the content of the fixtures as much as you care about the volume.
# In these cases, you can mix ERB in with your YAML fixtures to create a bunch of fixtures for load
# testing, like:
#
#   <% 1.upto(1000) do |i| %>
#   fix_<%= i %>:
#     id: <%= i %>
#     name: guy_<%= i %>
#   <% end %>
#
# This will create 1000 very simple fixtures.
#
# Using ERB, you can also inject dynamic values into your fixtures with inserts like
# <tt><%= Date.today.strftime("%Y-%m-%d") %></tt>.
# This is however a feature to be used with some caution. The point of fixtures are that they're
# stable units of predictable sample data. If you feel that you need to inject dynamic values, then
# perhaps you should reexamine whether your application is properly testable. Hence, dynamic values
# in fixtures are to be considered a code smell.
#
# Helper methods defined in a fixture will not be available in other fixtures, to prevent against
# unwanted inter-test dependencies. Methods used by multiple fixtures should be defined in a module
# that is included in ActiveRecord::FixtureSet.context_class.
#
# - define a helper method in <tt>test_helper.rb</tt>
#     module FixtureFileHelpers
#       def file_sha(path)
#         OpenSSL::Digest::SHA256.hexdigest(File.read(Rails.root.join('test/fixtures', path)))
#       end
#     end
#     ActiveRecord::FixtureSet.context_class.include FixtureFileHelpers
#
# - use the helper method in a fixture
#     photo:
#       name: kitten.png
#       sha: <%= file_sha 'files/kitten.png' %>
#
# == Transactional Tests
#
# Test cases can use begin+rollback to isolate their changes to the database instead of having to
# delete+insert for every test case.
#
#   class FooTest < ActiveSupport::TestCase
#     self.use_transactional_tests = true
#
#     test "godzilla" do
#       assert_not_empty Foo.all
#       Foo.destroy_all
#       assert_empty Foo.all
#     end
#
#     test "godzilla aftermath" do
#       assert_not_empty Foo.all
#     end
#   end
#
# If you preload your test database with all fixture data (probably by running <tt>bin/rails db:fixtures:load</tt>)
# and use transactional tests, then you may omit all fixtures declarations in your test cases since
# all the data's already there and every case rolls back its changes.
#
# In order to use instantiated fixtures with preloaded data, set +self.pre_loaded_fixtures+ to
# true. This will provide access to fixture data for every table that has been loaded through
# fixtures (depending on the value of +use_instantiated_fixtures+).
#
# When *not* to use transactional tests:
#
# 1. You're testing whether a transaction works correctly. Nested transactions don't commit until
#    all parent transactions commit, particularly, the fixtures transaction which is begun in setup
#    and rolled back in teardown. Thus, you won't be able to verify
#    the results of your transaction until Active Record supports nested transactions or savepoints (in progress).
# 2. Your database does not support transactions. Every Active Record database supports transactions except MySQL MyISAM.
#    Use InnoDB, MaxDB, or NDB instead.
#
# == Advanced Fixtures
#
# Fixtures that don't specify an ID get some extra features:
#
# * Stable, autogenerated IDs
# * Label references for associations (belongs_to, has_one, has_many)
# * HABTM associations as inline lists
#
# There are some more advanced features available even if the id is specified:
#
# * Autofilled timestamp columns
# * Fixture label interpolation
# * Support for YAML defaults
#
# === Stable, Autogenerated IDs
#
# Here, have a monkey fixture:
#
#   george:
#     id: 1
#     name: George the Monkey
#
#   reginald:
#     id: 2
#     name: Reginald the Pirate
#
# Each of these fixtures has two unique identifiers: one for the database
# and one for the humans. Why don't we generate the primary key instead?
# Hashing each fixture's label yields a consistent ID:
#
#   george: # generated id: 503576764
#     name: George the Monkey
#
#   reginald: # generated id: 324201669
#     name: Reginald the Pirate
#
# Active Record looks at the fixture's model class, discovers the correct
# primary key, and generates it right before inserting the fixture
# into the database.
#
# The generated ID for a given label is constant, so we can discover
# any fixture's ID without loading anything, as long as we know the label.
#
# === Label references for associations (+belongs_to+, +has_one+, +has_many+)
#
# Specifying foreign keys in fixtures can be very fragile, not to
# mention difficult to read. Since Active Record can figure out the ID of
# any fixture from its label, you can specify FK's by label instead of ID.
#
# ==== +belongs_to+
#
# Let's break out some more monkeys and pirates.
#
#   ### in pirates.yml
#
#   reginald:
#     id: 1
#     name: Reginald the Pirate
#     monkey_id: 1
#
# <code></code>
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     pirate_id: 1
#
# Add a few more monkeys and pirates and break this into multiple files,
# and it gets pretty hard to keep track of what's going on. Let's
# use labels instead of IDs:
#
#   ### in pirates.yml
#
#   reginald:
#     name: Reginald the Pirate
#     monkey: george
#
# <code></code>
#
#   ### in monkeys.yml
#
#   george:
#     name: George the Monkey
#     pirate: reginald
#
# Pow! All is made clear. Active Record reflects on the fixture's model class,
# finds all the +belongs_to+ associations, and allows you to specify
# a target *label* for the *association* (monkey: george) rather than
# a target *id* for the *FK* (<tt>monkey_id: 1</tt>).
#
# ==== Polymorphic +belongs_to+
#
# Supporting polymorphic relationships is a little bit more complicated, since
# Active Record needs to know what type your association is pointing at. Something
# like this should look familiar:
#
#   ### in fruit.rb
#
#   belongs_to :eater, polymorphic: true
#
# <code></code>
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#     eater_id: 1
#     eater_type: Monkey
#
# Can we do better? You bet!
#
#   apple:
#     eater: george (Monkey)
#
# Just provide the polymorphic target type and Active Record will take care of the rest.
#
# ==== +has_and_belongs_to_many+ or <tt>has_many :through</tt>
#
# \Time to give our monkey some fruit.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#
# <code></code>
#
#   ### in fruits.yml
#
#   apple:
#     id: 1
#     name: apple
#
#   orange:
#     id: 2
#     name: orange
#
#   grape:
#     id: 3
#     name: grape
#
# <code></code>
#
#   ### in fruits_monkeys.yml
#
#   apple_george:
#     fruit_id: 1
#     monkey_id: 1
#
#   orange_george:
#     fruit_id: 2
#     monkey_id: 1
#
#   grape_george:
#     fruit_id: 3
#     monkey_id: 1
#
# Let's make the HABTM fixture go away.
#
#   ### in monkeys.yml
#
#   george:
#     id: 1
#     name: George the Monkey
#     fruits: apple, orange, grape
#
# <code></code>
#
#   ### in fruits.yml
#
#   apple:
#     name: apple
#
#   orange:
#     name: orange
#
#   grape:
#     name: grape
#
# Zap! No more fruits_monkeys.yml file. We've specified the list of fruits
# on George's fixture, but we could've just as easily specified a list
# of monkeys on each fruit. As with +belongs_to+, Active Record reflects on
# the fixture's model class and discovers the +has_and_belongs_to_many+
# associations.
#
# === Autofilled \Timestamp Columns
#
# If your table/model specifies any of Active Record's
# standard timestamp columns (+created_at+, +created_on+, +updated_at+, +updated_on+),
# they will automatically be set to <tt>Time.now</tt>.
#
# If you've set specific values, they'll be left alone.
#
# === Fixture label interpolation
#
# The label of the current fixture is always available as a column value:
#
#   geeksomnia:
#     name: Geeksomnia's Account
#     subdomain: $LABEL
#     email: $LABEL@email.com
#
# Also, sometimes (like when porting older join table fixtures) you'll need
# to be able to get a hold of the identifier for a given label. ERB
# to the rescue:
#
#   george_reginald:
#     monkey_id: <%= ActiveRecord::FixtureSet.identify(:reginald) %>
#     pirate_id: <%= ActiveRecord::FixtureSet.identify(:george) %>
#
# If the model uses UUID values for identifiers, add the +:uuid+ argument:
#
#   ActiveRecord::FixtureSet.identify(:boaty_mcboatface, :uuid)
#
# === Support for YAML defaults
#
# You can set and reuse defaults in your fixtures YAML file.
# This is the same technique used in the +database.yml+ file to specify
# defaults:
#
#   DEFAULTS: &DEFAULTS
#     created_on: <%= 3.weeks.ago.to_fs(:db) %>
#
#   first:
#     name: Smurf
#     <<: *DEFAULTS
#
#   second:
#     name: Fraggle
#     <<: *DEFAULTS
#
# Any fixture labeled "DEFAULTS" is safely ignored.
#
# Besides using "DEFAULTS", you can also specify what fixtures will
# be ignored by setting "ignore" in "_fixture" section.
#
#   # users.yml
#   _fixture:
#     ignore:
#       - base
#     # or use "ignore: base" when there is only one fixture that needs to be ignored.
#
#   base: &base
#     admin: false
#     introduction: "This is a default description"
#
#   admin:
#     <<: *base
#     admin: true
#
#   visitor:
#     <<: *base
#
# In the above example, 'base' will be ignored when creating fixtures.
# This can be used for common attributes inheriting.
#
# == Composite Primary Key Fixtures
#
# Fixtures for composite primary key tables are fairly similar to normal tables.
# When using an id column, the column may be omitted as usual:
#
#   # app/models/book.rb
#   class Book < ApplicationRecord
#     self.primary_key = [:author_id, :id]
#     belongs_to :author
#   end
#
# <code></code>
#
#   # books.yml
#   alices_adventure_in_wonderland:
#     author_id: <%= ActiveRecord::FixtureSet.identify(:lewis_carroll) %>
#     title: "Alice's Adventures in Wonderland"
#
# However, in order to support composite primary key relationships,
# you must use the `composite_identify` method:
#
#   # app/models/book_orders.rb
#   class BookOrder < ApplicationRecord
#     self.primary_key = [:shop_id, :id]
#     belongs_to :order, query_constraints: [:shop_id, :order_id]
#     belongs_to :book, query_constraints: [:author_id, :book_id]
#   end
#
# <code></code>
#
#   # book_orders.yml
#   alices_adventure_in_wonderland_in_books:
#     author: lewis_carroll
#     book_id: <%= ActiveRecord::FixtureSet.composite_identify(
#                  :alices_adventure_in_wonderland, Book.primary_key)[:id] %>
#     shop: book_store
#     order_id: <%= ActiveRecord::FixtureSet.composite_identify(
#                  :books, Order.primary_key)[:id] %>
#
# == Configure the fixture model class
#
# It's possible to set the fixture's model class directly in the YAML file.
# This is helpful when fixtures are loaded outside tests and
# +set_fixture_class+ is not available (e.g.
# when running <tt>bin/rails db:fixtures:load</tt>).
#
#   _fixture:
#     model_class: User
#   david:
#     name: David
#
# Any fixtures labeled "_fixture" are safely ignored.
#
# source://activerecord//lib/active_record/fixtures.rb#523
class ActiveRecord::FixtureSet
  # @return [FixtureSet] a new instance of FixtureSet
  #
  # source://activerecord//lib/active_record/fixtures.rb#709
  def initialize(_, name, class_name, path, config = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/fixtures.rb#720
  def [](x); end

  # source://activerecord//lib/active_record/fixtures.rb#724
  def []=(k, v); end

  # source://activerecord//lib/active_record/fixtures.rb#537
  def all_loaded_fixtures; end

  # source://activerecord//lib/active_record/fixtures.rb#537
  def all_loaded_fixtures=(val); end

  # Returns the value of attribute config.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def config; end

  # source://activerecord//lib/active_record/fixtures.rb#728
  def each(&block); end

  # Returns the value of attribute fixtures.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def fixtures; end

  # Returns the value of attribute ignored_fixtures.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def ignored_fixtures; end

  # Returns the value of attribute model_class.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def model_class; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def name; end

  # source://activerecord//lib/active_record/fixtures.rb#732
  def size; end

  # Returns the value of attribute table_name.
  #
  # source://activerecord//lib/active_record/fixtures.rb#707
  def table_name; end

  # Returns a hash of rows to be inserted. The key is the table, the value is
  # a list of rows to insert to that table.
  #
  # source://activerecord//lib/active_record/fixtures.rb#738
  def table_rows; end

  private

  # source://activerecord//lib/active_record/fixtures.rb#796
  def default_fixture_model_class; end

  # source://activerecord//lib/active_record/fixtures.rb#758
  def ignored_fixtures=(base); end

  # source://activerecord//lib/active_record/fixtures.rb#750
  def model_class=(class_name); end

  # Loads the fixtures from the YAML file at +path+.
  # If the file sets the +model_class+ and current instance value is not set,
  # it uses the file value.
  #
  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/fixtures.rb#777
  def read_fixture_files(path); end

  class << self
    # source://activerecord//lib/active_record/fixtures.rb#537
    def all_loaded_fixtures; end

    # source://activerecord//lib/active_record/fixtures.rb#537
    def all_loaded_fixtures=(val); end

    # source://activerecord//lib/active_record/fixtures.rb#572
    def cache_fixtures(connection, fixtures_map); end

    # source://activerecord//lib/active_record/fixtures.rb#556
    def cache_for_connection(connection); end

    # source://activerecord//lib/active_record/fixtures.rb#564
    def cached_fixtures(connection, keys_to_fetch = T.unsafe(nil)); end

    # Returns a consistent, platform-independent hash representing a mapping
    # between the label and the subcomponents of the provided composite key.
    #
    # Example:
    #
    #   composite_identify("label", [:a, :b, :c]) # => { a: hash_1, b: hash_2, c: hash_3 }
    #
    # source://activerecord//lib/active_record/fixtures.rb#631
    def composite_identify(label, key); end

    # Superclass for the evaluation contexts used by \ERB fixtures.
    #
    # source://activerecord//lib/active_record/fixtures.rb#639
    def context_class; end

    # source://activerecord//lib/active_record/fixtures.rb#591
    def create_fixtures(fixtures_directories, fixture_set_names, class_names = T.unsafe(nil), config = T.unsafe(nil), &block); end

    # source://activerecord//lib/active_record/fixtures.rb#540
    def default_fixture_model_name(fixture_set_name, config = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/fixtures.rb#546
    def default_fixture_table_name(fixture_set_name, config = T.unsafe(nil)); end

    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/fixtures.rb#560
    def fixture_is_cached?(connection, table_name); end

    # Returns a consistent, platform-independent identifier for +label+.
    #
    # \Integer identifiers are values less than 2^30. UUIDs are RFC 4122 version 5 SHA-1 hashes.
    #
    # source://activerecord//lib/active_record/fixtures.rb#617
    def identify(label, column_type = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/fixtures.rb#585
    def instantiate_all_loaded_fixtures(object, load_instances = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/fixtures.rb#576
    def instantiate_fixtures(object, fixture_set, load_instances = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/fixtures.rb#552
    def reset_cache; end

    private

    # source://activerecord//lib/active_record/fixtures.rb#692
    def check_all_foreign_keys_valid!(conn); end

    # source://activerecord//lib/active_record/fixtures.rb#663
    def insert(fixture_sets, connection); end

    # source://activerecord//lib/active_record/fixtures.rb#644
    def read_and_insert(fixtures_directories, fixture_files, class_names, connection); end

    # source://activerecord//lib/active_record/fixtures.rb#702
    def update_all_loaded_fixtures(fixtures_map); end
  end
end

# source://activerecord//lib/active_record/fixture_set/file.rb#7
class ActiveRecord::FixtureSet::File
  include ::Enumerable

  # @return [File] a new instance of File
  #
  # source://activerecord//lib/active_record/fixture_set/file.rb#19
  def initialize(file); end

  # source://activerecord//lib/active_record/fixture_set/file.rb#23
  def each(&block); end

  # source://activerecord//lib/active_record/fixture_set/file.rb#31
  def ignored_fixtures; end

  # source://activerecord//lib/active_record/fixture_set/file.rb#27
  def model_class; end

  private

  # source://activerecord//lib/active_record/fixture_set/file.rb#40
  def config_row; end

  # source://activerecord//lib/active_record/fixture_set/file.rb#51
  def raw_rows; end

  # source://activerecord//lib/active_record/fixture_set/file.rb#36
  def rows; end

  # Validate our unmarshalled data.
  #
  # source://activerecord//lib/active_record/fixture_set/file.rb#76
  def validate(data); end

  # source://activerecord//lib/active_record/fixture_set/file.rb#61
  def validate_config_row(data); end

  class << self
    # Open a fixture file named +file+.  When called with a block, the block
    # is called with the filehandle and the filehandle is automatically closed
    # when the block finishes.
    #
    # source://activerecord//lib/active_record/fixture_set/file.rb#14
    def open(file); end
  end
end

# --
# An instance of FixtureSet is normally stored in a single YAML file and
# possibly in a folder with the same name.
# ++
#
# source://activerecord//lib/active_record/fixtures.rb#533
ActiveRecord::FixtureSet::MAX_ID = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/fixture_set/model_metadata.rb#5
class ActiveRecord::FixtureSet::ModelMetadata
  # @return [ModelMetadata] a new instance of ModelMetadata
  #
  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#6
  def initialize(model_class); end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#29
  def column_names; end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#18
  def column_type(column_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#25
  def has_column?(column_name); end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#37
  def inheritance_column_name; end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#10
  def primary_key_name; end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#14
  def primary_key_type; end

  # source://activerecord//lib/active_record/fixture_set/model_metadata.rb#33
  def timestamp_column_names; end
end

# NOTE: This class has to be defined in compact style in
# order for rendering context subclassing to work correctly.
#
# source://activerecord//lib/active_record/fixture_set/render_context.rb#7
class ActiveRecord::FixtureSet::RenderContext
  class << self
    # source://activerecord//lib/active_record/fixture_set/render_context.rb#8
    def create_subclass; end
  end
end

# source://activerecord//lib/active_record/fixture_set/table_row.rb#5
class ActiveRecord::FixtureSet::TableRow
  # @return [TableRow] a new instance of TableRow
  #
  # source://activerecord//lib/active_record/fixture_set/table_row.rb#65
  def initialize(fixture, table_rows:, label:, now:); end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#73
  def to_hash; end

  private

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#186
  def add_join_records(association); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/fixture_set/table_row.rb#136
  def column_defined?(col); end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#86
  def fill_row_model_attributes; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#103
  def fill_timestamps; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#127
  def generate_composite_primary_key; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#119
  def generate_primary_key; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#112
  def interpolate_label; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#82
  def model_class; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#78
  def model_metadata; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#95
  def reflection_class; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#140
  def resolve_enums; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#148
  def resolve_sti_reflections; end
end

# source://activerecord//lib/active_record/fixture_set/table_row.rb#24
class ActiveRecord::FixtureSet::TableRow::HasManyThroughProxy < ::ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  # source://activerecord//lib/active_record/fixture_set/table_row.rb#33
  def join_table; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#29
  def lhs_key; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#25
  def rhs_key; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#37
  def timestamp_column_names; end
end

# source://activerecord//lib/active_record/fixture_set/table_row.rb#42
class ActiveRecord::FixtureSet::TableRow::PrimaryKeyError < ::StandardError
  # @return [PrimaryKeyError] a new instance of PrimaryKeyError
  #
  # source://activerecord//lib/active_record/fixture_set/table_row.rb#43
  def initialize(label, association, value); end
end

# source://activerecord//lib/active_record/fixture_set/table_row.rb#6
class ActiveRecord::FixtureSet::TableRow::ReflectionProxy
  # @return [ReflectionProxy] a new instance of ReflectionProxy
  #
  # source://activerecord//lib/active_record/fixture_set/table_row.rb#7
  def initialize(association); end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#11
  def join_table; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#15
  def name; end

  # source://activerecord//lib/active_record/fixture_set/table_row.rb#19
  def primary_key_type; end
end

# source://activerecord//lib/active_record/fixture_set/table_rows.rb#8
class ActiveRecord::FixtureSet::TableRows
  # @return [TableRows] a new instance of TableRows
  #
  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#9
  def initialize(table_name, model_class:, fixtures:); end

  # Returns the value of attribute model_class.
  #
  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#21
  def model_class; end

  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#27
  def model_metadata; end

  # Returns the value of attribute tables.
  #
  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#21
  def tables; end

  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#23
  def to_hash; end

  private

  # source://activerecord//lib/active_record/fixture_set/table_rows.rb#32
  def build_table_rows_from(table_name, fixtures); end
end

# source://activerecord//lib/active_record/future_result.rb#4
class ActiveRecord::FutureResult
  # @return [FutureResult] a new instance of FutureResult
  #
  # source://activerecord//lib/active_record/future_result.rb#55
  def initialize(pool, *args, **kwargs); end

  # source://activerecord//lib/active_record/future_result.rb#83
  def cancel; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/future_result.rb#124
  def canceled?; end

  # source://activerecord//lib/active_record/future_result.rb#50
  def empty?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/future_result.rb#79
  def execute!(connection); end

  # source://activerecord//lib/active_record/future_result.rb#89
  def execute_or_skip; end

  # Returns the value of attribute lock_wait.
  #
  # source://activerecord//lib/active_record/future_result.rb#53
  def lock_wait; end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/delegation.rb#331
  def method_missing(method, *args, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/future_result.rb#120
  def pending?; end

  # source://activerecord//lib/active_record/future_result.rb#107
  def result; end

  # source://activerecord//lib/active_record/future_result.rb#74
  def schedule!(session); end

  # source://activerecord//lib/active_record/future_result.rb#70
  def then(&block); end

  # source://activerecord//lib/active_record/future_result.rb#50
  def to_a(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/future_result.rb#152
  def exec_query(connection, *args, **kwargs); end

  # source://activerecord//lib/active_record/future_result.rb#129
  def execute_or_wait; end

  # source://activerecord//lib/active_record/future_result.rb#144
  def execute_query(connection, async: T.unsafe(nil)); end

  # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/delegation.rb#323
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/future_result.rb#48
class ActiveRecord::FutureResult::Canceled < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/future_result.rb#5
class ActiveRecord::FutureResult::Complete
  # @return [Complete] a new instance of Complete
  #
  # source://activerecord//lib/active_record/future_result.rb#9
  def initialize(result); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/future_result.rb#17
  def canceled?; end

  # source://activerecord//lib/active_record/future_result.rb#7
  def empty?(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/future_result.rb#13
  def pending?; end

  # Returns the value of attribute result.
  #
  # source://activerecord//lib/active_record/future_result.rb#6
  def result; end

  # source://activerecord//lib/active_record/future_result.rb#21
  def then(&block); end

  # source://activerecord//lib/active_record/future_result.rb#7
  def to_a(*_arg0, **_arg1, &_arg2); end
end

# source://activerecord//lib/active_record/future_result.rb#26
class ActiveRecord::FutureResult::EventBuffer
  # @return [EventBuffer] a new instance of EventBuffer
  #
  # source://activerecord//lib/active_record/future_result.rb#27
  def initialize(future_result, instrumenter); end

  # source://activerecord//lib/active_record/future_result.rb#39
  def flush; end

  # source://activerecord//lib/active_record/future_result.rb#33
  def instrument(name, payload = T.unsafe(nil), &block); end
end

# source://activerecord//lib/active_record/future_result.rb#156
class ActiveRecord::FutureResult::SelectAll < ::ActiveRecord::FutureResult
  private

  # source://activerecord//lib/active_record/future_result.rb#158
  def exec_query(*_arg0, **_arg1); end
end

# source://activerecord//lib/active_record/associations.rb#74
class ActiveRecord::HasManyThroughAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  include ::DidYouMean::Correctable

  # @return [HasManyThroughAssociationNotFoundError] a new instance of HasManyThroughAssociationNotFoundError
  #
  # source://activerecord//lib/active_record/associations.rb#77
  def initialize(owner_class = T.unsafe(nil), reflection = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/associations.rb#90
  def corrections; end

  # Returns the value of attribute owner_class.
  #
  # source://activerecord//lib/active_record/associations.rb#75
  def owner_class; end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations.rb#75
  def reflection; end
end

# source://activerecord//lib/active_record/associations.rb#124
class ActiveRecord::HasManyThroughAssociationPointlessSourceTypeError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPointlessSourceTypeError] a new instance of HasManyThroughAssociationPointlessSourceTypeError
  #
  # source://activerecord//lib/active_record/associations.rb#125
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#104
class ActiveRecord::HasManyThroughAssociationPolymorphicSourceError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicSourceError] a new instance of HasManyThroughAssociationPolymorphicSourceError
  #
  # source://activerecord//lib/active_record/associations.rb#105
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), source_reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#114
class ActiveRecord::HasManyThroughAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughAssociationPolymorphicThroughError] a new instance of HasManyThroughAssociationPolymorphicThroughError
  #
  # source://activerecord//lib/active_record/associations.rb#115
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#218
class ActiveRecord::HasManyThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end

# source://activerecord//lib/active_record/associations.rb#234
class ActiveRecord::HasManyThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

# source://activerecord//lib/active_record/associations.rb#167
class ActiveRecord::HasManyThroughOrderError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughOrderError] a new instance of HasManyThroughOrderError
  #
  # source://activerecord//lib/active_record/associations.rb#168
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), through_reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#154
class ActiveRecord::HasManyThroughSourceAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  # @return [HasManyThroughSourceAssociationNotFoundError] a new instance of HasManyThroughSourceAssociationNotFoundError
  #
  # source://activerecord//lib/active_record/associations.rb#155
  def initialize(reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#144
class ActiveRecord::HasOneAssociationPolymorphicThroughError < ::ActiveRecord::ActiveRecordError
  # @return [HasOneAssociationPolymorphicThroughError] a new instance of HasOneAssociationPolymorphicThroughError
  #
  # source://activerecord//lib/active_record/associations.rb#145
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#134
class ActiveRecord::HasOneThroughCantAssociateThroughCollection < ::ActiveRecord::ActiveRecordError
  # @return [HasOneThroughCantAssociateThroughCollection] a new instance of HasOneThroughCantAssociateThroughCollection
  #
  # source://activerecord//lib/active_record/associations.rb#135
  def initialize(owner_class_name = T.unsafe(nil), reflection = T.unsafe(nil), through_reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#221
class ActiveRecord::HasOneThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection; end

# source://activerecord//lib/active_record/associations.rb#237
class ActiveRecord::HasOneThroughNestedAssociationsAreReadonly < ::ActiveRecord::ThroughNestedAssociationsAreReadonly; end

# source://activerecord//lib/active_record/migration.rb#124
class ActiveRecord::IllegalMigrationNameError < ::ActiveRecord::MigrationError
  # @return [IllegalMigrationNameError] a new instance of IllegalMigrationNameError
  #
  # source://activerecord//lib/active_record/migration.rb#125
  def initialize(name = T.unsafe(nil)); end
end

# Raised when a relation cannot be mutated because it's already loaded.
#
#   class Task < ActiveRecord::Base
#   end
#
#   relation = Task.all
#   relation.loaded? # => true
#
#   # Methods which try to mutate a loaded relation fail.
#   relation.where!(title: 'TODO')  # => ActiveRecord::ImmutableRelation
#   relation.limit!(5)              # => ActiveRecord::ImmutableRelation
#
# source://activerecord//lib/active_record/errors.rb#471
class ActiveRecord::ImmutableRelation < ::ActiveRecord::ActiveRecordError; end

# = Single table inheritance
#
# Active Record allows inheritance by storing the name of the class in a column that by
# default is named "type" (can be changed by overwriting <tt>Base.inheritance_column</tt>).
# This means that an inheritance looking like this:
#
#   class Company < ActiveRecord::Base; end
#   class Firm < Company; end
#   class Client < Company; end
#   class PriorityClient < Client; end
#
# When you do <tt>Firm.create(name: "37signals")</tt>, this record will be saved in
# the companies table with type = "Firm". You can then fetch this row again using
# <tt>Company.where(name: '37signals').first</tt> and it will return a Firm object.
#
# Be aware that because the type column is an attribute on the record every new
# subclass will instantly be marked as dirty and the type column will be included
# in the list of changed attributes on the record. This is different from non
# Single Table Inheritance(STI) classes:
#
#   Company.new.changed? # => false
#   Firm.new.changed?    # => true
#   Firm.new.changes     # => {"type"=>["","Firm"]}
#
# If you don't have a type column defined in your table, single-table inheritance won't
# be triggered. In that case, it'll work just like normal subclasses with no special magic
# for differentiating between them or reloading the right type with find.
#
# Note, all the attributes for all the cases are kept in the same table.
# Read more:
# * https://www.martinfowler.com/eaaCatalog/singleTableInheritance.html
#
# source://activerecord//lib/active_record/inheritance.rb#39
module ActiveRecord::Inheritance
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods

  private

  # Sets the attribute used for single table inheritance to this class name if this is not the
  # ActiveRecord::Base descendant.
  # Considering the hierarchy Reply < Message < ActiveRecord::Base, this makes it possible to
  # do Reply.new without having to set <tt>Reply[Reply.inheritance_column] = "Reply"</tt> yourself.
  # No such attribute would be set for objects of the Message class in that example.
  #
  # source://activerecord//lib/active_record/inheritance.rb#357
  def ensure_proper_type; end

  # source://activerecord//lib/active_record/inheritance.rb#341
  def initialize_dup(other); end

  # source://activerecord//lib/active_record/inheritance.rb#347
  def initialize_internals_callback; end

  module GeneratedClassMethods
    def store_full_class_name; end
    def store_full_class_name=(value); end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class=(value); end
    def store_full_sti_class?; end
  end

  module GeneratedInstanceMethods
    def store_full_class_name; end
    def store_full_class_name?; end
    def store_full_sti_class; end
    def store_full_sti_class?; end
  end
end

# source://activerecord//lib/active_record/inheritance.rb#52
module ActiveRecord::Inheritance::ClassMethods
  # Set this to +true+ if this is an abstract class (see
  # <tt>abstract_class?</tt>).
  # If you are using inheritance with Active Record and don't want a class
  # to be considered as part of the STI hierarchy, you must set this to
  # true.
  # +ApplicationRecord+, for example, is generated as an abstract class.
  #
  # Consider the following default behavior:
  #
  #   Shape = Class.new(ActiveRecord::Base)
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => "shapes"
  #   Polygon.table_name # => "shapes"
  #   Square.table_name  # => "shapes"
  #   Shape.create!      # => #<Shape id: 1, type: nil>
  #   Polygon.create!    # => #<Polygon id: 2, type: "Polygon">
  #   Square.create!     # => #<Square id: 3, type: "Square">
  #
  # However, when using <tt>abstract_class</tt>, +Shape+ is omitted from
  # the hierarchy:
  #
  #   class Shape < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => nil
  #   Polygon.table_name # => "polygons"
  #   Square.table_name  # => "polygons"
  #   Shape.create!      # => NotImplementedError: Shape is an abstract class and cannot be instantiated.
  #   Polygon.create!    # => #<Polygon id: 1, type: nil>
  #   Square.create!     # => #<Square id: 2, type: "Square">
  #
  # Note that in the above example, to disallow the creation of a plain
  # +Polygon+, you should use <tt>validates :type, presence: true</tt>,
  # instead of setting it as an abstract class. This way, +Polygon+ will
  # stay in the hierarchy, and Active Record will continue to correctly
  # derive the table name.
  #
  # source://activerecord//lib/active_record/inheritance.rb#164
  def abstract_class; end

  # Set this to +true+ if this is an abstract class (see
  # <tt>abstract_class?</tt>).
  # If you are using inheritance with Active Record and don't want a class
  # to be considered as part of the STI hierarchy, you must set this to
  # true.
  # +ApplicationRecord+, for example, is generated as an abstract class.
  #
  # Consider the following default behavior:
  #
  #   Shape = Class.new(ActiveRecord::Base)
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => "shapes"
  #   Polygon.table_name # => "shapes"
  #   Square.table_name  # => "shapes"
  #   Shape.create!      # => #<Shape id: 1, type: nil>
  #   Polygon.create!    # => #<Polygon id: 2, type: "Polygon">
  #   Square.create!     # => #<Square id: 3, type: "Square">
  #
  # However, when using <tt>abstract_class</tt>, +Shape+ is omitted from
  # the hierarchy:
  #
  #   class Shape < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   Shape.table_name   # => nil
  #   Polygon.table_name # => "polygons"
  #   Square.table_name  # => "polygons"
  #   Shape.create!      # => NotImplementedError: Shape is an abstract class and cannot be instantiated.
  #   Polygon.create!    # => #<Polygon id: 1, type: nil>
  #   Square.create!     # => #<Square id: 2, type: "Square">
  #
  # Note that in the above example, to disallow the creation of a plain
  # +Polygon+, you should use <tt>validates :type, presence: true</tt>,
  # instead of setting it as an abstract class. This way, +Polygon+ will
  # stay in the hierarchy, and Active Record will continue to correctly
  # derive the table name.
  #
  # source://activerecord//lib/active_record/inheritance.rb#164
  def abstract_class=(_arg0); end

  # Returns whether this class is an abstract class or not.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/inheritance.rb#167
  def abstract_class?; end

  # Returns the first class in the inheritance hierarchy that descends from either an
  # abstract class or from <tt>ActiveRecord::Base</tt>.
  #
  # Consider the following behaviour:
  #
  #   class ApplicationRecord < ActiveRecord::Base
  #     self.abstract_class = true
  #   end
  #   class Shape < ApplicationRecord
  #     self.abstract_class = true
  #   end
  #   Polygon = Class.new(Shape)
  #   Square = Class.new(Polygon)
  #
  #   ApplicationRecord.base_class # => ApplicationRecord
  #   Shape.base_class # => Shape
  #   Polygon.base_class # => Polygon
  #   Square.base_class # => Polygon
  #
  # source://activerecord//lib/active_record/inheritance.rb#115
  def base_class; end

  # Returns whether the class is a base class.
  # See #base_class for more information.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/inheritance.rb#119
  def base_class?; end

  # Returns +true+ if this does not need STI type condition. Returns
  # +false+ if STI type condition needs to be applied.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/inheritance.rb#82
  def descends_from_active_record?; end

  # source://activerecord//lib/active_record/inheritance.rb#224
  def dup; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/inheritance.rb#92
  def finder_needs_type_condition?; end

  # Determines if one of the attributes passed in is the inheritance column,
  # and if the inheritance column is attr accessible, it initializes an
  # instance of the given subclass instead of the base class.
  #
  # source://activerecord//lib/active_record/inheritance.rb#56
  def new(attributes = T.unsafe(nil), &block); end

  # Returns the class for the provided +name+.
  #
  # It is used to find the class correspondent to the value stored in the polymorphic type column.
  #
  # source://activerecord//lib/active_record/inheritance.rb#216
  def polymorphic_class_for(name); end

  # Returns the value to be stored in the polymorphic type column for Polymorphic Associations.
  #
  # source://activerecord//lib/active_record/inheritance.rb#209
  def polymorphic_name; end

  # Sets the application record class for Active Record
  #
  # This is useful if your application uses a different class than
  # ApplicationRecord for your primary abstract class. This class
  # will share a database connection with Active Record. It is the class
  # that connects to your primary database.
  #
  # source://activerecord//lib/active_record/inheritance.rb#177
  def primary_abstract_class; end

  # Returns the class for the provided +type_name+.
  #
  # It is used to find the class correspondent to the value stored in the inheritance column.
  #
  # source://activerecord//lib/active_record/inheritance.rb#194
  def sti_class_for(type_name); end

  # Returns the value to be stored in the inheritance column for STI.
  #
  # source://activerecord//lib/active_record/inheritance.rb#187
  def sti_name; end

  protected

  # Returns the class type of the record using the current module as a prefix. So descendants of
  # MyApp::Business::Account would appear as MyApp::Business::AccountSubclass.
  #
  # source://activerecord//lib/active_record/inheritance.rb#240
  def compute_type(type_name); end

  # source://activerecord//lib/active_record/inheritance.rb#268
  def set_base_class; end

  private

  # Called by +instantiate+ to decide which class to use for a new
  # record instance. For single-table inheritance, we check the record
  # for a +type+ column and return the corresponding class.
  #
  # source://activerecord//lib/active_record/inheritance.rb#297
  def discriminate_class_for_record(record); end

  # source://activerecord//lib/active_record/inheritance.rb#309
  def find_sti_class(type_name); end

  # source://activerecord//lib/active_record/inheritance.rb#285
  def inherited(subclass); end

  # source://activerecord//lib/active_record/inheritance.rb#232
  def initialize_clone(other); end

  # Detect the subclass from the inheritance column of attrs. If the inheritance column value
  # is not self or a valid subclass, raises ActiveRecord::SubclassNotFound
  #
  # source://activerecord//lib/active_record/inheritance.rb#329
  def subclass_from_attributes(attrs); end

  # source://activerecord//lib/active_record/inheritance.rb#320
  def type_condition(table = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/inheritance.rb#305
  def using_single_table_inheritance?(record); end
end

# source://activerecord//lib/active_record/insert_all.rb#6
class ActiveRecord::InsertAll
  # @return [InsertAll] a new instance of InsertAll
  #
  # source://activerecord//lib/active_record/insert_all.rb#10
  def initialize(model, inserts, on_duplicate:, update_only: T.unsafe(nil), returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  # Returns the value of attribute connection.
  #
  # source://activerecord//lib/active_record/insert_all.rb#7
  def connection; end

  # source://activerecord//lib/active_record/insert_all.rb#41
  def execute; end

  # Returns the value of attribute inserts.
  #
  # source://activerecord//lib/active_record/insert_all.rb#7
  def inserts; end

  # Returns the value of attribute keys.
  #
  # source://activerecord//lib/active_record/insert_all.rb#7
  def keys; end

  # TODO: Consider renaming this method, as it only conditionally extends keys, not always
  #
  # source://activerecord//lib/active_record/insert_all.rb#86
  def keys_including_timestamps; end

  # source://activerecord//lib/active_record/insert_all.rb#67
  def map_key_with_value; end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/insert_all.rb#7
  def model; end

  # Returns the value of attribute on_duplicate.
  #
  # source://activerecord//lib/active_record/insert_all.rb#8
  def on_duplicate; end

  # source://activerecord//lib/active_record/insert_all.rb#54
  def primary_keys; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#81
  def record_timestamps?; end

  # Returns the value of attribute returning.
  #
  # source://activerecord//lib/active_record/insert_all.rb#8
  def returning; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#59
  def skip_duplicates?; end

  # Returns the value of attribute unique_by.
  #
  # source://activerecord//lib/active_record/insert_all.rb#8
  def unique_by; end

  # source://activerecord//lib/active_record/insert_all.rb#50
  def updatable_columns; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#63
  def update_duplicates?; end

  # Returns the value of attribute update_only.
  #
  # source://activerecord//lib/active_record/insert_all.rb#8
  def update_only; end

  # Returns the value of attribute update_sql.
  #
  # source://activerecord//lib/active_record/insert_all.rb#8
  def update_sql; end

  private

  # source://activerecord//lib/active_record/insert_all.rb#125
  def configure_on_duplicate_update_logic; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#141
  def custom_update_sql_provided?; end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/insert_all.rb#209
  def disallow_raw_sql!(value); end

  # source://activerecord//lib/active_record/insert_all.rb#170
  def ensure_valid_options_for_connection!; end

  # source://activerecord//lib/active_record/insert_all.rb#145
  def find_unique_index_for(unique_by); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#97
  def has_attribute_aliases?(attributes); end

  # source://activerecord//lib/active_record/insert_all.rb#194
  def readonly_columns; end

  # source://activerecord//lib/active_record/insert_all.rb#121
  def resolve_attribute_alias(attribute); end

  # source://activerecord//lib/active_record/insert_all.rb#110
  def resolve_attribute_aliases; end

  # source://activerecord//lib/active_record/insert_all.rb#101
  def resolve_sti; end

  # Returns the value of attribute scope_attributes.
  #
  # source://activerecord//lib/active_record/insert_all.rb#95
  def scope_attributes; end

  # source://activerecord//lib/active_record/insert_all.rb#218
  def timestamps_for_create; end

  # source://activerecord//lib/active_record/insert_all.rb#189
  def to_sql; end

  # source://activerecord//lib/active_record/insert_all.rb#198
  def unique_by_columns; end

  # source://activerecord//lib/active_record/insert_all.rb#165
  def unique_indexes; end

  # source://activerecord//lib/active_record/insert_all.rb#203
  def verify_attributes(attributes); end
end

# source://activerecord//lib/active_record/insert_all.rb#222
class ActiveRecord::InsertAll::Builder
  # @return [Builder] a new instance of Builder
  #
  # source://activerecord//lib/active_record/insert_all.rb#227
  def initialize(insert_all); end

  # source://activerecord//lib/active_record/insert_all.rb#262
  def conflict_target; end

  # source://activerecord//lib/active_record/insert_all.rb#231
  def into; end

  # source://activerecord//lib/active_record/insert_all.rb#225
  def keys(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/insert_all.rb#225
  def keys_including_timestamps(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/insert_all.rb#223
  def model; end

  # source://activerecord//lib/active_record/insert_all.rb#286
  def raw_update_sql; end

  # source://activerecord//lib/active_record/insert_all.rb#286
  def raw_update_sql?; end

  # source://activerecord//lib/active_record/insert_all.rb#225
  def record_timestamps?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/insert_all.rb#246
  def returning; end

  # source://activerecord//lib/active_record/insert_all.rb#225
  def skip_duplicates?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/insert_all.rb#276
  def touch_model_timestamps_unless(&block); end

  # source://activerecord//lib/active_record/insert_all.rb#272
  def updatable_columns; end

  # source://activerecord//lib/active_record/insert_all.rb#225
  def update_duplicates?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/insert_all.rb#235
  def values_list; end

  private

  # source://activerecord//lib/active_record/insert_all.rb#299
  def columns_list; end

  # Returns the value of attribute connection.
  #
  # source://activerecord//lib/active_record/insert_all.rb#293
  def connection; end

  # @raise [UnknownAttributeError]
  #
  # source://activerecord//lib/active_record/insert_all.rb#303
  def extract_types_from_columns_on(table_name, keys:); end

  # source://activerecord//lib/active_record/insert_all.rb#312
  def format_columns(columns); end

  # Returns the value of attribute insert_all.
  #
  # source://activerecord//lib/active_record/insert_all.rb#293
  def insert_all; end

  # source://activerecord//lib/active_record/insert_all.rb#320
  def quote_column(column); end

  # source://activerecord//lib/active_record/insert_all.rb#316
  def quote_columns(columns); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/insert_all.rb#295
  def touch_timestamp_attribute?(column_name); end
end

# source://activerecord//lib/active_record/integration.rb#6
module ActiveRecord::Integration
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Integration::ClassMethods

  # Returns a stable cache key that can be used to identify this record.
  #
  #   Product.new.cache_key     # => "products/new"
  #   Product.find(5).cache_key # => "products/5"
  #
  # If ActiveRecord::Base.cache_versioning is turned off, as it was in \Rails 5.1 and earlier,
  # the cache key will also include a version.
  #
  #   Product.cache_versioning = false
  #   Product.find(5).cache_key  # => "products/5-20071224150000" (updated_at available)
  #
  # source://activerecord//lib/active_record/integration.rb#72
  def cache_key; end

  # Returns a cache key along with the version.
  #
  # source://activerecord//lib/active_record/integration.rb#114
  def cache_key_with_version; end

  # Returns a cache version that can be used together with the cache key to form
  # a recyclable caching scheme. By default, the #updated_at column is used for the
  # cache_version, but this method can be overwritten to return something else.
  #
  # Note, this method will return nil if ActiveRecord::Base.cache_versioning is set to
  # +false+.
  #
  # source://activerecord//lib/active_record/integration.rb#97
  def cache_version; end

  # Returns a +String+, which Action Pack uses for constructing a URL to this
  # object. The default implementation returns this record's id as a +String+,
  # or +nil+ if this record's unsaved.
  #
  # For example, suppose that you have a User model, and that you have a
  # <tt>resources :users</tt> route. Normally, +user_path+ will
  # construct a path with the user object's 'id' in it:
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/1"
  #
  # You can override +to_param+ in your model to make +user_path+ construct
  # a path using the user's name instead of the user's id:
  #
  #   class User < ActiveRecord::Base
  #     def to_param  # overridden
  #       name
  #     end
  #   end
  #
  #   user = User.find_by(name: 'Phusion')
  #   user_path(user)  # => "/users/Phusion"
  #
  # source://activerecord//lib/active_record/integration.rb#57
  def to_param; end

  private

  # Detects if the value before type cast
  # can be used to generate a cache_version.
  #
  # The fast cache version only works with a
  # string value directly from the database.
  #
  # We also must check if the timestamp format has been changed
  # or if the timezone is not set to UTC then
  # we cannot apply our transformations correctly.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/integration.rb#178
  def can_use_fast_cache_version?(timestamp); end

  # Converts a raw database string to `:usec`
  # format.
  #
  # Example:
  #
  #   timestamp = "2018-10-15 20:02:15.266505"
  #   raw_timestamp_to_cache_version(timestamp)
  #   # => "20181015200215266505"
  #
  # PostgreSQL truncates trailing zeros,
  # https://github.com/postgres/postgres/commit/3e1beda2cde3495f41290e1ece5d544525810214
  # to account for this we pad the output with zeros
  #
  # source://activerecord//lib/active_record/integration.rb#197
  def raw_timestamp_to_cache_version(timestamp); end

  module GeneratedClassMethods
    def cache_timestamp_format; end
    def cache_timestamp_format=(value); end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning=(value); end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning=(value); end
    def collection_cache_versioning?; end
  end

  module GeneratedInstanceMethods
    def cache_timestamp_format; end
    def cache_timestamp_format?; end
    def cache_versioning; end
    def cache_versioning?; end
    def collection_cache_versioning; end
    def collection_cache_versioning?; end
  end
end

# source://activerecord//lib/active_record/integration.rb#122
module ActiveRecord::Integration::ClassMethods
  # source://activerecord//lib/active_record/integration.rb#163
  def collection_cache_key(collection = T.unsafe(nil), timestamp_column = T.unsafe(nil)); end

  # Defines your model's +to_param+ method to generate "pretty" URLs
  # using +method_name+, which can be any attribute or method that
  # responds to +to_s+.
  #
  #   class User < ActiveRecord::Base
  #     to_param :name
  #   end
  #
  #   user = User.find_by(name: 'Fancy Pants')
  #   user.id         # => 123
  #   user_path(user) # => "/users/123-fancy-pants"
  #
  # Values longer than 20 characters will be truncated. The value
  # is truncated word by word.
  #
  #   user = User.find_by(name: 'David Heinemeier Hansson')
  #   user.id         # => 125
  #   user_path(user) # => "/users/125-david-heinemeier"
  #
  # Because the generated param begins with the record's +id+, it is
  # suitable for passing to +find+. In a controller, for example:
  #
  #   params[:id]               # => "123-fancy-pants"
  #   User.find(params[:id]).id # => 123
  #
  # source://activerecord//lib/active_record/integration.rb#147
  def to_param(method_name = T.unsafe(nil)); end
end

# This class is used to create a table that keeps track of values and keys such
# as which environment migrations were run in.
#
# This is enabled by default. To disable this functionality set
# `use_metadata_table` to false in your database configuration.
#
# source://activerecord//lib/active_record/internal_metadata.rb#12
class ActiveRecord::InternalMetadata
  # @return [InternalMetadata] a new instance of InternalMetadata
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#18
  def initialize(connection); end

  # source://activerecord//lib/active_record/internal_metadata.rb#45
  def [](key); end

  # source://activerecord//lib/active_record/internal_metadata.rb#39
  def []=(key, value); end

  # Returns the value of attribute arel_table.
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#16
  def arel_table; end

  # Returns the value of attribute connection.
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#16
  def connection; end

  # source://activerecord//lib/active_record/internal_metadata.rb#59
  def count; end

  # Creates an internal metadata table with columns +key+ and +value+
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#75
  def create_table; end

  # source://activerecord//lib/active_record/internal_metadata.rb#66
  def create_table_and_set_flags(environment, schema_sha1 = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/internal_metadata.rb#53
  def delete_all_entries; end

  # source://activerecord//lib/active_record/internal_metadata.rb#87
  def drop_table; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#23
  def enabled?; end

  # source://activerecord//lib/active_record/internal_metadata.rb#27
  def primary_key; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/internal_metadata.rb#93
  def table_exists?; end

  # source://activerecord//lib/active_record/internal_metadata.rb#35
  def table_name; end

  # source://activerecord//lib/active_record/internal_metadata.rb#31
  def value_key; end

  private

  # source://activerecord//lib/active_record/internal_metadata.rb#116
  def create_entry(key, value); end

  # source://activerecord//lib/active_record/internal_metadata.rb#112
  def current_time; end

  # source://activerecord//lib/active_record/internal_metadata.rb#140
  def select_entry(key); end

  # source://activerecord//lib/active_record/internal_metadata.rb#128
  def update_entry(key, new_value); end

  # source://activerecord//lib/active_record/internal_metadata.rb#98
  def update_or_create_entry(key, value); end
end

# source://activerecord//lib/active_record/internal_metadata.rb#13
class ActiveRecord::InternalMetadata::NullInternalMetadata; end

# Raised when a record cannot be inserted or updated because it references a non-existent record,
# or when a record cannot be deleted because a parent record references it.
#
# source://activerecord//lib/active_record/errors.rb#213
class ActiveRecord::InvalidForeignKey < ::ActiveRecord::WrappedDatabaseException; end

# source://activerecord//lib/active_record/associations.rb#33
class ActiveRecord::InverseOfAssociationNotFoundError < ::ActiveRecord::ActiveRecordError
  include ::DidYouMean::Correctable

  # @return [InverseOfAssociationNotFoundError] a new instance of InverseOfAssociationNotFoundError
  #
  # source://activerecord//lib/active_record/associations.rb#36
  def initialize(reflection = T.unsafe(nil), associated_class = T.unsafe(nil)); end

  # Returns the value of attribute associated_class.
  #
  # source://activerecord//lib/active_record/associations.rb#34
  def associated_class; end

  # source://activerecord//lib/active_record/associations.rb#49
  def corrections; end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations.rb#34
  def reflection; end
end

# source://activerecord//lib/active_record/associations.rb#62
class ActiveRecord::InverseOfAssociationRecursiveError < ::ActiveRecord::ActiveRecordError
  # @return [InverseOfAssociationRecursiveError] a new instance of InverseOfAssociationRecursiveError
  #
  # source://activerecord//lib/active_record/associations.rb#64
  def initialize(reflection = T.unsafe(nil)); end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/associations.rb#63
  def reflection; end
end

# Exception that can be raised to stop migrations from being rolled back.
# For example the following migration is not reversible.
# Rolling back this migration will raise an ActiveRecord::IrreversibleMigration error.
#
#   class IrreversibleMigrationExample < ActiveRecord::Migration[7.1]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       execute <<~SQL
#         ALTER TABLE distributors
#           ADD CONSTRAINT zipchk
#             CHECK (char_length(zipcode) = 5) NO INHERIT;
#       SQL
#     end
#   end
#
# There are two ways to mitigate this problem.
#
# 1. Define <tt>#up</tt> and <tt>#down</tt> methods instead of <tt>#change</tt>:
#
#  class ReversibleMigrationExample < ActiveRecord::Migration[7.1]
#    def up
#      create_table :distributors do |t|
#        t.string :zipcode
#      end
#
#      execute <<~SQL
#        ALTER TABLE distributors
#          ADD CONSTRAINT zipchk
#            CHECK (char_length(zipcode) = 5) NO INHERIT;
#      SQL
#    end
#
#    def down
#      execute <<~SQL
#        ALTER TABLE distributors
#          DROP CONSTRAINT zipchk
#      SQL
#
#      drop_table :distributors
#    end
#  end
#
# 2. Use the #reversible method in <tt>#change</tt> method:
#
#   class ReversibleMigrationExample < ActiveRecord::Migration[7.1]
#     def change
#       create_table :distributors do |t|
#         t.string :zipcode
#       end
#
#       reversible do |dir|
#         dir.up do
#           execute <<~SQL
#             ALTER TABLE distributors
#               ADD CONSTRAINT zipchk
#                 CHECK (char_length(zipcode) = 5) NO INHERIT;
#           SQL
#         end
#
#         dir.down do
#           execute <<~SQL
#             ALTER TABLE distributors
#               DROP CONSTRAINT zipchk
#           SQL
#         end
#       end
#     end
#   end
#
# source://activerecord//lib/active_record/migration.rb#91
class ActiveRecord::IrreversibleMigration < ::ActiveRecord::MigrationError; end

# IrreversibleOrderError is raised when a relation's order is too complex for
# +reverse_order+ to automatically reverse.
#
# source://activerecord//lib/active_record/errors.rb#530
class ActiveRecord::IrreversibleOrderError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/legacy_yaml_adapter.rb#4
module ActiveRecord::LegacyYamlAdapter
  class << self
    # source://activerecord//lib/active_record/legacy_yaml_adapter.rb#5
    def convert(coder); end
  end
end

# LockWaitTimeout will be raised when lock wait timeout exceeded.
#
# source://activerecord//lib/active_record/errors.rb#538
class ActiveRecord::LockWaitTimeout < ::ActiveRecord::StatementInvalid; end

# source://activerecord//lib/active_record.rb#143
module ActiveRecord::Locking
  extend ::ActiveSupport::Autoload
end

# In de/serialize we change `nil` to 0, so that we can allow passing
# `nil` values to `lock_version`, and not result in `ActiveRecord::StaleObjectError`
# during update record.
#
# source://activerecord//lib/active_record/locking/optimistic.rb#205
class ActiveRecord::Locking::LockingType
  # source://activerecord//lib/active_record/locking/optimistic.rb#210
  def deserialize(value); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#222
  def encode_with(coder); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#218
  def init_with(coder); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#214
  def serialize(value); end

  class << self
    # source://activerecord//lib/active_record/locking/optimistic.rb#206
    def new(subtype); end
  end
end

# == What is \Optimistic \Locking
#
# Optimistic locking allows multiple users to access the same record for edits, and assumes a minimum of
# conflicts with the data. It does this by checking whether another process has made changes to a record since
# it was opened, an ActiveRecord::StaleObjectError exception is thrown if that has occurred
# and the update is ignored.
#
# Check out +ActiveRecord::Locking::Pessimistic+ for an alternative.
#
# == Usage
#
# Active Record supports optimistic locking if the +lock_version+ field is present. Each update to the
# record increments the +lock_version+ column and the locking facilities ensure that records instantiated twice
# will let the last one saved raise a +StaleObjectError+ if the first was also updated. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.first_name = "should fail"
#   p2.save # Raises an ActiveRecord::StaleObjectError
#
# Optimistic locking will also check for stale data when objects are destroyed. Example:
#
#   p1 = Person.find(1)
#   p2 = Person.find(1)
#
#   p1.first_name = "Michael"
#   p1.save
#
#   p2.destroy # Raises an ActiveRecord::StaleObjectError
#
# You're then responsible for dealing with the conflict by rescuing the exception and either rolling back, merging,
# or otherwise apply the business logic needed to resolve the conflict.
#
# This locking mechanism will function inside a single Ruby process. To make it work across all
# web requests, the recommended approach is to add +lock_version+ as a hidden field to your form.
#
# This behavior can be turned off by setting <tt>ActiveRecord::Base.lock_optimistically = false</tt>.
# To override the name of the +lock_version+ column, set the <tt>locking_column</tt> class attribute:
#
#   class Person < ActiveRecord::Base
#     self.locking_column = :lock_person
#   end
#
# source://activerecord//lib/active_record/locking/optimistic.rb#52
module ActiveRecord::Locking::Optimistic
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Locking::Optimistic::ClassMethods

  # source://activerecord//lib/active_record/locking/optimistic.rb#63
  def increment!(*_arg0, **_arg1); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#59
  def locking_enabled?; end

  private

  # source://activerecord//lib/active_record/locking/optimistic.rb#142
  def _clear_locking_column; end

  # source://activerecord//lib/active_record/locking/optimistic.rb#78
  def _create_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#134
  def _lock_value_for_database(locking_column); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#147
  def _query_constraints_hash; end

  # source://activerecord//lib/active_record/locking/optimistic.rb#87
  def _touch_row(attribute_names, time); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#92
  def _update_row(attribute_names, attempted_action = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/locking/optimistic.rb#124
  def destroy_row; end

  # source://activerecord//lib/active_record/locking/optimistic.rb#72
  def initialize_dup(other); end

  module GeneratedClassMethods
    def lock_optimistically; end
    def lock_optimistically=(value); end
    def lock_optimistically?; end
  end

  module GeneratedInstanceMethods
    def lock_optimistically; end
    def lock_optimistically?; end
  end
end

# source://activerecord//lib/active_record/locking/optimistic.rb#154
module ActiveRecord::Locking::Optimistic::ClassMethods
  # source://activerecord//lib/active_record/locking/optimistic.rb#185
  def define_attribute(name, cast_type, **_arg2); end

  # The version column used for optimistic locking. Defaults to +lock_version+.
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#171
  def locking_column; end

  # Set the column to use for optimistic locking. Defaults to +lock_version+.
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#165
  def locking_column=(value); end

  # Returns true if the +lock_optimistically+ flag is set to true
  # (which it is, by default) and the table includes the
  # +locking_column+ column (defaults to +lock_version+).
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#160
  def locking_enabled?; end

  # Reset the column used for optimistic locking back to the +lock_version+ default.
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#174
  def reset_locking_column; end

  # Make sure the lock version column gets updated when counters are
  # updated.
  #
  # source://activerecord//lib/active_record/locking/optimistic.rb#180
  def update_counters(id, counters); end

  private

  # source://activerecord//lib/active_record/locking/optimistic.rb#193
  def inherited(base); end
end

# source://activerecord//lib/active_record/locking/optimistic.rb#155
ActiveRecord::Locking::Optimistic::ClassMethods::DEFAULT_LOCKING_COLUMN = T.let(T.unsafe(nil), String)

# = \Pessimistic \Locking
#
# Locking::Pessimistic provides support for row-level locking using
# SELECT ... FOR UPDATE and other lock types.
#
# Chain <tt>ActiveRecord::Base#find</tt> to ActiveRecord::QueryMethods#lock to obtain an exclusive
# lock on the selected rows:
#   # select * from accounts where id=1 for update
#   Account.lock.find(1)
#
# Call <tt>lock('some locking clause')</tt> to use a database-specific locking clause
# of your own such as 'LOCK IN SHARE MODE' or 'FOR UPDATE NOWAIT'. Example:
#
#   Account.transaction do
#     # select * from accounts where name = 'shugo' limit 1 for update nowait
#     shugo = Account.lock("FOR UPDATE NOWAIT").find_by(name: "shugo")
#     yuko = Account.lock("FOR UPDATE NOWAIT").find_by(name: "yuko")
#     shugo.balance -= 100
#     shugo.save!
#     yuko.balance += 100
#     yuko.save!
#   end
#
# You can also use <tt>ActiveRecord::Base#lock!</tt> method to lock one record by id.
# This may be better if you don't need to lock every row. Example:
#
#   Account.transaction do
#     # select * from accounts where ...
#     accounts = Account.where(...)
#     account1 = accounts.detect { |account| ... }
#     account2 = accounts.detect { |account| ... }
#     # select * from accounts where id=? for update
#     account1.lock!
#     account2.lock!
#     account1.balance -= 100
#     account1.save!
#     account2.balance += 100
#     account2.save!
#   end
#
# You can start a transaction and acquire the lock in one go by calling
# <tt>with_lock</tt> with a block. The block is called from within
# a transaction, the object is already locked. Example:
#
#   account = Account.first
#   account.with_lock do
#     # This block is called within a transaction,
#     # account is already locked.
#     account.balance -= 100
#     account.save!
#   end
#
# Database-specific information on row locking:
#
# [MySQL]
#   https://dev.mysql.com/doc/refman/en/innodb-locking-reads.html
#
# [PostgreSQL]
#   https://www.postgresql.org/docs/current/interactive/sql-select.html#SQL-FOR-UPDATE-SHARE
#
# source://activerecord//lib/active_record/locking/pessimistic.rb#64
module ActiveRecord::Locking::Pessimistic
  # Obtain a row lock on this record. Reloads the record to obtain the requested
  # lock. Pass an SQL locking clause to append the end of the SELECT statement
  # or pass true for "FOR UPDATE" (the default, an exclusive row lock). Returns
  # the locked record.
  #
  # source://activerecord//lib/active_record/locking/pessimistic.rb#69
  def lock!(lock = T.unsafe(nil)); end

  # Wraps the passed block in a transaction, reloading the object with a
  # lock before yielding. You can pass the SQL locking clause
  # as an optional argument (see #lock!).
  #
  # You can also pass options like <tt>requires_new:</tt>, <tt>isolation:</tt>,
  # and <tt>joinable:</tt> to the wrapping transaction (see
  # ActiveRecord::ConnectionAdapters::DatabaseStatements#transaction).
  #
  # source://activerecord//lib/active_record/locking/pessimistic.rb#92
  def with_lock(*args); end
end

# source://activerecord//lib/active_record/log_subscriber.rb#4
class ActiveRecord::LogSubscriber < ::ActiveSupport::LogSubscriber
  # source://activerecord//lib/active_record/log_subscriber.rb#7
  def backtrace_cleaner; end

  # source://activerecord//lib/active_record/log_subscriber.rb#7
  def backtrace_cleaner=(_arg0); end

  # source://activerecord//lib/active_record/log_subscriber.rb#7
  def backtrace_cleaner?; end

  # source://activerecord//lib/active_record/log_subscriber.rb#39
  def sql(event); end

  # source://activerecord//lib/active_record/log_subscriber.rb#30
  def strict_loading_violation(event); end

  private

  # source://activerecord//lib/active_record/log_subscriber.rb#101
  def colorize_payload_name(name, payload_name); end

  # source://activerecord//lib/active_record/log_subscriber.rb#134
  def debug(progname = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/log_subscriber.rb#164
  def filter(name, value); end

  # source://activerecord//lib/active_record/log_subscriber.rb#142
  def log_query_source; end

  # source://activerecord//lib/active_record/log_subscriber.rb#130
  def logger; end

  # source://activerecord//lib/active_record/log_subscriber.rb#151
  def query_source_location; end

  # source://activerecord//lib/active_record/log_subscriber.rb#86
  def render_bind(attr, value); end

  # source://activerecord//lib/active_record/log_subscriber.rb#109
  def sql_color(sql); end

  # source://activerecord//lib/active_record/log_subscriber.rb#82
  def type_casted_binds(casted_binds); end

  class << self
    # source://activerecord//lib/active_record/log_subscriber.rb#7
    def backtrace_cleaner; end

    # source://activerecord//lib/active_record/log_subscriber.rb#7
    def backtrace_cleaner=(value); end

    # source://activerecord//lib/active_record/log_subscriber.rb#7
    def backtrace_cleaner?; end

    # source://activesupport/7.1.3.2/lib/active_support/log_subscriber.rb#87
    def log_levels; end

    # source://activerecord//lib/active_record/log_subscriber.rb#23
    def reset_runtime; end

    # source://activerecord//lib/active_record/log_subscriber.rb#16
    def runtime; end

    # source://activerecord//lib/active_record/log_subscriber.rb#9
    def runtime=(value); end
  end
end

# source://activerecord//lib/active_record/log_subscriber.rb#5
ActiveRecord::LogSubscriber::IGNORE_PAYLOAD_NAMES = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/marshalling.rb#4
module ActiveRecord::Marshalling
  class << self
    # Returns the value of attribute format_version.
    #
    # source://activerecord//lib/active_record/marshalling.rb#8
    def format_version; end

    # source://activerecord//lib/active_record/marshalling.rb#10
    def format_version=(version); end
  end
end

# source://activerecord//lib/active_record/marshalling.rb#23
module ActiveRecord::Marshalling::Methods
  # source://activerecord//lib/active_record/marshalling.rb#24
  def _marshal_dump_7_1; end

  # source://activerecord//lib/active_record/marshalling.rb#40
  def marshal_load(state); end
end

# source://activerecord//lib/active_record.rb#161
module ActiveRecord::Middleware
  extend ::ActiveSupport::Autoload
end

# = Database Selector \Middleware
#
# The DatabaseSelector Middleware provides a framework for automatically
# swapping from the primary to the replica database connection. \Rails
# provides a basic framework to determine when to swap and allows for
# applications to write custom strategy classes to override the default
# behavior.
#
# The resolver class defines when the application should switch (i.e. read
# from the primary if a write occurred less than 2 seconds ago) and a
# resolver context class that sets a value that helps the resolver class
# decide when to switch.
#
# \Rails default middleware uses the request's session to set a timestamp
# that informs the application when to read from a primary or read from a
# replica.
#
# To use the DatabaseSelector in your application with default settings,
# run the provided generator.
#
#   $ bin/rails g active_record:multi_db
#
# This will create a file named +config/initializers/multi_db.rb+ with the
# following contents:
#
#   Rails.application.configure do
#     config.active_record.database_selector = { delay: 2.seconds }
#     config.active_record.database_resolver = ActiveRecord::Middleware::DatabaseSelector::Resolver
#     config.active_record.database_resolver_context = ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
#   end
#
# Alternatively you can set the options in your environment config or
# any other config file loaded on boot.
#
# The default behavior can be changed by setting the config options to a
# custom class:
#
#   config.active_record.database_selector = { delay: 2.seconds }
#   config.active_record.database_resolver = MyResolver
#   config.active_record.database_resolver_context = MyResolver::MySession
#
# Note: If you are using <tt>rails new my_app --minimal</tt> you will need
# to call <tt>require "active_support/core_ext/integer/time"</tt> to load
# the core extension in order to use +2.seconds+
#
# source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#5
class ActiveRecord::Middleware::DatabaseSelector
  # @return [DatabaseSelector] a new instance of DatabaseSelector
  #
  # source://activerecord//lib/active_record/middleware/database_selector.rb#52
  def initialize(app, resolver_klass = T.unsafe(nil), context_klass = T.unsafe(nil), options = T.unsafe(nil)); end

  # Middleware that determines which database connection to use in a multiple
  # database application.
  #
  # source://activerecord//lib/active_record/middleware/database_selector.rb#63
  def call(env); end

  # Returns the value of attribute context_klass.
  #
  # source://activerecord//lib/active_record/middleware/database_selector.rb#59
  def context_klass; end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/middleware/database_selector.rb#59
  def options; end

  # Returns the value of attribute resolver_klass.
  #
  # source://activerecord//lib/active_record/middleware/database_selector.rb#59
  def resolver_klass; end

  private

  # source://activerecord//lib/active_record/middleware/database_selector.rb#72
  def select_database(request, &blk); end
end

# The Resolver class is used by the DatabaseSelector middleware to
# determine which database the request should use.
#
# To change the behavior of the Resolver class in your application,
# create a custom resolver class that inherits from
# DatabaseSelector::Resolver and implements the methods that need to
# be changed.
#
# By default the Resolver class will send read traffic to the replica
# if it's been 2 seconds since the last write.
#
# source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#6
class ActiveRecord::Middleware::DatabaseSelector::Resolver
  # @return [Resolver] a new instance of Resolver
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#26
  def initialize(context, options = T.unsafe(nil)); end

  # Returns the value of attribute context.
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#33
  def context; end

  # Returns the value of attribute delay.
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#33
  def delay; end

  # Returns the value of attribute instrumenter.
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#33
  def instrumenter; end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#35
  def read(&blk); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#51
  def reading_request?(request); end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#47
  def update_context(response); end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#43
  def write(&blk); end

  private

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#56
  def read_from_primary(&blk); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#78
  def read_from_primary?; end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#62
  def read_from_replica(&blk); end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#82
  def send_to_replica_delay; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#86
  def time_since_last_write_ok?; end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#68
  def write_to_primary; end

  class << self
    # source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#22
    def call(context, options = T.unsafe(nil)); end
  end
end

# source://activerecord//lib/active_record/middleware/database_selector/resolver.rb#20
ActiveRecord::Middleware::DatabaseSelector::Resolver::SEND_TO_REPLICA_DELAY = T.let(T.unsafe(nil), ActiveSupport::Duration)

# The session class is used by the DatabaseSelector::Resolver to save
# timestamps of the last write in the session.
#
# The last_write is used to determine whether it's safe to read
# from the replica or the request needs to be sent to the primary.
#
# source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#12
class ActiveRecord::Middleware::DatabaseSelector::Resolver::Session
  # @return [Session] a new instance of Session
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#28
  def initialize(session); end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#34
  def last_write_timestamp; end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#42
  def save(response); end

  # Returns the value of attribute session.
  #
  # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#32
  def session; end

  # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#38
  def update_last_write_timestamp; end

  class << self
    # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#13
    def call(request); end

    # Converts time to a timestamp that represents milliseconds since
    # epoch.
    #
    # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#19
    def convert_time_to_timestamp(time); end

    # Converts milliseconds since epoch timestamp into a time object.
    #
    # source://activerecord//lib/active_record/middleware/database_selector/resolver/session.rb#24
    def convert_timestamp_to_time(timestamp); end
  end
end

# = Shard Selector \Middleware
#
# The ShardSelector Middleware provides a framework for automatically
# swapping shards. \Rails provides a basic framework to determine which
# shard to switch to and allows for applications to write custom strategies
# for swapping if needed.
#
# The ShardSelector takes a set of options (currently only +lock+ is supported)
# that can be used by the middleware to alter behavior. +lock+ is
# true by default and will prohibit the request from switching shards once
# inside the block. If +lock+ is false, then shard swapping will be allowed.
# For tenant based sharding, +lock+ should always be true to prevent application
# code from mistakenly switching between tenants.
#
# Options can be set in the config:
#
#   config.active_record.shard_selector = { lock: true }
#
# Applications must also provide the code for the resolver as it depends on application
# specific models. An example resolver would look like this:
#
#   config.active_record.shard_resolver = ->(request) {
#     subdomain = request.subdomain
#     tenant = Tenant.find_by_subdomain!(subdomain)
#     tenant.shard
#   }
#
# source://activerecord//lib/active_record/middleware/shard_selector.rb#31
class ActiveRecord::Middleware::ShardSelector
  # @return [ShardSelector] a new instance of ShardSelector
  #
  # source://activerecord//lib/active_record/middleware/shard_selector.rb#32
  def initialize(app, resolver, options = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/middleware/shard_selector.rb#40
  def call(env); end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/middleware/shard_selector.rb#38
  def options; end

  # Returns the value of attribute resolver.
  #
  # source://activerecord//lib/active_record/middleware/shard_selector.rb#38
  def resolver; end

  private

  # source://activerecord//lib/active_record/middleware/shard_selector.rb#51
  def selected_shard(request); end

  # source://activerecord//lib/active_record/middleware/shard_selector.rb#55
  def set_shard(shard, &block); end
end

# = Active Record Migrations
#
# Migrations can manage the evolution of a schema used by several physical
# databases. It's a solution to the common problem of adding a field to make
# a new feature work in your local database, but being unsure of how to
# push that change to other developers and to the production server. With
# migrations, you can describe the transformations in self-contained classes
# that can be checked into version control systems and executed against
# another database that might be one, two, or five versions behind.
#
# Example of a simple migration:
#
#   class AddSsl < ActiveRecord::Migration[7.1]
#     def up
#       add_column :accounts, :ssl_enabled, :boolean, default: true
#     end
#
#     def down
#       remove_column :accounts, :ssl_enabled
#     end
#   end
#
# This migration will add a boolean flag to the accounts table and remove it
# if you're backing out of the migration. It shows how all migrations have
# two methods +up+ and +down+ that describes the transformations
# required to implement or remove the migration. These methods can consist
# of both the migration specific methods like +add_column+ and +remove_column+,
# but may also contain regular Ruby code for generating data needed for the
# transformations.
#
# Example of a more complex migration that also needs to initialize data:
#
#   class AddSystemSettings < ActiveRecord::Migration[7.1]
#     def up
#       create_table :system_settings do |t|
#         t.string  :name
#         t.string  :label
#         t.text    :value
#         t.string  :type
#         t.integer :position
#       end
#
#       SystemSetting.create  name:  'notice',
#                             label: 'Use notice?',
#                             value: 1
#     end
#
#     def down
#       drop_table :system_settings
#     end
#   end
#
# This migration first adds the +system_settings+ table, then creates the very
# first row in it using the Active Record model that relies on the table. It
# also uses the more advanced +create_table+ syntax where you can specify a
# complete table schema in one block call.
#
# == Available transformations
#
# === Creation
#
# * <tt>create_join_table(table_1, table_2, options)</tt>: Creates a join
#   table having its name as the lexical order of the first two
#   arguments. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#create_join_table for
#   details.
# * <tt>create_table(name, options)</tt>: Creates a table called +name+ and
#   makes the table object available to a block that can then add columns to it,
#   following the same format as +add_column+. See example above. The options hash
#   is for fragments like "DEFAULT CHARSET=UTF-8" that are appended to the create
#   table definition.
# * <tt>add_column(table_name, column_name, type, options)</tt>: Adds a new column
#   to the table called +table_name+
#   named +column_name+ specified to be one of the following types:
#   <tt>:string</tt>, <tt>:text</tt>, <tt>:integer</tt>, <tt>:float</tt>,
#   <tt>:decimal</tt>, <tt>:datetime</tt>, <tt>:timestamp</tt>, <tt>:time</tt>,
#   <tt>:date</tt>, <tt>:binary</tt>, <tt>:boolean</tt>. A default value can be
#   specified by passing an +options+ hash like <tt>{ default: 11 }</tt>.
#   Other options include <tt>:limit</tt> and <tt>:null</tt> (e.g.
#   <tt>{ limit: 50, null: false }</tt>) -- see
#   ActiveRecord::ConnectionAdapters::TableDefinition#column for details.
# * <tt>add_foreign_key(from_table, to_table, options)</tt>: Adds a new
#   foreign key. +from_table+ is the table with the key column, +to_table+ contains
#   the referenced primary key.
# * <tt>add_index(table_name, column_names, options)</tt>: Adds a new index
#   with the name of the column. Other options include
#   <tt>:name</tt>, <tt>:unique</tt> (e.g.
#   <tt>{ name: 'users_name_index', unique: true }</tt>) and <tt>:order</tt>
#   (e.g. <tt>{ order: { name: :desc } }</tt>).
# * <tt>add_reference(:table_name, :reference_name)</tt>: Adds a new column
#   +reference_name_id+ by default an integer. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#add_reference for details.
# * <tt>add_timestamps(table_name, options)</tt>: Adds timestamps (+created_at+
#   and +updated_at+) columns to +table_name+.
#
# === Modification
#
# * <tt>change_column(table_name, column_name, type, options)</tt>:  Changes
#   the column to a different type using the same parameters as add_column.
# * <tt>change_column_default(table_name, column_name, default_or_changes)</tt>:
#   Sets a default value for +column_name+ defined by +default_or_changes+ on
#   +table_name+. Passing a hash containing <tt>:from</tt> and <tt>:to</tt>
#   as +default_or_changes+ will make this change reversible in the migration.
# * <tt>change_column_null(table_name, column_name, null, default = nil)</tt>:
#   Sets or removes a <tt>NOT NULL</tt> constraint on +column_name+. The +null+ flag
#   indicates whether the value can be +NULL+. See
#   ActiveRecord::ConnectionAdapters::SchemaStatements#change_column_null for
#   details.
# * <tt>change_table(name, options)</tt>: Allows to make column alterations to
#   the table called +name+. It makes the table object available to a block that
#   can then add/remove columns, indexes, or foreign keys to it.
# * <tt>rename_column(table_name, column_name, new_column_name)</tt>: Renames
#   a column but keeps the type and content.
# * <tt>rename_index(table_name, old_name, new_name)</tt>: Renames an index.
# * <tt>rename_table(old_name, new_name)</tt>: Renames the table called +old_name+
#   to +new_name+.
#
# === Deletion
#
# * <tt>drop_table(name)</tt>: Drops the table called +name+.
# * <tt>drop_join_table(table_1, table_2, options)</tt>: Drops the join table
#   specified by the given arguments.
# * <tt>remove_column(table_name, column_name, type, options)</tt>: Removes the column
#   named +column_name+ from the table called +table_name+.
# * <tt>remove_columns(table_name, *column_names)</tt>: Removes the given
#   columns from the table definition.
# * <tt>remove_foreign_key(from_table, to_table = nil, **options)</tt>: Removes the
#   given foreign key from the table called +table_name+.
# * <tt>remove_index(table_name, column: column_names)</tt>: Removes the index
#   specified by +column_names+.
# * <tt>remove_index(table_name, name: index_name)</tt>: Removes the index
#   specified by +index_name+.
# * <tt>remove_reference(table_name, ref_name, options)</tt>: Removes the
#   reference(s) on +table_name+ specified by +ref_name+.
# * <tt>remove_timestamps(table_name, options)</tt>: Removes the timestamp
#   columns (+created_at+ and +updated_at+) from the table definition.
#
# == Irreversible transformations
#
# Some transformations are destructive in a manner that cannot be reversed.
# Migrations of that kind should raise an ActiveRecord::IrreversibleMigration
# exception in their +down+ method.
#
# == Running migrations from within \Rails
#
# The \Rails package has several tools to help create and apply migrations.
#
# To generate a new migration, you can use
#
#   $ bin/rails generate migration MyNewMigration
#
# where MyNewMigration is the name of your migration. The generator will
# create an empty migration file <tt>timestamp_my_new_migration.rb</tt>
# in the <tt>db/migrate/</tt> directory where <tt>timestamp</tt> is the
# UTC formatted date and time that the migration was generated.
#
# There is a special syntactic shortcut to generate migrations that add fields to a table.
#
#   $ bin/rails generate migration add_fieldname_to_tablename fieldname:string
#
# This will generate the file <tt>timestamp_add_fieldname_to_tablename.rb</tt>, which will look like this:
#   class AddFieldnameToTablename < ActiveRecord::Migration[7.1]
#     def change
#       add_column :tablenames, :fieldname, :string
#     end
#   end
#
# To run migrations against the currently configured database, use
# <tt>bin/rails db:migrate</tt>. This will update the database by running all of the
# pending migrations, creating the <tt>schema_migrations</tt> table
# (see "About the schema_migrations table" section below) if missing. It will also
# invoke the db:schema:dump command, which will update your db/schema.rb file
# to match the structure of your database.
#
# To roll the database back to a previous migration version, use
# <tt>bin/rails db:rollback VERSION=X</tt> where <tt>X</tt> is the version to which
# you wish to downgrade. Alternatively, you can also use the STEP option if you
# wish to rollback last few migrations. <tt>bin/rails db:rollback STEP=2</tt> will rollback
# the latest two migrations.
#
# If any of the migrations throw an ActiveRecord::IrreversibleMigration exception,
# that step will fail and you'll have some manual work to do.
#
# == More examples
#
# Not all migrations change the schema. Some just fix the data:
#
#   class RemoveEmptyTags < ActiveRecord::Migration[7.1]
#     def up
#       Tag.all.each { |tag| tag.destroy if tag.pages.empty? }
#     end
#
#     def down
#       # not much we can do to restore deleted data
#       raise ActiveRecord::IrreversibleMigration, "Can't recover the deleted tags"
#     end
#   end
#
# Others remove columns when they migrate up instead of down:
#
#   class RemoveUnnecessaryItemAttributes < ActiveRecord::Migration[7.1]
#     def up
#       remove_column :items, :incomplete_items_count
#       remove_column :items, :completed_items_count
#     end
#
#     def down
#       add_column :items, :incomplete_items_count
#       add_column :items, :completed_items_count
#     end
#   end
#
# And sometimes you need to do something in SQL not abstracted directly by migrations:
#
#   class MakeJoinUnique < ActiveRecord::Migration[7.1]
#     def up
#       execute "ALTER TABLE `pages_linked_pages` ADD UNIQUE `page_id_linked_page_id` (`page_id`,`linked_page_id`)"
#     end
#
#     def down
#       execute "ALTER TABLE `pages_linked_pages` DROP INDEX `page_id_linked_page_id`"
#     end
#   end
#
# == Using a model after changing its table
#
# Sometimes you'll want to add a column in a migration and populate it
# immediately after. In that case, you'll need to make a call to
# <tt>Base#reset_column_information</tt> in order to ensure that the model has the
# latest column data from after the new column was added. Example:
#
#   class AddPeopleSalary < ActiveRecord::Migration[7.1]
#     def up
#       add_column :people, :salary, :integer
#       Person.reset_column_information
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#   end
#
# == Controlling verbosity
#
# By default, migrations will describe the actions they are taking, writing
# them to the console as they happen, along with benchmarks describing how
# long each step took.
#
# You can quiet them down by setting ActiveRecord::Migration.verbose = false.
#
# You can also insert your own messages and benchmarks by using the +say_with_time+
# method:
#
#   def up
#     ...
#     say_with_time "Updating salaries..." do
#       Person.all.each do |p|
#         p.update_attribute :salary, SalaryCalculator.compute(p)
#       end
#     end
#     ...
#   end
#
# The phrase "Updating salaries..." would then be printed, along with the
# benchmark for the block when the block completes.
#
# == Timestamped Migrations
#
# By default, \Rails generates migrations that look like:
#
#    20080717013526_your_migration_name.rb
#
# The prefix is a generation timestamp (in UTC).
#
# If you'd prefer to use numeric prefixes, you can turn timestamped migrations
# off by setting:
#
#    config.active_record.timestamped_migrations = false
#
# In application.rb.
#
# == Reversible Migrations
#
# Reversible migrations are migrations that know how to go +down+ for you.
# You simply supply the +up+ logic, and the Migration system figures out
# how to execute the down commands for you.
#
# To define a reversible migration, define the +change+ method in your
# migration like this:
#
#   class TenderloveMigration < ActiveRecord::Migration[7.1]
#     def change
#       create_table(:horses) do |t|
#         t.column :content, :text
#         t.column :remind_at, :datetime
#       end
#     end
#   end
#
# This migration will create the horses table for you on the way up, and
# automatically figure out how to drop the table on the way down.
#
# Some commands cannot be reversed. If you care to define how to move up
# and down in these cases, you should define the +up+ and +down+ methods
# as before.
#
# If a command cannot be reversed, an
# ActiveRecord::IrreversibleMigration exception will be raised when
# the migration is moving down.
#
# For a list of commands that are reversible, please see
# +ActiveRecord::Migration::CommandRecorder+.
#
# == Transactional Migrations
#
# If the database adapter supports DDL transactions, all migrations will
# automatically be wrapped in a transaction. There are queries that you
# can't execute inside a transaction though, and for these situations
# you can turn the automatic transactions off.
#
#   class ChangeEnum < ActiveRecord::Migration[7.1]
#     disable_ddl_transaction!
#
#     def up
#       execute "ALTER TYPE model_size ADD VALUE 'new_value'"
#     end
#   end
#
# Remember that you can still open your own transactions, even if you
# are in a Migration with <tt>self.disable_ddl_transaction!</tt>.
#
# source://activerecord//lib/active_record/migration.rb#555
class ActiveRecord::Migration
  # @return [Migration] a new instance of Migration
  #
  # source://activerecord//lib/active_record/migration.rb#796
  def initialize(name = T.unsafe(nil), version = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#1000
  def announce(message); end

  # source://activerecord//lib/active_record/migration.rb#1031
  def connection; end

  # source://activerecord//lib/active_record/migration.rb#1052
  def copy(destination, sources, options = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#789
  def disable_ddl_transaction; end

  # source://activerecord//lib/active_record/migration.rb#952
  def down; end

  # source://activerecord//lib/active_record/migration.rb#980
  def exec_migration(conn, direction); end

  # source://activerecord//lib/active_record/migration.rb#802
  def execution_strategy; end

  # source://activerecord//lib/active_record/migration.rb#1035
  def method_missing(method, *arguments, **_arg2, &block); end

  # Execute this migration in the named direction
  #
  # source://activerecord//lib/active_record/migration.rb#959
  def migrate(direction); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/migration.rb#794
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activerecord//lib/active_record/migration.rb#794
  def name=(_arg0); end

  # Determines the version number of the next migration.
  #
  # source://activerecord//lib/active_record/migration.rb#1119
  def next_migration_number(number); end

  # Finds the correct table name given an Active Record object.
  # Uses the Active Record object's own table_name, or pre/suffix from the
  # options passed in.
  #
  # source://activerecord//lib/active_record/migration.rb#1110
  def proper_table_name(name, options = T.unsafe(nil)); end

  # Used to specify an operation that can be run in one direction or another.
  # Call the methods +up+ and +down+ of the yielded object to run a block
  # only in one given direction.
  # The whole block will be called in the right order within the migration.
  #
  # In the following example, the looping on users will always be done
  # when the three columns 'first_name', 'last_name' and 'full_name' exist,
  # even when migrating down:
  #
  #    class SplitNameMigration < ActiveRecord::Migration[7.1]
  #      def change
  #        add_column :users, :first_name, :string
  #        add_column :users, :last_name, :string
  #
  #        reversible do |dir|
  #          User.reset_column_information
  #          User.all.each do |u|
  #            dir.up   { u.first_name, u.last_name = u.full_name.split(' ') }
  #            dir.down { u.full_name = "#{u.first_name} #{u.last_name}" }
  #            u.save
  #          end
  #        end
  #
  #        revert { add_column :users, :full_name, :string }
  #      end
  #    end
  #
  # source://activerecord//lib/active_record/migration.rb#904
  def reversible; end

  # Reverses the migration commands for the given block and
  # the given migrations.
  #
  # The following migration will remove the table 'horses'
  # and create the table 'apples' on the way up, and the reverse
  # on the way down.
  #
  #   class FixTLMigration < ActiveRecord::Migration[7.1]
  #     def change
  #       revert do
  #         create_table(:horses) do |t|
  #           t.text :content
  #           t.datetime :remind_at
  #         end
  #       end
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # Or equivalently, if +TenderloveMigration+ is defined as in the
  # documentation for Migration:
  #
  #   require_relative "20121212123456_tenderlove_migration"
  #
  #   class FixupTLMigration < ActiveRecord::Migration[7.1]
  #     def change
  #       revert TenderloveMigration
  #
  #       create_table(:apples) do |t|
  #         t.string :variety
  #       end
  #     end
  #   end
  #
  # This command can be nested.
  #
  # source://activerecord//lib/active_record/migration.rb#847
  def revert(*migration_classes, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#864
  def reverting?; end

  # Runs the given migration classes.
  # Last argument can specify options:
  #
  # - +:direction+ - Default is +:up+.
  # - +:revert+ - Default is +false+.
  #
  # source://activerecord//lib/active_record/migration.rb#932
  def run(*migration_classes); end

  # Takes a message argument and outputs it as is.
  # A second boolean argument can be passed to specify whether to indent or not.
  #
  # source://activerecord//lib/active_record/migration.rb#1008
  def say(message, subitem = T.unsafe(nil)); end

  # Outputs text along with how long it took to run its block.
  # If the block returns an integer it assumes it is the number of rows affected.
  #
  # source://activerecord//lib/active_record/migration.rb#1014
  def say_with_time(message); end

  # Takes a block as an argument and suppresses any output generated by the block.
  #
  # source://activerecord//lib/active_record/migration.rb#1024
  def suppress_messages; end

  # Builds a hash for use in ActiveRecord::Migration#proper_table_name using
  # the Active Record object's table_name prefix and suffix
  #
  # source://activerecord//lib/active_record/migration.rb#1129
  def table_name_options(config = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#946
  def up; end

  # Used to specify an operation that is only run when migrating up
  # (for example, populating a new column with its initial values).
  #
  # In the following example, the new column +published+ will be given
  # the value +true+ for all existing records.
  #
  #    class AddPublishedToPosts < ActiveRecord::Migration[7.1]
  #      def change
  #        add_column :posts, :published, :boolean, default: false
  #        up_only do
  #          execute "update posts set published = 'true'"
  #        end
  #      end
  #    end
  #
  # source://activerecord//lib/active_record/migration.rb#923
  def up_only(&block); end

  # source://activerecord//lib/active_record/migration.rb#793
  def verbose; end

  # source://activerecord//lib/active_record/migration.rb#793
  def verbose=(val); end

  # Returns the value of attribute version.
  #
  # source://activerecord//lib/active_record/migration.rb#794
  def version; end

  # Sets the attribute version
  #
  # @param value the value to set the attribute version to.
  #
  # source://activerecord//lib/active_record/migration.rb#794
  def version=(_arg0); end

  # source://activerecord//lib/active_record/migration.rb#996
  def write(text = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/migration.rb#1161
  def command_recorder; end

  # source://activerecord//lib/active_record/migration.rb#1137
  def execute_block; end

  # source://activerecord//lib/active_record/migration.rb#1145
  def format_arguments(arguments); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1157
  def internal_option?(option_name); end

  class << self
    # source://activerecord//lib/active_record/migration.rb#613
    def [](version); end

    # Raises ActiveRecord::PendingMigrationError error if any migrations are pending
    # for all database configurations in an environment.
    #
    # source://activerecord//lib/active_record/migration.rb#698
    def check_all_pending!; end

    # Raises ActiveRecord::PendingMigrationError error if any migrations are pending.
    #
    # This is deprecated in favor of +check_all_pending!+
    #
    # source://activerecord//lib/active_record/migration.rb#682
    def check_pending!(connection = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/migration.rb#751
    def check_pending_migrations; end

    # source://activerecord//lib/active_record/migration.rb#617
    def current_version; end

    # source://activerecord//lib/active_record/migration.rb#672
    def delegate; end

    # source://activerecord//lib/active_record/migration.rb#672
    def delegate=(_arg0); end

    # source://activerecord//lib/active_record/migration.rb#673
    def disable_ddl_transaction; end

    # Disable the transaction wrapping this migration.
    # You can still create your own transactions even after calling #disable_ddl_transaction!
    #
    # For more details read the {"Transactional Migrations" section above}[rdoc-ref:Migration].
    #
    # source://activerecord//lib/active_record/migration.rb#747
    def disable_ddl_transaction!; end

    # source://activerecord//lib/active_record/migration.rb#673
    def disable_ddl_transaction=(_arg0); end

    # source://activerecord//lib/active_record/migration.rb#601
    def inherited(subclass); end

    # source://activerecord//lib/active_record/migration.rb#714
    def load_schema_if_pending!; end

    # source://activerecord//lib/active_record/migration.rb#728
    def maintain_test_schema!; end

    # source://activerecord//lib/active_record/migration.rb#734
    def method_missing(name, *args, **_arg2, &block); end

    # source://activerecord//lib/active_record/migration.rb#739
    def migrate(direction); end

    # source://activerecord//lib/active_record/migration.rb#675
    def nearest_delegate; end

    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/migration.rb#623
    def valid_version_format?(version_string); end

    # source://activerecord//lib/active_record/migration.rb#793
    def verbose; end

    # source://activerecord//lib/active_record/migration.rb#793
    def verbose=(val); end

    private

    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/migration.rb#760
    def any_schema_needs_update?; end

    # source://activerecord//lib/active_record/migration.rb#766
    def db_configs_in_current_env; end

    # source://activerecord//lib/active_record/migration.rb#784
    def env; end

    # source://activerecord//lib/active_record/migration.rb#770
    def pending_migrations; end
  end
end

# This class is used to verify that all migrations have been run before
# loading a web page if <tt>config.active_record.migration_error</tt> is set to +:page_load+.
#
# source://activerecord//lib/active_record/migration.rb#632
class ActiveRecord::Migration::CheckPending
  # @return [CheckPending] a new instance of CheckPending
  #
  # source://activerecord//lib/active_record/migration.rb#633
  def initialize(app, file_watcher: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#640
  def call(env); end

  private

  # source://activerecord//lib/active_record/migration.rb#659
  def build_watcher(&block); end

  # source://activerecord//lib/active_record/migration.rb#666
  def connection; end
end

# = \Migration Command Recorder
#
# +ActiveRecord::Migration::CommandRecorder+ records commands done during
# a migration and knows how to reverse those commands. The CommandRecorder
# knows how to invert the following commands:
#
# * add_column
# * add_foreign_key
# * add_check_constraint
# * add_exclusion_constraint
# * add_unique_constraint
# * add_index
# * add_reference
# * add_timestamps
# * change_column_default (must supply a +:from+ and +:to+ option)
# * change_column_null
# * change_column_comment (must supply a +:from+ and +:to+ option)
# * change_table_comment (must supply a +:from+ and +:to+ option)
# * create_enum
# * create_join_table
# * create_table
# * disable_extension
# * drop_enum (must supply a list of values)
# * drop_join_table
# * drop_table (must supply a block)
# * enable_extension
# * remove_column (must supply a type)
# * remove_columns (must supply a +:type+ option)
# * remove_foreign_key (must supply a second table)
# * remove_check_constraint
# * remove_exclusion_constraint
# * remove_unique_constraint
# * remove_index
# * remove_reference
# * remove_timestamps
# * rename_column
# * rename_enum (must supply a +:to+ option)
# * rename_enum_value (must supply a +:from+ and +:to+ option)
# * rename_index
# * rename_table
#
# source://activerecord//lib/active_record/migration/command_recorder.rb#45
class ActiveRecord::Migration::CommandRecorder
  include ::ActiveRecord::Migration::JoinTable
  include ::ActiveRecord::Migration::CommandRecorder::StraightReversions

  # @return [CommandRecorder] a new instance of CommandRecorder
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#63
  def initialize(delegate = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_belongs_to(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_check_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_column(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_enum_value(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_exclusion_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_foreign_key(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_index(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_reference(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_timestamps(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def add_unique_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def change_column(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def change_column_comment(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def change_column_default(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def change_column_null(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#132
  def change_table(table_name, **options); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def change_table_comment(*args, **_arg1, &block); end

  # Returns the value of attribute commands.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def commands; end

  # Sets the attribute commands
  #
  # @param value the value to set the attribute commands to.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def commands=(_arg0); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def create_enum(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def create_join_table(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def create_table(*args, **_arg1, &block); end

  # Returns the value of attribute delegate.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def delegate; end

  # Sets the attribute delegate
  #
  # @param value the value to set the attribute delegate to.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def delegate=(_arg0); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def disable_extension(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def drop_enum(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def drop_join_table(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def drop_table(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def enable_extension(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def execute(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def execute_block(*args, **_arg1, &block); end

  # Returns the inverse of the given command. For example:
  #
  #   recorder.inverse_of(:rename_table, [:old, :new])
  #   # => [:rename_table, [:new, :old]]
  #
  # If the inverse of a command requires several commands, returns array of commands.
  #
  #   recorder.inverse_of(:remove_columns, [:some_table, :foo, :bar, type: :string])
  #   # => [[:add_column, :some_table, :foo, :string], [:add_column, :some_table, :bar, :string]]
  #
  # This method will raise an +IrreversibleMigration+ exception if it cannot
  # invert the +command+.
  #
  # @raise [IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#110
  def inverse_of(command, args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_belongs_to(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_belongs_to(args, &block); end

  # Record +command+. +command+ should be a method name and arguments.
  # For example:
  #
  #   recorder.record(:method_name, [:arg1, :arg2])
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#90
  def record(*command, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_belongs_to(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_check_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_column(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_columns(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_exclusion_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_foreign_key(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_index(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_reference(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_timestamps(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def remove_unique_constraint(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def rename_column(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def rename_enum(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def rename_enum_value(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def rename_index(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def rename_table(*args, **_arg1, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#144
  def replay(migration); end

  # While executing the given block, the recorded will be in reverting mode.
  # All commands recorded will end up being recorded reverted
  # and in reverse order.
  # For example:
  #
  #   recorder.revert{ recorder.record(:rename_table, [:old, :new]) }
  #   # same effect as recorder.record(:rename_table, [:new, :old])
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#76
  def revert; end

  # Returns the value of attribute reverting.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def reverting; end

  # Sets the attribute reverting
  #
  # @param value the value to set the attribute reverting to.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#61
  def reverting=(_arg0); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#123
  def transaction(*args, **_arg1, &block); end

  private

  # source://activerecord//lib/active_record/migration/command_recorder.rb#313
  def invert_add_check_constraint(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#274
  def invert_add_foreign_key(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#335
  def invert_add_unique_constraint(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#293
  def invert_change_column_comment(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#259
  def invert_change_column_default(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#269
  def invert_change_column_null(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#303
  def invert_change_table_comment(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#191
  def invert_create_table(args, &block); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#349
  def invert_drop_enum(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#198
  def invert_drop_table(args, &block); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#321
  def invert_remove_check_constraint(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#215
  def invert_remove_column(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#220
  def invert_remove_columns(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#330
  def invert_remove_exclusion_constraint(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#279
  def invert_remove_foreign_key(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#238
  def invert_remove_index(args); end

  # @raise [ActiveRecord::IrreversibleMigration]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#342
  def invert_remove_unique_constraint(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#233
  def invert_rename_column(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#355
  def invert_rename_enum(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#365
  def invert_rename_enum_value(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#228
  def invert_rename_index(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#208
  def invert_rename_table(args); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#180
  def invert_transaction(args, &block); end

  # Forwards any missing method call to the \target.
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#380
  def method_missing(method, *args, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration/command_recorder.rb#375
  def respond_to_missing?(method, _); end
end

# source://activerecord//lib/active_record/migration/command_recorder.rb#46
ActiveRecord::Migration::CommandRecorder::ReversibleAndIrreversibleMethods = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/migration/command_recorder.rb#151
module ActiveRecord::Migration::CommandRecorder::StraightReversions
  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_check_constraint(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_column(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_exclusion_constraint(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_foreign_key(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_index(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_reference(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_timestamps(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_add_unique_constraint(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_create_enum(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_create_join_table(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_create_table(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_disable_extension(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_drop_enum(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_drop_join_table(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_drop_table(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_enable_extension(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_execute_block(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_check_constraint(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_column(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_exclusion_constraint(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_foreign_key(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_index(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_reference(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_timestamps(args, &block); end

  # source://activerecord//lib/active_record/migration/command_recorder.rb#170
  def invert_remove_unique_constraint(args, &block); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#5
module ActiveRecord::Migration::Compatibility
  class << self
    # source://activerecord//lib/active_record/migration/compatibility.rb#6
    def find(version); end
  end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#405
class ActiveRecord::Migration::Compatibility::V4_2 < ::ActiveRecord::Migration::Compatibility::V5_0
  # source://activerecord//lib/active_record/migration/compatibility.rb#423
  def add_belongs_to(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#423
  def add_reference(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#429
  def add_timestamps(table_name, **options); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration/compatibility.rb#434
  def index_exists?(table_name, column_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#445
  def remove_index(table_name, column_name = T.unsafe(nil), **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#451
  def compatible_table_definition(t); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#458
  def index_name_for_remove(table_name, column_name, options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#406
module ActiveRecord::Migration::Compatibility::V4_2::TableDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#407
  def belongs_to(*_arg0, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#407
  def references(*_arg0, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#413
  def timestamps(**options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#419
  def raise_on_if_exist_options(options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#336
class ActiveRecord::Migration::Compatibility::V5_0 < ::ActiveRecord::Migration::Compatibility::V5_1
  # source://activerecord//lib/active_record/migration/compatibility.rb#391
  def add_belongs_to(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#381
  def add_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#391
  def add_reference(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#376
  def create_join_table(table_1, table_2, column_options: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#353
  def create_table(table_name, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#397
  def compatible_table_definition(t); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#337
module ActiveRecord::Migration::Compatibility::V5_0::TableDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#343
  def belongs_to(*args, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#338
  def primary_key(name, type = T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#343
  def references(*args, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#349
  def raise_on_if_exist_options(options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#315
class ActiveRecord::Migration::Compatibility::V5_1 < ::ActiveRecord::Migration::Compatibility::V5_2
  # source://activerecord//lib/active_record/migration/compatibility.rb#316
  def change_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#327
  def create_table(table_name, **options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#259
class ActiveRecord::Migration::Compatibility::V5_2 < ::ActiveRecord::Migration::Compatibility::V6_0
  # source://activerecord//lib/active_record/migration/compatibility.rb#293
  def add_timestamps(table_name, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#306
  def command_recorder; end

  # source://activerecord//lib/active_record/migration/compatibility.rb#299
  def compatible_table_definition(t); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#279
module ActiveRecord::Migration::Compatibility::V5_2::CommandRecorder
  # source://activerecord//lib/active_record/migration/compatibility.rb#284
  def invert_change_column_comment(args); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#288
  def invert_change_table_comment(args); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#280
  def invert_transaction(args, &block); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#260
module ActiveRecord::Migration::Compatibility::V5_2::TableDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#266
  def column(name, type, index: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#261
  def timestamps(**options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#275
  def raise_on_duplicate_column(name); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#272
  def raise_on_if_exist_options(options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#216
class ActiveRecord::Migration::Compatibility::V6_0 < ::ActiveRecord::Migration::Compatibility::V6_1
  # source://activerecord//lib/active_record/migration/compatibility.rb#240
  def add_belongs_to(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#240
  def add_reference(table_name, ref_name, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#251
  def compatible_table_definition(t); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#217
class ActiveRecord::Migration::Compatibility::V6_0::ReferenceDefinition < ::ActiveRecord::ConnectionAdapters::ReferenceDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#218
  def index_options(table_name); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#223
module ActiveRecord::Migration::Compatibility::V6_0::TableDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#224
  def belongs_to(*args, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#230
  def column(name, type, index: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#224
  def references(*args, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#236
  def raise_on_if_exist_options(options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#153
class ActiveRecord::Migration::Compatibility::V6_1 < ::ActiveRecord::Migration::Compatibility::V7_0
  # source://activerecord//lib/active_record/migration/compatibility.rb#168
  def add_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#177
  def change_column(table_name, column_name, type, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#208
  def compatible_table_definition(t); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#154
class ActiveRecord::Migration::Compatibility::V6_1::PostgreSQLCompat
  class << self
    # source://activerecord//lib/active_record/migration/compatibility.rb#155
    def compatible_timestamp_type(type, connection); end
  end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#186
module ActiveRecord::Migration::Compatibility::V6_1::TableDefinition
  # source://activerecord//lib/active_record/migration/compatibility.rb#192
  def change(name, type, index: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#197
  def column(name, type, index: T.unsafe(nil), **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#187
  def new_column_definition(name, type, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#203
  def raise_on_if_exist_options(options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#35
class ActiveRecord::Migration::Compatibility::V7_0 < ::ActiveRecord::Migration::Current
  include ::ActiveRecord::Migration::Compatibility::V7_0::LegacyIndexName

  # source://activerecord//lib/active_record/migration/compatibility.rb#100
  def add_belongs_to(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#90
  def add_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#137
  def add_foreign_key(from_table, to_table, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#95
  def add_index(table_name, column_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#100
  def add_reference(table_name, ref_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#118
  def change_column(table_name, column_name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#126
  def change_column_null(table_name, column_name, null, default = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#106
  def create_table(table_name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#130
  def disable_extension(name, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#113
  def rename_table(table_name, new_name, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#145
  def compatible_table_definition(t); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#36
module ActiveRecord::Migration::Compatibility::V7_0::LegacyIndexName
  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration/compatibility.rb#60
  def expression_column_name?(column_name); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#52
  def index_name_options(column_names); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#38
  def legacy_index_name(table_name, options); end
end

# source://activerecord//lib/active_record/migration/compatibility.rb#65
module ActiveRecord::Migration::Compatibility::V7_0::TableDefinition
  include ::ActiveRecord::Migration::Compatibility::V7_0::LegacyIndexName

  # source://activerecord//lib/active_record/migration/compatibility.rb#73
  def change(name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#68
  def column(name, type, **options); end

  # source://activerecord//lib/active_record/migration/compatibility.rb#78
  def index(column_name, **options); end

  private

  # source://activerecord//lib/active_record/migration/compatibility.rb#84
  def raise_on_if_exist_options(options); end
end

# This file exists to ensure that old migrations run the same way they did before a Rails upgrade.
# e.g. if you write a migration on Rails 6.1, then upgrade to Rails 7, the migration should do the same thing to your
# database as it did when you were running Rails 6.1
#
# "Current" is an alias for `ActiveRecord::Migration`, it represents the current Rails version.
# New migration functionality that will never be backward compatible should be added directly to `ActiveRecord::Migration`.
#
# There are classes for each prior Rails version. Each class descends from the *next* Rails version, so:
# 7.0 < 7.1
# 5.2 < 6.0 < 6.1 < 7.0 < 7.1
#
# If you are introducing new migration functionality that should only apply from Rails 7 onward, then you should
# find the class that immediately precedes it (6.1), and override the relevant migration methods to undo your changes.
#
# For example, Rails 6 added a default value for the `precision` option on datetime columns. So in this file, the `V5_2`
# class sets the value of `precision` to `nil` if it's not explicitly provided. This way, the default value will not apply
# for migrations written for 5.2, but will for migrations written for 6.0.
#
# source://activerecord//lib/active_record/migration/compatibility.rb#33
ActiveRecord::Migration::Compatibility::V7_1 = ActiveRecord::Migration::Current

# This must be defined before the inherited hook, below
#
# source://activerecord//lib/active_record/migration.rb#563
class ActiveRecord::Migration::Current < ::ActiveRecord::Migration
  # source://activerecord//lib/active_record/migration.rb#572
  def change_table(table_name, **options); end

  # source://activerecord//lib/active_record/migration.rb#596
  def compatible_table_definition(t); end

  # source://activerecord//lib/active_record/migration.rb#580
  def create_join_table(table_1, table_2, **options); end

  # source://activerecord//lib/active_record/migration.rb#564
  def create_table(table_name, **options); end

  # source://activerecord//lib/active_record/migration.rb#588
  def drop_table(table_name, **options); end
end

# The default strategy for executing migrations. Delegates method calls
# to the connection adapter.
#
# source://activerecord//lib/active_record/migration/default_strategy.rb#7
class ActiveRecord::Migration::DefaultStrategy < ::ActiveRecord::Migration::ExecutionStrategy
  private

  # source://activerecord//lib/active_record/migration/default_strategy.rb#18
  def connection; end

  # source://activerecord//lib/active_record/migration/default_strategy.rb#9
  def method_missing(method, *arguments, **_arg2, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration/default_strategy.rb#14
  def respond_to_missing?(method, *_arg1); end
end

# ExecutionStrategy is used by the migration to respond to any method calls
# that the migration class does not implement directly. This is the base strategy.
# All strategies should inherit from this class.
#
# The ExecutionStrategy receives the current +migration+ when initialized.
#
# source://activerecord//lib/active_record/migration/execution_strategy.rb#10
class ActiveRecord::Migration::ExecutionStrategy
  # @return [ExecutionStrategy] a new instance of ExecutionStrategy
  #
  # source://activerecord//lib/active_record/migration/execution_strategy.rb#11
  def initialize(migration); end

  private

  # Returns the value of attribute migration.
  #
  # source://activerecord//lib/active_record/migration/execution_strategy.rb#16
  def migration; end
end

# source://activerecord//lib/active_record/migration/join_table.rb#5
module ActiveRecord::Migration::JoinTable
  private

  # source://activerecord//lib/active_record/migration/join_table.rb#7
  def find_join_table_name(table_1, table_2, options = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration/join_table.rb#11
  def join_table_name(table_1, table_2); end
end

# source://activerecord//lib/active_record/migration.rb#621
ActiveRecord::Migration::MigrationFilenameRegexp = T.let(T.unsafe(nil), Regexp)

# source://activerecord//lib/active_record/migration.rb#868
class ActiveRecord::Migration::ReversibleBlockHelper < ::Struct
  # source://activerecord//lib/active_record/migration.rb#873
  def down; end

  # Returns the value of attribute reverting
  #
  # @return [Object] the current value of reverting
  def reverting; end

  # Sets the attribute reverting
  #
  # @param value [Object] the value to set the attribute reverting to.
  # @return [Object] the newly set value
  def reverting=(_); end

  # source://activerecord//lib/active_record/migration.rb#869
  def up; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# = \Migration \Context
#
# MigrationContext sets the context in which a migration is run.
#
# A migration context requires the path to the migrations is set
# in the +migrations_paths+ parameter. Optionally a +schema_migration+
# class can be provided. Multiple database applications will instantiate
# a +SchemaMigration+ object per database. From the Rake tasks, \Rails will
# handle this for you.
#
# source://activerecord//lib/active_record/migration.rb#1202
class ActiveRecord::MigrationContext
  # @return [MigrationContext] a new instance of MigrationContext
  #
  # source://activerecord//lib/active_record/migration.rb#1205
  def initialize(migrations_paths, schema_migration = T.unsafe(nil), internal_metadata = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#1347
  def current_environment; end

  # source://activerecord//lib/active_record/migration.rb#1303
  def current_version; end

  # source://activerecord//lib/active_record/migration.rb#1277
  def down(target_version = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/migration.rb#1263
  def forward(steps = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#1295
  def get_all_versions; end

  # Returns the value of attribute internal_metadata.
  #
  # source://activerecord//lib/active_record/migration.rb#1203
  def internal_metadata; end

  # @raise [NoEnvironmentInSchemaError]
  #
  # source://activerecord//lib/active_record/migration.rb#1355
  def last_stored_environment; end

  # Runs the migrations in the +migrations_path+.
  #
  # If +target_version+ is +nil+, +migrate+ will run +up+.
  #
  # If the +current_version+ and +target_version+ are both
  # 0 then an empty array will be returned and no migrations
  # will be run.
  #
  # If the +current_version+ in the schema is greater than
  # the +target_version+, then +down+ will be run.
  #
  # If none of the conditions are met, +up+ will be run with
  # the +target_version+.
  #
  # source://activerecord//lib/active_record/migration.rb#1246
  def migrate(target_version = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/migration.rb#1316
  def migrations; end

  # Returns the value of attribute migrations_paths.
  #
  # source://activerecord//lib/active_record/migration.rb#1203
  def migrations_paths; end

  # source://activerecord//lib/active_record/migration.rb#1329
  def migrations_status; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1308
  def needs_migration?; end

  # source://activerecord//lib/active_record/migration.rb#1291
  def open; end

  # source://activerecord//lib/active_record/migration.rb#1312
  def pending_migration_versions; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1351
  def protected_environment?; end

  # source://activerecord//lib/active_record/migration.rb#1259
  def rollback(steps = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#1287
  def run(direction, target_version); end

  # Returns the value of attribute schema_migration.
  #
  # source://activerecord//lib/active_record/migration.rb#1203
  def schema_migration; end

  # source://activerecord//lib/active_record/migration.rb#1267
  def up(target_version = T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/migration.rb#1366
  def connection; end

  # source://activerecord//lib/active_record/migration.rb#1370
  def migration_files; end

  # source://activerecord//lib/active_record/migration.rb#1379
  def move(direction, steps); end

  # source://activerecord//lib/active_record/migration.rb#1375
  def parse_migration_filename(filename); end
end

# source://activerecord//lib/active_record/migration.rb#13
class ActiveRecord::MigrationError < ::ActiveRecord::ActiveRecordError
  # @return [MigrationError] a new instance of MigrationError
  #
  # source://activerecord//lib/active_record/migration.rb#14
  def initialize(message = T.unsafe(nil)); end
end

# MigrationProxy is used to defer loading of the actual migration classes
# until they are needed
#
# source://activerecord//lib/active_record/migration.rb#1168
class ActiveRecord::MigrationProxy < ::Struct
  # @return [MigrationProxy] a new instance of MigrationProxy
  #
  # source://activerecord//lib/active_record/migration.rb#1169
  def initialize(name, version, filename, scope); end

  # source://activerecord//lib/active_record/migration.rb#1178
  def announce(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/migration.rb#1174
  def basename; end

  # source://activerecord//lib/active_record/migration.rb#1178
  def disable_ddl_transaction(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute filename
  #
  # @return [Object] the current value of filename
  def filename; end

  # Sets the attribute filename
  #
  # @param value [Object] the value to set the attribute filename to.
  # @return [Object] the newly set value
  def filename=(_); end

  # source://activerecord//lib/active_record/migration.rb#1178
  def migrate(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  # Returns the value of attribute scope
  #
  # @return [Object] the current value of scope
  def scope; end

  # Sets the attribute scope
  #
  # @param value [Object] the value to set the attribute scope to.
  # @return [Object] the newly set value
  def scope=(_); end

  # Returns the value of attribute version
  #
  # @return [Object] the current value of version
  def version; end

  # Sets the attribute version
  #
  # @param value [Object] the value to set the attribute version to.
  # @return [Object] the newly set value
  def version=(_); end

  # source://activerecord//lib/active_record/migration.rb#1178
  def write(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/migration.rb#1185
  def load_migration; end

  # source://activerecord//lib/active_record/migration.rb#1181
  def migration; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/migration.rb#1399
class ActiveRecord::Migrator
  # @return [Migrator] a new instance of Migrator
  #
  # source://activerecord//lib/active_record/migration.rb#1415
  def initialize(direction, migrations, schema_migration, internal_metadata, target_version = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/migration.rb#1433
  def current; end

  # source://activerecord//lib/active_record/migration.rb#1433
  def current_migration; end

  # source://activerecord//lib/active_record/migration.rb#1429
  def current_version; end

  # source://activerecord//lib/active_record/migration.rb#1478
  def load_migrated; end

  # source://activerecord//lib/active_record/migration.rb#1446
  def migrate; end

  # source://activerecord//lib/active_record/migration.rb#1474
  def migrated; end

  # source://activerecord//lib/active_record/migration.rb#1465
  def migrations; end

  # source://activerecord//lib/active_record/migration.rb#1469
  def pending_migrations; end

  # source://activerecord//lib/active_record/migration.rb#1438
  def run; end

  # source://activerecord//lib/active_record/migration.rb#1454
  def runnable; end

  private

  # source://activerecord//lib/active_record/migration.rb#1483
  def connection; end

  # Wrap the migration in a transaction only if supported by the adapter.
  #
  # source://activerecord//lib/active_record/migration.rb#1578
  def ddl_transaction(migration, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1573
  def down?; end

  # source://activerecord//lib/active_record/migration.rb#1522
  def execute_migration_in_transaction(migration); end

  # source://activerecord//lib/active_record/migration.rb#1543
  def finish; end

  # source://activerecord//lib/active_record/migration.rb#1610
  def generate_migrator_advisory_lock_id; end

  # Return true if a valid version is not provided.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1518
  def invalid_target?; end

  # Used for running multiple migrations up to or down to a certain value.
  #
  # source://activerecord//lib/active_record/migration.rb#1497
  def migrate_without_lock; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1513
  def ran?(migration); end

  # Stores the current environment in the database.
  #
  # source://activerecord//lib/active_record/migration.rb#1507
  def record_environment; end

  # source://activerecord//lib/active_record/migration.rb#1559
  def record_version_state_after_migrating(version); end

  # Used for running a specific migration.
  #
  # @raise [UnknownMigrationVersionError]
  #
  # source://activerecord//lib/active_record/migration.rb#1488
  def run_without_lock; end

  # source://activerecord//lib/active_record/migration.rb#1547
  def start; end

  # source://activerecord//lib/active_record/migration.rb#1539
  def target; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1569
  def up?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1590
  def use_advisory_lock?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/migration.rb#1586
  def use_transaction?(migration); end

  # @raise [DuplicateMigrationNameError]
  #
  # source://activerecord//lib/active_record/migration.rb#1551
  def validate(migrations); end

  # source://activerecord//lib/active_record/migration.rb#1594
  def with_advisory_lock; end

  class << self
    # For cases where a table doesn't exist like loading from schema cache
    #
    # source://activerecord//lib/active_record/migration.rb#1404
    def current_version; end

    # Returns the value of attribute migrations_paths.
    #
    # source://activerecord//lib/active_record/migration.rb#1401
    def migrations_paths; end

    # Sets the attribute migrations_paths
    #
    # @param value the value to set the attribute migrations_paths to.
    #
    # source://activerecord//lib/active_record/migration.rb#1401
    def migrations_paths=(_arg0); end
  end
end

# source://activerecord//lib/active_record/migration.rb#1609
ActiveRecord::Migrator::MIGRATOR_SALT = T.let(T.unsafe(nil), Integer)

# Raised when a foreign key constraint cannot be added because the column type does not match the referenced column type.
#
# source://activerecord//lib/active_record/errors.rb#217
class ActiveRecord::MismatchedForeignKey < ::ActiveRecord::StatementInvalid
  # @return [MismatchedForeignKey] a new instance of MismatchedForeignKey
  #
  # source://activerecord//lib/active_record/errors.rb#218
  def initialize(message: T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), table: T.unsafe(nil), foreign_key: T.unsafe(nil), target_table: T.unsafe(nil), primary_key: T.unsafe(nil), primary_key_column: T.unsafe(nil), query_parser: T.unsafe(nil), connection_pool: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/errors.rb#254
  def set_query(sql, binds); end
end

# source://activerecord//lib/active_record/model_schema.rb#6
module ActiveRecord::ModelSchema
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::ModelSchema::ClassMethods

  class << self
    # Derives the join table name for +first_table+ and +second_table+. The
    # table names appear in alphabetical order. A common prefix is removed
    # (useful for namespaced models like Music::Artist and Music::Record):
    #
    #   artists, records => artists_records
    #   records, artists => artists_records
    #   music_artists, music_records => music_artists_records
    #   music.artists, music.records => music.artists_records
    #
    # source://activerecord//lib/active_record/model_schema.rb#191
    def derive_join_table_name(first_table, second_table); end
  end

  module GeneratedClassMethods
    def immutable_strings_by_default; end
    def immutable_strings_by_default=(value); end
    def immutable_strings_by_default?; end
    def implicit_order_column; end
    def implicit_order_column=(value); end
    def implicit_order_column?; end
    def inheritance_column; end
    def inheritance_column=(value); end
    def inheritance_column?; end
    def internal_metadata_table_name; end
    def internal_metadata_table_name=(value); end
    def internal_metadata_table_name?; end
    def pluralize_table_names; end
    def pluralize_table_names=(value); end
    def pluralize_table_names?; end
    def primary_key_prefix_type; end
    def primary_key_prefix_type=(value); end
    def primary_key_prefix_type?; end
    def schema_migrations_table_name; end
    def schema_migrations_table_name=(value); end
    def schema_migrations_table_name?; end
    def table_name_prefix; end
    def table_name_prefix=(value); end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix=(value); end
    def table_name_suffix?; end
  end

  module GeneratedInstanceMethods
    def pluralize_table_names; end
    def pluralize_table_names?; end
    def primary_key_prefix_type; end
    def primary_key_prefix_type?; end
    def table_name_prefix; end
    def table_name_prefix?; end
    def table_name_suffix; end
    def table_name_suffix?; end
  end
end

# source://activerecord//lib/active_record/model_schema.rb#195
module ActiveRecord::ModelSchema::ClassMethods
  # source://activerecord//lib/active_record/model_schema.rb#498
  def _default_attributes; end

  # source://activerecord//lib/active_record/model_schema.rb#434
  def _returning_columns_for_insert; end

  # source://activerecord//lib/active_record/model_schema.rb#440
  def attribute_types; end

  # source://activerecord//lib/active_record/model_schema.rb#416
  def attributes_builder; end

  # Returns a hash where the keys are column names and the values are
  # default values when instantiating the Active Record object for this table.
  #
  # source://activerecord//lib/active_record/model_schema.rb#493
  def column_defaults; end

  # Returns the column object for the named attribute.
  # Returns an ActiveRecord::ConnectionAdapters::NullColumn if the
  # named attribute does not exist.
  #
  #   class Person < ActiveRecord::Base
  #   end
  #
  #   person = Person.new
  #   person.column_for_attribute(:name) # the result depends on the ConnectionAdapter
  #   # => #<ActiveRecord::ConnectionAdapters::Column:0x007ff4ab083980 @name="name", @sql_type="varchar(255)", @null=true, ...>
  #
  #   person.column_for_attribute(:nothing)
  #   # => #<ActiveRecord::ConnectionAdapters::NullColumn:0xXXX @name=nil, @sql_type=nil, @cast_type=#<Type::Value>, ...>
  #
  # source://activerecord//lib/active_record/model_schema.rb#484
  def column_for_attribute(name); end

  # Returns an array of column names as strings.
  #
  # source://activerecord//lib/active_record/model_schema.rb#504
  def column_names; end

  # source://activerecord//lib/active_record/model_schema.rb#429
  def columns; end

  # source://activerecord//lib/active_record/model_schema.rb#424
  def columns_hash; end

  # Returns an array of column objects where the primary id, all columns ending in "_id" or "_count",
  # and columns used for single table inheritance have been removed.
  #
  # source://activerecord//lib/active_record/model_schema.rb#515
  def content_columns; end

  # source://activerecord//lib/active_record/model_schema.rb#298
  def full_table_name_prefix; end

  # source://activerecord//lib/active_record/model_schema.rb#302
  def full_table_name_suffix; end

  # The list of columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  #
  # source://activerecord//lib/active_record/model_schema.rb#327
  def ignored_columns; end

  # Sets the columns names the model should ignore. Ignored columns won't have attribute
  # accessors defined, and won't be referenced in SQL queries.
  #
  # A common usage pattern for this method is to ensure all references to an attribute
  # have been removed and deployed, before a migration to drop the column from the database
  # has been deployed and run. Using this two step approach to dropping columns ensures there
  # is no code that raises errors due to having a cached schema in memory at the time the
  # schema migration is run.
  #
  # For example, given a model where you want to drop the "category" attribute, first mark it
  # as ignored:
  #
  #   class Project < ActiveRecord::Base
  #     # schema:
  #     #   id         :bigint
  #     #   name       :string, limit: 255
  #     #   category   :string, limit: 255
  #
  #     self.ignored_columns += [:category]
  #   end
  #
  # The schema still contains "category", but now the model omits it, so any meta-driven code or
  # schema caching will not attempt to use the column:
  #
  #   Project.columns_hash["category"] => nil
  #
  # You will get an error if accessing that attribute directly, so ensure all usages of the
  # column are removed (automated tests can help you find any usages).
  #
  #   user = Project.create!(name: "First Project")
  #   user.category # => raises NoMethodError
  #
  # source://activerecord//lib/active_record/model_schema.rb#362
  def ignored_columns=(columns); end

  # source://activerecord//lib/active_record/model_schema.rb#558
  def load_schema; end

  # Returns the next value that will be used as the primary key on
  # an insert statement.
  #
  # source://activerecord//lib/active_record/model_schema.rb#407
  def next_sequence_value; end

  # Determines if the primary key values should be selected from their
  # corresponding sequence before the insert statement.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/model_schema.rb#401
  def prefetch_primary_key?; end

  # The array of names of environments where destructive actions should be prohibited. By default,
  # the value is <tt>["production"]</tt>.
  #
  # source://activerecord//lib/active_record/model_schema.rb#308
  def protected_environments; end

  # Sets an array of names of environments where destructive actions should be prohibited.
  #
  # source://activerecord//lib/active_record/model_schema.rb#317
  def protected_environments=(environments); end

  # Returns a quoted version of the table name, used to construct SQL statements.
  #
  # source://activerecord//lib/active_record/model_schema.rb#281
  def quoted_table_name; end

  # source://activerecord//lib/active_record/model_schema.rb#321
  def real_inheritance_column=(value); end

  # Resets all the cached information about columns, which will cause them
  # to be reloaded on the next request.
  #
  # The most common usage pattern for this method is probably in a migration,
  # when just after creating a table you want to populate it with some default
  # values, e.g.:
  #
  #  class CreateJobLevels < ActiveRecord::Migration[7.1]
  #    def up
  #      create_table :job_levels do |t|
  #        t.integer :id
  #        t.string :name
  #
  #        t.timestamps
  #      end
  #
  #      JobLevel.reset_column_information
  #      %w{assistant executive manager director}.each do |type|
  #        JobLevel.create(name: type)
  #      end
  #    end
  #
  #    def down
  #      drop_table :job_levels
  #    end
  #  end
  #
  # source://activerecord//lib/active_record/model_schema.rb#549
  def reset_column_information; end

  # source://activerecord//lib/active_record/model_schema.rb#375
  def reset_sequence_name; end

  # Computes the table name, (re)sets it internally, and returns it.
  #
  # source://activerecord//lib/active_record/model_schema.rb#286
  def reset_table_name; end

  # source://activerecord//lib/active_record/model_schema.rb#367
  def sequence_name; end

  # Sets the name of the sequence to use when generating ids to the given
  # value, or (if the value is +nil+ or +false+) to the value returned by the
  # given block. This is required for Oracle and is useful for any
  # database which relies on sequences for primary key generation.
  #
  # If a sequence name is not explicitly set when using Oracle,
  # it will default to the commonly used pattern of: #{table_name}_seq
  #
  # If a sequence name is not explicitly set when using PostgreSQL, it
  # will discover the sequence corresponding to your primary key for you.
  #
  #   class Project < ActiveRecord::Base
  #     self.sequence_name = "projectseq"   # default would have been "project_seq"
  #   end
  #
  # source://activerecord//lib/active_record/model_schema.rb#394
  def sequence_name=(value); end

  # source://activerecord//lib/active_record/model_schema.rb#508
  def symbol_column_to_string(name_symbol); end

  # Indicates whether the table associated with this class exists
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/model_schema.rb#412
  def table_exists?; end

  # Guesses the table name (in forced lower-case) based on the name of the class in the
  # inheritance hierarchy descending directly from ActiveRecord::Base. So if the hierarchy
  # looks like: Reply < Message < ActiveRecord::Base, then Message is used
  # to guess the table name even when called on Reply. The rules used to do the guess
  # are handled by the Inflector class in Active Support, which knows almost all common
  # English inflections. You can add new inflections in config/initializers/inflections.rb.
  #
  # Nested classes are given table names prefixed by the singular form of
  # the parent's table name. Enclosing modules are not considered.
  #
  # ==== Examples
  #
  #   class Invoice < ActiveRecord::Base
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice             invoices
  #
  #   class Invoice < ActiveRecord::Base
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice.rb            Invoice::Lineitem   invoice_lineitems
  #
  #   module Invoice
  #     class Lineitem < ActiveRecord::Base
  #     end
  #   end
  #
  #   file                  class               table_name
  #   invoice/lineitem.rb   Invoice::Lineitem   lineitems
  #
  # Additionally, the class-level +table_name_prefix+ is prepended and the
  # +table_name_suffix+ is appended. So if you have "myapp_" as a prefix,
  # the table name guess for an Invoice class becomes "myapp_invoices".
  # Invoice::Lineitem becomes "myapp_invoice_lineitems".
  #
  # Active Model Naming's +model_name+ is the base name used to guess the
  # table name. In case a custom Active Model Name is defined, it will be
  # used for the table name as well:
  #
  #   class PostRecord < ActiveRecord::Base
  #     class << self
  #       def model_name
  #         ActiveModel::Name.new(self, nil, "Post")
  #       end
  #     end
  #   end
  #
  #   PostRecord.table_name
  #   # => "posts"
  #
  # You can also set your own table name explicitly:
  #
  #   class Mouse < ActiveRecord::Base
  #     self.table_name = "mice"
  #   end
  #
  # source://activerecord//lib/active_record/model_schema.rb#255
  def table_name; end

  # Sets the table name explicitly. Example:
  #
  #   class Project < ActiveRecord::Base
  #     self.table_name = "project"
  #   end
  #
  # source://activerecord//lib/active_record/model_schema.rb#265
  def table_name=(value); end

  # Returns the type of the attribute with the given name, after applying
  # all modifiers. This method is the only valid source of information for
  # anything related to the types of a model's attributes. This method will
  # access the database and load the model's schema if it is required.
  #
  # The return value of this method will implement the interface described
  # by ActiveModel::Type::Value (though the object itself may not subclass
  # it).
  #
  # +attr_name+ The name of the attribute to retrieve the type for. Must be
  # a string or a symbol.
  #
  # source://activerecord//lib/active_record/model_schema.rb#460
  def type_for_attribute(attr_name, &block); end

  # source://activerecord//lib/active_record/model_schema.rb#445
  def yaml_encoder; end

  protected

  # source://activerecord//lib/active_record/model_schema.rb#573
  def initialize_load_schema_monitor; end

  # source://activerecord//lib/active_record/model_schema.rb#577
  def reload_schema_from_cache(recursive = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/model_schema.rb#657
  def _convert_type_from_options(type); end

  # Computes and returns a table name according to default conventions.
  #
  # source://activerecord//lib/active_record/model_schema.rb#641
  def compute_table_name; end

  # source://activerecord//lib/active_record/model_schema.rb#600
  def inherited(child_class); end

  # source://activerecord//lib/active_record/model_schema.rb#613
  def load_schema!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/model_schema.rb#609
  def schema_loaded?; end

  # Guesses the table name, but does not decorate it with prefix and suffix information.
  #
  # source://activerecord//lib/active_record/model_schema.rb#635
  def undecorated_table_name(model_name); end
end

# Raised when there are multiple errors while doing a mass assignment through the
# {ActiveRecord::Base#attributes=}[rdoc-ref:AttributeAssignment#attributes=]
# method. The exception has an +errors+ property that contains an array of AttributeAssignmentError
# objects, each corresponding to the error while assigning to an attribute.
#
# source://activerecord//lib/active_record/errors.rb#436
class ActiveRecord::MultiparameterAssignmentErrors < ::ActiveRecord::ActiveRecordError
  # @return [MultiparameterAssignmentErrors] a new instance of MultiparameterAssignmentErrors
  #
  # source://activerecord//lib/active_record/errors.rb#439
  def initialize(errors = T.unsafe(nil)); end

  # Returns the value of attribute errors.
  #
  # source://activerecord//lib/active_record/errors.rb#437
  def errors; end
end

# source://activerecord//lib/active_record/nested_attributes.rb#8
module ActiveRecord::NestedAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::NestedAttributes::ClassMethods

  # Returns ActiveRecord::AutosaveAssociation#marked_for_destruction? It's
  # used in conjunction with fields_for to build a form element for the
  # destruction of this association.
  #
  # See ActionView::Helpers::FormHelper#fields_for for more info.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#401
  def _destroy; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#606
  def allow_destroy?(association_name); end

  # Assigns the given attributes to the collection association.
  #
  # Hashes with an <tt>:id</tt> value matching an existing associated record
  # will update that record. Hashes without an <tt>:id</tt> value will build
  # a new record for the association. Hashes with a matching <tt>:id</tt>
  # value and a <tt>:_destroy</tt> key set to a truthy value will mark the
  # matched record for destruction.
  #
  # For example:
  #
  #   assign_nested_attributes_for_collection_association(:people, {
  #     '1' => { id: '1', name: 'Peter' },
  #     '2' => { name: 'John' },
  #     '3' => { id: '2', _destroy: true }
  #   })
  #
  # Will update the name of the Person with ID 1, build a new associated
  # person with the name 'John', and mark the associated Person with ID 2
  # for destruction.
  #
  # Also accepts an Array of attribute hashes:
  #
  #   assign_nested_attributes_for_collection_association(:people, [
  #     { id: '1', name: 'Peter' },
  #     { name: 'John' },
  #     { id: '2', _destroy: true }
  #   ])
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#482
  def assign_nested_attributes_for_collection_association(association_name, attributes_collection); end

  # Assigns the given attributes to the association.
  #
  # If an associated record does not yet exist, one will be instantiated. If
  # an associated record already exists, the method's behavior depends on
  # the value of the update_only option. If update_only is +false+ and the
  # given attributes include an <tt>:id</tt> that matches the existing record's
  # id, then the existing record will be modified. If no <tt>:id</tt> is provided
  # it will be replaced with a new record. If update_only is +true+ the existing
  # record will be modified regardless of whether an <tt>:id</tt> is provided.
  #
  # If the given attributes include a matching <tt>:id</tt> attribute, or
  # update_only is true, and a <tt>:_destroy</tt> key set to a truthy value,
  # then the existing record will be marked for destruction.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#423
  def assign_nested_attributes_for_one_to_one_association(association_name, attributes); end

  # Updates a record with the +attributes+ or marks it for destruction if
  # +allow_destroy+ is +true+ and has_destroy_flag? returns +true+.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#568
  def assign_to_or_mark_for_destruction(record, attributes, allow_destroy); end

  # Determines if a record with the particular +attributes+ should be
  # rejected by calling the reject_if Symbol or Proc (if defined).
  # The reject_if option is defined by +accepts_nested_attributes_for+.
  #
  # Returns false if there is a +destroy_flag+ on the attributes.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#590
  def call_reject_if(association_name, attributes); end

  # Takes in a limit and checks if the attributes_collection has too many
  # records. It accepts limit in the form of symbol, proc, or
  # number-like object (anything that can be compared with an integer).
  #
  # Raises TooManyRecords error if the attributes_collection is
  # larger than the limit.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#548
  def check_record_limit!(limit, attributes_collection); end

  # Determines if a hash contains a truthy _destroy key.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#574
  def has_destroy_flag?(hash); end

  # @raise [RecordNotFound]
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#610
  def raise_nested_attributes_record_not_found!(association_name, record_id); end

  # Determines if a new record should be rejected by checking
  # has_destroy_flag? or if a <tt>:reject_if</tt> proc exists for this
  # association and evaluates to +true+.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#581
  def reject_new_record?(association_name, attributes); end

  # Only take into account the destroy flag if <tt>:allow_destroy</tt> is true
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#602
  def will_be_destroyed?(association_name, attributes); end

  module GeneratedClassMethods
    def nested_attributes_options; end
    def nested_attributes_options=(value); end
    def nested_attributes_options?; end
  end

  module GeneratedInstanceMethods
    def nested_attributes_options; end
    def nested_attributes_options?; end
  end
end

# = Active Record Nested \Attributes
#
# Nested attributes allow you to save attributes on associated records
# through the parent. By default nested attribute updating is turned off
# and you can enable it using the accepts_nested_attributes_for class
# method. When you enable nested attributes an attribute writer is
# defined on the model.
#
# The attribute writer is named after the association, which means that
# in the following example, two new methods are added to your model:
#
# <tt>author_attributes=(attributes)</tt> and
# <tt>pages_attributes=(attributes)</tt>.
#
#   class Book < ActiveRecord::Base
#     has_one :author
#     has_many :pages
#
#     accepts_nested_attributes_for :author, :pages
#   end
#
# Note that the <tt>:autosave</tt> option is automatically enabled on every
# association that accepts_nested_attributes_for is used for.
#
# === One-to-one
#
# Consider a Member model that has one Avatar:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#   end
#
# Enabling nested attributes on a one-to-one association allows you to
# create the member and avatar in one go:
#
#   params = { member: { name: 'Jack', avatar_attributes: { icon: 'smiling' } } }
#   member = Member.create(params[:member])
#   member.avatar.id # => 2
#   member.avatar.icon # => 'smiling'
#
# It also allows you to update the avatar through the member:
#
#   params = { member: { avatar_attributes: { id: '2', icon: 'sad' } } }
#   member.update params[:member]
#   member.avatar.icon # => 'sad'
#
# If you want to update the current avatar without providing the id, you must add <tt>:update_only</tt> option.
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar, update_only: true
#   end
#
#   params = { member: { avatar_attributes: { icon: 'sad' } } }
#   member.update params[:member]
#   member.avatar.id # => 2
#   member.avatar.icon # => 'sad'
#
# By default you will only be able to set and update attributes on the
# associated model. If you want to destroy the associated model through the
# attributes hash, you have to enable it first using the
# <tt>:allow_destroy</tt> option.
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar, allow_destroy: true
#   end
#
# Now, when you add the <tt>_destroy</tt> key to the attributes hash, with a
# value that evaluates to +true+, you will destroy the associated model:
#
#   member.avatar_attributes = { id: '2', _destroy: '1' }
#   member.avatar.marked_for_destruction? # => true
#   member.save
#   member.reload.avatar # => nil
#
# Note that the model will _not_ be destroyed until the parent is saved.
#
# Also note that the model will not be destroyed unless you also specify
# its id in the updated hash.
#
# === One-to-many
#
# Consider a member that has a number of posts:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts
#   end
#
# You can now set or update attributes on the associated posts through
# an attribute hash for a member: include the key +:posts_attributes+
# with an array of hashes of post attributes as a value.
#
# For each hash that does _not_ have an <tt>id</tt> key a new record will
# be instantiated, unless the hash also contains a <tt>_destroy</tt> key
# that evaluates to +true+.
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '', _destroy: '1' } # this will be ignored
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# You may also set a +:reject_if+ proc to silently ignore any new record
# hashes if they fail to pass your criteria. For example, the previous
# example could be rewritten as:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: proc { |attributes| attributes['title'].blank? }
#   end
#
#   params = { member: {
#     name: 'joe', posts_attributes: [
#       { title: 'Kari, the awesome Ruby documentation browser!' },
#       { title: 'The egalitarian assumption of the modern citizen' },
#       { title: '' } # this will be ignored because of the :reject_if proc
#     ]
#   }}
#
#   member = Member.create(params[:member])
#   member.posts.length # => 2
#   member.posts.first.title # => 'Kari, the awesome Ruby documentation browser!'
#   member.posts.second.title # => 'The egalitarian assumption of the modern citizen'
#
# Alternatively, +:reject_if+ also accepts a symbol for using methods:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :new_record?
#   end
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, reject_if: :reject_posts
#
#     def reject_posts(attributes)
#       attributes['title'].blank?
#     end
#   end
#
# If the hash contains an <tt>id</tt> key that matches an already
# associated record, the matching record will be modified:
#
#   member.attributes = {
#     name: 'Joe',
#     posts_attributes: [
#       { id: 1, title: '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!' },
#       { id: 2, title: '[UPDATED] other post' }
#     ]
#   }
#
#   member.posts.first.title # => '[UPDATED] An, as of yet, undisclosed awesome Ruby documentation browser!'
#   member.posts.second.title # => '[UPDATED] other post'
#
# However, the above applies if the parent model is being updated as well.
# For example, if you wanted to create a +member+ named _joe_ and wanted to
# update the +posts+ at the same time, that would give an
# ActiveRecord::RecordNotFound error.
#
# By default the associated records are protected from being destroyed. If
# you want to destroy any of the associated records through the attributes
# hash, you have to enable it first using the <tt>:allow_destroy</tt>
# option. This will allow you to also use the <tt>_destroy</tt> key to
# destroy existing records:
#
#   class Member < ActiveRecord::Base
#     has_many :posts
#     accepts_nested_attributes_for :posts, allow_destroy: true
#   end
#
#   params = { member: {
#     posts_attributes: [{ id: '2', _destroy: '1' }]
#   }}
#
#   member.attributes = params[:member]
#   member.posts.detect { |p| p.id == 2 }.marked_for_destruction? # => true
#   member.posts.length # => 2
#   member.save
#   member.reload.posts.length # => 1
#
# Nested attributes for an associated collection can also be passed in
# the form of a hash of hashes instead of an array of hashes:
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: {
#       first:  { title: 'Foo' },
#       second: { title: 'Bar' }
#     }
#   )
#
# has the same effect as
#
#   Member.create(
#     name: 'joe',
#     posts_attributes: [
#       { title: 'Foo' },
#       { title: 'Bar' }
#     ]
#   )
#
# The keys of the hash which is the value for +:posts_attributes+ are
# ignored in this case.
# However, it is not allowed to use <tt>'id'</tt> or <tt>:id</tt> for one of
# such keys, otherwise the hash will be wrapped in an array and
# interpreted as an attribute hash for a single post.
#
# Passing attributes for an associated collection in the form of a hash
# of hashes can be used with hashes generated from HTTP/HTML parameters,
# where there may be no natural way to submit an array of hashes.
#
# === Saving
#
# All changes to models, including the destruction of those marked for
# destruction, are saved and destroyed automatically and atomically when
# the parent model is saved. This happens inside the transaction initiated
# by the parent's save method. See ActiveRecord::AutosaveAssociation.
#
# === Validating the presence of a parent model
#
# The +belongs_to+ association validates the presence of the parent model
# by default. You can disable this behavior by specifying <code>optional: true</code>.
# This can be used, for example, when conditionally validating the presence
# of the parent model:
#
#   class Veterinarian < ActiveRecord::Base
#     has_many :patients, inverse_of: :veterinarian
#     accepts_nested_attributes_for :patients
#   end
#
#   class Patient < ActiveRecord::Base
#     belongs_to :veterinarian, inverse_of: :patients, optional: true
#     validates :veterinarian, presence: true, unless: -> { awaiting_intake }
#   end
#
# Note that if you do not specify the +:inverse_of+ option, then
# Active Record will try to automatically guess the inverse association
# based on heuristics.
#
# For one-to-one nested associations, if you build the new (in-memory)
# child object yourself before assignment, then this module will not
# overwrite it, e.g.:
#
#   class Member < ActiveRecord::Base
#     has_one :avatar
#     accepts_nested_attributes_for :avatar
#
#     def avatar
#       super || build_avatar(width: 200)
#     end
#   end
#
#   member = Member.new
#   member.avatar_attributes = {icon: 'sad'}
#   member.avatar.width # => 200
#
# === Creating forms with nested attributes
#
# Use ActionView::Helpers::FormHelper#fields_for to create form elements for
# nested attributes.
#
# Integration test params should reflect the structure of the form. For
# example:
#
#   post members_path, params: {
#     member: {
#       name: 'joe',
#       posts_attributes: {
#         '0' => { title: 'Foo' },
#         '1' => { title: 'Bar' }
#       }
#     }
#   }
#
# source://activerecord//lib/active_record/nested_attributes.rb#301
module ActiveRecord::NestedAttributes::ClassMethods
  # Defines an attributes writer for the specified association(s).
  #
  # Supported options:
  # [:allow_destroy]
  #   If true, destroys any members from the attributes hash with a
  #   <tt>_destroy</tt> key and a value that evaluates to +true+
  #   (e.g. 1, '1', true, or 'true'). This option is false by default.
  # [:reject_if]
  #   Allows you to specify a Proc or a Symbol pointing to a method
  #   that checks whether a record should be built for a certain attribute
  #   hash. The hash is passed to the supplied Proc or the method
  #   and it should return either +true+ or +false+. When no +:reject_if+
  #   is specified, a record will be built for all attribute hashes that
  #   do not have a <tt>_destroy</tt> value that evaluates to true.
  #   Passing <tt>:all_blank</tt> instead of a Proc will create a proc
  #   that will reject a record where all the attributes are blank excluding
  #   any value for +_destroy+.
  # [:limit]
  #   Allows you to specify the maximum number of associated records that
  #   can be processed with the nested attributes. Limit also can be specified
  #   as a Proc or a Symbol pointing to a method that should return a number.
  #   If the size of the nested attributes array exceeds the specified limit,
  #   NestedAttributes::TooManyRecords exception is raised. If omitted, any
  #   number of associations can be processed.
  #   Note that the +:limit+ option is only applicable to one-to-many
  #   associations.
  # [:update_only]
  #   For a one-to-one association, this option allows you to specify how
  #   nested attributes are going to be used when an associated record already
  #   exists. In general, an existing record may either be updated with the
  #   new set of attribute values or be replaced by a wholly new record
  #   containing those values. By default the +:update_only+ option is false
  #   and the nested attributes are used to update the existing record only
  #   if they include the record's <tt>:id</tt> value. Otherwise a new
  #   record will be instantiated and used to replace the existing one.
  #   However if the +:update_only+ option is true, the nested attributes
  #   are used to update the record's attributes always, regardless of
  #   whether the <tt>:id</tt> is present. The option is ignored for collection
  #   associations.
  #
  # Examples:
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: proc { |attributes| attributes['name'].blank? }
  #   # creates avatar_attributes=
  #   accepts_nested_attributes_for :avatar, reject_if: :all_blank
  #   # creates avatar_attributes= and posts_attributes=
  #   accepts_nested_attributes_for :avatar, :posts, allow_destroy: true
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#351
  def accepts_nested_attributes_for(*attr_names); end

  private

  # Generates a writer method for this association. Serves as a point for
  # accessing the objects in the association. For example, this method
  # could generate the following:
  #
  #   def pirate_attributes=(attributes)
  #     assign_nested_attributes_for_one_to_one_association(:pirate, attributes)
  #   end
  #
  # This redirects the attempts to write objects in an association through
  # the helper methods defined below. Makes it seem like the nested
  # associations are just regular associations.
  #
  # source://activerecord//lib/active_record/nested_attributes.rb#386
  def generate_association_writer(association_name, type); end
end

# source://activerecord//lib/active_record/nested_attributes.rb#302
ActiveRecord::NestedAttributes::ClassMethods::REJECT_ALL_BLANK_PROC = T.let(T.unsafe(nil), Proc)

# source://activerecord//lib/active_record/nested_attributes.rb#9
class ActiveRecord::NestedAttributes::TooManyRecords < ::ActiveRecord::ActiveRecordError; end

# Attribute hash keys that should not be assigned as normal attributes.
# These hash keys are nested attributes implementation details.
#
# source://activerecord//lib/active_record/nested_attributes.rb#408
ActiveRecord::NestedAttributes::UNASSIGNABLE_KEYS = T.let(T.unsafe(nil), Array)

# Raised when a given database does not exist.
#
# source://activerecord//lib/active_record/errors.rb#307
class ActiveRecord::NoDatabaseError < ::ActiveRecord::StatementInvalid
  include ::ActiveSupport::ActionableError
  extend ::ActiveSupport::ActionableError::ClassMethods

  # @return [NoDatabaseError] a new instance of NoDatabaseError
  #
  # source://activerecord//lib/active_record/errors.rb#314
  def initialize(message = T.unsafe(nil), connection_pool: T.unsafe(nil)); end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions; end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions=(_arg0); end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions?; end

  class << self
    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions; end

    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions?; end

    # source://activerecord//lib/active_record/errors.rb#319
    def db_error(db_name); end
  end
end

# source://activerecord//lib/active_record/migration.rb#184
class ActiveRecord::NoEnvironmentInSchemaError < ::ActiveRecord::MigrationError
  # @return [NoEnvironmentInSchemaError] a new instance of NoEnvironmentInSchemaError
  #
  # source://activerecord//lib/active_record/migration.rb#185
  def initialize; end
end

# = Active Record No Touching
#
# source://activerecord//lib/active_record/no_touching.rb#5
module ActiveRecord::NoTouching
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::NoTouching::ClassMethods

  # Returns +true+ if the class has +no_touching+ set, +false+ otherwise.
  #
  #   Project.no_touching do
  #     Project.first.no_touching? # true
  #     Message.first.no_touching? # false
  #   end
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/no_touching.rb#53
  def no_touching?; end

  # source://activerecord//lib/active_record/no_touching.rb#61
  def touch(*_arg0, **_arg1); end

  # source://activerecord//lib/active_record/no_touching.rb#57
  def touch_later(*_arg0); end

  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/no_touching.rb#36
    def applied_to?(klass); end

    # source://activerecord//lib/active_record/no_touching.rb#29
    def apply_to(klass); end

    private

    # source://activerecord//lib/active_record/no_touching.rb#41
    def klasses; end
  end
end

# source://activerecord//lib/active_record/no_touching.rb#8
module ActiveRecord::NoTouching::ClassMethods
  # Lets you selectively disable calls to +touch+ for the
  # duration of a block.
  #
  # ==== Examples
  #   ActiveRecord::Base.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # does nothing
  #   end
  #
  #   Project.no_touching do
  #     Project.first.touch  # does nothing
  #     Message.first.touch  # works, but does not touch the associated project
  #   end
  #
  # source://activerecord//lib/active_record/no_touching.rb#23
  def no_touching(&block); end
end

# source://activerecord//lib/active_record/normalization.rb#4
module ActiveRecord::Normalization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Normalization::ClassMethods

  # Normalizes a specified attribute using its declared normalizations.
  #
  # ==== Examples
  #
  #   class User < ActiveRecord::Base
  #     normalizes :email, with: -> email { email.strip.downcase }
  #   end
  #
  #   legacy_user = User.find(1)
  #   legacy_user.email # => " CRUISE-CONTROL@EXAMPLE.COM\n"
  #   legacy_user.normalize_attribute(:email)
  #   legacy_user.email # => "cruise-control@example.com"
  #   legacy_user.save
  #
  # source://activerecord//lib/active_record/normalization.rb#26
  def normalize_attribute(name); end

  private

  # source://activerecord//lib/active_record/normalization.rb#114
  def normalize_changed_in_place_attributes; end

  module GeneratedClassMethods
    def normalized_attributes; end
    def normalized_attributes=(value); end
    def normalized_attributes?; end
  end

  module GeneratedInstanceMethods
    def normalized_attributes; end
    def normalized_attributes=(value); end
    def normalized_attributes?; end
  end
end

# source://activerecord//lib/active_record/normalization.rb#31
module ActiveRecord::Normalization::ClassMethods
  # Normalizes a given +value+ using normalizations declared for +name+.
  #
  # ==== Examples
  #
  #   class User < ActiveRecord::Base
  #     normalizes :email, with: -> email { email.strip.downcase }
  #   end
  #
  #   User.normalize_value_for(:email, " CRUISE-CONTROL@EXAMPLE.COM\n")
  #   # => "cruise-control@example.com"
  #
  # source://activerecord//lib/active_record/normalization.rb#108
  def normalize_value_for(name, value); end

  # Declares a normalization for one or more attributes. The normalization
  # is applied when the attribute is assigned or updated, and the normalized
  # value will be persisted to the database. The normalization is also
  # applied to the corresponding keyword argument of query methods. This
  # allows a record to be created and later queried using unnormalized
  # values.
  #
  # However, to prevent confusion, the normalization will not be applied
  # when the attribute is fetched from the database. This means that if a
  # record was persisted before the normalization was declared, the record's
  # attribute will not be normalized until either it is assigned a new
  # value, or it is explicitly migrated via Normalization#normalize_attribute.
  #
  # Because the normalization may be applied multiple times, it should be
  # _idempotent_. In other words, applying the normalization more than once
  # should have the same result as applying it only once.
  #
  # By default, the normalization will not be applied to +nil+ values. This
  # behavior can be changed with the +:apply_to_nil+ option.
  #
  # Be aware that if your app was created before Rails 7.1, and your app
  # marshals instances of the targeted model (for example, when caching),
  # then you should set ActiveRecord.marshalling_format_version to +7.1+ or
  # higher via either <tt>config.load_defaults 7.1</tt> or
  # <tt>config.active_record.marshalling_format_version = 7.1</tt>.
  # Otherwise, +Marshal+ may attempt to serialize the normalization +Proc+
  # and raise +TypeError+.
  #
  # ==== Options
  #
  # * +:with+ - Any callable object that accepts the attribute's value as
  #   its sole argument, and returns it normalized.
  # * +:apply_to_nil+ - Whether to apply the normalization to +nil+ values.
  #   Defaults to +false+.
  #
  # ==== Examples
  #
  #   class User < ActiveRecord::Base
  #     normalizes :email, with: -> email { email.strip.downcase }
  #     normalizes :phone, with: -> phone { phone.delete("^0-9").delete_prefix("1") }
  #   end
  #
  #   user = User.create(email: " CRUISE-CONTROL@EXAMPLE.COM\n")
  #   user.email                  # => "cruise-control@example.com"
  #
  #   user = User.find_by(email: "\tCRUISE-CONTROL@EXAMPLE.COM ")
  #   user.email                  # => "cruise-control@example.com"
  #   user.email_before_type_cast # => "cruise-control@example.com"
  #
  #   User.where(email: "\tCRUISE-CONTROL@EXAMPLE.COM ").count         # => 1
  #   User.where(["email = ?", "\tCRUISE-CONTROL@EXAMPLE.COM "]).count # => 0
  #
  #   User.exists?(email: "\tCRUISE-CONTROL@EXAMPLE.COM ")         # => true
  #   User.exists?(["email = ?", "\tCRUISE-CONTROL@EXAMPLE.COM "]) # => false
  #
  #   User.normalize_value_for(:phone, "+1 (555) 867-5309") # => "5558675309"
  #
  # source://activerecord//lib/active_record/normalization.rb#88
  def normalizes(*names, with:, apply_to_nil: T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/normalization.rb#120
class ActiveRecord::Normalization::NormalizedValueType
  include ::ActiveModel::Type::SerializeCastValue
  extend ::ActiveModel::Type::SerializeCastValue::ClassMethods

  # @return [NormalizedValueType] a new instance of NormalizedValueType
  #
  # source://activerecord//lib/active_record/normalization.rb#126
  def initialize(cast_type:, normalizer:, normalize_nil:); end

  # source://activerecord//lib/active_record/normalization.rb#145
  def ==(other); end

  # source://activerecord//lib/active_record/normalization.rb#133
  def cast(value); end

  # Returns the value of attribute cast_type.
  #
  # source://activerecord//lib/active_record/normalization.rb#123
  def cast_type; end

  # source://activerecord//lib/active_record/normalization.rb#145
  def eql?(other); end

  # source://activerecord//lib/active_record/normalization.rb#153
  def hash; end

  # source://activerecord//lib/active_record/normalization.rb#157
  def inspect; end

  # Returns the value of attribute normalize_nil.
  #
  # source://activerecord//lib/active_record/normalization.rb#123
  def normalize_nil; end

  # Returns the value of attribute normalize_nil.
  #
  # source://activerecord//lib/active_record/normalization.rb#123
  def normalize_nil?; end

  # Returns the value of attribute normalizer.
  #
  # source://activerecord//lib/active_record/normalization.rb#123
  def normalizer; end

  # source://activerecord//lib/active_record/normalization.rb#137
  def serialize(value); end

  # source://activerecord//lib/active_record/normalization.rb#141
  def serialize_cast_value(value); end

  private

  # source://activerecord//lib/active_record/normalization.rb#162
  def normalize(value); end
end

# Raised when a record cannot be inserted or updated because it would violate a not null constraint.
#
# source://activerecord//lib/active_record/errors.rb#272
class ActiveRecord::NotNullViolation < ::ActiveRecord::StatementInvalid; end

# source://activerecord//lib/active_record/migration/pending_migration_connection.rb#4
class ActiveRecord::PendingMigrationConnection
  class << self
    # source://activerecord//lib/active_record/migration/pending_migration_connection.rb#17
    def current_preventing_writes; end

    # source://activerecord//lib/active_record/migration/pending_migration_connection.rb#5
    def establish_temporary_connection(db_config, &block); end

    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/migration/pending_migration_connection.rb#13
    def primary_class?; end
  end
end

# source://activerecord//lib/active_record/migration.rb#134
class ActiveRecord::PendingMigrationError < ::ActiveRecord::MigrationError
  include ::ActiveSupport::ActionableError
  extend ::ActiveSupport::ActionableError::ClassMethods

  # @return [PendingMigrationError] a new instance of PendingMigrationError
  #
  # source://activerecord//lib/active_record/migration.rb#146
  def initialize(message = T.unsafe(nil), pending_migrations: T.unsafe(nil)); end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions; end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions=(_arg0); end

  # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
  def _actions?; end

  private

  # source://activerecord//lib/active_record/migration.rb#170
  def connection; end

  # source://activerecord//lib/active_record/migration.rb#156
  def detailed_migration_message(pending_migrations); end

  class << self
    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions; end

    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions=(value); end

    # source://activesupport/7.1.3.2/lib/active_support/actionable_error.rb#17
    def _actions?; end
  end
end

# = Active Record \Persistence
#
# source://activerecord//lib/active_record/persistence.rb#7
module ActiveRecord::Persistence
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Persistence::ClassMethods

  # Returns an instance of the specified +klass+ with the attributes of the
  # current record. This is mostly useful in relation to single table
  # inheritance (STI) structures where you want a subclass to appear as the
  # superclass. This can be used along with record identification in
  # Action Pack to allow, say, <tt>Client < Company</tt> to do something
  # like render <tt>partial: @client.becomes(Company)</tt> to render that
  # instance using the companies/company partial instead of clients/client.
  #
  # Note: The new instance will share a link to the same attributes as the original class.
  # Therefore the STI column value will still be the same.
  # Any change to the attributes on either instance will affect both instances.
  # This includes any attribute initialization done by the new instance.
  #
  # If you want to change the STI column as well, use #becomes! instead.
  #
  # source://activerecord//lib/active_record/persistence.rb#814
  def becomes(klass); end

  # Wrapper around #becomes that also changes the instance's STI column value.
  # This is especially useful if you want to persist the changed class in your
  # database.
  #
  # Note: The old instance's STI column value will be changed too, as both objects
  # share the same set of attributes.
  #
  # source://activerecord//lib/active_record/persistence.rb#835
  def becomes!(klass); end

  # Initializes +attribute+ to zero if +nil+ and subtracts the value passed as +by+ (default is 1).
  # The decrement is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  #
  # source://activerecord//lib/active_record/persistence.rb#982
  def decrement(attribute, by = T.unsafe(nil)); end

  # Wrapper around #decrement that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  #
  # source://activerecord//lib/active_record/persistence.rb#992
  def decrement!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end

  # Deletes the record in the database and freezes this instance to
  # reflect that no changes should be made (since they can't be
  # persisted). Returns the frozen instance.
  #
  # The row is simply removed with an SQL +DELETE+ statement on the
  # record's primary key, and no callbacks are executed.
  #
  # Note that this will also delete records marked as {#readonly?}[rdoc-ref:Core#readonly?].
  #
  # To enforce the object's +before_destroy+ and +after_destroy+
  # callbacks or any <tt>:dependent</tt> association
  # options, use #destroy.
  #
  # source://activerecord//lib/active_record/persistence.rb#766
  def delete; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy returns +false+.
  # See ActiveRecord::Callbacks for further details.
  #
  # source://activerecord//lib/active_record/persistence.rb#780
  def destroy; end

  # Deletes the record in the database and freezes this instance to reflect
  # that no changes should be made (since they can't be persisted).
  #
  # There's a series of callbacks associated with #destroy!. If the
  # <tt>before_destroy</tt> callback throws +:abort+ the action is cancelled
  # and #destroy! raises ActiveRecord::RecordNotDestroyed.
  # See ActiveRecord::Callbacks for further details.
  #
  # source://activerecord//lib/active_record/persistence.rb#796
  def destroy!; end

  # Returns true if this object has been destroyed, otherwise returns false.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#682
  def destroyed?; end

  # Initializes +attribute+ to zero if +nil+ and adds the value passed as +by+ (default is 1).
  # The increment is performed directly on the underlying attribute, no setter is invoked.
  # Only makes sense for number-based attributes. Returns +self+.
  #
  # source://activerecord//lib/active_record/persistence.rb#959
  def increment(attribute, by = T.unsafe(nil)); end

  # Wrapper around #increment that writes the update to the database.
  # Only +attribute+ is updated; the record itself is not saved.
  # This means that any other modified attributes will still be dirty.
  # Validations and callbacks are skipped. Supports the +touch+ option from
  # +update_counters+, see that for more.
  # Returns +self+.
  #
  # source://activerecord//lib/active_record/persistence.rb#971
  def increment!(attribute, by = T.unsafe(nil), touch: T.unsafe(nil)); end

  # Returns true if this object hasn't been saved yet -- that is, a record
  # for the object doesn't exist in the database yet; otherwise, returns false.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#665
  def new_record?; end

  # Returns true if the record is persisted, i.e. it's not a new record and it was
  # not destroyed, otherwise returns false.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#688
  def persisted?; end

  # Returns true if this object was just created -- that is, prior to the last
  # update or delete, the object didn't exist in the database and new_record? would have
  # returned true.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#672
  def previously_new_record?; end

  # Returns true if this object was previously persisted but now it has been deleted.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#677
  def previously_persisted?; end

  # Reloads the record from the database.
  #
  # This method finds the record by its primary key (which could be assigned
  # manually) and modifies the receiver in-place:
  #
  #   account = Account.new
  #   # => #<Account id: nil, email: nil>
  #   account.id = 1
  #   account.reload
  #   # Account Load (1.2ms)  SELECT "accounts".* FROM "accounts" WHERE "accounts"."id" = $1 LIMIT 1  [["id", 1]]
  #   # => #<Account id: 1, email: 'account@example.com'>
  #
  # Attributes are reloaded from the database, and caches busted, in
  # particular the associations cache and the QueryCache.
  #
  # If the record no longer exists in the database ActiveRecord::RecordNotFound
  # is raised. Otherwise, in addition to the in-place modification the method
  # returns +self+ for convenience.
  #
  # The optional <tt>:lock</tt> flag option allows you to lock the reloaded record:
  #
  #   reload(lock: true) # reload with pessimistic locking
  #
  # Reloading is commonly used in test suites to test something is actually
  # written to the database, or when some action modifies the corresponding
  # row in the database but not the object in memory:
  #
  #   assert account.deposit!(25)
  #   assert_equal 25, account.credit        # check it is updated in memory
  #   assert_equal 25, account.reload.credit # check it is also persisted
  #
  # Another common use case is optimistic locking handling:
  #
  #   def with_optimistic_retry
  #     begin
  #       yield
  #     rescue ActiveRecord::StaleObjectError
  #       begin
  #         # Reload lock_version in particular.
  #         reload
  #       rescue ActiveRecord::RecordNotFound
  #         # If the record is gone there is nothing to do.
  #       else
  #         retry
  #       end
  #     end
  #   end
  #
  # source://activerecord//lib/active_record/persistence.rb#1069
  def reload(options = T.unsafe(nil)); end

  # :call-seq:
  #   save(**options)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, save always runs validations. If any of them fail the action
  # is cancelled and #save returns +false+, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save. If any of the
  # <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled and
  # #save returns +false+. See ActiveRecord::Callbacks for further
  # details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  #
  # source://activerecord//lib/active_record/persistence.rb#717
  def save(**options, &block); end

  # :call-seq:
  #   save!(**options)
  #
  # Saves the model.
  #
  # If the model is new, a record gets created in the database, otherwise
  # the existing record gets updated.
  #
  # By default, #save! always runs validations. If any of them fail
  # ActiveRecord::RecordInvalid gets raised, and the record won't be saved. However, if you supply
  # <tt>validate: false</tt>, validations are bypassed altogether. See
  # ActiveRecord::Validations for more information.
  #
  # By default, #save! also sets the +updated_at+/+updated_on+ attributes to
  # the current time. However, if you supply <tt>touch: false</tt>, these
  # timestamps will not be updated.
  #
  # There's a series of callbacks associated with #save!. If any of
  # the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled
  # and #save! raises ActiveRecord::RecordNotSaved. See
  # ActiveRecord::Callbacks for further details.
  #
  # Attributes marked as readonly are silently ignored if the record is
  # being updated.
  #
  # Unless an error is raised, returns true.
  #
  # source://activerecord//lib/active_record/persistence.rb#750
  def save!(**options, &block); end

  # Assigns to +attribute+ the boolean opposite of <tt>attribute?</tt>. So
  # if the predicate returns +true+ the attribute will become +false+. This
  # method toggles directly the underlying value without calling any setter.
  # Returns +self+.
  #
  # Example:
  #
  #   user = User.first
  #   user.banned? # => false
  #   user.toggle(:banned)
  #   user.banned? # => true
  #
  # source://activerecord//lib/active_record/persistence.rb#1008
  def toggle(attribute); end

  # Wrapper around #toggle that saves the record. This method differs from
  # its non-bang version in the sense that it passes through the attribute setter.
  # Saving is not subjected to validation checks. Returns +true+ if the
  # record could be saved.
  #
  # source://activerecord//lib/active_record/persistence.rb#1017
  def toggle!(attribute); end

  # Saves the record with the updated_at/on attributes set to the current time
  # or the time specified.
  # Please note that no validation is performed and only the +after_touch+,
  # +after_commit+ and +after_rollback+ callbacks are executed.
  #
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with updated_at/on
  # attributes. If no time argument is passed, the current time is used as default.
  #
  #   product.touch                         # updates updated_at/on with current time
  #   product.touch(time: Time.new(2015, 2, 16, 0, 0, 0)) # updates updated_at/on with specified time
  #   product.touch(:designed_at)           # updates the designed_at attribute and updated_at/on
  #   product.touch(:started_at, :ended_at) # updates started_at, ended_at and updated_at/on attributes
  #
  # If used along with {belongs_to}[rdoc-ref:Associations::ClassMethods#belongs_to]
  # then +touch+ will invoke +touch+ method on associated object.
  #
  #   class Brake < ActiveRecord::Base
  #     belongs_to :car, touch: true
  #   end
  #
  #   class Car < ActiveRecord::Base
  #     belongs_to :corporation, touch: true
  #   end
  #
  #   # triggers @brake.car.touch and @brake.car.corporation.touch
  #   @brake.touch
  #
  # Note that +touch+ must be used on a persisted object, or else an
  # ActiveRecordError will be thrown. For example:
  #
  #   ball = Ball.new
  #   ball.touch(:updated_at)   # => raises ActiveRecordError
  #
  # source://activerecord//lib/active_record/persistence.rb#1120
  def touch(*names, time: T.unsafe(nil)); end

  # Updates the attributes of the model from the passed-in hash and saves the
  # record, all wrapped in a transaction. If the object is invalid, the saving
  # will fail and false will be returned.
  #
  # source://activerecord//lib/active_record/persistence.rb#890
  def update(attributes); end

  # Updates its receiver just like #update but calls #save! instead
  # of +save+, so an exception is raised if the record is invalid and saving will fail.
  #
  # source://activerecord//lib/active_record/persistence.rb#901
  def update!(attributes); end

  # Updates a single attribute and saves the record.
  # This is especially useful for boolean flags on existing records. Also note that
  #
  # * Validation is skipped.
  # * \Callbacks are invoked.
  # * updated_at/updated_on column is updated if that column is available.
  # * Updates all the attributes that are dirty in this object.
  #
  # This method raises an ActiveRecord::ActiveRecordError if the
  # attribute is marked as readonly.
  #
  # Also see #update_column.
  #
  # source://activerecord//lib/active_record/persistence.rb#857
  def update_attribute(name, value); end

  # Updates a single attribute and saves the record.
  # This is especially useful for boolean flags on existing records. Also note that
  #
  # * Validation is skipped.
  # * \Callbacks are invoked.
  # * updated_at/updated_on column is updated if that column is available.
  # * Updates all the attributes that are dirty in this object.
  #
  # This method raises an ActiveRecord::ActiveRecordError if the
  # attribute is marked as readonly.
  #
  # If any of the <tt>before_*</tt> callbacks throws +:abort+ the action is cancelled
  # and #update_attribute! raises ActiveRecord::RecordNotSaved. See
  # ActiveRecord::Callbacks for further details.
  #
  # source://activerecord//lib/active_record/persistence.rb#879
  def update_attribute!(name, value); end

  # Equivalent to <code>update_columns(name => value)</code>.
  #
  # source://activerecord//lib/active_record/persistence.rb#911
  def update_column(name, value); end

  # Updates the attributes directly in the database issuing an UPDATE SQL
  # statement and sets them in the receiver:
  #
  #   user.update_columns(last_request_at: Time.current)
  #
  # This is the fastest way to update attributes because it goes straight to
  # the database, but take into account that in consequence the regular update
  # procedures are totally bypassed. In particular:
  #
  # * \Validations are skipped.
  # * \Callbacks are skipped.
  # * +updated_at+/+updated_on+ are not updated.
  # * However, attributes are serialized with the same rules as ActiveRecord::Relation#update_all
  #
  # This method raises an ActiveRecord::ActiveRecordError when called on new
  # objects, or when at least one of the attributes is marked as readonly.
  #
  # @raise [ActiveRecordError]
  #
  # source://activerecord//lib/active_record/persistence.rb#931
  def update_columns(attributes); end

  private

  # Creates a record with values matching those of the instance attributes
  # and returns its id.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  #
  # source://activerecord//lib/active_record/persistence.rb#1247
  def _create_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/persistence.rb#1197
  def _delete_row; end

  # source://activerecord//lib/active_record/persistence.rb#1153
  def _find_record(options); end

  # source://activerecord//lib/active_record/persistence.rb#1164
  def _in_memory_query_constraints_hash; end

  # source://activerecord//lib/active_record/persistence.rb#1179
  def _query_constraints_hash; end

  # @raise [ReadOnlyRecord]
  #
  # source://activerecord//lib/active_record/persistence.rb#1281
  def _raise_readonly_record_error; end

  # source://activerecord//lib/active_record/persistence.rb#1273
  def _raise_record_not_destroyed; end

  # @raise [ActiveRecordError]
  #
  # source://activerecord//lib/active_record/persistence.rb#1285
  def _raise_record_not_touched_error; end

  # source://activerecord//lib/active_record/persistence.rb#1201
  def _touch_row(attribute_names, time); end

  # Updates the associated record with values matching those of the instance attributes.
  # Returns the number of affected rows.
  #
  # @yield [_self]
  # @yieldparam _self [ActiveRecord::Persistence] the object that the method was called on
  #
  # source://activerecord//lib/active_record/persistence.rb#1227
  def _update_record(attribute_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/persistence.rb#1211
  def _update_row(attribute_names, attempted_action = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#1174
  def apply_scoping?(options); end

  # source://activerecord//lib/active_record/persistence.rb#1218
  def create_or_update(**_arg0, &block); end

  # A hook to be overridden by association modules.
  #
  # source://activerecord//lib/active_record/persistence.rb#1190
  def destroy_associations; end

  # source://activerecord//lib/active_record/persistence.rb#1193
  def destroy_row; end

  # source://activerecord//lib/active_record/persistence.rb#1141
  def init_internals; end

  # source://activerecord//lib/active_record/persistence.rb#1147
  def strict_loaded_associations; end

  # @raise [ActiveRecordError]
  #
  # source://activerecord//lib/active_record/persistence.rb#1269
  def verify_readonly_attribute(name); end
end

# source://activerecord//lib/active_record/persistence.rb#10
module ActiveRecord::Persistence::ClassMethods
  # source://activerecord//lib/active_record/persistence.rb#611
  def _delete_record(constraints); end

  # source://activerecord//lib/active_record/persistence.rb#569
  def _insert_record(values, returning); end

  # source://activerecord//lib/active_record/persistence.rb#594
  def _update_record(values, constraints); end

  # Builds an object (or multiple objects) and returns either the built object or a list of built
  # objects.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the
  # attributes on the objects that are to be built.
  #
  # ==== Examples
  #   # Build a single new object
  #   User.build(first_name: 'Jamie')
  #
  #   # Build an Array of new objects
  #   User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])
  #
  #   # Build a single object and pass it into a block to set other attributes.
  #   User.build(first_name: 'Jamie') do |u|
  #     u.is_admin = false
  #   end
  #
  #   # Building an Array of new objects using a block, where the block is executed for each object:
  #   User.build([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
  #     u.is_admin = false
  #   end
  #
  # source://activerecord//lib/active_record/persistence.rb#82
  def build(attributes = T.unsafe(nil), &block); end

  # Returns an array of column names to be used in queries. The source of column
  # names is derived from +query_constraints_list+ or +primary_key+. This method
  # is for internal use when the primary key is to be treated as an array.
  #
  # source://activerecord//lib/active_record/persistence.rb#510
  def composite_query_constraints_list; end

  # Creates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes. These Hashes describe the
  # attributes on the objects that are to be created.
  #
  # ==== Examples
  #   # Create a single new object
  #   User.create(first_name: 'Jamie')
  #
  #   # Create an Array of new objects
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }])
  #
  #   # Create a single object and pass it into a block to set other attributes.
  #   User.create(first_name: 'Jamie') do |u|
  #     u.is_admin = false
  #   end
  #
  #   # Creating an Array of new objects using a block, where the block is executed for each object:
  #   User.create([{ first_name: 'Jamie' }, { first_name: 'Jeremy' }]) do |u|
  #     u.is_admin = false
  #   end
  #
  # source://activerecord//lib/active_record/persistence.rb#33
  def create(attributes = T.unsafe(nil), &block); end

  # Creates an object (or multiple objects) and saves it to the database,
  # if validations pass. Raises a RecordInvalid error if validations fail,
  # unlike Base#create.
  #
  # The +attributes+ parameter can be either a Hash or an Array of Hashes.
  # These describe which attributes to be created on the object, or
  # multiple objects when given an Array of Hashes.
  #
  # source://activerecord//lib/active_record/persistence.rb#50
  def create!(attributes = T.unsafe(nil), &block); end

  # Deletes the row with a primary key matching the +id+ argument, using an
  # SQL +DELETE+ statement, and returns the number of rows deleted. Active
  # Record objects are not instantiated, so the object's callbacks are not
  # executed, including any <tt>:dependent</tt> association options.
  #
  # You can delete multiple rows at once by passing an Array of <tt>id</tt>s.
  #
  # Note: Although it is often much faster than the alternative, #destroy,
  # skipping callbacks might bypass business logic in your application
  # that ensures referential integrity or performs other essential jobs.
  #
  # ==== Examples
  #
  #   # Delete a single row
  #   Todo.delete(1)
  #
  #   # Delete multiple rows
  #   Todo.delete([2,3,4])
  #
  # source://activerecord//lib/active_record/persistence.rb#565
  def delete(id_or_array); end

  # Destroy an object (or multiple objects) that has the given id. The object is instantiated first,
  # therefore all callbacks and filters are fired off before the object is deleted. This method is
  # less efficient than #delete but allows cleanup methods and other actions to be run.
  #
  # This essentially finds the object (or multiple objects) with the given id, creates a new object
  # from the attributes, and then calls destroy on it.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be destroyed.
  #
  # ==== Examples
  #
  #   # Destroy a single object
  #   Todo.destroy(1)
  #
  #   # Destroy multiple objects
  #   todos = [1,2,3]
  #   Todo.destroy(todos)
  #
  # source://activerecord//lib/active_record/persistence.rb#533
  def destroy(id); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/persistence.rb#495
  def has_query_constraints?; end

  # Inserts a single record into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See #insert_all for documentation.
  #
  # source://activerecord//lib/active_record/persistence.rb#96
  def insert(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  # Inserts a single record into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See #insert_all! for more.
  #
  # source://activerecord//lib/active_record/persistence.rb#185
  def insert!(attributes, returning: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  # Inserts multiple records into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Rows are considered to be unique by every unique index on the table. Any
  # duplicate rows are skipped.
  # Override with <tt>:unique_by</tt> (see below).
  #
  # Returns an ActiveRecord::Result with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL and SQLite3 only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  #   You can also pass an SQL string if you need more control on the return values
  #   (for example, <tt>returning: Arel.sql("id, name as new_name")</tt>).
  #
  # [:unique_by]
  #   (PostgreSQL and SQLite only) By default rows are considered to be unique
  #   by every unique index on the table. Any duplicate rows are skipped.
  #
  #   To skip rows according to just one unique index pass <tt>:unique_by</tt>.
  #
  #   Consider a Book model where no duplicate ISBNs make sense, but if any
  #   row has an existing id, or is not unique by another unique index,
  #   ActiveRecord::RecordNotUnique is raised.
  #
  #   Unique indexes can be identified by columns or name:
  #
  #     unique_by: :isbn
  #     unique_by: %i[ author_id name ]
  #     unique_by: :index_books_on_isbn
  #
  # [:record_timestamps]
  #   By default, automatic setting of timestamp columns is controlled by
  #   the model's <tt>record_timestamps</tt> config, matching typical
  #   behavior.
  #
  #   To override this and force automatic setting of timestamp columns one
  #   way or the other, pass <tt>:record_timestamps</tt>:
  #
  #     record_timestamps: true  # Always set timestamps automatically
  #     record_timestamps: false # Never set timestamps automatically
  #
  # Because it relies on the index information from the database
  # <tt>:unique_by</tt> is recommended to be paired with
  # Active Record's schema_cache.
  #
  # ==== Example
  #
  #   # Insert records and skip inserting any duplicates.
  #   # Here "Eloquent Ruby" is skipped because its id is not unique.
  #
  #   Book.insert_all([
  #     { id: 1, title: "Rework", author: "David" },
  #     { id: 1, title: "Eloquent Ruby", author: "Russ" }
  #   ])
  #
  #   # insert_all works on chained scopes, and you can use create_with
  #   # to set default attributes for all inserted records.
  #
  #   author.books.create_with(created_at: Time.now).insert_all([
  #     { id: 1, title: "Rework" },
  #     { id: 2, title: "Eloquent Ruby" }
  #   ])
  #
  # source://activerecord//lib/active_record/persistence.rb#175
  def insert_all(attributes, returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  # Inserts multiple records into the database in a single SQL INSERT
  # statement. It does not instantiate any models nor does it trigger
  # Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Raises ActiveRecord::RecordNotUnique if any rows violate a
  # unique index on the table. In that case, no rows are inserted.
  #
  # To skip duplicate rows, see #insert_all. To replace them, see #upsert_all.
  #
  # Returns an ActiveRecord::Result with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL and SQLite3 only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  #   You can also pass an SQL string if you need more control on the return values
  #   (for example, <tt>returning: Arel.sql("id, name as new_name")</tt>).
  #
  # [:record_timestamps]
  #   By default, automatic setting of timestamp columns is controlled by
  #   the model's <tt>record_timestamps</tt> config, matching typical
  #   behavior.
  #
  #   To override this and force automatic setting of timestamp columns one
  #   way or the other, pass <tt>:record_timestamps</tt>:
  #
  #     record_timestamps: true  # Always set timestamps automatically
  #     record_timestamps: false # Never set timestamps automatically
  #
  # ==== Examples
  #
  #   # Insert multiple records
  #   Book.insert_all!([
  #     { title: "Rework", author: "David" },
  #     { title: "Eloquent Ruby", author: "Russ" }
  #   ])
  #
  #   # Raises ActiveRecord::RecordNotUnique because "Eloquent Ruby"
  #   # does not have a unique id.
  #   Book.insert_all!([
  #     { id: 1, title: "Rework", author: "David" },
  #     { id: 1, title: "Eloquent Ruby", author: "Russ" }
  #   ])
  #
  # source://activerecord//lib/active_record/persistence.rb#242
  def insert_all!(attributes, returning: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  # Given an attributes hash, +instantiate+ returns a new instance of
  # the appropriate class. Accepts only keys as strings.
  #
  # For example, +Post.all+ may return Comments, Messages, and Emails
  # by storing the record's subclass in a +type+ attribute. By calling
  # +instantiate+ instead of +new+, finder methods ensure they get new
  # instances of the appropriate class for each record.
  #
  # See <tt>ActiveRecord::Inheritance#discriminate_class_for_record</tt> to see
  # how this "single-table" inheritance mapping is implemented.
  #
  # source://activerecord//lib/active_record/persistence.rb#376
  def instantiate(attributes, column_types = T.unsafe(nil), &block); end

  # Accepts a list of attribute names to be used in the WHERE clause
  # of SELECT / UPDATE / DELETE queries and in the ORDER BY clause for `#first` and `#last` finder methods.
  #
  #   class Developer < ActiveRecord::Base
  #     query_constraints :company_id, :id
  #   end
  #
  #   developer = Developer.first
  #   # SELECT "developers".* FROM "developers" ORDER BY "developers"."company_id" ASC, "developers"."id" ASC LIMIT 1
  #   developer.inspect # => #<Developer id: 1, company_id: 1, ...>
  #
  #   developer.update!(name: "Nikita")
  #   # UPDATE "developers" SET "name" = 'Nikita' WHERE "developers"."company_id" = 1 AND "developers"."id" = 1
  #
  #   It is possible to update attribute used in the query_by clause:
  #   developer.update!(company_id: 2)
  #   # UPDATE "developers" SET "company_id" = 2 WHERE "developers"."company_id" = 1 AND "developers"."id" = 1
  #
  #   developer.name = "Bob"
  #   developer.save!
  #   # UPDATE "developers" SET "name" = 'Bob' WHERE "developers"."company_id" = 1 AND "developers"."id" = 1
  #
  #   developer.destroy!
  #   # DELETE FROM "developers" WHERE "developers"."company_id" = 1 AND "developers"."id" = 1
  #
  #   developer.delete
  #   # DELETE FROM "developers" WHERE "developers"."company_id" = 1 AND "developers"."id" = 1
  #
  #   developer.reload
  #   # SELECT "developers".* FROM "developers" WHERE "developers"."company_id" = 1 AND "developers"."id" = 1 LIMIT 1
  #
  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/persistence.rb#488
  def query_constraints(*columns_list); end

  # source://activerecord//lib/active_record/persistence.rb#499
  def query_constraints_list; end

  # Updates an object (or multiple objects) and saves it to the database, if validations pass.
  # The resulting object is returned whether the object was saved successfully to the database or not.
  #
  # ==== Parameters
  #
  # * +id+ - This should be the id or an array of ids to be updated.
  #   Optional argument, defaults to all records in the relation.
  # * +attributes+ - This should be a hash of attributes or an array of hashes.
  #
  # ==== Examples
  #
  #   # Updates one record
  #   Person.update(15, user_name: "Samuel", group: "expert")
  #
  #   # Updates multiple records
  #   people = { 1 => { "first_name" => "David" }, 2 => { "first_name" => "Jeremy" } }
  #   Person.update(people.keys, people.values)
  #
  #   # Updates multiple records from the result of a relation
  #   people = Person.where(group: "expert")
  #   people.update(group: "masters")
  #
  # Note: Updating a large number of records will run an UPDATE
  # query for each record, which may cause a performance issue.
  # When running callbacks is not needed for each record update,
  # it is preferred to use {update_all}[rdoc-ref:Relation#update_all]
  # for updating all records in a single query.
  #
  # source://activerecord//lib/active_record/persistence.rb#408
  def update(id = T.unsafe(nil), attributes); end

  # Updates the object (or multiple objects) just like #update but calls #update! instead
  # of +update+, so an exception is raised if the record is invalid and saving will fail.
  #
  # source://activerecord//lib/active_record/persistence.rb#434
  def update!(id = T.unsafe(nil), attributes); end

  # Updates or inserts (upserts) a single record into the database in a
  # single SQL INSERT statement. It does not instantiate any models nor does
  # it trigger Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # See #upsert_all for documentation.
  #
  # source://activerecord//lib/active_record/persistence.rb#252
  def upsert(attributes, **kwargs); end

  # Updates or inserts (upserts) multiple records into the database in a
  # single SQL INSERT statement. It does not instantiate any models nor does
  # it trigger Active Record callbacks or validations. Though passed values
  # go through Active Record's type casting and serialization.
  #
  # The +attributes+ parameter is an Array of Hashes. Every Hash determines
  # the attributes for a single row and must have the same keys.
  #
  # Returns an ActiveRecord::Result with its contents based on
  # <tt>:returning</tt> (see below).
  #
  # By default, +upsert_all+ will update all the columns that can be updated when
  # there is a conflict. These are all the columns except primary keys, read-only
  # columns, and columns covered by the optional +unique_by+.
  #
  # ==== Options
  #
  # [:returning]
  #   (PostgreSQL and SQLite3 only) An array of attributes to return for all successfully
  #   inserted records, which by default is the primary key.
  #   Pass <tt>returning: %w[ id name ]</tt> for both id and name
  #   or <tt>returning: false</tt> to omit the underlying <tt>RETURNING</tt> SQL
  #   clause entirely.
  #
  #   You can also pass an SQL string if you need more control on the return values
  #   (for example, <tt>returning: Arel.sql("id, name as new_name")</tt>).
  #
  # [:unique_by]
  #   (PostgreSQL and SQLite only) By default rows are considered to be unique
  #   by every unique index on the table. Any duplicate rows are skipped.
  #
  #   To skip rows according to just one unique index pass <tt>:unique_by</tt>.
  #
  #   Consider a Book model where no duplicate ISBNs make sense, but if any
  #   row has an existing id, or is not unique by another unique index,
  #   ActiveRecord::RecordNotUnique is raised.
  #
  #   Unique indexes can be identified by columns or name:
  #
  #     unique_by: :isbn
  #     unique_by: %i[ author_id name ]
  #     unique_by: :index_books_on_isbn
  #
  # Because it relies on the index information from the database
  # <tt>:unique_by</tt> is recommended to be paired with
  # Active Record's schema_cache.
  #
  # [:on_duplicate]
  #   Configure the SQL update sentence that will be used in case of conflict.
  #
  #   NOTE: If you use this option you must provide all the columns you want to update
  #   by yourself.
  #
  #   Example:
  #
  #     Commodity.upsert_all(
  #       [
  #         { id: 2, name: "Copper", price: 4.84 },
  #         { id: 4, name: "Gold", price: 1380.87 },
  #         { id: 6, name: "Aluminium", price: 0.35 }
  #       ],
  #       on_duplicate: Arel.sql("price = GREATEST(commodities.price, EXCLUDED.price)")
  #     )
  #
  #   See the related +:update_only+ option. Both options can't be used at the same time.
  #
  # [:update_only]
  #   Provide a list of column names that will be updated in case of conflict. If not provided,
  #   +upsert_all+ will update all the columns that can be updated. These are all the columns
  #   except primary keys, read-only columns, and columns covered by the optional +unique_by+
  #
  #   Example:
  #
  #     Commodity.upsert_all(
  #       [
  #         { id: 2, name: "Copper", price: 4.84 },
  #         { id: 4, name: "Gold", price: 1380.87 },
  #         { id: 6, name: "Aluminium", price: 0.35 }
  #       ],
  #       update_only: [:price] # Only prices will be updated
  #     )
  #
  #   See the related +:on_duplicate+ option. Both options can't be used at the same time.
  #
  # [:record_timestamps]
  #   By default, automatic setting of timestamp columns is controlled by
  #   the model's <tt>record_timestamps</tt> config, matching typical
  #   behavior.
  #
  #   To override this and force automatic setting of timestamp columns one
  #   way or the other, pass <tt>:record_timestamps</tt>:
  #
  #     record_timestamps: true  # Always set timestamps automatically
  #     record_timestamps: false # Never set timestamps automatically
  #
  # ==== Examples
  #
  #   # Inserts multiple records, performing an upsert when records have duplicate ISBNs.
  #   # Here "Eloquent Ruby" overwrites "Rework" because its ISBN is duplicate.
  #
  #   Book.upsert_all([
  #     { title: "Rework", author: "David", isbn: "1" },
  #     { title: "Eloquent Ruby", author: "Russ", isbn: "1" }
  #   ], unique_by: :isbn)
  #
  #   Book.find_by(isbn: "1").title # => "Eloquent Ruby"
  #
  # source://activerecord//lib/active_record/persistence.rb#362
  def upsert_all(attributes, on_duplicate: T.unsafe(nil), update_only: T.unsafe(nil), returning: T.unsafe(nil), unique_by: T.unsafe(nil), record_timestamps: T.unsafe(nil)); end

  private

  # Called by +_update_record+ and +_delete_record+
  # to build `where` clause from default scopes.
  # Skips empty scopes.
  #
  # source://activerecord//lib/active_record/persistence.rb#655
  def build_default_constraint; end

  # Called by +instantiate+ to decide which class to use for a new
  # record instance.
  #
  # See +ActiveRecord::Inheritance#discriminate_class_for_record+ for
  # the single-table inheritance discriminator.
  #
  # source://activerecord//lib/active_record/persistence.rb#648
  def discriminate_class_for_record(record); end

  # source://activerecord//lib/active_record/persistence.rb#628
  def inherited(subclass); end

  # Given a class, an attributes hash, +instantiate_instance_of+ returns a
  # new instance of the class. Accepts only keys as strings.
  #
  # source://activerecord//lib/active_record/persistence.rb#638
  def instantiate_instance_of(klass, attributes, column_types = T.unsafe(nil), &block); end
end

# source://activerecord//lib/active_record/relation/predicate_builder.rb#4
class ActiveRecord::PredicateBuilder
  # @return [PredicateBuilder] a new instance of PredicateBuilder
  #
  # source://activerecord//lib/active_record/relation/predicate_builder.rb#12
  def initialize(table); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#53
  def [](attr_name, value, operator = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#57
  def build(attribute, value, operator = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#67
  def build_bind_attribute(column_name, value); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#23
  def build_from_hash(attributes, &block); end

  # Define how a class is converted to Arel nodes when passed to +where+.
  # The handler can be any object that responds to +call+, and will be used
  # for any value that +===+ the class given. For example:
  #
  #     MyCustomDateRange = Struct.new(:start, :end)
  #     handler = proc do |column, range|
  #       Arel::Nodes::Between.new(column,
  #         Arel::Nodes::And.new([range.start, range.end])
  #       )
  #     end
  #     ActiveRecord::PredicateBuilder.new("users").register_handler(MyCustomDateRange, handler)
  #
  # source://activerecord//lib/active_record/relation/predicate_builder.rb#49
  def register_handler(klass, handler); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#71
  def resolve_arel_attribute(table_name, column_name, &block); end

  protected

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#76
  def expand_from_hash(attributes, &block); end

  private

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#150
  def convert_dot_notation_to_hash(attributes); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#140
  def grouping_queries(queries); end

  # source://activerecord//lib/active_record/relation/predicate_builder.rb#172
  def handler_for(object); end

  # Returns the value of attribute table.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder.rb#138
  def table; end

  class << self
    # source://activerecord//lib/active_record/relation/predicate_builder.rb#28
    def references(attributes); end
  end
end

# source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#7
class ActiveRecord::PredicateBuilder::ArrayHandler
  # @return [ArrayHandler] a new instance of ArrayHandler
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#8
  def initialize(predicate_builder); end

  # source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#12
  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#39
  def predicate_builder; end
end

# source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#41
module ActiveRecord::PredicateBuilder::ArrayHandler::NullPredicate
  class << self
    # source://activerecord//lib/active_record/relation/predicate_builder/array_handler.rb#42
    def or(other); end
  end
end

# source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#5
class ActiveRecord::PredicateBuilder::AssociationQueryValue
  # @return [AssociationQueryValue] a new instance of AssociationQueryValue
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#6
  def initialize(associated_table, value); end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#11
  def queries; end

  private

  # Returns the value of attribute associated_table.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#23
  def associated_table; end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#59
  def convert_to_id(value); end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#25
  def ids; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#55
  def polymorphic_clause?; end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#47
  def polymorphic_name; end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#39
  def primary_key; end

  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#43
  def primary_type; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#51
  def select_clause?; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/association_query_value.rb#23
  def value; end
end

# source://activerecord//lib/active_record/relation/predicate_builder/basic_object_handler.rb#5
class ActiveRecord::PredicateBuilder::BasicObjectHandler
  # @return [BasicObjectHandler] a new instance of BasicObjectHandler
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/basic_object_handler.rb#6
  def initialize(predicate_builder); end

  # source://activerecord//lib/active_record/relation/predicate_builder/basic_object_handler.rb#10
  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/basic_object_handler.rb#16
  def predicate_builder; end
end

# source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#5
class ActiveRecord::PredicateBuilder::PolymorphicArrayValue
  # @return [PolymorphicArrayValue] a new instance of PolymorphicArrayValue
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#6
  def initialize(associated_table, values); end

  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#11
  def queries; end

  private

  # Returns the value of attribute associated_table.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#23
  def associated_table; end

  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#44
  def convert_to_id(value); end

  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#36
  def klass(value); end

  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#32
  def primary_key(value); end

  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#25
  def type_to_ids_mapping; end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/polymorphic_array_value.rb#23
  def values; end
end

# source://activerecord//lib/active_record/relation/predicate_builder/range_handler.rb#5
class ActiveRecord::PredicateBuilder::RangeHandler
  # @return [RangeHandler] a new instance of RangeHandler
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/range_handler.rb#8
  def initialize(predicate_builder); end

  # source://activerecord//lib/active_record/relation/predicate_builder/range_handler.rb#12
  def call(attribute, value); end

  private

  # Returns the value of attribute predicate_builder.
  #
  # source://activerecord//lib/active_record/relation/predicate_builder/range_handler.rb#19
  def predicate_builder; end
end

# source://activerecord//lib/active_record/relation/predicate_builder/range_handler.rb#6
class ActiveRecord::PredicateBuilder::RangeHandler::RangeWithBinds < ::Struct
  # Returns the value of attribute begin
  #
  # @return [Object] the current value of begin
  def begin; end

  # Sets the attribute begin
  #
  # @param value [Object] the value to set the attribute begin to.
  # @return [Object] the newly set value
  def begin=(_); end

  # Returns the value of attribute end
  #
  # @return [Object] the current value of end
  def end; end

  # Sets the attribute end
  #
  # @param value [Object] the value to set the attribute end to.
  # @return [Object] the newly set value
  def end=(_); end

  # Returns the value of attribute exclude_end?
  #
  # @return [Object] the current value of exclude_end?
  def exclude_end?; end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# source://activerecord//lib/active_record/relation/predicate_builder/relation_handler.rb#5
class ActiveRecord::PredicateBuilder::RelationHandler
  # source://activerecord//lib/active_record/relation/predicate_builder/relation_handler.rb#6
  def call(attribute, value); end
end

# Raised when PostgreSQL returns 'cached plan must not change result type' and
# we cannot retry gracefully (e.g. inside a transaction)
#
# source://activerecord//lib/active_record/errors.rb#341
class ActiveRecord::PreparedStatementCacheExpired < ::ActiveRecord::StatementInvalid; end

# Raised when the number of placeholders in an SQL fragment passed to
# {ActiveRecord::Base.where}[rdoc-ref:QueryMethods#where]
# does not match the number of values supplied.
#
# For example, when there are two placeholders with only one value supplied:
#
#   Location.where("lat = ? AND lng = ?", 53.7362)
#
# source://activerecord//lib/active_record/errors.rb#303
class ActiveRecord::PreparedStatementInvalid < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/promise.rb#4
class ActiveRecord::Promise < ::BasicObject
  # @return [Promise] a new instance of Promise
  #
  # source://activerecord//lib/active_record/promise.rb#7
  def initialize(future_result, block); end

  def class; end

  # source://activerecord//lib/active_record/promise.rb#44
  def inspect; end

  def is_a?(_arg0); end

  # Returns whether the associated query is still being executed or not.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/promise.rb#13
  def pending?; end

  # source://activerecord//lib/active_record/promise.rb#48
  def pretty_print(q); end

  def respond_to?(*_arg0); end

  # Returns a new +ActiveRecord::Promise+ that will apply the passed block
  # when the value is accessed:
  #
  #   Post.async_pick(:title).then { |title| title.upcase }.value
  #   # => "POST TITLE"
  #
  # source://activerecord//lib/active_record/promise.rb#36
  def then(&block); end

  # Returns the query result.
  # If the query wasn't completed yet, accessing +#value+ will block until the query completes.
  # If the query failed, +#value+ will raise the corresponding error.
  #
  # source://activerecord//lib/active_record/promise.rb#20
  def value; end

  private

  # source://activerecord//lib/active_record/promise.rb#53
  def status; end
end

# source://activerecord//lib/active_record/promise.rb#63
class ActiveRecord::Promise::Complete < ::ActiveRecord::Promise
  # @return [Complete] a new instance of Complete
  #
  # source://activerecord//lib/active_record/promise.rb#66
  def initialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/promise.rb#74
  def pending?; end

  # source://activerecord//lib/active_record/promise.rb#70
  def then; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/active_record/promise.rb#64
  def value; end

  private

  # source://activerecord//lib/active_record/promise.rb#79
  def status; end
end

# source://activerecord//lib/active_record/migration.rb#195
class ActiveRecord::ProtectedEnvironmentError < ::ActiveRecord::ActiveRecordError
  # @return [ProtectedEnvironmentError] a new instance of ProtectedEnvironmentError
  #
  # source://activerecord//lib/active_record/migration.rb#196
  def initialize(env = T.unsafe(nil)); end
end

# Superclass for errors that have been aborted (either by client or server).
#
# source://activerecord//lib/active_record/errors.rb#534
class ActiveRecord::QueryAborted < ::ActiveRecord::StatementInvalid; end

# = Active Record Query Cache
#
# source://activerecord//lib/active_record/query_cache.rb#5
class ActiveRecord::QueryCache
  class << self
    # source://activerecord//lib/active_record/query_cache.rb#32
    def complete(pools); end

    # source://activerecord//lib/active_record/query_cache.rb#40
    def install_executor_hooks(executor = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/query_cache.rb#28
    def run; end
  end
end

# source://activerecord//lib/active_record/query_cache.rb#6
module ActiveRecord::QueryCache::ClassMethods
  # Enable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  #
  # source://activerecord//lib/active_record/query_cache.rb#9
  def cache(&block); end

  # Disable the query cache within the block if Active Record is configured.
  # If it's not, it will execute the given block.
  #
  # source://activerecord//lib/active_record/query_cache.rb#19
  def uncached(&block); end
end

# QueryCanceled will be raised when canceling statement due to user request.
#
# source://activerecord//lib/active_record/errors.rb#546
class ActiveRecord::QueryCanceled < ::ActiveRecord::QueryAborted; end

# = Active Record Query Logs
#
# Automatically append comments to SQL queries with runtime information tags. This can be used to trace troublesome
# SQL statements back to the application code that generated these statements.
#
# Query logs can be enabled via \Rails configuration in <tt>config/application.rb</tt> or an initializer:
#
#     config.active_record.query_log_tags_enabled = true
#
# By default the name of the application, the name and action of the controller, or the name of the job are logged.
# The default format is {SQLCommenter}[https://open-telemetry.github.io/opentelemetry-sqlcommenter/].
# The tags shown in a query comment can be configured via \Rails configuration:
#
#     config.active_record.query_log_tags = [ :application, :controller, :action, :job ]
#
# Active Record defines default tags available for use:
#
# * +application+
# * +pid+
# * +socket+
# * +db_host+
# * +database+
#
# Action Controller adds default tags when loaded:
#
# * +controller+
# * +action+
# * +namespaced_controller+
#
# Active Job adds default tags when loaded:
#
# * +job+
#
# New comment tags can be defined by adding them in a +Hash+ to the tags +Array+. Tags can have dynamic content by
# setting a +Proc+ or lambda value in the +Hash+, and can reference any value stored by \Rails in the +context+ object.
# ActiveSupport::CurrentAttributes can be used to store application values. Tags with +nil+ values are
# omitted from the query comment.
#
# Escaping is performed on the string returned, however untrusted user input should not be used.
#
# Example:
#
#     config.active_record.query_log_tags = [
#       :namespaced_controller,
#       :action,
#       :job,
#       {
#         request_id: ->(context) { context[:controller]&.request&.request_id },
#         job_id: ->(context) { context[:job]&.job_id },
#         tenant_id: -> { Current.tenant&.id },
#         static: "value",
#       },
#     ]
#
# By default the name of the application, the name and action of the controller, or the name of the job are logged
# using the {SQLCommenter}[https://open-telemetry.github.io/opentelemetry-sqlcommenter/] format. This can be changed
# via {config.active_record.query_log_tags_format}[https://guides.rubyonrails.org/configuring.html#config-active-record-query-log-tags-format]
#
# Tag comments can be prepended to the query:
#
#    ActiveRecord::QueryLogs.prepend_comment = true
#
# For applications where the content will not change during the lifetime of
# the request or job execution, the tags can be cached for reuse in every query:
#
#    config.active_record.cache_query_log_tags = true
#
# source://activerecord//lib/active_record/query_logs_formatter.rb#4
module ActiveRecord::QueryLogs
  class << self
    # source://activerecord//lib/active_record/query_logs.rb#77
    def cache_query_log_tags; end

    # source://activerecord//lib/active_record/query_logs.rb#77
    def cache_query_log_tags=(val); end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#49
    def cached_comment; end

    # source://activesupport/7.1.3.2/lib/active_support/core_ext/module/attribute_accessors_per_thread.rb#108
    def cached_comment=(obj); end

    # source://activerecord//lib/active_record/query_logs.rb#82
    def call(sql, connection); end

    # source://activerecord//lib/active_record/query_logs.rb#94
    def clear_cache; end

    # source://activerecord//lib/active_record/query_logs.rb#76
    def prepend_comment; end

    # source://activerecord//lib/active_record/query_logs.rb#76
    def prepend_comment=(val); end

    # source://activerecord//lib/active_record/query_logs.rb#74
    def taggings; end

    # source://activerecord//lib/active_record/query_logs.rb#74
    def taggings=(val); end

    # source://activerecord//lib/active_record/query_logs.rb#75
    def tags; end

    # source://activerecord//lib/active_record/query_logs.rb#75
    def tags=(val); end

    # source://activerecord//lib/active_record/query_logs.rb#78
    def tags_formatter; end

    # source://activerecord//lib/active_record/query_logs.rb#78
    def tags_formatter=(val); end

    # Updates the formatter to be what the passed in format is.
    #
    # source://activerecord//lib/active_record/query_logs.rb#99
    def update_formatter(format); end

    private

    # Returns an SQL comment +String+ containing the query log tags.
    # Sets and returns a cached comment if <tt>cache_query_log_tags</tt> is +true+.
    #
    # source://activerecord//lib/active_record/query_logs.rb#116
    def comment(connection); end

    # source://activerecord//lib/active_record/query_logs.rb#136
    def escape_sql_comment(content); end

    # source://activerecord//lib/active_record/query_logs.rb#124
    def formatter; end

    # source://activerecord//lib/active_record/query_logs.rb#149
    def tag_content(connection); end

    # source://activerecord//lib/active_record/query_logs.rb#128
    def uncached_comment(connection); end
  end
end

# source://activerecord//lib/active_record/query_logs_formatter.rb#5
class ActiveRecord::QueryLogs::LegacyFormatter
  # @return [LegacyFormatter] a new instance of LegacyFormatter
  #
  # source://activerecord//lib/active_record/query_logs_formatter.rb#6
  def initialize; end

  # Formats the key value pairs into a string.
  #
  # source://activerecord//lib/active_record/query_logs_formatter.rb#11
  def format(pairs); end

  private

  # source://activerecord//lib/active_record/query_logs_formatter.rb#20
  def format_value(value); end

  # Returns the value of attribute key_value_separator.
  #
  # source://activerecord//lib/active_record/query_logs_formatter.rb#18
  def key_value_separator; end
end

# source://activerecord//lib/active_record/query_logs_formatter.rb#25
class ActiveRecord::QueryLogs::SQLCommenter < ::ActiveRecord::QueryLogs::LegacyFormatter
  # @return [SQLCommenter] a new instance of SQLCommenter
  #
  # source://activerecord//lib/active_record/query_logs_formatter.rb#26
  def initialize; end

  # source://activerecord//lib/active_record/query_logs_formatter.rb#30
  def format(pairs); end

  private

  # source://activerecord//lib/active_record/query_logs_formatter.rb#36
  def format_value(value); end
end

# source://activerecord//lib/active_record/relation/query_methods.rb#9
module ActiveRecord::QueryMethods
  include ::ActiveModel::ForbiddenAttributesProtection

  # source://activerecord//lib/active_record/relation/query_methods.rb#405
  def _select!(*fields); end

  # Returns a new relation, which is the logical intersection of this relation and the one passed
  # as an argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where(id: [1, 2]).and(Post.where(id: [2, 3]))
  #    # SELECT `posts`.* FROM `posts` WHERE `posts`.`id` IN (1, 2) AND `posts`.`id` IN (2, 3)
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1034
  def and(other); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1042
  def and!(other); end

  # Adds an SQL comment to queries generated from this relation. For example:
  #
  #   User.annotate("selecting user names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting user names */
  #
  #   User.annotate("selecting", "user", "names").select(:name)
  #   # SELECT "users"."name" FROM "users" /* selecting */ /* user */ /* names */
  #
  # The SQL block comment delimiters, "/*" and "*/", will be added automatically.
  #
  # Some escaping is performed, however untrusted user input should not be used.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1428
  def annotate(*args); end

  # Like #annotate, but modifies relation in place.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1434
  def annotate!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def annotate_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def annotate_values=(value); end

  # Returns the Arel object associated with the relation.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1489
  def arel(aliases = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1493
  def construct_join_dependency(associations, join_type); end

  # Sets attributes to be used when creating new records from a
  # relation object.
  #
  #   users = User.where(name: 'Oscar')
  #   users.new.name # => 'Oscar'
  #
  #   users = users.create_with(name: 'DHH')
  #   users.new.name # => 'DHH'
  #
  # You can pass +nil+ to #create_with to reset attributes:
  #
  #   users = users.create_with(nil)
  #   users.new.name # => 'Oscar'
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1245
  def create_with(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1249
  def create_with!(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def create_with_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def create_with_value=(value); end

  # Specifies whether the records should be unique or not. For example:
  #
  #   User.select(:name)
  #   # Might return two records with the same name
  #
  #   User.select(:name).distinct
  #   # Returns 1 record per distinct name
  #
  #   User.select(:name).distinct.distinct(false)
  #   # You can also remove the uniqueness
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1309
  def distinct(value = T.unsafe(nil)); end

  # Like #distinct, but modifies relation in place.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1314
  def distinct!(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def distinct_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def distinct_value=(value); end

  # Specify associations +args+ to be eager loaded using a <tt>LEFT OUTER JOIN</tt>.
  # Performs a single query joining all specified associations. For example:
  #
  #   users = User.eager_load(:address).limit(5)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  #   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ... FROM "users"
  #   #   LEFT OUTER JOIN "addresses" ON "addresses"."id" = "users"."address_id"
  #   #   LIMIT 5
  #
  # Instead of loading the 5 addresses with 5 separate queries, all addresses
  # are loaded with a single joined query.
  #
  # Loading multiple and nested associations is possible using Hashes and Arrays,
  # similar to #includes:
  #
  #   User.eager_load(:address, friends: [:address, :followers])
  #   # SELECT "users"."id" AS t0_r0, "users"."name" AS t0_r1, ... FROM "users"
  #   #   LEFT OUTER JOIN "addresses" ON "addresses"."id" = "users"."address_id"
  #   #   LEFT OUTER JOIN "friends" ON "friends"."user_id" = "users"."id"
  #   #   ...
  #
  # NOTE: Loading the associations in a join can result in many rows that
  # contain redundant data and it performs poorly at scale.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#267
  def eager_load(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#272
  def eager_load!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def eager_load_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def eager_load_values=(value); end

  # Excludes the specified record (or collection of records) from the resulting
  # relation. For example:
  #
  #   Post.excluding(post)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."id" != 1
  #
  #   Post.excluding(post_one, post_two)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."id" NOT IN (1, 2)
  #
  # This can also be called on associations. As with the above example, either
  # a single record of collection thereof may be specified:
  #
  #   post = Post.find(1)
  #   comment = Comment.find(2)
  #   post.comments.excluding(comment)
  #   # SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 AND "comments"."id" != 2
  #
  # This is short-hand for <tt>.where.not(id: post.id)</tt> and <tt>.where.not(id: [post_one.id, post_two.id])</tt>.
  #
  # An <tt>ArgumentError</tt> will be raised if either no records are
  # specified, or if any of the records in the collection (if a collection
  # is passed in) are not instances of the same model that the relation is
  # scoping.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1470
  def excluding(*records); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1482
  def excluding!(records); end

  # Used to extend a scope with additional methods, either through
  # a module or through a block provided.
  #
  # The object returned is a relation, which can be further extended.
  #
  # === Using a \Module
  #
  #   module Pagination
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #
  #   scope = Model.all.extending(Pagination)
  #   scope.page(params[:page])
  #
  # You can also pass a list of modules:
  #
  #   scope = Model.all.extending(Pagination, SomethingElse)
  #
  # === Using a Block
  #
  #   scope = Model.all.extending do
  #     def page(number)
  #       # pagination code goes here
  #     end
  #   end
  #   scope.page(params[:page])
  #
  # You can also use a block and a module list:
  #
  #   scope = Model.all.extending(Pagination) do
  #     def per_page(number)
  #       # pagination code goes here
  #     end
  #   end
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1355
  def extending(*modules, &block); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1363
  def extending!(*modules, &block); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def extending_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def extending_values=(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def extensions; end

  # Extracts a named +association+ from the relation. The named association is first preloaded,
  # then the individual association records are collected from the relation. Like so:
  #
  #   account.memberships.extract_associated(:user)
  #   # => Returns collection of User records
  #
  # This is short-hand for:
  #
  #   account.memberships.preload(:user).collect(&:user)
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#318
  def extract_associated(association); end

  # Specifies the table from which the records will be fetched. For example:
  #
  #   Topic.select('title').from('posts')
  #   # SELECT title FROM posts
  #
  # Can accept other relation objects. For example:
  #
  #   Topic.select('title').from(Topic.approved)
  #   # SELECT title FROM (SELECT * FROM topics WHERE approved = 't') subquery
  #
  # Passing a second argument (string or symbol), creates the alias for the SQL from clause. Otherwise the alias "subquery" is used:
  #
  #   Topic.select('a.title').from(Topic.approved, :a)
  #   # SELECT a.title FROM (SELECT * FROM topics WHERE approved = 't') a
  #
  # It does not add multiple arguments to the SQL from clause. The last +from+ chained is the one used:
  #
  #   Topic.select('title').from(Topic.approved).from(Topic.inactive)
  #   # SELECT title FROM (SELECT topics.* FROM topics WHERE topics.active = 'f') subquery
  #
  # For multiple arguments for the SQL from clause, you can pass a string with the exact elements in the SQL from list:
  #
  #   color = "red"
  #   Color
  #     .from("colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)")
  #     .where("colorvalue->>'color' = ?", color)
  #     .select("c.*").to_a
  #   # SELECT c.*
  #   # FROM colors c, JSONB_ARRAY_ELEMENTS(colored_things) AS colorvalues(colorvalue)
  #   # WHERE (colorvalue->>'color' = 'red')
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1290
  def from(value, subquery_name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1294
  def from!(value, subquery_name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def from_clause; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def from_clause=(value); end

  # Allows to specify a group attribute:
  #
  #   User.group(:name)
  #   # SELECT "users".* FROM "users" GROUP BY name
  #
  # Returns an array with distinct records based on the +group+ attribute:
  #
  #   User.select([:id, :name])
  #   # => [#<User id: 1, name: "Oscar">, #<User id: 2, name: "Oscar">, #<User id: 3, name: "Foo">]
  #
  #   User.group(:name)
  #   # => [#<User id: 3, name: "Foo", ...>, #<User id: 2, name: "Oscar", ...>]
  #
  #   User.group('name AS grouped_name, age')
  #   # => [#<User id: 3, name: "Foo", age: 21, ...>, #<User id: 2, name: "Oscar", age: 21, ...>, #<User id: 5, name: "Foo", age: 23, ...>]
  #
  # Passing in an array of attributes to group by is also supported.
  #
  #   User.select([:id, :first_name]).group(:id, :first_name).first(3)
  #   # => [#<User id: 1, first_name: "Bill">, #<User id: 2, first_name: "Earl">, #<User id: 3, first_name: "Beto">]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#512
  def group(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#517
  def group!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def group_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def group_values=(value); end

  # Allows to specify a HAVING clause. Note that you can't use HAVING
  # without also specifying a GROUP clause.
  #
  #   Order.having('SUM(price) > 30').group('user_id')
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1096
  def having(opts, *rest); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1100
  def having!(opts, *rest); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def having_clause; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def having_clause=(value); end

  # Allows to specify an order by a specific set of values.
  #
  #   User.in_order_of(:id, [1, 5, 3])
  #   # SELECT "users".* FROM "users"
  #   #   WHERE "users"."id" IN (1, 5, 3)
  #   #   ORDER BY CASE
  #   #     WHEN "users"."id" = 1 THEN 1
  #   #     WHEN "users"."id" = 5 THEN 2
  #   #     WHEN "users"."id" = 3 THEN 3
  #   #   END ASC
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#620
  def in_order_of(column, values); end

  # Specify associations +args+ to be eager loaded to prevent N + 1 queries.
  # A separate query is performed for each association, unless a join is
  # required by conditions.
  #
  # For example:
  #
  #   users = User.includes(:address).limit(5)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  #   # SELECT "users".* FROM "users" LIMIT 5
  #   # SELECT "addresses".* FROM "addresses" WHERE "addresses"."id" IN (1,2,3,4,5)
  #
  # Instead of loading the 5 addresses with 5 separate queries, all addresses
  # are loaded with a single query.
  #
  # Loading the associations in a separate query will often result in a
  # performance improvement over a simple join, as a join can result in many
  # rows that contain redundant data and it performs poorly at scale.
  #
  # You can also specify multiple associations. Each association will result
  # in an additional query:
  #
  #   User.includes(:address, :friends).to_a
  #   # SELECT "users".* FROM "users"
  #   # SELECT "addresses".* FROM "addresses" WHERE "addresses"."id" IN (1,2,3,4,5)
  #   # SELECT "friends".* FROM "friends" WHERE "friends"."user_id" IN (1,2,3,4,5)
  #
  # Loading nested associations is possible using a Hash:
  #
  #   User.includes(:address, friends: [:address, :followers])
  #
  # === Conditions
  #
  # If you want to add string conditions to your included models, you'll have
  # to explicitly reference them. For example:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example').to_a
  #
  # Will throw an error, but this will work:
  #
  #   User.includes(:posts).where('posts.name = ?', 'example').references(:posts).to_a
  #   # SELECT "users"."id" AS t0_r0, ... FROM "users"
  #   #   LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   #   WHERE "posts"."name" = ?  [["name", "example"]]
  #
  # As the <tt>LEFT OUTER JOIN</tt> already contains the posts, the second query for
  # the posts is no longer performed.
  #
  # Note that #includes works with association names while #references needs
  # the actual table name.
  #
  # If you pass the conditions via a Hash, you don't need to call #references
  # explicitly, as #where references the tables for you. For example, this
  # will work correctly:
  #
  #   User.includes(:posts).where(posts: { name: 'example' })
  #
  # NOTE: Conditions affect both sides of an association. For example, the
  # above code will return only users that have a post named "example",
  # <em>and will only include posts named "example"</em>, even when a
  # matching user has other additional posts.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#231
  def includes(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#236
  def includes!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def includes_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def includes_values=(value); end

  # Allows you to invert an entire where clause instead of manually applying conditions.
  #
  #   class User
  #     scope :active, -> { where(accepted: true, locked: false) }
  #   end
  #
  #   User.where(accepted: true)
  #   # WHERE `accepted` = 1
  #
  #   User.where(accepted: true).invert_where
  #   # WHERE `accepted` != 1
  #
  #   User.active
  #   # WHERE `accepted` = 1 AND `locked` = 0
  #
  #   User.active.invert_where
  #   # WHERE NOT (`accepted` = 1 AND `locked` = 0)
  #
  # Be careful because this inverts all conditions before +invert_where+ call.
  #
  #   class User
  #     scope :active, -> { where(accepted: true, locked: false) }
  #     scope :inactive, -> { active.invert_where } # Do not attempt it
  #   end
  #
  #   # It also inverts `where(role: 'admin')` unexpectedly.
  #   User.where(role: 'admin').inactive
  #   # WHERE NOT (`role` = 'admin' AND `accepted` = 1 AND `locked` = 0)
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1000
  def invert_where; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1004
  def invert_where!; end

  # Performs JOINs on +args+. The given symbol(s) should match the name of
  # the association(s).
  #
  #   User.joins(:posts)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # Multiple joins:
  #
  #   User.joins(:posts, :account)
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "accounts" ON "accounts"."id" = "users"."account_id"
  #
  # Nested joins:
  #
  #   User.joins(posts: [:comments])
  #   # SELECT "users".*
  #   # FROM "users"
  #   # INNER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #   # INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #
  # You can use strings in order to customize your joins:
  #
  #   User.joins("LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id")
  #   # SELECT "users".* FROM "users" LEFT JOIN bookmarks ON bookmarks.bookmarkable_type = 'Post' AND bookmarks.user_id = users.id
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#767
  def joins(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#772
  def joins!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def joins_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def joins_values=(value); end

  # Performs LEFT OUTER JOINs on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   # SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#782
  def left_joins(*args); end

  # Performs LEFT OUTER JOINs on +args+:
  #
  #   User.left_outer_joins(:posts)
  #   # SELECT "users".* FROM "users" LEFT OUTER JOIN "posts" ON "posts"."user_id" = "users"."id"
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#782
  def left_outer_joins(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#788
  def left_outer_joins!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def left_outer_joins_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def left_outer_joins_values=(value); end

  # Specifies a limit for the number of records to retrieve.
  #
  #   User.limit(10) # generated SQL has 'LIMIT 10'
  #
  #   User.limit(10).limit(20) # generated SQL has 'LIMIT 20'
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1110
  def limit(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1114
  def limit!(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def limit_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def limit_value=(value); end

  # Specifies locking settings (default to +true+). For more information
  # on locking, please see ActiveRecord::Locking.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1137
  def lock(locks = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1141
  def lock!(locks = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def lock_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def lock_value=(value); end

  # Returns a chainable relation with zero records.
  #
  # The returned relation implements the Null Object pattern. It is an
  # object with defined null behavior and always returns an empty array of
  # records without querying the database.
  #
  # Any subsequent condition chained to the returned relation will continue
  # generating an empty relation and will not fire any query to the database.
  #
  # Used in cases where a method or scope could return zero records but the
  # result needs to be chainable.
  #
  # For example:
  #
  #   @posts = current_user.visible_posts.where(name: params[:name])
  #   # the visible_posts method is expected to return a chainable Relation
  #
  #   def visible_posts
  #     case role
  #     when 'Country Manager'
  #       Post.where(country: country)
  #     when 'Reviewer'
  #       Post.published
  #     when 'Bad User'
  #       Post.none # It can't be chained if [] is returned.
  #     end
  #   end
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1180
  def none; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1184
  def none!; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1192
  def null_relation?; end

  # Specifies the number of rows to skip before returning rows.
  #
  #   User.offset(10) # generated SQL has "OFFSET 10"
  #
  # Should be used with order.
  #
  #   User.offset(10).order("name ASC")
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1126
  def offset(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1130
  def offset!(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def offset_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def offset_value=(value); end

  # Specify optimizer hints to be used in the SELECT statement.
  #
  # Example (for MySQL):
  #
  #   Topic.optimizer_hints("MAX_EXECUTION_TIME(50000)", "NO_INDEX_MERGE(topics)")
  #   # SELECT /*+ MAX_EXECUTION_TIME(50000) NO_INDEX_MERGE(topics) */ `topics`.* FROM `topics`
  #
  # Example (for PostgreSQL with pg_hint_plan):
  #
  #   Topic.optimizer_hints("SeqScan(topics)", "Parallel(topics 8)")
  #   # SELECT /*+ SeqScan(topics) Parallel(topics 8) */ "topics".* FROM "topics"
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1384
  def optimizer_hints(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1389
  def optimizer_hints!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def optimizer_hints_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def optimizer_hints_values=(value); end

  # Returns a new relation, which is the logical union of this relation and the one passed as an
  # argument.
  #
  # The two relations must be structurally compatible: they must be scoping the same model, and
  # they must differ only by #where (if no #group has been defined) or #having (if a #group is
  # present).
  #
  #    Post.where("id = 1").or(Post.where("author_id = 3"))
  #    # SELECT `posts`.* FROM `posts` WHERE ((id = 1) OR (author_id = 3))
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1066
  def or(other); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1078
  def or!(other); end

  # Applies an <code>ORDER BY</code> clause to a query.
  #
  # #order accepts arguments in one of several formats.
  #
  # === symbols
  #
  # The symbol represents the name of the column you want to order the results by.
  #
  #   User.order(:name)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC
  #
  # By default, the order is ascending. If you want descending order, you can
  # map the column name symbol to +:desc+.
  #
  #   User.order(email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."email" DESC
  #
  # Multiple columns can be passed this way, and they will be applied in the order specified.
  #
  #   User.order(:name, email: :desc)
  #   # SELECT "users".* FROM "users" ORDER BY "users"."name" ASC, "users"."email" DESC
  #
  # === strings
  #
  # Strings are passed directly to the database, allowing you to specify
  # simple SQL expressions.
  #
  # This could be a source of SQL injection, so only strings composed of plain
  # column names and simple <code>function(column_name)</code> expressions
  # with optional +ASC+/+DESC+ modifiers are allowed.
  #
  #   User.order('name')
  #   # SELECT "users".* FROM "users" ORDER BY name
  #
  #   User.order('name DESC')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC
  #
  #   User.order('name DESC, email')
  #   # SELECT "users".* FROM "users" ORDER BY name DESC, email
  #
  # === Arel
  #
  # If you need to pass in complicated expressions that you have verified
  # are safe for the database, you can use Arel.
  #
  #   User.order(Arel.sql('end_date - start_date'))
  #   # SELECT "users".* FROM "users" ORDER BY end_date - start_date
  #
  # Custom query syntax, like JSON columns for PostgreSQL, is supported in this way.
  #
  #   User.order(Arel.sql("payload->>'kind'"))
  #   # SELECT "users".* FROM "users" ORDER BY payload->>'kind'
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#595
  def order(*args); end

  # Same as #order but operates on relation in-place instead of copying.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#603
  def order!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def order_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def order_values=(value); end

  # Specify associations +args+ to be eager loaded using separate queries.
  # A separate query is performed for each association.
  #
  #   users = User.preload(:address).limit(5)
  #   users.each do |user|
  #     user.address.city
  #   end
  #
  #   # SELECT "users".* FROM "users" LIMIT 5
  #   # SELECT "addresses".* FROM "addresses" WHERE "addresses"."id" IN (1,2,3,4,5)
  #
  # Instead of loading the 5 addresses with 5 separate queries, all addresses
  # are loaded with a separate query.
  #
  # Loading multiple and nested associations is possible using Hashes and Arrays,
  # similar to #includes:
  #
  #   User.preload(:address, friends: [:address, :followers])
  #   # SELECT "users".* FROM "users"
  #   # SELECT "addresses".* FROM "addresses" WHERE "addresses"."id" IN (1,2,3,4,5)
  #   # SELECT "friends".* FROM "friends" WHERE "friends"."user_id" IN (1,2,3,4,5)
  #   # SELECT ...
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#299
  def preload(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#304
  def preload!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def preload_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def preload_values=(value); end

  # Mark a relation as readonly. Attempting to update a record will result in
  # an error.
  #
  #   users = User.readonly
  #   users.first.save
  #   => ActiveRecord::ReadOnlyRecord: User is marked as readonly
  #
  # To make a readonly relation writable, pass +false+.
  #
  #   users.readonly(false)
  #   users.first.save
  #   => true
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1208
  def readonly(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1212
  def readonly!(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def readonly_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def readonly_value=(value); end

  # Use to indicate that the given +table_names+ are referenced by an SQL string,
  # and should therefore be +JOIN+ed in any query rather than loaded separately.
  # This method only works in conjunction with #includes.
  # See #includes for more details.
  #
  #   User.includes(:posts).where("posts.name = 'foo'")
  #   # Doesn't JOIN the posts table, resulting in an error.
  #
  #   User.includes(:posts).where("posts.name = 'foo'").references(:posts)
  #   # Query now knows the string references posts, so adds a JOIN
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#332
  def references(*table_names); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#337
  def references!(*table_names); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def references_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def references_values=(value); end

  # Allows you to change a previously set group statement.
  #
  #   Post.group(:title, :body)
  #   # SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`, `posts`.`body`
  #
  #   Post.group(:title, :body).regroup(:title)
  #   # SELECT `posts`.`*` FROM `posts` GROUP BY `posts`.`title`
  #
  # This is short-hand for <tt>unscope(:group).group(fields)</tt>.
  # Note that we're unscoping the entire group statement.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#532
  def regroup(*args); end

  # Same as #regroup but operates on relation in-place instead of copying.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#538
  def regroup!(*args); end

  # Replaces any existing order defined on the relation with the specified order.
  #
  #   User.order('email DESC').reorder('id ASC') # generated SQL has 'ORDER BY id ASC'
  #
  # Subsequent calls to order on the same relation will be appended. For example:
  #
  #   User.order('email DESC').reorder('id ASC').order('name ASC')
  #
  # generates a query with <tt>ORDER BY id ASC, name ASC</tt>.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#651
  def reorder(*args); end

  # Same as #reorder but operates on relation in-place instead of copying.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#659
  def reorder!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def reordering_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def reordering_value=(value); end

  # Allows you to change a previously set select statement.
  #
  #   Post.select(:title, :body)
  #   # SELECT `posts`.`title`, `posts`.`body` FROM `posts`
  #
  #   Post.select(:title, :body).reselect(:created_at)
  #   # SELECT `posts`.`created_at` FROM `posts`
  #
  # This is short-hand for <tt>unscope(:select).select(fields)</tt>.
  # Note that we're unscoping the entire select statement.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#480
  def reselect(*args); end

  # Same as #reselect but operates on relation in-place instead of copying.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#487
  def reselect!(*args); end

  # Reverse the existing order clause on the relation.
  #
  #   User.order('name ASC').reverse_order # generated SQL has 'ORDER BY name DESC'
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1397
  def reverse_order; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1401
  def reverse_order!; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def reverse_order_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def reverse_order_value=(value); end

  # Allows you to change a previously set where condition for a given attribute, instead of appending to that condition.
  #
  #   Post.where(trashed: true).where(trashed: false)
  #   # WHERE `trashed` = 1 AND `trashed` = 0
  #
  #   Post.where(trashed: true).rewhere(trashed: false)
  #   # WHERE `trashed` = 0
  #
  #   Post.where(active: true).where(trashed: true).rewhere(trashed: false)
  #   # WHERE `active` = 1 AND `trashed` = 0
  #
  # This is short-hand for <tt>unscope(where: conditions.keys).where(conditions)</tt>.
  # Note that unlike reorder, we're only unscoping the named conditions -- not the entire where statement.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#960
  def rewhere(conditions); end

  # Works in two unique ways.
  #
  # First: takes a block so it can be used just like <tt>Array#select</tt>.
  #
  #   Model.all.select { |m| m.field == value }
  #
  # This will build an array of objects from the database for the scope,
  # converting them into an array and iterating through them using
  # <tt>Array#select</tt>.
  #
  # Second: Modifies the SELECT statement for the query so that only certain
  # fields are retrieved:
  #
  #   Model.select(:field)
  #   # => [#<Model id: nil, field: "value">]
  #
  # Although in the above example it looks as though this method returns an
  # array, it actually returns a relation object and can have other query
  # methods appended to it, such as the other methods in ActiveRecord::QueryMethods.
  #
  # The argument to the method can also be an array of fields.
  #
  #   Model.select(:field, :other_field, :and_one_more)
  #   # => [#<Model id: nil, field: "value", other_field: "value", and_one_more: "value">]
  #
  # The argument also can be a hash of fields and aliases.
  #
  #   Model.select(models: { field: :alias, other_field: :other_alias })
  #   # => [#<Model id: nil, alias: "value", other_alias: "value">]
  #
  #   Model.select(models: [:field, :other_field])
  #   # => [#<Model id: nil, field: "value", other_field: "value">]
  #
  # You can also use one or more strings, which will be used unchanged as SELECT fields.
  #
  #   Model.select('field AS field_one', 'other_field AS field_two')
  #   # => [#<Model id: nil, field_one: "value", field_two: "value">]
  #
  # If an alias was specified, it will be accessible from the resulting objects:
  #
  #   Model.select('field AS field_one').first.field_one
  #   # => "value"
  #
  # Accessing attributes of an object that do not have fields retrieved by a select
  # except +id+ will throw ActiveModel::MissingAttributeError:
  #
  #   Model.select(:field).first.other_field
  #   # => ActiveModel::MissingAttributeError: missing attribute 'other_field' for Model
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#390
  def select(*fields); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def select_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def select_values=(value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1412
  def skip_preloading!; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1407
  def skip_query_cache!(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def skip_query_cache_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def skip_query_cache_value=(value); end

  # Sets the returned relation to strict_loading mode. This will raise an error
  # if the record tries to lazily load an association.
  #
  #   user = User.strict_loading.first
  #   user.comments.to_a
  #   => ActiveRecord::StrictLoadingViolationError
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1223
  def strict_loading(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1227
  def strict_loading!(value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def strict_loading_value; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def strict_loading_value=(value); end

  # Checks whether the given relation is structurally compatible with this relation, to determine
  # if it's possible to use the #and and #or methods without raising an error. Structurally
  # compatible is defined as: they must be scoping the same model, and they must differ only by
  # #where (if no #group has been defined) or #having (if a #group is present).
  #
  #    Post.where("id = 1").structurally_compatible?(Post.where("author_id = 3"))
  #    # => true
  #
  #    Post.joins(:comments).structurally_compatible?(Post.where("id = 1"))
  #    # => false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1020
  def structurally_compatible?(other); end

  # Deduplicate multiple values.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1440
  def uniq!(name); end

  # Removes an unwanted relation that is already defined on a chain of relations.
  # This is useful when passing around chains of relations and would like to
  # modify the relations without reconstructing the entire chain.
  #
  #   User.order('email DESC').unscope(:order) == User.all
  #
  # The method arguments are symbols which correspond to the names of the methods
  # which should be unscoped. The valid arguments are given in VALID_UNSCOPING_VALUES.
  # The method can also be called with multiple arguments. For example:
  #
  #   User.order('email DESC').select('id').where(name: "John")
  #       .unscope(:order, :select, :where) == User.all
  #
  # One can additionally pass a hash as an argument to unscope specific +:where+ values.
  # This is done by passing a hash with a single key-value pair. The key should be
  # +:where+ and the value should be the where value to unscope. For example:
  #
  #   User.where(name: "John", active: true).unscope(where: :name)
  #       == User.where(active: true)
  #
  # This method is similar to #except, but unlike
  # #except, it persists across merges:
  #
  #   User.order('email').merge(User.except(:order))
  #       == User.order('email')
  #
  #   User.order('email').merge(User.unscope(:order))
  #       == User.all
  #
  # This means it can be used in association definitions:
  #
  #   has_many :comments, -> { unscope(where: :trashed) }
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#705
  def unscope(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#710
  def unscope!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def unscope_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def unscope_values=(value); end

  # Returns a new relation, which is the result of filtering the current relation
  # according to the conditions in the arguments.
  #
  # #where accepts conditions in one of several formats. In the examples below, the resulting
  # SQL is given as an illustration; the actual query generated may be different depending
  # on the database adapter.
  #
  # === \String
  #
  # A single string, without additional arguments, is passed to the query
  # constructor as an SQL fragment, and used in the where clause of the query.
  #
  #    Client.where("orders_count = '2'")
  #    # SELECT * from clients where orders_count = '2';
  #
  # Note that building your own string from user input may expose your application
  # to injection attacks if not done properly. As an alternative, it is recommended
  # to use one of the following methods.
  #
  # === \Array
  #
  # If an array is passed, then the first element of the array is treated as a template, and
  # the remaining elements are inserted into the template to generate the condition.
  # Active Record takes care of building the query to avoid injection attacks, and will
  # convert from the ruby type to the database type where needed. Elements are inserted
  # into the string in the order in which they appear.
  #
  #   User.where(["name = ? and email = ?", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # Alternatively, you can use named placeholders in the template, and pass a hash as the
  # second element of the array. The names in the template are replaced with the corresponding
  # values from the hash.
  #
  #   User.where(["name = :name and email = :email", { name: "Joe", email: "joe@example.com" }])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # This can make for more readable code in complex queries.
  #
  # Lastly, you can use sprintf-style % escapes in the template. This works slightly differently
  # than the previous methods; you are responsible for ensuring that the values in the template
  # are properly quoted. The values are passed to the connector for quoting, but the caller
  # is responsible for ensuring they are enclosed in quotes in the resulting SQL. After quoting,
  # the values are inserted using the same escapes as the Ruby core method +Kernel::sprintf+.
  #
  #   User.where(["name = '%s' and email = '%s'", "Joe", "joe@example.com"])
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # If #where is called with multiple arguments, these are treated as if they were passed as
  # the elements of a single array.
  #
  #   User.where("name = :name and email = :email", { name: "Joe", email: "joe@example.com" })
  #   # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com';
  #
  # When using strings to specify conditions, you can use any operator available from
  # the database. While this provides the most flexibility, you can also unintentionally introduce
  # dependencies on the underlying database. If your code is intended for general consumption,
  # test with multiple database backends.
  #
  # === \Hash
  #
  # #where will also accept a hash condition, in which the keys are fields and the values
  # are values to be searched for.
  #
  # Fields can be symbols or strings. Values can be single values, arrays, or ranges.
  #
  #    User.where(name: "Joe", email: "joe@example.com")
  #    # SELECT * FROM users WHERE name = 'Joe' AND email = 'joe@example.com'
  #
  #    User.where(name: ["Alice", "Bob"])
  #    # SELECT * FROM users WHERE name IN ('Alice', 'Bob')
  #
  #    User.where(created_at: (Time.now.midnight - 1.day)..Time.now.midnight)
  #    # SELECT * FROM users WHERE (created_at BETWEEN '2012-06-09 07:00:00.000000' AND '2012-06-10 07:00:00.000000')
  #
  # In the case of a belongs_to relationship, an association key can be used
  # to specify the model if an ActiveRecord object is used as the value.
  #
  #    author = Author.find(1)
  #
  #    # The following queries will be equivalent:
  #    Post.where(author: author)
  #    Post.where(author_id: author)
  #
  # This also works with polymorphic belongs_to relationships:
  #
  #    treasure = Treasure.create(name: 'gold coins')
  #    treasure.price_estimates << PriceEstimate.create(price: 125)
  #
  #    # The following queries will be equivalent:
  #    PriceEstimate.where(estimate_of: treasure)
  #    PriceEstimate.where(estimate_of_type: 'Treasure', estimate_of_id: treasure)
  #
  # Hash conditions may also be specified in a tuple-like syntax. Hash keys may be
  # an array of columns with an array of tuples as values.
  #
  #   Article.where([:author_id, :id] => [[15, 1], [15, 2]])
  #   # SELECT * FROM articles WHERE author_id = 15 AND id = 1 OR author_id = 15 AND id = 2
  #
  # === Joins
  #
  # If the relation is the result of a join, you may create a condition which uses any of the
  # tables in the join. For string and array conditions, use the table name in the condition.
  #
  #    User.joins(:posts).where("posts.created_at < ?", Time.now)
  #
  # For hash conditions, you can either use the table name in the key, or use a sub-hash.
  #
  #    User.joins(:posts).where("posts.published" => true)
  #    User.joins(:posts).where(posts: { published: true })
  #
  # === No Argument
  #
  # If no argument is passed, #where returns a new instance of WhereChain, that
  # can be chained with WhereChain#not, WhereChain#missing, or WhereChain#associated.
  #
  # Chaining with WhereChain#not:
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  # Chaining with WhereChain#associated:
  #
  #    Post.where.associated(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NOT NULL
  #
  # Chaining with WhereChain#missing:
  #
  #    Post.where.missing(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NULL
  #
  # === Blank Condition
  #
  # If the condition is any blank-ish object, then #where is a no-op and returns
  # the current relation.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#932
  def where(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#942
  def where!(opts, *rest); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def where_clause; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def where_clause=(value); end

  # Add a Common Table Expression (CTE) that you can then reference within another SELECT statement.
  #
  # Note: CTE's are only supported in MySQL for versions 8.0 and above. You will not be able to
  # use CTE's with MySQL 5.7.
  #
  #   Post.with(posts_with_tags: Post.where("tags_count > ?", 0))
  #   # => ActiveRecord::Relation
  #   # WITH posts_with_tags AS (
  #   #   SELECT * FROM posts WHERE (tags_count > 0)
  #   # )
  #   # SELECT * FROM posts
  #
  # Once you define Common Table Expression you can use custom +FROM+ value or +JOIN+ to reference it.
  #
  #   Post.with(posts_with_tags: Post.where("tags_count > ?", 0)).from("posts_with_tags AS posts")
  #   # => ActiveRecord::Relation
  #   # WITH posts_with_tags AS (
  #   #  SELECT * FROM posts WHERE (tags_count > 0)
  #   # )
  #   # SELECT * FROM posts_with_tags AS posts
  #
  #   Post.with(posts_with_tags: Post.where("tags_count > ?", 0)).joins("JOIN posts_with_tags ON posts_with_tags.id = posts.id")
  #   # => ActiveRecord::Relation
  #   # WITH posts_with_tags AS (
  #   #   SELECT * FROM posts WHERE (tags_count > 0)
  #   # )
  #   # SELECT * FROM posts JOIN posts_with_tags ON posts_with_tags.id = posts.id
  #
  # It is recommended to pass a query as ActiveRecord::Relation. If that is not possible
  # and you have verified it is safe for the database, you can pass it as SQL literal
  # using +Arel+.
  #
  #   Post.with(popular_posts: Arel.sql("... complex sql to calculate posts popularity ..."))
  #
  # Great caution should be taken to avoid SQL injection vulnerabilities. This method should not
  # be used with unsafe values that include unsanitized input.
  #
  # To add multiple CTEs just pass multiple key-value pairs
  #
  #   Post.with(
  #     posts_with_comments: Post.where("comments_count > ?", 0),
  #     posts_with_tags: Post.where("tags_count > ?", 0)
  #   )
  #
  # or chain multiple +.with+ calls
  #
  #   Post
  #     .with(posts_with_comments: Post.where("comments_count > ?", 0))
  #     .with(posts_with_tags: Post.where("tags_count > ?", 0))
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#459
  def with(*args); end

  # Like #with, but modifies relation in place.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#465
  def with!(*args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def with_values; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#159
  def with_values=(value); end

  # Excludes the specified record (or collection of records) from the resulting
  # relation. For example:
  #
  #   Post.excluding(post)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."id" != 1
  #
  #   Post.excluding(post_one, post_two)
  #   # SELECT "posts".* FROM "posts" WHERE "posts"."id" NOT IN (1, 2)
  #
  # This can also be called on associations. As with the above example, either
  # a single record of collection thereof may be specified:
  #
  #   post = Post.find(1)
  #   comment = Comment.find(2)
  #   post.comments.excluding(comment)
  #   # SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 AND "comments"."id" != 2
  #
  # This is short-hand for <tt>.where.not(id: post.id)</tt> and <tt>.where.not(id: [post_one.id, post_two.id])</tt>.
  #
  # An <tt>ArgumentError</tt> will be raised if either no records are
  # specified, or if any of the records in the collection (if a collection
  # is passed in) are not instances of the same model that the relation is
  # scoping.
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1470
  def without(*records); end

  protected

  # source://activerecord//lib/active_record/relation/query_methods.rb#1539
  def async!; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1508
  def build_having_clause(opts, rest = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1500
  def build_subquery(subquery_alias, select_value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1508
  def build_where_clause(opts, rest = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/relation/query_methods.rb#1792
  def arel_column(field); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1775
  def arel_columns(columns); end

  # @raise [ImmutableRelation]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1573
  def assert_mutability!; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1545
  def async; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1578
  def build_arel(aliases = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1936
  def build_case_for_value_position(column, values); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1607
  def build_cast_value(name, value); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1611
  def build_from; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1653
  def build_join_buckets; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1562
  def build_join_dependencies; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1709
  def build_joins(join_sources, aliases = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1854
  def build_order(arel); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1731
  def build_select(arel); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1741
  def build_with(arel); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1767
  def build_with_join_node(name, kind = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1753
  def build_with_value_from_hash(hash); end

  # Checks to make sure that the arguments are not blank. Note that if some
  # blank-like object were initially passed into the query method, then this
  # method will not raise an error.
  #
  # Example:
  #
  #    Post.references()   # raises an error
  #    Post.references([]) # does not raise an error
  #
  # This particular method should be called with a method_name (__callee__) and the args
  # passed into that method as an input. For example:
  #
  # def references(*args)
  #   check_if_method_has_arguments!(__callee__, args)
  #   ...
  # end
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1985
  def check_if_method_has_arguments!(method_name, args, message = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1911
  def column_references(order_args); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1843
  def does_not_support_reverse?(order); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1556
  def each_join_dependencies(join_dependencies = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1549
  def lookup_table_klass_from_join_dependencies(table_name); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1926
  def order_column(field); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1874
  def preprocess_order_args(order_args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1996
  def process_select_args(fields); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1945
  def resolve_arel_attributes(attrs); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1814
  def reverse_sql_order(order_query); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1905
  def sanitize_order_arguments(order_args); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1638
  def select_association_list(associations, stashed_joins = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1626
  def select_named_joins(join_names, stashed_joins = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#2036
  def structurally_incompatible_values_for(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#1808
  def table_name_matches?(from); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#2006
  def transform_select_hash_values(fields); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#1862
  def validate_order_args(args); end
end

# A wrapper to distinguish CTE joins from other nodes.
#
# source://activerecord//lib/active_record/relation/query_methods.rb#132
class ActiveRecord::QueryMethods::CTEJoin
  # @return [CTEJoin] a new instance of CTEJoin
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#135
  def initialize(name); end

  # source://activerecord//lib/active_record/relation/query_methods.rb#133
  def name; end
end

# source://activerecord//lib/active_record/relation/query_methods.rb#140
ActiveRecord::QueryMethods::FROZEN_EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/query_methods.rb#141
ActiveRecord::QueryMethods::FROZEN_EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# source://activerecord//lib/active_record/relation/query_methods.rb#2031
ActiveRecord::QueryMethods::STRUCTURAL_VALUE_METHODS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/query_methods.rb#1859
ActiveRecord::QueryMethods::VALID_DIRECTIONS = T.let(T.unsafe(nil), Set)

# source://activerecord//lib/active_record/relation/query_methods.rb#667
ActiveRecord::QueryMethods::VALID_UNSCOPING_VALUES = T.let(T.unsafe(nil), Set)

# +WhereChain+ objects act as placeholder for queries in which +where+ does not have any parameter.
# In this case, +where+ can be chained to return a new relation.
#
# source://activerecord//lib/active_record/relation/query_methods.rb#14
class ActiveRecord::QueryMethods::WhereChain
  # @return [WhereChain] a new instance of WhereChain
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#15
  def initialize(scope); end

  # Returns a new relation with joins and where clause to identify
  # associated relations.
  #
  # For example, posts that are associated to a related author:
  #
  #    Post.where.associated(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NOT NULL
  #
  # Additionally, multiple relations can be combined. This will return posts
  # associated to both an author and any comments:
  #
  #    Post.where.associated(:author, :comments)
  #    # SELECT "posts".* FROM "posts"
  #    # INNER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # INNER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #    # WHERE "authors"."id" IS NOT NULL AND "comments"."id" IS NOT NULL
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#75
  def associated(*associations); end

  # Returns a new relation with left outer joins and where clause to identify
  # missing relations.
  #
  # For example, posts that are missing a related author:
  #
  #    Post.where.missing(:author)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # WHERE "authors"."id" IS NULL
  #
  # Additionally, multiple relations can be combined. This will return posts
  # that are missing both an author and any comments:
  #
  #    Post.where.missing(:author, :comments)
  #    # SELECT "posts".* FROM "posts"
  #    # LEFT OUTER JOIN "authors" ON "authors"."id" = "posts"."author_id"
  #    # LEFT OUTER JOIN "comments" ON "comments"."post_id" = "posts"."id"
  #    # WHERE "authors"."id" IS NULL AND "comments"."id" IS NULL
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#107
  def missing(*associations); end

  # Returns a new relation expressing WHERE + NOT condition according to
  # the conditions in the arguments.
  #
  # #not accepts conditions as a string, array, or hash. See QueryMethods#where for
  # more details on each format.
  #
  #    User.where.not("name = 'Jon'")
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(["name = ?", "Jon"])
  #    # SELECT * FROM users WHERE NOT (name = 'Jon')
  #
  #    User.where.not(name: "Jon")
  #    # SELECT * FROM users WHERE name != 'Jon'
  #
  #    User.where.not(name: nil)
  #    # SELECT * FROM users WHERE name IS NOT NULL
  #
  #    User.where.not(name: %w(Ko1 Nobu))
  #    # SELECT * FROM users WHERE name NOT IN ('Ko1', 'Nobu')
  #
  #    User.where.not(name: "Jon", role: "admin")
  #    # SELECT * FROM users WHERE NOT (name = 'Jon' AND role = 'admin')
  #
  # If there is a non-nil condition on a nullable column in the hash condition, the records that have
  # nil values on the nullable column won't be returned.
  #    User.create!(nullable_country: nil)
  #    User.where.not(nullable_country: "UK")
  #    # SELECT * FROM users WHERE NOT (nullable_country = 'UK')
  #    # => []
  #
  # source://activerecord//lib/active_record/relation/query_methods.rb#49
  def not(opts, *rest); end

  private

  # source://activerecord//lib/active_record/relation/query_methods.rb#122
  def scope_association_reflection(association); end
end

# source://activerecord//lib/active_record/querying.rb#4
module ActiveRecord::Querying
  # source://activerecord//lib/active_record/querying.rb#65
  def _load_from_sql(result_set, &block); end

  # source://activerecord//lib/active_record/querying.rb#61
  def _query_by_sql(sql, binds = T.unsafe(nil), preparable: T.unsafe(nil), async: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/querying.rb#23
  def and(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def annotate(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def any?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_average(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_count(*_arg0, **_arg1, &_arg2); end

  # Same as <tt>#count_by_sql</tt> but perform the query asynchronously and returns an ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/querying.rb#106
  def async_count_by_sql(sql); end

  # Same as <tt>#find_by_sql</tt> but perform the query asynchronously and returns an ActiveRecord::Promise.
  #
  # source://activerecord//lib/active_record/querying.rb#55
  def async_find_by_sql(sql, binds = T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_ids(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_maximum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_minimum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_pick(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_pluck(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def async_sum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def average(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def calculate(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def count(*_arg0, **_arg1, &_arg2); end

  # Returns the result of an SQL statement that should only include a COUNT(*) in the SELECT part.
  # The use of this method should be restricted to complicated SQL queries that can't be executed
  # using the ActiveRecord::Calculations class methods. Look into those before using this method,
  # as it could lock you into a specific database engine or require a code change to switch
  # database engines.
  #
  #   Product.count_by_sql "SELECT COUNT(*) FROM sales s, customers c WHERE s.customer_id = c.id"
  #   # => 12
  #
  # ==== Parameters
  #
  # * +sql+ - An SQL statement which should return a count query from the database, see the example above.
  #
  # source://activerecord//lib/active_record/querying.rb#101
  def count_by_sql(sql); end

  # source://activerecord//lib/active_record/querying.rb#23
  def create_or_find_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def create_or_find_by!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def create_with(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def delete_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def delete_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def destroy_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def destroy_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def distinct(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def eager_load(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def except(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def excluding(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def exists?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def extending(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def extract_associated(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def fifth(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def fifth!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_by!(*_arg0, **_arg1, &_arg2); end

  # Executes a custom SQL query against your database and returns all the results. The results will
  # be returned as an array, with the requested columns encapsulated as attributes of the model you call
  # this method from. For example, if you call <tt>Product.find_by_sql</tt>, then the results will be returned in
  # a +Product+ object with the attributes you specified in the SQL query.
  #
  # If you call a complicated SQL query which spans multiple tables, the columns specified by the
  # SELECT will be attributes of the model, whether or not they are columns of the corresponding
  # table.
  #
  # The +sql+ parameter is a full SQL query as a string. It will be called as is; there will be
  # no database agnostic conversions performed. This should be a last resort because using
  # database-specific terms will lock you into using that particular database engine, or require you to
  # change your call if you switch engines.
  #
  #   # A simple SQL query spanning multiple tables
  #   Post.find_by_sql "SELECT p.title, c.author FROM posts p, comments c WHERE p.id = c.post_id"
  #   # => [#<Post:0x36bff9c @attributes={"title"=>"Ruby Meetup", "author"=>"Quentin"}>, ...]
  #
  # You can use the same string replacement techniques as you can with ActiveRecord::QueryMethods#where :
  #
  #   Post.find_by_sql ["SELECT title FROM posts WHERE author = ? AND created > ?", author_id, start_date]
  #   Post.find_by_sql ["SELECT body FROM comments WHERE author = :user_id OR approved_by = :user_id", { :user_id => user_id }]
  #
  # Note that building your own SQL query string from user input may expose your application to
  # injection attacks (https://guides.rubyonrails.org/security.html#sql-injection).
  #
  # source://activerecord//lib/active_record/querying.rb#50
  def find_by_sql(sql, binds = T.unsafe(nil), preparable: T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_each(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_in_batches(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_or_create_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_or_create_by!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_or_initialize_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def find_sole_by(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def first(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def first!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def first_or_create(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def first_or_create!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def first_or_initialize(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def forty_two(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def forty_two!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def fourth(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def fourth!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def from(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def group(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def having(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def ids(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def in_batches(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def in_order_of(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def includes(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def invert_where(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def last(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def last!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def left_joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def left_outer_joins(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def limit(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def lock(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def many?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def maximum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def merge(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def minimum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def none(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def none?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def offset(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def one?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def only(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def optimizer_hints(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def or(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def order(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def pick(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def pluck(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def preload(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def readonly(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def references(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def regroup(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def reorder(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def reselect(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def rewhere(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def second(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def second!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def second_to_last(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def second_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def select(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def sole(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def strict_loading(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def sum(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def take(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def take!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def third(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def third!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def third_to_last(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def third_to_last!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def touch_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def unscope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def update_all(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def where(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def with(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/querying.rb#23
  def without(*_arg0, **_arg1, &_arg2); end
end

# source://activerecord//lib/active_record/querying.rb#5
ActiveRecord::Querying::QUERYING_METHODS = T.let(T.unsafe(nil), Array)

# = Active Record Railtie
#
# source://activerecord//lib/active_record/railtie.rb#16
class ActiveRecord::Railtie < ::Rails::Railtie; end

# source://activerecord//lib/active_record/railtie.rb#230
ActiveRecord::Railtie::SQLITE3_PRODUCTION_WARN = T.let(T.unsafe(nil), String)

# Raised when values that executed are out of range.
#
# source://activerecord//lib/active_record/errors.rb#280
class ActiveRecord::RangeError < ::ActiveRecord::StatementInvalid; end

# Raised when a write to the database is attempted on a read only connection.
#
# source://activerecord//lib/active_record/errors.rb#123
class ActiveRecord::ReadOnlyError < ::ActiveRecord::ActiveRecordError; end

# Raised on attempt to update record that is instantiated as read only.
#
# source://activerecord//lib/active_record/errors.rb#373
class ActiveRecord::ReadOnlyRecord < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/readonly_attributes.rb#4
class ActiveRecord::ReadonlyAttributeError < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/readonly_attributes.rb#7
module ActiveRecord::ReadonlyAttributes
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::ReadonlyAttributes::ClassMethods

  module GeneratedClassMethods
    def _attr_readonly; end
    def _attr_readonly=(value); end
    def _attr_readonly?; end
  end

  module GeneratedInstanceMethods; end
end

# source://activerecord//lib/active_record/readonly_attributes.rb#14
module ActiveRecord::ReadonlyAttributes::ClassMethods
  # Attributes listed as readonly will be used to create a new record.
  # Assigning a new value to a readonly attribute on a persisted record raises an error.
  #
  # By setting +config.active_record.raise_on_assign_to_attr_readonly+ to +false+, it will
  # not raise. The value will change in memory, but will not be persisted on +save+.
  #
  # ==== Examples
  #
  #   class Post < ActiveRecord::Base
  #     attr_readonly :title
  #   end
  #
  #   post = Post.create!(title: "Introducing Ruby on Rails!")
  #   post.title = "a different title" # raises ActiveRecord::ReadonlyAttributeError
  #   post.update(title: "a different title") # raises ActiveRecord::ReadonlyAttributeError
  #
  # source://activerecord//lib/active_record/readonly_attributes.rb#30
  def attr_readonly(*attributes); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/readonly_attributes.rb#43
  def readonly_attribute?(name); end

  # Returns an array of all the attributes that have been specified as readonly.
  #
  # source://activerecord//lib/active_record/readonly_attributes.rb#39
  def readonly_attributes; end
end

# source://activerecord//lib/active_record/readonly_attributes.rb#48
module ActiveRecord::ReadonlyAttributes::HasReadonlyAttributes
  # source://activerecord//lib/active_record/readonly_attributes.rb#57
  def _write_attribute(attr_name, value); end

  # source://activerecord//lib/active_record/readonly_attributes.rb#49
  def write_attribute(attr_name, value); end
end

# = Active Record \RecordInvalid
#
# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base#create!}[rdoc-ref:Persistence::ClassMethods#create!] when the record is invalid.
# Use the #record method to retrieve the record which did not validate.
#
#   begin
#     complex_operation_that_internally_calls_save!
#   rescue ActiveRecord::RecordInvalid => invalid
#     puts invalid.record.errors
#   end
#
# source://activerecord//lib/active_record/validations.rb#15
class ActiveRecord::RecordInvalid < ::ActiveRecord::ActiveRecordError
  # @return [RecordInvalid] a new instance of RecordInvalid
  #
  # source://activerecord//lib/active_record/validations.rb#18
  def initialize(record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/validations.rb#16
  def record; end
end

# Raised by {ActiveRecord::Base#destroy!}[rdoc-ref:Persistence#destroy!]
# when a call to {#destroy}[rdoc-ref:Persistence#destroy]
# would return false.
#
#   begin
#     complex_operation_that_internally_calls_destroy!
#   rescue ActiveRecord::RecordNotDestroyed => invalid
#     puts invalid.record.errors
#   end
#
# source://activerecord//lib/active_record/errors.rb#161
class ActiveRecord::RecordNotDestroyed < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotDestroyed] a new instance of RecordNotDestroyed
  #
  # source://activerecord//lib/active_record/errors.rb#164
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/errors.rb#162
  def record; end
end

# Raised when Active Record cannot find a record by given id or set of ids.
#
# source://activerecord//lib/active_record/errors.rb#127
class ActiveRecord::RecordNotFound < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotFound] a new instance of RecordNotFound
  #
  # source://activerecord//lib/active_record/errors.rb#130
  def initialize(message = T.unsafe(nil), model = T.unsafe(nil), primary_key = T.unsafe(nil), id = T.unsafe(nil)); end

  # Returns the value of attribute id.
  #
  # source://activerecord//lib/active_record/errors.rb#128
  def id; end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/errors.rb#128
  def model; end

  # Returns the value of attribute primary_key.
  #
  # source://activerecord//lib/active_record/errors.rb#128
  def primary_key; end
end

# Raised by {ActiveRecord::Base#save!}[rdoc-ref:Persistence#save!] and
# {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!]
# methods when a record is invalid and cannot be saved.
#
# source://activerecord//lib/active_record/errors.rb#142
class ActiveRecord::RecordNotSaved < ::ActiveRecord::ActiveRecordError
  # @return [RecordNotSaved] a new instance of RecordNotSaved
  #
  # source://activerecord//lib/active_record/errors.rb#145
  def initialize(message = T.unsafe(nil), record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/errors.rb#143
  def record; end
end

# Raised when a record cannot be inserted or updated because it would violate a uniqueness constraint.
#
# source://activerecord//lib/active_record/errors.rb#208
class ActiveRecord::RecordNotUnique < ::ActiveRecord::WrappedDatabaseException; end

# = Active Record Reflection
#
# source://activerecord//lib/active_record/reflection.rb#7
module ActiveRecord::Reflection
  extend ::ActiveSupport::Concern
  extend ::ActiveStorage::Reflection::ReflectionExtension
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Reflection::ClassMethods

  class << self
    # source://activerecord//lib/active_record/reflection.rb#28
    def add_aggregate_reflection(ar, name, reflection); end

    # source://activerecord//lib/active_record/reflection.rb#22
    def add_reflection(ar, name, reflection); end

    # source://activerecord//lib/active_record/reflection.rb#17
    def create(macro, name, scope, options, ar); end

    private

    # source://activestorage/7.1.3.2/lib/active_storage/reflection.rb#37
    def reflection_class_for(macro); end
  end

  module GeneratedClassMethods
    def _reflections; end
    def _reflections=(value); end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections=(value); end
    def aggregate_reflections?; end
    def automatic_scope_inversing; end
    def automatic_scope_inversing=(value); end
    def automatic_scope_inversing?; end
  end

  module GeneratedInstanceMethods
    def _reflections; end
    def _reflections?; end
    def aggregate_reflections; end
    def aggregate_reflections?; end
    def automatic_scope_inversing; end
    def automatic_scope_inversing?; end
  end
end

# Holds all the methods that are shared between MacroReflection and ThroughReflection.
#
#   AbstractReflection
#     MacroReflection
#       AggregateReflection
#       AssociationReflection
#         HasManyReflection
#         HasOneReflection
#         BelongsToReflection
#         HasAndBelongsToManyReflection
#     ThroughReflection
#     PolymorphicReflection
#     RuntimeReflection
#
# source://activerecord//lib/active_record/reflection.rb#156
class ActiveRecord::Reflection::AbstractReflection
  # @return [AbstractReflection] a new instance of AbstractReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#157
  def initialize; end

  # source://activerecord//lib/active_record/reflection.rb#308
  def alias_candidate(name); end

  # Returns a new, unsaved instance of the associated class. +attributes+ will
  # be passed to the class's constructor.
  #
  # source://activerecord//lib/active_record/reflection.rb#175
  def build_association(attributes, &block); end

  # source://activerecord//lib/active_record/reflection.rb#316
  def build_scope(table, predicate_builder = T.unsafe(nil), klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#312
  def chain; end

  # source://activerecord//lib/active_record/reflection.rb#255
  def check_validity_of_inverse!; end

  # Returns the class name for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>'Money'</tt>
  # <tt>has_many :clients</tt> returns <tt>'Client'</tt>
  #
  # source://activerecord//lib/active_record/reflection.rb#183
  def class_name; end

  # source://activerecord//lib/active_record/reflection.rb#233
  def constraints; end

  # source://activerecord//lib/active_record/reflection.rb#237
  def counter_cache_column; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#304
  def counter_must_be_updated_by_has_many?; end

  # Returns whether a counter cache should be used for this association.
  #
  # The counter_cache option must be given on either the owner or inverse
  # association, and the column must be present on the owner.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#298
  def has_cached_counter?; end

  # source://activerecord//lib/active_record/reflection.rb#249
  def inverse_of; end

  # We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  #
  # source://activerecord//lib/active_record/reflection.rb#276
  def inverse_updates_counter_cache?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#290
  def inverse_updates_counter_in_memory?; end

  # We need to avoid the following situation:
  #
  #   * An associated record is deleted via record.destroy
  #   * Hence the callbacks run, and they find a belongs_to on the record with a
  #     :counter_cache options which points back at our owner. So they update the
  #     counter cache.
  #   * In which case, we must make sure to *not* update the counter cache, or else
  #     it will be decremented twice.
  #
  # Hence this method.
  #
  # source://activerecord//lib/active_record/reflection.rb#276
  def inverse_which_updates_counter_cache; end

  # source://activerecord//lib/active_record/reflection.rb#193
  def join_scope(table, foreign_table, foreign_klass); end

  # source://activerecord//lib/active_record/reflection.rb#220
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil), record = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#228
  def klass_join_scope(table, predicate_builder); end

  # Returns a list of scopes that should be applied for this Reflection
  # object when querying the database.
  #
  # source://activerecord//lib/active_record/reflection.rb#189
  def scopes; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#324
  def strict_loading?; end

  # source://activerecord//lib/active_record/reflection.rb#328
  def strict_loading_violation_message(owner); end

  # source://activerecord//lib/active_record/reflection.rb#169
  def table_name; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#165
  def through_reflection?; end

  protected

  # FIXME: this is a horrible name
  #
  # source://activerecord//lib/active_record/reflection.rb#335
  def actual_source_reflection; end

  private

  # source://activerecord//lib/active_record/reflection.rb#348
  def ensure_option_not_given_as_class!(option_name); end

  # source://activerecord//lib/active_record/reflection.rb#340
  def predicate_builder(table); end

  # source://activerecord//lib/active_record/reflection.rb#344
  def primary_key(klass); end
end

# Holds all the metadata about an aggregation as it was specified in the
# Active Record class.
#
# source://activerecord//lib/active_record/reflection.rb#452
class ActiveRecord::Reflection::AggregateReflection < ::ActiveRecord::Reflection::MacroReflection
  # source://activerecord//lib/active_record/reflection.rb#453
  def mapping; end
end

# Holds all the metadata about an association as it was specified in the
# Active Record class.
#
# source://activerecord//lib/active_record/reflection.rb#461
class ActiveRecord::Reflection::AssociationReflection < ::ActiveRecord::Reflection::MacroReflection
  # @return [AssociationReflection] a new instance of AssociationReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#489
  def initialize(name, scope, options, active_record); end

  # source://activerecord//lib/active_record/reflection.rb#537
  def active_record_primary_key; end

  # source://activerecord//lib/active_record/reflection.rb#683
  def add_as_polymorphic_through(reflection, seed); end

  # source://activerecord//lib/active_record/reflection.rb#679
  def add_as_source(seed); end

  # source://activerecord//lib/active_record/reflection.rb#687
  def add_as_through(seed); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/reflection.rb#669
  def association_class; end

  # source://activerecord//lib/active_record/reflection.rb#529
  def association_foreign_key; end

  # source://activerecord//lib/active_record/reflection.rb#533
  def association_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#501
  def association_scope_cache(klass, owner, &block); end

  # Returns +true+ if +self+ is a +belongs_to+ reflection.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#664
  def belongs_to?; end

  # source://activerecord//lib/active_record/reflection.rb#580
  def check_eager_loadable!; end

  # source://activerecord//lib/active_record/reflection.rb#568
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  #
  # source://activerecord//lib/active_record/reflection.rb#612
  def clear_association_scope_cache; end

  # A chain of reflections from this one back to the owner. For more see the explanation in
  # ThroughReflection.
  #
  # source://activerecord//lib/active_record/reflection.rb#606
  def collect_join_chain; end

  # Returns whether or not this association reflection is for a collection
  # association. Returns +true+ if the +macro+ is either +has_many+ or
  # +has_and_belongs_to_many+, +false+ otherwise.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#646
  def collection?; end

  # source://activerecord//lib/active_record/reflection.rb#462
  def compute_class(name); end

  # source://activerecord//lib/active_record/reflection.rb#691
  def extensions; end

  # source://activerecord//lib/active_record/reflection.rb#513
  def foreign_key(infer_from_inverse_of: T.unsafe(nil)); end

  # Returns the value of attribute foreign_type.
  #
  # source://activerecord//lib/active_record/reflection.rb#486
  def foreign_type; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#624
  def has_inverse?; end

  # Returns +true+ if +self+ is a +has_one+ reflection.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#667
  def has_one?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#620
  def has_scope?; end

  # source://activerecord//lib/active_record/reflection.rb#564
  def join_foreign_key; end

  # source://activerecord//lib/active_record/reflection.rb#592
  def join_id_for(owner); end

  # source://activerecord//lib/active_record/reflection.rb#556
  def join_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#560
  def join_primary_type; end

  # source://activerecord//lib/active_record/reflection.rb#509
  def join_table; end

  # Returns the macro type.
  #
  # <tt>has_many :clients</tt> returns <tt>:has_many</tt>
  #
  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/active_record/reflection.rb#641
  def macro; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#616
  def nested?; end

  # Reflection
  #
  # source://activerecord//lib/active_record/reflection.rb#487
  def parent_reflection; end

  # Reflection
  #
  # source://activerecord//lib/active_record/reflection.rb#487
  def parent_reflection=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#671
  def polymorphic?; end

  # source://activerecord//lib/active_record/reflection.rb#628
  def polymorphic_inverse_of(associated_class); end

  # source://activerecord//lib/active_record/reflection.rb#675
  def polymorphic_name; end

  # source://activerecord//lib/active_record/reflection.rb#600
  def source_reflection; end

  # source://activerecord//lib/active_record/reflection.rb#596
  def through_reflection; end

  # Returns the value of attribute type.
  #
  # source://activerecord//lib/active_record/reflection.rb#486
  def type; end

  # Returns whether or not the association should be validated as part of
  # the parent's validation.
  #
  # Unless you explicitly disable validation with
  # <tt>validate: false</tt>, validation will take place when:
  #
  # * you explicitly enable validation; <tt>validate: true</tt>
  # * you use autosave; <tt>autosave: true</tt>
  # * the association is a +has_many+ association
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#659
  def validate?; end

  private

  # returns either +nil+ or the inverse association name that it finds.
  #
  # source://activerecord//lib/active_record/reflection.rb#708
  def automatic_inverse_of; end

  # Checks to see if the reflection doesn't have any options that prevent
  # us from being able to guess the inverse automatically. First, the
  # <tt>inverse_of</tt> option cannot be set to false. Second, we must
  # have <tt>has_many</tt>, <tt>has_one</tt>, <tt>belongs_to</tt> associations.
  # Third, we must not have options such as <tt>:foreign_key</tt>
  # which prevent us from correctly guessing the inverse association.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#746
  def can_find_inverse_of_automatically?(reflection, inverse_reflection = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#767
  def derive_class_name; end

  # source://activerecord//lib/active_record/reflection.rb#785
  def derive_fk_query_constraints(foreign_key); end

  # source://activerecord//lib/active_record/reflection.rb#773
  def derive_foreign_key(infer_from_inverse_of: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#823
  def derive_join_table; end

  # Attempts to find the inverse association name automatically.
  # If it cannot find a suitable inverse association name, it returns
  # +nil+.
  #
  # source://activerecord//lib/active_record/reflection.rb#699
  def inverse_name; end

  # Scopes on the potential inverse reflection prevent automatic
  # <tt>inverse_of</tt>, since the scope could exclude the owner record
  # we would inverse from. Scopes on the reflection itself allow for
  # automatic <tt>inverse_of</tt> as long as
  # <tt>config.active_record.automatic_scope_inversing<tt> is set to
  # +true+ (the default for new applications).
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#759
  def scope_allows_automatic_inverse_of?(reflection, inverse_reflection); end

  # Checks if the inverse reflection that is returned from the
  # +automatic_inverse_of+ method is a valid reflection. We must
  # make sure that the reflection's active_record name matches up
  # with the current reflection's klass name.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#732
  def valid_inverse_reflection?(reflection); end
end

# source://activerecord//lib/active_record/reflection.rb#856
class ActiveRecord::Reflection::BelongsToReflection < ::ActiveRecord::Reflection::AssociationReflection
  # source://activerecord//lib/active_record/reflection.rb#861
  def association_class; end

  # klass option is necessary to support loading polymorphic associations
  #
  # source://activerecord//lib/active_record/reflection.rb#870
  def association_primary_key(klass = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#859
  def belongs_to?; end

  # source://activerecord//lib/active_record/reflection.rb#888
  def join_foreign_key; end

  # source://activerecord//lib/active_record/reflection.rb#892
  def join_foreign_type; end

  # source://activerecord//lib/active_record/reflection.rb#884
  def join_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#857
  def macro; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#897
  def can_find_inverse_of_automatically?(*_arg0); end
end

# = Active Record Reflection
#
# \Reflection enables the ability to examine the associations and aggregations of
# Active Record classes and objects. This information, for example,
# can be used in a form builder that takes an Active Record object
# and creates input fields for all of the attributes depending on their type
# and displays the associations to other objects.
#
# MacroReflection class has info for AggregateReflection and AssociationReflection
# classes.
#
# source://activerecord//lib/active_record/reflection.rb#59
module ActiveRecord::Reflection::ClassMethods
  # source://activerecord//lib/active_record/reflection.rb#121
  def _reflect_on_association(association); end

  # source://activerecord//lib/active_record/reflection.rb#130
  def clear_reflections_cache; end

  # Returns the AggregateReflection object for the named +aggregation+ (use the symbol).
  #
  #   Account.reflect_on_aggregation(:balance) # => the balance AggregateReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#69
  def reflect_on_aggregation(aggregation); end

  # Returns an array of AggregateReflection objects for all the aggregations in the class.
  #
  # source://activerecord//lib/active_record/reflection.rb#61
  def reflect_on_all_aggregations; end

  # Returns an array of AssociationReflection objects for all the
  # associations in the class. If you only want to reflect on a certain
  # association type, pass in the symbol (<tt>:has_many</tt>, <tt>:has_one</tt>,
  # <tt>:belongs_to</tt>) as the first parameter.
  #
  # Example:
  #
  #   Account.reflect_on_all_associations             # returns an array of all associations
  #   Account.reflect_on_all_associations(:has_many)  # returns an array of all has_many associations
  #
  # source://activerecord//lib/active_record/reflection.rb#106
  def reflect_on_all_associations(macro = T.unsafe(nil)); end

  # Returns an array of AssociationReflection objects for all associations which have <tt>:autosave</tt> enabled.
  #
  # source://activerecord//lib/active_record/reflection.rb#126
  def reflect_on_all_autosave_associations; end

  # Returns the AssociationReflection object for the +association+ (use the symbol).
  #
  #   Account.reflect_on_association(:owner)             # returns the owner AssociationReflection
  #   Invoice.reflect_on_association(:line_items).macro  # returns :has_many
  #
  # source://activerecord//lib/active_record/reflection.rb#117
  def reflect_on_association(association); end

  # Returns a Hash of name of the reflection as the key and an AssociationReflection as the value.
  #
  #   Account.reflections # => {"balance" => AggregateReflection}
  #
  # source://activerecord//lib/active_record/reflection.rb#77
  def reflections; end

  private

  # source://activerecord//lib/active_record/reflection.rb#135
  def inherited(subclass); end
end

# source://activerecord//lib/active_record/reflection.rb#902
class ActiveRecord::Reflection::HasAndBelongsToManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#905
  def collection?; end

  # source://activerecord//lib/active_record/reflection.rb#903
  def macro; end
end

# source://activerecord//lib/active_record/reflection.rb#828
class ActiveRecord::Reflection::HasManyReflection < ::ActiveRecord::Reflection::AssociationReflection
  # source://activerecord//lib/active_record/reflection.rb#833
  def association_class; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#831
  def collection?; end

  # source://activerecord//lib/active_record/reflection.rb#829
  def macro; end
end

# source://activerecord//lib/active_record/reflection.rb#842
class ActiveRecord::Reflection::HasOneReflection < ::ActiveRecord::Reflection::AssociationReflection
  # source://activerecord//lib/active_record/reflection.rb#847
  def association_class; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#845
  def has_one?; end

  # source://activerecord//lib/active_record/reflection.rb#843
  def macro; end
end

# Base class for AggregateReflection and AssociationReflection. Objects of
# AggregateReflection and AssociationReflection are returned by the Reflection::ClassMethods.
#
# source://activerecord//lib/active_record/reflection.rb#357
class ActiveRecord::Reflection::MacroReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [MacroReflection] a new instance of MacroReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#376
  def initialize(name, scope, options, active_record); end

  # Returns +true+ if +self+ and +other_aggregation+ have the same +name+ attribute, +active_record+ attribute,
  # and +other_aggregation+ has an options hash assigned to it.
  #
  # source://activerecord//lib/active_record/reflection.rb#421
  def ==(other_aggregation); end

  # Returns the value of attribute active_record.
  #
  # source://activerecord//lib/active_record/reflection.rb#372
  def active_record; end

  # source://activerecord//lib/active_record/reflection.rb#388
  def autosave=(autosave); end

  # source://activerecord//lib/active_record/reflection.rb#415
  def compute_class(name); end

  # Returns the class for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns the Money class
  # <tt>has_many :clients</tt> returns the Client class
  #
  #   class Company < ActiveRecord::Base
  #     has_many :clients
  #   end
  #
  #   Company.reflect_on_association(:clients).klass
  #   # => Client
  #
  # <b>Note:</b> Do not call +klass.new+ or +klass.create+ to instantiate
  # a new association object. Use +build_association+ or +create_association+
  # instead. This allows plugins to hook into association object creation.
  #
  # source://activerecord//lib/active_record/reflection.rb#411
  def klass; end

  # Returns the name of the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>:balance</tt>
  # <tt>has_many :clients</tt> returns <tt>:clients</tt>
  #
  # source://activerecord//lib/active_record/reflection.rb#362
  def name; end

  # Returns the hash of options used for the macro.
  #
  # <tt>composed_of :balance, class_name: 'Money'</tt> returns <tt>{ class_name: "Money" }</tt>
  # <tt>has_many :clients</tt> returns <tt>{}</tt>
  #
  # source://activerecord//lib/active_record/reflection.rb#370
  def options; end

  # source://activerecord//lib/active_record/reflection.rb#374
  def plural_name; end

  # Returns the value of attribute scope.
  #
  # source://activerecord//lib/active_record/reflection.rb#364
  def scope; end

  # source://activerecord//lib/active_record/reflection.rb#429
  def scope_for(relation, owner = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/reflection.rb#434
  def derive_class_name; end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/reflection.rb#438
  def validate_reflection!; end
end

# source://activerecord//lib/active_record/reflection.rb#1166
class ActiveRecord::Reflection::PolymorphicReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [PolymorphicReflection] a new instance of PolymorphicReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#1170
  def initialize(reflection, previous_reflection); end

  # source://activerecord//lib/active_record/reflection.rb#1181
  def constraints; end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def join_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def join_primary_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1176
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil), record = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def klass(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def plural_name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def scope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def scope_for(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1167
  def type(*_arg0, **_arg1, &_arg2); end

  private

  # source://activerecord//lib/active_record/reflection.rb#1186
  def source_type_scope; end
end

# source://activerecord//lib/active_record/reflection.rb#1193
class ActiveRecord::Reflection::RuntimeReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [RuntimeReflection] a new instance of RuntimeReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#1196
  def initialize(reflection, association); end

  # source://activerecord//lib/active_record/reflection.rb#1206
  def aliased_table; end

  # source://activerecord//lib/active_record/reflection.rb#1214
  def all_includes; end

  # source://activerecord//lib/active_record/reflection.rb#1194
  def constraints(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1194
  def join_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1210
  def join_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#1202
  def klass; end

  # source://activerecord//lib/active_record/reflection.rb#1194
  def scope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1194
  def type(*_arg0, **_arg1, &_arg2); end
end

# Holds all the metadata about a :through association as it was specified
# in the Active Record class.
#
# source://activerecord//lib/active_record/reflection.rb#912
class ActiveRecord::Reflection::ThroughReflection < ::ActiveRecord::Reflection::AbstractReflection
  # @return [ThroughReflection] a new instance of ThroughReflection
  #
  # source://activerecord//lib/active_record/reflection.rb#916
  def initialize(delegate_reflection); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def active_record(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#913
  def active_record_primary_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1128
  def add_as_polymorphic_through(reflection, seed); end

  # source://activerecord//lib/active_record/reflection.rb#1124
  def add_as_source(seed); end

  # source://activerecord//lib/active_record/reflection.rb#1132
  def add_as_through(seed); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def association_class(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#913
  def association_foreign_key(*_arg0, **_arg1, &_arg2); end

  # We want to use the klass from this reflection, rather than just delegate straight to
  # the source_reflection, because the source_reflection may be polymorphic. We still
  # need to respect the source_reflection's :primary_key option, though.
  #
  # source://activerecord//lib/active_record/reflection.rb#1021
  def association_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def association_scope_cache(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def autosave=(arg); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def belongs_to?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def check_eager_loadable!(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1078
  def check_validity!; end

  # This is for clearing cache on the reflection. Useful for tests that need to compare
  # SQL queries on associations.
  #
  # source://activerecord//lib/active_record/reflection.rb#993
  def clear_association_scope_cache; end

  # Returns an array of reflections which are involved in this association. Each item in the
  # array corresponds to a table which will be part of the query for this association.
  #
  # The chain is built by recursively calling #chain on the source reflection and the through
  # reflection. The base case for the recursion is a normal association, which just returns
  # [self] as its #chain.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.chain
  #   # => [<ActiveRecord::Reflection::ThroughReflection: @delegate_reflection=#<ActiveRecord::Reflection::HasManyReflection: @name=:tags...>,
  #         <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @options={}, @active_record=Post>]
  #
  # source://activerecord//lib/active_record/reflection.rb#987
  def collect_join_chain; end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def collection?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def compute_class(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1118
  def constraints; end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def extensions(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#913
  def foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#913
  def foreign_type(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def has_inverse?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def has_one?(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#1007
  def has_scope?; end

  # source://activerecord//lib/active_record/reflection.rb#913
  def join_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#913
  def join_id_for(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1031
  def join_primary_key(klass = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def join_primary_type(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1003
  def join_scopes(table, predicate_builder, klass = T.unsafe(nil), record = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def join_table(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#929
  def klass; end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def macro(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def name(*_arg0, **_arg1, &_arg2); end

  # A through association is nested if there would be more than one join table
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#1014
  def nested?; end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def options(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def parent_reflection(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def parent_reflection=(arg); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def plural_name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def polymorphic?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def polymorphic_inverse_of(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def polymorphic_name(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def scope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def scope_for(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#999
  def scopes; end

  # source://activerecord//lib/active_record/reflection.rb#1070
  def source_options; end

  # Returns the source of the through reflection. It checks both a singularized
  # and pluralized form for <tt>:belongs_to</tt> or <tt>:has_many</tt>.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   class Tagging < ActiveRecord::Base
  #     belongs_to :post
  #     belongs_to :tag
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection
  #   # => <ActiveRecord::Reflection::BelongsToReflection: @name=:tag, @active_record=Tagging, @plural_name="tags">
  #
  # source://activerecord//lib/active_record/reflection.rb#950
  def source_reflection; end

  # source://activerecord//lib/active_record/reflection.rb#1050
  def source_reflection_name; end

  # Gets an array of possible <tt>:through</tt> source reflection names in both singular and plural form.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.source_reflection_names
  #   # => [:tag, :tags]
  #
  # source://activerecord//lib/active_record/reflection.rb#1046
  def source_reflection_names; end

  # source://activerecord//lib/active_record/reflection.rb#1074
  def through_options; end

  # Returns the AssociationReflection object specified in the <tt>:through</tt> option
  # of a HasManyThrough or HasOneThrough association.
  #
  #   class Post < ActiveRecord::Base
  #     has_many :taggings
  #     has_many :tags, through: :taggings
  #   end
  #
  #   tags_reflection = Post.reflect_on_association(:tags)
  #   tags_reflection.through_reflection
  #   # => <ActiveRecord::Reflection::HasManyReflection: @name=:taggings, @active_record=Post, @plural_name="taggings">
  #
  # source://activerecord//lib/active_record/reflection.rb#966
  def through_reflection; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/reflection.rb#925
  def through_reflection?; end

  # source://activerecord//lib/active_record/reflection.rb#913
  def type(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/reflection.rb#1163
  def validate?(*_arg0, **_arg1, &_arg2); end

  protected

  # FIXME: this is a horrible name
  #
  # source://activerecord//lib/active_record/reflection.rb#1137
  def actual_source_reflection; end

  private

  # source://activerecord//lib/active_record/reflection.rb#1144
  def collect_join_reflections(seed); end

  # Returns the value of attribute delegate_reflection.
  #
  # source://activerecord//lib/active_record/reflection.rb#1142
  def delegate_reflection; end

  # source://activerecord//lib/active_record/reflection.rb#1155
  def derive_class_name; end

  # source://activerecord//lib/active_record/reflection.rb#1153
  def inverse_name; end
end

# = Active Record \Relation
#
# source://activerecord//lib/active_record/relation.rb#5
class ActiveRecord::Relation
  include ::Enumerable
  include ::ActiveRecord::Delegation
  include ::ActiveRecord::Explain
  include ::ActiveRecord::Batches
  include ::ActiveModel::ForbiddenAttributesProtection
  include ::ActiveRecord::QueryMethods
  include ::ActiveRecord::SpawnMethods
  include ::ActiveRecord::Calculations
  include ::ActiveRecord::FinderMethods
  extend ::ActiveRecord::Delegation::ClassMethods

  # @return [Relation] a new instance of Relation
  #
  # source://activerecord//lib/active_record/relation.rb#28
  def initialize(klass, table: T.unsafe(nil), predicate_builder: T.unsafe(nil), values: T.unsafe(nil)); end

  # Compares two relations for equality.
  #
  # source://activerecord//lib/active_record/relation.rb#813
  def ==(other); end

  # source://activerecord//lib/active_record/relation.rb#471
  def _exec_scope(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation.rb#863
  def alias_tracker(joins = T.unsafe(nil), aliases = T.unsafe(nil)); end

  # Returns true if there are any records.
  #
  # When a pattern argument is given, this method checks whether elements in
  # the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).
  #
  #    posts.any?(Post) # => true or false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#312
  def any?(*args); end

  # @yield [attr, bind]
  #
  # source://activerecord//lib/active_record/relation.rb#46
  def bind_attribute(name, value); end

  # Returns true if relation is blank.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#834
  def blank?; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  #
  # source://activerecord//lib/active_record/relation.rb#69
  def build(attributes = T.unsafe(nil), &block); end

  # Returns a stable cache key that can be used to identify this query.
  # The cache key is built with a fingerprint of the SQL query.
  #
  #    Product.where("name like ?", "%Cosmic Encounter%").cache_key
  #    # => "products/query-1850ab3d302391b85b8693e941286659"
  #
  # If ActiveRecord::Base.collection_cache_versioning is turned off, as it was
  # in \Rails 6.0 and earlier, the cache key will also include a version.
  #
  #    ActiveRecord::Base.collection_cache_versioning = false
  #    Product.where("name like ?", "%Cosmic Encounter%").cache_key
  #    # => "products/query-1850ab3d302391b85b8693e941286659-1-20150714212553907087000"
  #
  # You can also pass a custom timestamp column to fetch the timestamp of the
  # last updated record.
  #
  #   Product.where("name like ?", "%Game%").cache_key(:last_reviewed_at)
  #
  # source://activerecord//lib/active_record/relation.rb#359
  def cache_key(timestamp_column = T.unsafe(nil)); end

  # Returns a cache key along with the version.
  #
  # source://activerecord//lib/active_record/relation.rb#438
  def cache_key_with_version; end

  # Returns a cache version that can be used together with the cache key to form
  # a recyclable caching scheme. The cache version is built with the number of records
  # matching the query, and the timestamp of the last updated record. When a new record
  # comes to match the query, or any of the existing records is updated or deleted,
  # the cache version changes.
  #
  # If the collection is loaded, the method will iterate through the records
  # to generate the timestamp, otherwise it will trigger one SQL query like:
  #
  #    SELECT COUNT(*), MAX("products"."updated_at") FROM "products" WHERE (name like '%Cosmic Encounter%')
  #
  # source://activerecord//lib/active_record/relation.rb#386
  def cache_version(timestamp_column = T.unsafe(nil)); end

  # Tries to create a new record with the same scoped attributes
  # defined in the relation. Returns the initialized object if validation fails.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create}[rdoc-ref:Persistence::ClassMethods#create].
  #
  # ==== Examples
  #
  #   users = User.where(name: 'Oscar')
  #   users.create # => #<User id: 3, name: "Oscar", ...>
  #
  #   users.create(name: 'fxn')
  #   users.create # => #<User id: 4, name: "fxn", ...>
  #
  #   users.create { |user| user.name = 'tenderlove' }
  #   # => #<User id: 5, name: "tenderlove", ...>
  #
  #   users.create(name: nil) # validation on name
  #   # => #<User id: nil, name: nil, ...>
  #
  # source://activerecord//lib/active_record/relation.rb#98
  def create(attributes = T.unsafe(nil), &block); end

  # Similar to #create, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!]
  # on the base class. Raises an exception if a validation error occurs.
  #
  # Expects arguments in the same format as
  # {ActiveRecord::Base.create!}[rdoc-ref:Persistence::ClassMethods#create!].
  #
  # source://activerecord//lib/active_record/relation.rb#113
  def create!(attributes = T.unsafe(nil), &block); end

  # Attempts to create a record with the given attributes in a table that has a unique database constraint
  # on one or several of its columns. If a row already exists with one or several of these
  # unique constraints, the exception such an insertion would normally raise is caught,
  # and the existing record with those attributes is found using #find_by!.
  #
  # This is similar to #find_or_create_by, but tries to create the record first. As such it is
  # better suited for cases where the record is most likely not to exist yet.
  #
  # There are several drawbacks to #create_or_find_by, though:
  #
  # * The underlying table must have the relevant columns defined with unique database constraints.
  # * A unique constraint violation may be triggered by only one, or at least less than all,
  #   of the given attributes. This means that the subsequent #find_by! may fail to find a
  #   matching record, which will then raise an ActiveRecord::RecordNotFound exception,
  #   rather than a record with the given attributes.
  # * While we avoid the race condition between SELECT -> INSERT from #find_or_create_by,
  #   we actually have another race condition between INSERT -> SELECT, which can be triggered
  #   if a DELETE between those two statements is run by another client. But for most applications,
  #   that's a significantly less likely condition to hit.
  # * It relies on exception handling to handle control flow, which may be marginally slower.
  # * The primary key may auto-increment on each create, even if it fails. This can accelerate
  #   the problem of running out of integers, if the underlying table is still stuck on a primary
  #   key of type int (note: All \Rails apps since 5.1+ have defaulted to bigint, which is not liable
  #   to this problem).
  #
  # This method will return a record if all given attributes are covered by unique constraints
  # (unless the INSERT -> DELETE -> SELECT race condition is triggered), but if creation was attempted
  # and failed due to validation errors it won't be persisted, you get what #create returns in
  # such situation.
  #
  # source://activerecord//lib/active_record/relation.rb#215
  def create_or_find_by(attributes, &block); end

  # Like #create_or_find_by, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception
  # is raised if the created record is invalid.
  #
  # source://activerecord//lib/active_record/relation.rb#228
  def create_or_find_by!(attributes, &block); end

  # Deletes the records without instantiating the records
  # first, and hence not calling the {#destroy}[rdoc-ref:Persistence#destroy]
  # method nor invoking callbacks.
  # This is a single SQL DELETE statement that goes straight to the database, much more
  # efficient than #destroy_all. Be careful with relations though, in particular
  # <tt>:dependent</tt> rules defined on associations are not honored. Returns the
  # number of rows affected.
  #
  #   Post.where(person_id: 5).where(category: ['Something', 'Else']).delete_all
  #
  # Both calls delete the affected posts all at once with a single DELETE statement.
  # If you need to destroy dependent associations or call your <tt>before_*</tt> or
  # +after_destroy+ callbacks, use the #destroy_all method instead.
  #
  # If an invalid method is supplied, #delete_all raises an ActiveRecordError:
  #
  #   Post.distinct.delete_all
  #   # => ActiveRecord::ActiveRecordError: delete_all doesn't support distinct
  #
  # source://activerecord//lib/active_record/relation.rb#646
  def delete_all; end

  # Finds and deletes all records matching the specified conditions.
  # This is short-hand for <tt>relation.where(condition).delete_all</tt>.
  # Returns the number of rows affected.
  #
  # If no record is found, returns <tt>0</tt> as zero rows were affected.
  #
  #   Person.delete_by(id: 13)
  #   Person.delete_by(name: 'Spartacus', rating: 4)
  #   Person.delete_by("published_at < ?", 2.weeks.ago)
  #
  # source://activerecord//lib/active_record/relation.rb#689
  def delete_by(*args); end

  # Destroys the records by instantiating each
  # record and calling its {#destroy}[rdoc-ref:Persistence#destroy] method.
  # Each object's callbacks are executed (including <tt>:dependent</tt> association options).
  # Returns the collection of objects that were destroyed; each will be frozen, to
  # reflect that no changes should be made (since they can't be persisted).
  #
  # Note: Instantiation, callback execution, and deletion of each
  # record can be time consuming when you're removing many records at
  # once. It generates at least one SQL +DELETE+ query per record (or
  # possibly more, to enforce your callbacks). If you want to delete many
  # rows quickly, without concern for their associations or callbacks, use
  # #delete_all instead.
  #
  # ==== Examples
  #
  #   Person.where(age: 0..18).destroy_all
  #
  # source://activerecord//lib/active_record/relation.rb#624
  def destroy_all; end

  # Finds and destroys all records matching the specified conditions.
  # This is short-hand for <tt>relation.where(condition).destroy_all</tt>.
  # Returns the collection of objects that were destroyed.
  #
  # If no record is found, returns empty array.
  #
  #   Person.destroy_by(id: 13)
  #   Person.destroy_by(name: 'Spartacus', rating: 4)
  #   Person.destroy_by("published_at < ?", 2.weeks.ago)
  #
  # source://activerecord//lib/active_record/relation.rb#676
  def destroy_by(*args); end

  # Returns true if relation needs eager loading.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#798
  def eager_loading?; end

  # Returns true if there are no records.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#283
  def empty?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#855
  def empty_scope?; end

  # Serializes the relation objects Array.
  #
  # source://activerecord//lib/active_record/relation.rb#269
  def encode_with(coder); end

  # Runs EXPLAIN on the query or queries triggered by this relation and
  # returns the result as a string. The string is formatted imitating the
  # ones printed by the database shell.
  #
  # Note that this method actually runs the queries, since the results of some
  # are needed by the next ones when eager loading is going on.
  #
  # Please see further details in the
  # {Active Record Query Interface guide}[https://guides.rubyonrails.org/active_record_querying.html#running-explain].
  #
  # source://activerecord//lib/active_record/relation.rb#253
  def explain(*options); end

  # Finds the first record with the given attributes, or creates a record
  # with the attributes if one is not found:
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Penélope" or create a new one.
  #   # We already have one so the existing record will be returned.
  #   User.find_or_create_by(first_name: 'Penélope')
  #   # => #<User id: 1, first_name: "Penélope", last_name: nil>
  #
  #   # Find the first user named "Scarlett" or create a new one with
  #   # a particular last name.
  #   User.create_with(last_name: 'Johansson').find_or_create_by(first_name: 'Scarlett')
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method accepts a block, which is passed down to #create. The last example
  # above can be alternatively written this way:
  #
  #   # Find the first user named "Scarlett" or create a new one with a
  #   # particular last name.
  #   User.find_or_create_by(first_name: 'Scarlett') do |user|
  #     user.last_name = 'Johansson'
  #   end
  #   # => #<User id: 2, first_name: "Scarlett", last_name: "Johansson">
  #
  # This method always returns a record, but if creation was attempted and
  # failed due to validation errors it won't be persisted, you get what
  # #create returns in such situation.
  #
  # If creation failed because of a unique constraint, this method will
  # assume it encountered a race condition and will try finding the record
  # once more. If somehow the second find still does not find a record
  # because a concurrent DELETE happened, it will then raise an
  # ActiveRecord::RecordNotFound exception.
  #
  # Please note <b>this method is not atomic</b>, it runs first a SELECT,
  # and if there are no results an INSERT is attempted. So if the table
  # doesn't have a relevant unique constraint it could be the case that
  # you end up with two or more similar records.
  #
  # source://activerecord//lib/active_record/relation.rb#175
  def find_or_create_by(attributes, &block); end

  # Like #find_or_create_by, but calls
  # {create!}[rdoc-ref:Persistence::ClassMethods#create!] so an exception
  # is raised if the created record is invalid.
  #
  # source://activerecord//lib/active_record/relation.rb#182
  def find_or_create_by!(attributes, &block); end

  # Like #find_or_create_by, but calls {new}[rdoc-ref:Core#new]
  # instead of {create}[rdoc-ref:Persistence::ClassMethods#create].
  #
  # source://activerecord//lib/active_record/relation.rb#240
  def find_or_initialize_by(attributes, &block); end

  # source://activerecord//lib/active_record/relation.rb#122
  def first_or_create(attributes = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/relation.rb#126
  def first_or_create!(attributes = T.unsafe(nil), &block); end

  # source://activerecord//lib/active_record/relation.rb#130
  def first_or_initialize(attributes = T.unsafe(nil), &block); end

  # source://groupdate/6.4.0/lib/groupdate/relation.rb#8
  def groupdate_values; end

  # source://groupdate/6.4.0/lib/groupdate/relation.rb#8
  def groupdate_values=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#859
  def has_limit_or_offset?; end

  # source://activerecord//lib/active_record/relation.rb#846
  def inspect; end

  # Joins that are also marked for preloading. In which case we should just eager load them.
  # Note that this is a naive implementation because we could have strings and symbols which
  # represent the same association, but that aren't matched by this. Also, we could have
  # nested hashes which partially match, e.g. <tt>{ a: :b } & { a: [:b, :c] }</tt>
  #
  # source://activerecord//lib/active_record/relation.rb#808
  def joined_includes_values; end

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def klass; end

  # Causes the records to be loaded from the database if they have not
  # been loaded already. You can use this if for some reason you need
  # to explicitly load some records before actually using them. The
  # return value is the relation itself, not the records.
  #
  #   Post.where(published: true).load # => #<ActiveRecord::Relation>
  #
  # source://activerecord//lib/active_record/relation.rb#740
  def load(&block); end

  # Schedule the query to be performed from a background thread pool.
  #
  #   Post.where(published: true).load_async # => #<ActiveRecord::Relation>
  #
  # When the +Relation+ is iterated, if the background query wasn't executed yet,
  # it will be performed by the foreground thread.
  #
  # Note that {config.active_record.async_query_executor}[https://guides.rubyonrails.org/configuring.html#config-active-record-async-query-executor] must be configured
  # for queries to actually be executed concurrently. Otherwise it defaults to
  # executing them in the foreground.
  #
  # +load_async+ will also fall back to executing in the foreground in the test environment when transactional
  # fixtures are enabled.
  #
  # If the query was actually executed in the background, the Active Record logs will show
  # it by prefixing the log line with <tt>ASYNC</tt>:
  #
  #   ASYNC Post Load (0.0ms) (db time 2ms)  SELECT "posts".* FROM "posts" LIMIT 100
  #
  # source://activerecord//lib/active_record/relation.rb#711
  def load_async; end

  # Returns the value of attribute loaded.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def loaded; end

  # Returns the value of attribute loaded.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def loaded?; end

  # source://activerecord//lib/active_record/relation/query_methods.rb#155
  def locked?; end

  # Returns true if there is more than one record.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#334
  def many?; end

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def model; end

  # Initializes new record from relation while maintaining the current
  # scope.
  #
  # Expects arguments in the same format as {ActiveRecord::Base.new}[rdoc-ref:Core.new].
  #
  #   users = User.where(name: 'DHH')
  #   user = users.new # => #<User id: nil, name: "DHH", created_at: nil, updated_at: nil>
  #
  # You can also pass a block to new with the new record as argument:
  #
  #   user = users.new { |user| user.name = 'Oscar' }
  #   user.name # => Oscar
  #
  # source://activerecord//lib/active_record/relation.rb#69
  def new(attributes = T.unsafe(nil), &block); end

  # Returns true if there are no records.
  #
  # When a pattern argument is given, this method checks whether elements in
  # the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).
  #
  #   posts.none?(Comment) # => true or false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#299
  def none?(*args); end

  # Returns true if there is exactly one record.
  #
  # When a pattern argument is given, this method checks whether elements in
  # the Enumerable match the pattern via the case-equality operator (<tt>===</tt>).
  #
  #    posts.one?(Post) # => true or false
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#325
  def one?(*args); end

  # Returns the value of attribute predicate_builder.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def predicate_builder; end

  # source://activerecord//lib/active_record/relation.rb#877
  def preload_associations(records); end

  # source://activerecord//lib/active_record/relation.rb#824
  def pretty_print(pp); end

  # source://activerecord//lib/active_record/relation.rb#263
  def records; end

  # Forces reloading of relation.
  #
  # source://activerecord//lib/active_record/relation.rb#750
  def reload; end

  # source://activerecord//lib/active_record/relation.rb#755
  def reset; end

  # Returns <tt>true</tt> if the relation was scheduled on the background
  # thread pool.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#730
  def scheduled?; end

  # source://activerecord//lib/active_record/relation.rb#791
  def scope_for_create; end

  # Scope all queries to the current scope.
  #
  #   Comment.where(post_id: 1).scoping do
  #     Comment.first
  #   end
  #   # SELECT "comments".* FROM "comments" WHERE "comments"."post_id" = 1 ORDER BY "comments"."id" ASC LIMIT 1
  #
  # If <tt>all_queries: true</tt> is passed, scoping will apply to all queries
  # for the relation including +update+ and +delete+ on instances.
  # Once +all_queries+ is set to true it cannot be set to false in a
  # nested block.
  #
  # Please check unscoped if you want to remove all previous scopes (including
  # the default_scope) during the execution of a block.
  #
  # source://activerecord//lib/active_record/relation.rb#460
  def scoping(all_queries: T.unsafe(nil), &block); end

  # Returns size of the records.
  #
  # source://activerecord//lib/active_record/relation.rb#274
  def size; end

  # Returns the value of attribute skip_preloading_value.
  #
  # source://activerecord//lib/active_record/relation.rb#23
  def skip_preloading_value; end

  # Sets the attribute skip_preloading_value
  #
  # @param value the value to set the attribute skip_preloading_value to.
  #
  # source://activerecord//lib/active_record/relation.rb#23
  def skip_preloading_value=(_arg0); end

  # Returns the value of attribute table.
  #
  # source://activerecord//lib/active_record/relation.rb#22
  def table; end

  # Converts relation objects to Array.
  #
  # source://activerecord//lib/active_record/relation.rb#258
  def to_a; end

  # Converts relation objects to Array.
  #
  # source://activerecord//lib/active_record/relation.rb#258
  def to_ary; end

  # Returns sql statement for the relation.
  #
  #   User.where(name: 'Oscar').to_sql
  #   # SELECT "users".* FROM "users"  WHERE "users"."name" = 'Oscar'
  #
  # source://activerecord//lib/active_record/relation.rb#771
  def to_sql; end

  # Touches all records in the current relation, setting the +updated_at+/+updated_on+ attributes to the current time or the time specified.
  # It does not instantiate the involved models, and it does not trigger Active Record callbacks or validations.
  # This method can be passed attribute names and an optional time argument.
  # If attribute names are passed, they are updated along with +updated_at+/+updated_on+ attributes.
  # If no time argument is passed, the current time is used as default.
  #
  # === Examples
  #
  #   # Touch all records
  #   Person.all.touch_all
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670'"
  #
  #   # Touch multiple records with a custom attribute
  #   Person.all.touch_all(:created_at)
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670', \"created_at\" = '2018-01-04 22:55:23.132670'"
  #
  #   # Touch multiple records with a specified time
  #   Person.all.touch_all(time: Time.new(2020, 5, 16, 0, 0, 0))
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2020-05-16 00:00:00'"
  #
  #   # Touch records with scope
  #   Person.where(name: 'David').touch_all
  #   # => "UPDATE \"people\" SET \"updated_at\" = '2018-01-04 22:55:23.132670' WHERE \"people\".\"name\" = 'David'"
  #
  # source://activerecord//lib/active_record/relation.rb#604
  def touch_all(*names, time: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation.rb#533
  def update(id = T.unsafe(nil), attributes); end

  # source://activerecord//lib/active_record/relation.rb#541
  def update!(id = T.unsafe(nil), attributes); end

  # Updates all records in the current relation with details given. This method constructs a single SQL UPDATE
  # statement and sends it straight to the database. It does not instantiate the involved models and it does not
  # trigger Active Record callbacks or validations. However, values passed to #update_all will still go through
  # Active Record's normal type casting and serialization. Returns the number of rows affected.
  #
  # Note: As Active Record callbacks are not triggered, this method will not automatically update +updated_at+/+updated_on+ columns.
  #
  # ==== Parameters
  #
  # * +updates+ - A string, array, or hash representing the SET part of an SQL statement. Any strings provided will
  #   be type cast, unless you use +Arel.sql+. (Don't pass user-provided values to +Arel.sql+.)
  #
  # ==== Examples
  #
  #   # Update all customers with the given attributes
  #   Customer.update_all wants_email: true
  #
  #   # Update all books with 'Rails' in their title
  #   Book.where('title LIKE ?', '%Rails%').update_all(author: 'David')
  #
  #   # Update all books that match conditions, but limit it to 5 ordered by date
  #   Book.where('title LIKE ?', '%Rails%').order(:created_at).limit(5).update_all(author: 'David')
  #
  #   # Update all invoices and set the number column to its id value.
  #   Invoice.update_all('number = id')
  #
  #   # Update all books with 'Rails' in their title
  #   Book.where('title LIKE ?', '%Rails%').update_all(title: Arel.sql("title + ' - volume 1'"))
  #
  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/relation.rb#507
  def update_all(updates); end

  # Updates the counters of the records in the current relation.
  #
  # ==== Parameters
  #
  # * +counter+ - A Hash containing the names of the fields to update as keys and the amount to update as values.
  # * <tt>:touch</tt> option - Touch the timestamp columns when updating.
  # * If attributes names are passed, they are updated along with update_at/on attributes.
  #
  # ==== Examples
  #
  #   # For Posts by a given author increment the comment_count by 1.
  #   Post.where(author_id: author.id).update_counters(comment_count: 1)
  #
  # source://activerecord//lib/active_record/relation.rb#561
  def update_counters(counters); end

  # source://activerecord//lib/active_record/relation.rb#838
  def values; end

  # source://activerecord//lib/active_record/relation.rb#842
  def values_for_queries; end

  # Returns a hash of where conditions.
  #
  #   User.where(name: 'Oscar').where_values_hash
  #   # => {name: "Oscar"}
  #
  # source://activerecord//lib/active_record/relation.rb#787
  def where_values_hash(relation_table_name = T.unsafe(nil)); end

  protected

  # source://activerecord//lib/active_record/relation.rb#887
  def load_records(records); end

  private

  # source://activerecord//lib/active_record/relation.rb#913
  def _create(attributes, &block); end

  # source://activerecord//lib/active_record/relation.rb#917
  def _create!(attributes, &block); end

  # source://activerecord//lib/active_record/relation.rb#948
  def _increment_attribute(attribute, value = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation.rb#909
  def _new(attributes, &block); end

  # source://activerecord//lib/active_record/relation.rb#921
  def _scoping(scope, registry, all_queries = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation.rb#937
  def _substitute_values(values); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#893
  def already_in_scope?(registry); end

  # source://activerecord//lib/active_record/relation.rb#364
  def compute_cache_key(timestamp_column = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation.rb#393
  def compute_cache_version(timestamp_column); end

  # source://activerecord//lib/active_record/relation.rb#901
  def current_scope_restoring_block(&block); end

  # source://activerecord//lib/active_record/relation.rb#975
  def exec_main_query(async: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation.rb#955
  def exec_queries(&block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#897
  def global_scope?(registry); end

  # source://activerecord//lib/active_record/relation.rb#41
  def initialize_copy(other); end

  # source://activerecord//lib/active_record/relation.rb#1003
  def instantiate_records(rows, &block); end

  # source://activerecord//lib/active_record/relation.rb#1046
  def limited_count; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation.rb#1022
  def references_eager_loaded_tables?; end

  # source://activerecord//lib/active_record/relation.rb#1014
  def skip_query_cache_if_necessary(&block); end

  # source://activerecord//lib/active_record/relation.rb#1039
  def tables_in_string(string); end
end

# source://activerecord//lib/active_record/relation.rb#14
ActiveRecord::Relation::CLAUSE_METHODS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/from_clause.rb#5
class ActiveRecord::Relation::FromClause
  # @return [FromClause] a new instance of FromClause
  #
  # source://activerecord//lib/active_record/relation/from_clause.rb#8
  def initialize(value, name); end

  # source://activerecord//lib/active_record/relation/from_clause.rb#21
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/from_clause.rb#17
  def empty?; end

  # source://activerecord//lib/active_record/relation/from_clause.rb#13
  def merge(other); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/relation/from_clause.rb#6
  def name; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/active_record/relation/from_clause.rb#6
  def value; end

  class << self
    # source://activerecord//lib/active_record/relation/from_clause.rb#25
    def empty; end
  end
end

# source://activerecord//lib/active_record/relation/merger.rb#7
class ActiveRecord::Relation::HashMerger
  # @return [HashMerger] a new instance of HashMerger
  #
  # source://activerecord//lib/active_record/relation/merger.rb#10
  def initialize(relation, hash, rewhere = T.unsafe(nil)); end

  # Returns the value of attribute hash.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#8
  def hash; end

  # source://activerecord//lib/active_record/relation/merger.rb#18
  def merge; end

  # Applying values to a relation has some side effects. E.g.
  # interpolation might take place for where values. So we should
  # build a relation to merge in rather than directly merging
  # the values.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#26
  def other; end

  # Returns the value of attribute relation.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#8
  def relation; end
end

# source://activerecord//lib/active_record/relation.rb#15
ActiveRecord::Relation::INVALID_METHODS_FOR_DELETE_ALL = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation.rb#6
ActiveRecord::Relation::MULTI_VALUE_METHODS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/merger.rb#44
class ActiveRecord::Relation::Merger
  # @return [Merger] a new instance of Merger
  #
  # source://activerecord//lib/active_record/relation/merger.rb#47
  def initialize(relation, other, rewhere = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/merger.rb#60
  def merge; end

  # Returns the value of attribute other.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#45
  def other; end

  # Returns the value of attribute relation.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#45
  def relation; end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/active_record/relation/merger.rb#45
  def values; end

  private

  # source://activerecord//lib/active_record/relation/merger.rb#178
  def merge_clauses; end

  # source://activerecord//lib/active_record/relation/merger.rb#119
  def merge_joins; end

  # source://activerecord//lib/active_record/relation/merger.rb#157
  def merge_multi_values; end

  # source://activerecord//lib/active_record/relation/merger.rb#138
  def merge_outer_joins; end

  # source://activerecord//lib/active_record/relation/merger.rb#98
  def merge_preloads; end

  # source://activerecord//lib/active_record/relation/merger.rb#86
  def merge_select_values; end

  # source://activerecord//lib/active_record/relation/merger.rb#170
  def merge_single_values; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/merger.rb#188
  def replace_from_clause?; end
end

# source://activerecord//lib/active_record/relation/merger.rb#54
ActiveRecord::Relation::Merger::NORMAL_VALUES = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/query_attribute.rb#7
class ActiveRecord::Relation::QueryAttribute < ::ActiveModel::Attribute
  # @return [QueryAttribute] a new instance of QueryAttribute
  #
  # source://activerecord//lib/active_record/relation/query_attribute.rb#8
  def initialize(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#53
  def ==(other); end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#53
  def eql?(other); end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#58
  def hash; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_attribute.rb#42
  def infinite?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_attribute.rb#35
  def nil?; end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#22
  def type_cast(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_attribute.rb#46
  def unboundable?; end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#26
  def value_for_database; end

  # source://activerecord//lib/active_record/relation/query_attribute.rb#31
  def with_cast_value(value); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/query_attribute.rb#63
  def infinity?(value); end
end

# source://activerecord//lib/active_record/relation.rb#11
ActiveRecord::Relation::SINGLE_VALUE_METHODS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation.rb#867
class ActiveRecord::Relation::StrictLoadingScope
  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/relation.rb#868
    def empty_scope?; end

    # source://activerecord//lib/active_record/relation.rb#872
    def strict_loading_value; end
  end
end

# source://activerecord//lib/active_record/relation.rb#17
ActiveRecord::Relation::VALUE_METHODS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/relation/where_clause.rb#7
class ActiveRecord::Relation::WhereClause
  # @return [WhereClause] a new instance of WhereClause
  #
  # source://activerecord//lib/active_record/relation/where_clause.rb#10
  def initialize(predicates); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#14
  def +(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#18
  def -(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#75
  def ==(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#8
  def any?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#70
  def ast; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/where_clause.rb#99
  def contradiction?; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#8
  def empty?(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#75
  def eql?(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#36
  def except(*columns); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#110
  def extract_attributes; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#81
  def hash; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#85
  def invert; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#26
  def merge(other, rewhere = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#40
  def or(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#61
  def to_h(table_name = T.unsafe(nil), equality_only: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#22
  def |(other); end

  protected

  # Returns the value of attribute predicates.
  #
  # source://activerecord//lib/active_record/relation/where_clause.rb#117
  def predicates; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#119
  def referenced_columns; end

  private

  # source://activerecord//lib/active_record/relation/where_clause.rb#126
  def each_attributes; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#145
  def equalities(predicates, equality_only); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/relation/where_clause.rb#171
  def equality_node?(node); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#186
  def except_predicates(columns); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#136
  def extract_attribute(node); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#221
  def extract_node_value(node); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#175
  def invert_predicate(node); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#210
  def non_empty_predicates; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#159
  def predicates_unreferenced_by(other); end

  # source://activerecord//lib/active_record/relation/where_clause.rb#199
  def predicates_with_wrapped_sql_literals; end

  # source://activerecord//lib/active_record/relation/where_clause.rb#214
  def wrap_sql_literal(node); end

  class << self
    # source://activerecord//lib/active_record/relation/where_clause.rb#95
    def empty; end
  end
end

# source://activerecord//lib/active_record/relation/where_clause.rb#209
ActiveRecord::Relation::WhereClause::ARRAY_WITH_EMPTY_STRING = T.let(T.unsafe(nil), Array)

# = Active Record \Result
#
# This class encapsulates a result returned from calling
# {#exec_query}[rdoc-ref:ConnectionAdapters::DatabaseStatements#exec_query]
# on any database connection adapter. For example:
#
#   result = ActiveRecord::Base.connection.exec_query('SELECT id, title, body FROM posts')
#   result # => #<ActiveRecord::Result:0xdeadbeef>
#
#   # Get the column names of the result:
#   result.columns
#   # => ["id", "title", "body"]
#
#   # Get the record values of the result:
#   result.rows
#   # => [[1, "title_1", "body_1"],
#         [2, "title_2", "body_2"],
#         ...
#        ]
#
#   # Get an array of hashes representing the result (column => value):
#   result.to_a
#   # => [{"id" => 1, "title" => "title_1", "body" => "body_1"},
#         {"id" => 2, "title" => "title_2", "body" => "body_2"},
#         ...
#        ]
#
#   # ActiveRecord::Result also includes Enumerable.
#   result.each do |row|
#     puts row['title'] + " " + row['body']
#   end
#
# source://activerecord//lib/active_record/result.rb#36
class ActiveRecord::Result
  include ::Enumerable

  # @return [Result] a new instance of Result
  #
  # source://activerecord//lib/active_record/result.rb#49
  def initialize(columns, rows, column_types = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/result.rb#90
  def [](idx); end

  # source://activerecord//lib/active_record/result.rb#103
  def cancel; end

  # source://activerecord//lib/active_record/result.rb#107
  def cast_values(type_overrides = T.unsafe(nil)); end

  # Returns the value of attribute column_types.
  #
  # source://activerecord//lib/active_record/result.rb#39
  def column_types; end

  # Returns the value of attribute columns.
  #
  # source://activerecord//lib/active_record/result.rb#39
  def columns; end

  # Calls the given block once for each element in row collection, passing
  # row as parameter.
  #
  # Returns an +Enumerator+ if no block is given.
  #
  # source://activerecord//lib/active_record/result.rb#70
  def each(&block); end

  # Returns true if there are no records, otherwise false.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/result.rb#79
  def empty?; end

  # source://activerecord//lib/active_record/result.rb#140
  def freeze; end

  # Returns true if this result set includes the column named +name+
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/result.rb#57
  def includes_column?(name); end

  # Returns the last record from the rows collection.
  #
  # source://activerecord//lib/active_record/result.rb#95
  def last(n = T.unsafe(nil)); end

  # Returns the number of elements in the rows array.
  #
  # source://activerecord//lib/active_record/result.rb#62
  def length; end

  # source://activerecord//lib/active_record/result.rb#99
  def result; end

  # Returns the value of attribute rows.
  #
  # source://activerecord//lib/active_record/result.rb#39
  def rows; end

  # Returns an array of hashes representing each row record.
  #
  # source://activerecord//lib/active_record/result.rb#84
  def to_a; end

  # Returns an array of hashes representing each row record.
  #
  # source://activerecord//lib/active_record/result.rb#84
  def to_ary; end

  private

  # source://activerecord//lib/active_record/result.rb#146
  def column_type(name, index, type_overrides); end

  # source://activerecord//lib/active_record/result.rb#154
  def hash_rows; end

  # source://activerecord//lib/active_record/result.rb#133
  def initialize_copy(other); end

  class << self
    # source://activerecord//lib/active_record/result.rb#41
    def empty(async: T.unsafe(nil)); end
  end
end

# source://activerecord//lib/active_record/result.rb#195
ActiveRecord::Result::EMPTY = T.let(T.unsafe(nil), ActiveRecord::Result)

# source://activerecord//lib/active_record/result.rb#198
ActiveRecord::Result::EMPTY_ASYNC = T.let(T.unsafe(nil), ActiveRecord::FutureResult::Complete)

# {ActiveRecord::Base.transaction}[rdoc-ref:Transactions::ClassMethods#transaction]
# uses this exception to distinguish a deliberate rollback from other exceptional situations.
# Normally, raising an exception will cause the
# {.transaction}[rdoc-ref:Transactions::ClassMethods#transaction] method to rollback
# the database transaction *and* pass on the exception. But if you raise an
# ActiveRecord::Rollback exception, then the database transaction will be rolled back,
# without passing on the exception.
#
# For example, you could do this in your controller to rollback a transaction:
#
#   class BooksController < ActionController::Base
#     def create
#       Book.transaction do
#         book = Book.new(params[:book])
#         book.save!
#         if today_is_friday?
#           # The system must fail on Friday so that our support department
#           # won't be out of job. We silently rollback this transaction
#           # without telling the user.
#           raise ActiveRecord::Rollback
#         end
#       end
#       # ActiveRecord::Rollback is the only exception that won't be passed on
#       # by ActiveRecord::Base.transaction, so this line will still be reached
#       # even on Friday.
#       redirect_to root_url
#     end
#   end
#
# source://activerecord//lib/active_record/errors.rb#408
class ActiveRecord::Rollback < ::ActiveRecord::ActiveRecordError; end

# This is a thread locals registry for Active Record. For example:
#
#   ActiveRecord::RuntimeRegistry.sql_runtime
#
# returns the connection handler local to the current unit of execution (either thread of fiber).
#
# source://activerecord//lib/active_record/runtime_registry.rb#9
module ActiveRecord::RuntimeRegistry
  extend ::ActiveRecord::RuntimeRegistry

  # source://activerecord//lib/active_record/runtime_registry.rb#20
  def async_sql_runtime; end

  # source://activerecord//lib/active_record/runtime_registry.rb#24
  def async_sql_runtime=(runtime); end

  # source://activerecord//lib/active_record/runtime_registry.rb#28
  def reset; end

  # source://activerecord//lib/active_record/runtime_registry.rb#12
  def sql_runtime; end

  # source://activerecord//lib/active_record/runtime_registry.rb#16
  def sql_runtime=(runtime); end
end

# Raised when a statement produces an SQL warning.
#
# source://activerecord//lib/active_record/errors.rb#284
class ActiveRecord::SQLWarning < ::ActiveRecord::AdapterError
  # @return [SQLWarning] a new instance of SQLWarning
  #
  # source://activerecord//lib/active_record/errors.rb#288
  def initialize(message = T.unsafe(nil), code = T.unsafe(nil), level = T.unsafe(nil), sql = T.unsafe(nil), connection_pool = T.unsafe(nil)); end

  # Returns the value of attribute code.
  #
  # source://activerecord//lib/active_record/errors.rb#285
  def code; end

  # Returns the value of attribute level.
  #
  # source://activerecord//lib/active_record/errors.rb#285
  def level; end

  # Returns the value of attribute sql.
  #
  # source://activerecord//lib/active_record/errors.rb#286
  def sql; end

  # Sets the attribute sql
  #
  # @param value the value to set the attribute sql to.
  #
  # source://activerecord//lib/active_record/errors.rb#286
  def sql=(_arg0); end
end

# source://activerecord//lib/active_record/sanitization.rb#4
module ActiveRecord::Sanitization
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Sanitization::ClassMethods
end

# source://activerecord//lib/active_record/sanitization.rb#7
module ActiveRecord::Sanitization::ClassMethods
  # source://activerecord//lib/active_record/sanitization.rb#176
  def disallow_raw_sql!(args, permit: T.unsafe(nil)); end

  # Accepts an array of SQL conditions and sanitizes them into a valid
  # SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  # This method will NOT sanitize a SQL string since it won't contain
  # any conditions in it and will return the string as is.
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  #
  # Note that this sanitization method is not schema-aware, hence won't do any type casting
  # and will directly use the database adapter's +quote+ method.
  # For MySQL specifically this means that numeric parameters will be quoted as strings
  # to prevent query manipulation attacks.
  #
  #   sanitize_sql_for_conditions(["role = ?", 0])
  #   # => "role = '0'"
  #
  # source://activerecord//lib/active_record/sanitization.rb#33
  def sanitize_sql(condition); end

  # Accepts an array of conditions. The array has each value
  # sanitized and interpolated into the SQL statement. If using named bind
  # variables in SQL statements where a colon is required verbatim use a
  # backslash to escape.
  #
  #   sanitize_sql_array(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_array(["TO_TIMESTAMP(:date, 'YYYY/MM/DD HH12\\:MI\\:SS')", date: "foo"])
  #   # => "TO_TIMESTAMP('foo', 'YYYY/MM/DD HH12:MI:SS')"
  #
  #   sanitize_sql_array(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  # Note that this sanitization method is not schema-aware, hence won't do any type casting
  # and will directly use the database adapter's +quote+ method.
  # For MySQL specifically this means that numeric parameters will be quoted as strings
  # to prevent query manipulation attacks.
  #
  #   sanitize_sql_array(["role = ?", 0])
  #   # => "role = '0'"
  #
  # source://activerecord//lib/active_record/sanitization.rb#163
  def sanitize_sql_array(ary); end

  # Accepts an array or hash of SQL conditions and sanitizes them into
  # a valid SQL fragment for a SET clause.
  #
  #   sanitize_sql_for_assignment(["name=? and group_id=?", nil, 4])
  #   # => "name=NULL and group_id=4"
  #
  #   sanitize_sql_for_assignment(["name=:name and group_id=:group_id", name: nil, group_id: 4])
  #   # => "name=NULL and group_id=4"
  #
  #   Post.sanitize_sql_for_assignment({ name: nil, group_id: 4 })
  #   # => "`posts`.`name` = NULL, `posts`.`group_id` = 4"
  #
  # This method will NOT sanitize a SQL string since it won't contain
  # any conditions in it and will return the string as is.
  #
  #   sanitize_sql_for_assignment("name=NULL and group_id='4'")
  #   # => "name=NULL and group_id='4'"
  #
  # Note that this sanitization method is not schema-aware, hence won't do any type casting
  # and will directly use the database adapter's +quote+ method.
  # For MySQL specifically this means that numeric parameters will be quoted as strings
  # to prevent query manipulation attacks.
  #
  #   sanitize_sql_for_assignment(["role = ?", 0])
  #   # => "role = '0'"
  #
  # source://activerecord//lib/active_record/sanitization.rb#68
  def sanitize_sql_for_assignment(assignments, default_table_name = T.unsafe(nil)); end

  # Accepts an array of SQL conditions and sanitizes them into a valid
  # SQL fragment for a WHERE clause.
  #
  #   sanitize_sql_for_conditions(["name=? and group_id=?", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id=4"
  #
  #   sanitize_sql_for_conditions(["name=:name and group_id=:group_id", name: "foo'bar", group_id: 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  #   sanitize_sql_for_conditions(["name='%s' and group_id='%s'", "foo'bar", 4])
  #   # => "name='foo''bar' and group_id='4'"
  #
  # This method will NOT sanitize a SQL string since it won't contain
  # any conditions in it and will return the string as is.
  #
  #   sanitize_sql_for_conditions("name='foo''bar' and group_id='4'")
  #   # => "name='foo''bar' and group_id='4'"
  #
  # Note that this sanitization method is not schema-aware, hence won't do any type casting
  # and will directly use the database adapter's +quote+ method.
  # For MySQL specifically this means that numeric parameters will be quoted as strings
  # to prevent query manipulation attacks.
  #
  #   sanitize_sql_for_conditions(["role = ?", 0])
  #   # => "role = '0'"
  #
  # source://activerecord//lib/active_record/sanitization.rb#33
  def sanitize_sql_for_conditions(condition); end

  # Accepts an array, or string of SQL conditions and sanitizes
  # them into a valid SQL fragment for an ORDER clause.
  #
  #   sanitize_sql_for_order([Arel.sql("field(id, ?)"), [1,3,2]])
  #   # => "field(id, 1,3,2)"
  #
  #   sanitize_sql_for_order("id ASC")
  #   # => "id ASC"
  #
  # source://activerecord//lib/active_record/sanitization.rb#84
  def sanitize_sql_for_order(condition); end

  # Sanitizes a hash of attribute/value pairs into SQL conditions for a SET clause.
  #
  #   sanitize_sql_hash_for_assignment({ status: nil, group_id: 1 }, "posts")
  #   # => "`posts`.`status` = NULL, `posts`.`group_id` = 1"
  #
  # source://activerecord//lib/active_record/sanitization.rb#107
  def sanitize_sql_hash_for_assignment(attrs, table); end

  # Sanitizes a +string+ so that it is safe to use within an SQL
  # LIKE statement. This method uses +escape_character+ to escape all
  # occurrences of itself, "_" and "%".
  #
  #   sanitize_sql_like("100% true!")
  #   # => "100\\% true!"
  #
  #   sanitize_sql_like("snake_cased_string")
  #   # => "snake\\_cased\\_string"
  #
  #   sanitize_sql_like("100% true!", "!")
  #   # => "100!% true!!"
  #
  #   sanitize_sql_like("snake_cased_string", "!")
  #   # => "snake!_cased!_string"
  #
  # source://activerecord//lib/active_record/sanitization.rb#131
  def sanitize_sql_like(string, escape_character = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/sanitization.rb#227
  def quote_bound_value(value, c = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/sanitization.rb#241
  def raise_if_bind_arity_mismatch(statement, expected, provided); end

  # source://activerecord//lib/active_record/sanitization.rb#205
  def replace_bind_variable(value, c = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/sanitization.rb#196
  def replace_bind_variables(statement, values); end

  # source://activerecord//lib/active_record/sanitization.rb#213
  def replace_named_bind_variables(statement, bind_vars); end
end

# = Active Record \Schema
#
# Allows programmers to programmatically define a schema in a portable
# DSL. This means you can define tables, indexes, etc. without using SQL
# directly, so your applications can more easily support multiple
# databases.
#
# Usage:
#
#   ActiveRecord::Schema[7.0].define do
#     create_table :authors do |t|
#       t.string :name, null: false
#     end
#
#     add_index :authors, :name, :unique
#
#     create_table :posts do |t|
#       t.integer :author_id, null: false
#       t.string :subject
#       t.text :body
#       t.boolean :private, default: false
#     end
#
#     add_index :posts, :author_id
#   end
#
# ActiveRecord::Schema is only supported by database adapters that also
# support migrations, the two features being very similar.
#
# source://activerecord//lib/active_record/schema.rb#32
class ActiveRecord::Schema < ::ActiveRecord::Migration::Current
  include ::ActiveRecord::Schema::Definition
  extend ::ActiveRecord::Schema::Definition::ClassMethods

  class << self
    # source://activerecord//lib/active_record/schema.rb#68
    def [](version); end
  end
end

# source://activerecord//lib/active_record/schema.rb#33
module ActiveRecord::Schema::Definition
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Schema::Definition::ClassMethods

  # source://activerecord//lib/active_record/schema.rb#54
  def define(info, &block); end
end

# source://activerecord//lib/active_record/schema.rb#36
module ActiveRecord::Schema::Definition::ClassMethods
  # Eval the given block. All methods available to the current connection
  # adapter are available within the block, so you can easily use the
  # database definition DSL to build up your schema (
  # {create_table}[rdoc-ref:ConnectionAdapters::SchemaStatements#create_table],
  # {add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index], etc.).
  #
  # The +info+ hash is optional, and if given is used to define metadata
  # about the current schema (currently, only the schema's version):
  #
  #   ActiveRecord::Schema[7.0].define(version: 2038_01_19_000001) do
  #     ...
  #   end
  #
  # source://activerecord//lib/active_record/schema.rb#49
  def define(info = T.unsafe(nil), &block); end
end

# = Active Record Schema Dumper
#
# This class is used to dump the database schema for some connection to some
# output format (i.e., ActiveRecord::Schema).
#
# source://activerecord//lib/active_record/schema_dumper.rb#10
class ActiveRecord::SchemaDumper
  # @return [SchemaDumper] a new instance of SchemaDumper
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#71
  def initialize(connection, options = T.unsafe(nil)); end

  # :singleton-method:
  # Specify a custom regular expression matching check constraints which name
  # should not be dumped to db/schema.rb.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#29
  def chk_ignore_pattern; end

  # source://activerecord//lib/active_record/schema_dumper.rb#29
  def chk_ignore_pattern=(val); end

  # source://activerecord//lib/active_record/schema_dumper.rb#58
  def dump(stream); end

  # :singleton-method:
  # Specify a custom regular expression matching exclusion constraints which name
  # should not be dumped to db/schema.rb.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#35
  def excl_ignore_pattern; end

  # source://activerecord//lib/active_record/schema_dumper.rb#35
  def excl_ignore_pattern=(val); end

  # :singleton-method:
  # Specify a custom regular expression matching foreign keys which name
  # should not be dumped to db/schema.rb.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#23
  def fk_ignore_pattern; end

  # source://activerecord//lib/active_record/schema_dumper.rb#23
  def fk_ignore_pattern=(val); end

  # :singleton-method:
  # A list of tables which should not be dumped to the schema.
  # Acceptable values are strings and regexps.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#17
  def ignore_tables; end

  # source://activerecord//lib/active_record/schema_dumper.rb#17
  def ignore_tables=(val); end

  # :singleton-method:
  # Specify a custom regular expression matching unique constraints which name
  # should not be dumped to db/schema.rb.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#41
  def unique_ignore_pattern; end

  # source://activerecord//lib/active_record/schema_dumper.rb#41
  def unique_ignore_pattern=(val); end

  private

  # source://activerecord//lib/active_record/schema_dumper.rb#263
  def check_constraints_in_create(table, stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#89
  def define_params; end

  # extensions are only supported by PostgreSQL
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#116
  def extensions(stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#283
  def foreign_keys(table, stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#315
  def format_colspec(colspec); end

  # source://activerecord//lib/active_record/schema_dumper.rb#325
  def format_index_parts(options); end

  # source://activerecord//lib/active_record/schema_dumper.rb#321
  def format_options(options); end

  # turns 20170404131909 into "2017_04_04_131909"
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#83
  def formatted_version; end

  # source://activerecord//lib/active_record/schema_dumper.rb#93
  def header(stream); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#343
  def ignored?(table_name); end

  # source://activerecord//lib/active_record/schema_dumper.rb#245
  def index_parts(index); end

  # Keep it for indexing materialized views
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#212
  def indexes(table, stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#224
  def indexes_in_create(table, stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#333
  def remove_prefix_and_suffix(table); end

  # schemas are only supported by PostgreSQL
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#124
  def schemas(stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#142
  def table(table, stream); end

  # Returns the value of attribute table_name.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#69
  def table_name; end

  # Sets the attribute table_name
  #
  # @param value the value to set the attribute table_name to.
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#69
  def table_name=(_arg0); end

  # source://activerecord//lib/active_record/schema_dumper.rb#127
  def tables(stream); end

  # source://activerecord//lib/active_record/schema_dumper.rb#111
  def trailer(stream); end

  # (enum) types are only supported by PostgreSQL
  #
  # source://activerecord//lib/active_record/schema_dumper.rb#120
  def types(stream); end

  class << self
    # source://activerecord//lib/active_record/schema_dumper.rb#29
    def chk_ignore_pattern; end

    # source://activerecord//lib/active_record/schema_dumper.rb#29
    def chk_ignore_pattern=(val); end

    # source://activerecord//lib/active_record/schema_dumper.rb#44
    def dump(connection = T.unsafe(nil), stream = T.unsafe(nil), config = T.unsafe(nil)); end

    # source://activerecord//lib/active_record/schema_dumper.rb#35
    def excl_ignore_pattern; end

    # source://activerecord//lib/active_record/schema_dumper.rb#35
    def excl_ignore_pattern=(val); end

    # source://activerecord//lib/active_record/schema_dumper.rb#23
    def fk_ignore_pattern; end

    # source://activerecord//lib/active_record/schema_dumper.rb#23
    def fk_ignore_pattern=(val); end

    # source://activerecord//lib/active_record/schema_dumper.rb#17
    def ignore_tables; end

    # source://activerecord//lib/active_record/schema_dumper.rb#17
    def ignore_tables=(val); end

    # source://activerecord//lib/active_record/schema_dumper.rb#41
    def unique_ignore_pattern; end

    # source://activerecord//lib/active_record/schema_dumper.rb#41
    def unique_ignore_pattern=(val); end

    private

    # source://activerecord//lib/active_record/schema_dumper.rb#50
    def generate_options(config); end

    def new(*_arg0); end
  end
end

# This class is used to create a table that keeps track of which migrations
# have been applied to a given database. When a migration is run, its schema
# number is inserted in to the schema migrations table so it doesn't need
# to be executed the next time.
#
# source://activerecord//lib/active_record/schema_migration.rb#8
class ActiveRecord::SchemaMigration
  # @return [SchemaMigration] a new instance of SchemaMigration
  #
  # source://activerecord//lib/active_record/schema_migration.rb#14
  def initialize(connection); end

  # Returns the value of attribute arel_table.
  #
  # source://activerecord//lib/active_record/schema_migration.rb#12
  def arel_table; end

  # Returns the value of attribute connection.
  #
  # source://activerecord//lib/active_record/schema_migration.rb#12
  def connection; end

  # source://activerecord//lib/active_record/schema_migration.rb#78
  def count; end

  # source://activerecord//lib/active_record/schema_migration.rb#46
  def create_table; end

  # source://activerecord//lib/active_record/schema_migration.rb#19
  def create_version(version); end

  # source://activerecord//lib/active_record/schema_migration.rb#32
  def delete_all_versions; end

  # source://activerecord//lib/active_record/schema_migration.rb#25
  def delete_version(version); end

  # source://activerecord//lib/active_record/schema_migration.rb#54
  def drop_table; end

  # source://activerecord//lib/active_record/schema_migration.rb#74
  def integer_versions; end

  # source://activerecord//lib/active_record/schema_migration.rb#58
  def normalize_migration_number(number); end

  # source://activerecord//lib/active_record/schema_migration.rb#62
  def normalized_versions; end

  # source://activerecord//lib/active_record/schema_migration.rb#38
  def primary_key; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/schema_migration.rb#85
  def table_exists?; end

  # source://activerecord//lib/active_record/schema_migration.rb#42
  def table_name; end

  # source://activerecord//lib/active_record/schema_migration.rb#66
  def versions; end
end

# source://activerecord//lib/active_record/schema_migration.rb#9
class ActiveRecord::SchemaMigration::NullSchemaMigration; end

# = Active Record \Named \Scopes
#
# source://activerecord//lib/active_record/scoping.rb#6
module ActiveRecord::Scoping
  extend ::ActiveSupport::Concern
  extend ::ActiveSupport::Autoload
  include GeneratedInstanceMethods
  include ::ActiveRecord::Scoping::Default
  include ::ActiveRecord::Scoping::Named

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods

  # source://activerecord//lib/active_record/scoping.rb#54
  def initialize_internals_callback; end

  # source://activerecord//lib/active_record/scoping.rb#47
  def populate_with_current_scope_attributes; end

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

# source://activerecord//lib/active_record/scoping.rb#14
module ActiveRecord::Scoping::ClassMethods
  # source://activerecord//lib/active_record/scoping.rb#26
  def current_scope(skip_inherited_scope = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping.rb#30
  def current_scope=(scope); end

  # source://activerecord//lib/active_record/scoping.rb#34
  def global_current_scope(skip_inherited_scope = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping.rb#38
  def global_current_scope=(scope); end

  # Collects attributes from scopes that should be applied when creating
  # an AR instance for the particular class this is called on.
  #
  # source://activerecord//lib/active_record/scoping.rb#17
  def scope_attributes; end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/scoping.rb#22
  def scope_attributes?; end

  # source://activerecord//lib/active_record/scoping.rb#42
  def scope_registry; end
end

# source://activerecord//lib/active_record/scoping/default.rb#14
module ActiveRecord::Scoping::Default
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Scoping::Default::ClassMethods

  module GeneratedClassMethods
    def default_scope_override; end
    def default_scope_override=(value); end
    def default_scopes; end
    def default_scopes=(value); end
  end

  module GeneratedInstanceMethods
    def default_scope_override; end
    def default_scopes; end
  end
end

# source://activerecord//lib/active_record/scoping/default.rb#23
module ActiveRecord::Scoping::Default::ClassMethods
  # Checks if the model has any default scopes. If all_queries
  # is set to true, the method will check if there are any
  # default_scopes for the model  where +all_queries+ is true.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/scoping/default.rb#62
  def default_scopes?(all_queries: T.unsafe(nil)); end

  # Are there attributes associated with this scope?
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/scoping/default.rb#55
  def scope_attributes?; end

  # Returns a scope for the model without the previously set scopes.
  #
  #   class Post < ActiveRecord::Base
  #     belongs_to :user
  #
  #     def self.default_scope
  #       where(published: true)
  #     end
  #   end
  #
  #   class User < ActiveRecord::Base
  #     has_many :posts
  #   end
  #
  #   Post.all                                  # Fires "SELECT * FROM posts WHERE published = true"
  #   Post.unscoped.all                         # Fires "SELECT * FROM posts"
  #   Post.where(published: false).unscoped.all # Fires "SELECT * FROM posts"
  #   User.find(1).posts                        # Fires "SELECT * FROM posts WHERE published = true AND posts.user_id = 1"
  #   User.find(1).posts.unscoped               # Fires "SELECT * FROM posts"
  #
  # This method also accepts a block. All queries inside the block will
  # not use the previously set scopes.
  #
  #   Post.unscoped {
  #     Post.limit(10) # Fires "SELECT * FROM posts LIMIT 10"
  #   }
  #
  # source://activerecord//lib/active_record/scoping/default.rb#50
  def unscoped(&block); end

  private

  # source://activerecord//lib/active_record/scoping/default.rb#145
  def build_default_scope(relation = T.unsafe(nil), all_queries: T.unsafe(nil)); end

  # Use this macro in your model to set a default scope for all operations on
  # the model.
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #   end
  #
  #   Article.all
  #   # SELECT * FROM articles WHERE published = true
  #
  # The #default_scope is also applied while creating/building a record.
  # It is not applied while updating or deleting a record.
  #
  #   Article.new.published    # => true
  #   Article.create.published # => true
  #
  # To apply a #default_scope when updating or deleting a record, add
  # <tt>all_queries: true</tt>:
  #
  #   class Article < ActiveRecord::Base
  #     default_scope -> { where(blog_id: 1) }, all_queries: true
  #   end
  #
  # Applying a default scope to all queries will ensure that records
  # are always queried by the additional conditions. Note that only
  # where clauses apply, as it does not make sense to add order to
  # queries that return a single object by primary key.
  #
  #   Article.find(1).destroy
  #   # DELETE ... FROM `articles` where ID = 1 AND blog_id = 1;
  #
  # (You can also pass any object which responds to +call+ to the
  # +default_scope+ macro, and it will be called when building the
  # default scope.)
  #
  # If you use multiple #default_scope declarations in your model then
  # they will be merged together:
  #
  #   class Article < ActiveRecord::Base
  #     default_scope { where(published: true) }
  #     default_scope { where(rating: 'G') }
  #   end
  #
  #   Article.all
  #   # SELECT * FROM articles WHERE published = true AND rating = 'G'
  #
  # This is also the case with inheritance and module includes where the
  # parent or module defines a #default_scope and the child or including
  # class defines a second one.
  #
  # If you need to do more complex things with a default scope, you can
  # alternatively define it as a class method:
  #
  #   class Article < ActiveRecord::Base
  #     def self.default_scope
  #       # Should return a scope, you can call 'super' here etc.
  #     end
  #   end
  #
  # source://activerecord//lib/active_record/scoping/default.rb#129
  def default_scope(scope = T.unsafe(nil), all_queries: T.unsafe(nil), &block); end

  # The ignore_default_scope flag is used to prevent an infinite recursion
  # situation where a default scope references a scope which has a default
  # scope which references a scope...
  #
  # source://activerecord//lib/active_record/scoping/default.rb#192
  def evaluate_default_scope; end

  # If all_queries is nil, only execute on select and insert queries.
  #
  # If all_queries is true, check if the default_scope object has
  # all_queries set, then execute on all queries; select, insert, update,
  # delete, and reload.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/scoping/default.rb#177
  def execute_scope?(all_queries, default_scope_obj); end

  # source://activerecord//lib/active_record/scoping/default.rb#185
  def ignore_default_scope=(ignore); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/scoping/default.rb#181
  def ignore_default_scope?; end
end

# source://activerecord//lib/active_record/scoping/default.rb#5
class ActiveRecord::Scoping::DefaultScope
  # @return [DefaultScope] a new instance of DefaultScope
  #
  # source://activerecord//lib/active_record/scoping/default.rb#8
  def initialize(scope, all_queries = T.unsafe(nil)); end

  # Returns the value of attribute all_queries.
  #
  # source://activerecord//lib/active_record/scoping/default.rb#6
  def all_queries; end

  # Returns the value of attribute scope.
  #
  # source://activerecord//lib/active_record/scoping/default.rb#6
  def scope; end
end

# source://activerecord//lib/active_record/scoping/named.rb#6
module ActiveRecord::Scoping::Named
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Scoping::Named::ClassMethods
end

# source://activerecord//lib/active_record/scoping/named.rb#9
module ActiveRecord::Scoping::Named::ClassMethods
  # Returns an ActiveRecord::Relation scope object.
  #
  #   posts = Post.all
  #   posts.size # Fires "select count(*) from  posts" and returns the count
  #   posts.each {|p| puts p.name } # Fires "select * from posts" and loads post objects
  #
  #   fruits = Fruit.all
  #   fruits = fruits.where(color: 'red') if options[:red_only]
  #   fruits = fruits.limit(10) if limited?
  #
  # You can define a scope that applies to all finders using
  # {default_scope}[rdoc-ref:Scoping::Default::ClassMethods#default_scope].
  #
  # source://activerecord//lib/active_record/scoping/named.rb#22
  def all(all_queries: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping/named.rb#49
  def default_extensions; end

  # Returns a scope for the model with default scopes.
  #
  # source://activerecord//lib/active_record/scoping/named.rb#45
  def default_scoped(scope = T.unsafe(nil), all_queries: T.unsafe(nil)); end

  # Adds a class method for retrieving and querying objects.
  # The method is intended to return an ActiveRecord::Relation
  # object, which is composable with other scopes.
  # If it returns +nil+ or +false+, an
  # {all}[rdoc-ref:Scoping::Named::ClassMethods#all] scope is returned instead.
  #
  # A \scope represents a narrowing of a database query, such as
  # <tt>where(color: :red).select('shirts.*').includes(:washing_instructions)</tt>.
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') }
  #     scope :dry_clean_only, -> { joins(:washing_instructions).where('washing_instructions.dry_clean_only = ?', true) }
  #   end
  #
  # The above calls to #scope define class methods <tt>Shirt.red</tt> and
  # <tt>Shirt.dry_clean_only</tt>. <tt>Shirt.red</tt>, in effect,
  # represents the query <tt>Shirt.where(color: 'red')</tt>.
  #
  # Note that this is simply 'syntactic sugar' for defining an actual
  # class method:
  #
  #   class Shirt < ActiveRecord::Base
  #     def self.red
  #       where(color: 'red')
  #     end
  #   end
  #
  # Unlike <tt>Shirt.find(...)</tt>, however, the object returned by
  # <tt>Shirt.red</tt> is not an Array but an ActiveRecord::Relation,
  # which is composable with other scopes; it resembles the association object
  # constructed by a {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # declaration. For instance, you can invoke <tt>Shirt.red.first</tt>, <tt>Shirt.red.count</tt>,
  # <tt>Shirt.red.where(size: 'small')</tt>. Also, just as with the
  # association objects, named \scopes act like an Array, implementing
  # Enumerable; <tt>Shirt.red.each(&block)</tt>, <tt>Shirt.red.first</tt>,
  # and <tt>Shirt.red.inject(memo, &block)</tt> all behave as if
  # <tt>Shirt.red</tt> really was an array.
  #
  # These named \scopes are composable. For instance,
  # <tt>Shirt.red.dry_clean_only</tt> will produce all shirts that are
  # both red and dry clean only. Nested finds and calculations also work
  # with these compositions: <tt>Shirt.red.dry_clean_only.count</tt>
  # returns the number of garments for which these criteria obtain.
  # Similarly with <tt>Shirt.red.dry_clean_only.average(:thread_count)</tt>.
  #
  # All scopes are available as class methods on the ActiveRecord::Base
  # descendant upon which the \scopes were defined. But they are also
  # available to {has_many}[rdoc-ref:Associations::ClassMethods#has_many]
  # associations. If,
  #
  #   class Person < ActiveRecord::Base
  #     has_many :shirts
  #   end
  #
  # then <tt>elton.shirts.red.dry_clean_only</tt> will return all of
  # Elton's red, dry clean only shirts.
  #
  # \Named scopes can also have extensions, just as with
  # {has_many}[rdoc-ref:Associations::ClassMethods#has_many] declarations:
  #
  #   class Shirt < ActiveRecord::Base
  #     scope :red, -> { where(color: 'red') } do
  #       def dom_id
  #         'red_shirts'
  #       end
  #     end
  #   end
  #
  # Scopes can also be used while creating/building a record.
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #   end
  #
  #   Article.published.new.published    # => true
  #   Article.published.create.published # => true
  #
  # \Class methods on your model are automatically available
  # on scopes. Assuming the following setup:
  #
  #   class Article < ActiveRecord::Base
  #     scope :published, -> { where(published: true) }
  #     scope :featured, -> { where(featured: true) }
  #
  #     def self.latest_article
  #       order('published_at desc').first
  #     end
  #
  #     def self.titles
  #       pluck(:title)
  #     end
  #   end
  #
  # We are able to call the methods like this:
  #
  #   Article.published.featured.latest_article
  #   Article.featured.titles
  #
  # source://activerecord//lib/active_record/scoping/named.rb#154
  def scope(name, body, &block); end

  # source://activerecord//lib/active_record/scoping/named.rb#36
  def scope_for_association(scope = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/scoping/named.rb#192
  def singleton_method_added(name); end
end

# This class stores the +:current_scope+ and +:ignore_default_scope+ values
# for different classes. The registry is stored as either a thread or fiber
# local depending on the application configuration.
#
# This class allows you to store and get the scope values on different
# classes and different types of scopes. For example, if you are attempting
# to get the current_scope for the +Board+ model, then you would use the
# following code:
#
#   registry = ActiveRecord::Scoping::ScopeRegistry
#   registry.set_current_scope(Board, some_new_scope)
#
# Now when you run:
#
#   registry.current_scope(Board)
#
# You will obtain whatever was defined in +some_new_scope+.
#
# source://activerecord//lib/active_record/scoping.rb#76
class ActiveRecord::Scoping::ScopeRegistry
  # @return [ScopeRegistry] a new instance of ScopeRegistry
  #
  # source://activerecord//lib/active_record/scoping.rb#86
  def initialize; end

  # source://activerecord//lib/active_record/scoping.rb#92
  def current_scope(model, skip_inherited_scope = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping.rb#108
  def global_current_scope(model, skip_inherited_scope = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping.rb#100
  def ignore_default_scope(model, skip_inherited_scope = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/scoping.rb#96
  def set_current_scope(model, value); end

  # source://activerecord//lib/active_record/scoping.rb#112
  def set_global_current_scope(model, value); end

  # source://activerecord//lib/active_record/scoping.rb#104
  def set_ignore_default_scope(model, value); end

  private

  # Sets the +value+ for a given +scope_type+ and +model+.
  #
  # source://activerecord//lib/active_record/scoping.rb#131
  def set_value_for(scope_type, model, value); end

  # Obtains the value for a given +scope_type+ and +model+.
  #
  # source://activerecord//lib/active_record/scoping.rb#118
  def value_for(scope_type, model, skip_inherited_scope = T.unsafe(nil)); end

  class << self
    # source://activerecord//lib/active_record/scoping.rb#78
    def current_scope(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/scoping.rb#78
    def global_current_scope(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/scoping.rb#78
    def ignore_default_scope(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/scoping.rb#81
    def instance; end

    # source://activerecord//lib/active_record/scoping.rb#78
    def set_current_scope(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/scoping.rb#78
    def set_global_current_scope(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/scoping.rb#78
    def set_ignore_default_scope(*_arg0, **_arg1, &_arg2); end
  end
end

# source://activerecord//lib/active_record/secure_password.rb#4
module ActiveRecord::SecurePassword
  extend ::ActiveSupport::Concern
  include ::ActiveModel::SecurePassword

  mixes_in_class_methods ::ActiveModel::SecurePassword::ClassMethods
  mixes_in_class_methods ::ActiveRecord::SecurePassword::ClassMethods
end

# source://activerecord//lib/active_record/secure_password.rb#9
module ActiveRecord::SecurePassword::ClassMethods
  # Given a set of attributes, finds a record using the non-password
  # attributes, and then authenticates that record using the password
  # attributes. Returns the record if authentication succeeds; otherwise,
  # returns +nil+.
  #
  # Regardless of whether a record is found, +authenticate_by+ will
  # cryptographically digest the given password attributes. This behavior
  # helps mitigate timing-based enumeration attacks, wherein an attacker can
  # determine if a passworded record exists even without knowing the
  # password.
  #
  # Raises an ArgumentError if the set of attributes doesn't contain at
  # least one password and one non-password attribute.
  #
  # ==== Examples
  #
  #   class User < ActiveRecord::Base
  #     has_secure_password
  #   end
  #
  #   User.create(name: "John Doe", email: "jdoe@example.com", password: "abc123")
  #
  #   User.authenticate_by(email: "jdoe@example.com", password: "abc123").name # => "John Doe" (in 373.4ms)
  #   User.authenticate_by(email: "jdoe@example.com", password: "wrong")       # => nil (in 373.9ms)
  #   User.authenticate_by(email: "wrong@example.com", password: "abc123")     # => nil (in 373.6ms)
  #
  #   User.authenticate_by(email: "jdoe@example.com", password: nil) # => nil (no queries executed)
  #   User.authenticate_by(email: "jdoe@example.com", password: "")  # => nil (no queries executed)
  #
  #   User.authenticate_by(email: "jdoe@example.com") # => ArgumentError
  #   User.authenticate_by(password: "abc123")        # => ArgumentError
  #
  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/secure_password.rb#41
  def authenticate_by(attributes); end
end

# source://activerecord//lib/active_record/secure_token.rb#4
module ActiveRecord::SecureToken
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::SecureToken::ClassMethods
end

# source://activerecord//lib/active_record/secure_token.rb#11
module ActiveRecord::SecureToken::ClassMethods
  # source://activerecord//lib/active_record/secure_token.rb#61
  def generate_unique_secure_token(length: T.unsafe(nil)); end

  # Example using #has_secure_token
  #
  #   # Schema: User(token:string, auth_token:string)
  #   class User < ActiveRecord::Base
  #     has_secure_token
  #     has_secure_token :auth_token, length: 36
  #   end
  #
  #   user = User.new
  #   user.save
  #   user.token # => "pX27zsMN2ViQKta1bGfLmVJE"
  #   user.auth_token # => "tU9bLuZseefXQ4yQxQo8wjtBvsAfPc78os6R"
  #   user.regenerate_token # => true
  #   user.regenerate_auth_token # => true
  #
  # +SecureRandom::base58+ is used to generate at minimum a 24-character unique token, so collisions are highly unlikely.
  #
  # Note that it's still possible to generate a race condition in the database in the same way that
  # {validates_uniqueness_of}[rdoc-ref:Validations::ClassMethods#validates_uniqueness_of] can.
  # You're encouraged to add a unique index in the database to deal with this even more unlikely scenario.
  #
  # === Options
  #
  # [:length]
  #   Length of the Secure Random, with a minimum of 24 characters. It will
  #   default to 24.
  #
  # [:on]
  #   The callback when the value is generated. When called with <tt>on:
  #   :initialize</tt>, the value is generated in an
  #   <tt>after_initialize</tt> callback, otherwise the value will be used
  #   in a <tt>before_</tt> callback. When not specified, +:on+ will use the value of
  #   <tt>config.active_record.generate_secure_token_on</tt>, which defaults to +:initialize+
  #   starting in \Rails 7.1.
  #
  # source://activerecord//lib/active_record/secure_token.rb#46
  def has_secure_token(attribute = T.unsafe(nil), length: T.unsafe(nil), on: T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/secure_token.rb#7
ActiveRecord::SecureToken::MINIMUM_TOKEN_LENGTH = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/secure_token.rb#5
class ActiveRecord::SecureToken::MinimumLengthError < ::StandardError; end

# = Active Record \Serialization
#
# source://activerecord//lib/active_record/serialization.rb#5
module ActiveRecord::Serialization
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveModel::Serializers::JSON

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Naming

  # source://activerecord//lib/active_record/serialization.rb#13
  def serializable_hash(options = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/serialization.rb#25
  def attribute_names_for_serialization; end

  module GeneratedClassMethods
    def include_root_in_json; end
    def include_root_in_json=(value); end
    def include_root_in_json?; end
  end

  module GeneratedInstanceMethods
    def include_root_in_json; end
    def include_root_in_json?; end
  end
end

# SerializationFailure will be raised when a transaction is rolled
# back by the database due to a serialization failure.
#
# This is a subclass of TransactionRollbackError, please make sure to check
# its documentation to be aware of its caveats.
#
# source://activerecord//lib/active_record/errors.rb#517
class ActiveRecord::SerializationFailure < ::ActiveRecord::TransactionRollbackError; end

# Raised when unserialized object's type mismatches one specified for serializable field.
#
# source://activerecord//lib/active_record/errors.rb#41
class ActiveRecord::SerializationTypeMismatch < ::ActiveRecord::ActiveRecordError; end

# = Active Record Signed Id
#
# source://activerecord//lib/active_record/signed_id.rb#5
module ActiveRecord::SignedId
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::SignedId::ClassMethods

  # Returns a signed id that's generated using a preconfigured +ActiveSupport::MessageVerifier+ instance.
  # This signed id is tamper proof, so it's safe to send in an email or otherwise share with the outside world.
  # It can furthermore be set to expire (the default is not to expire), and scoped down with a specific purpose.
  # If the expiration date has been exceeded before +find_signed+ is called, the id won't find the designated
  # record. If a purpose is set, this too must match.
  #
  # If you accidentally let a signed id out in the wild that you wish to retract sooner than its expiration date
  # (or maybe you forgot to set an expiration date while meaning to!), you can use the purpose to essentially
  # version the signed_id, like so:
  #
  #   user.signed_id purpose: :v2
  #
  # And you then change your +find_signed+ calls to require this new purpose. Any old signed ids that were not
  # created with the purpose will no longer find the record.
  #
  # @raise [ArgumentError]
  #
  # source://activerecord//lib/active_record/signed_id.rb#112
  def signed_id(expires_in: T.unsafe(nil), expires_at: T.unsafe(nil), purpose: T.unsafe(nil)); end

  module GeneratedClassMethods
    def signed_id_verifier_secret; end
    def signed_id_verifier_secret=(value); end
    def signed_id_verifier_secret?; end
  end

  module GeneratedInstanceMethods
    def signed_id_verifier_secret; end
    def signed_id_verifier_secret?; end
  end
end

# source://activerecord//lib/active_record/signed_id.rb#16
module ActiveRecord::SignedId::ClassMethods
  # source://activerecord//lib/active_record/signed_id.rb#92
  def combine_signed_id_purposes(purpose); end

  # Lets you find a record based on a signed id that's safe to put into the world without risk of tampering.
  # This is particularly useful for things like password reset or email verification, where you want
  # the bearer of the signed id to be able to interact with the underlying record, but usually only within
  # a certain time period.
  #
  # You set the time period that the signed id is valid for during generation, using the instance method
  # <tt>signed_id(expires_in: 15.minutes)</tt>. If the time has elapsed before a signed find is attempted,
  # the signed id will no longer be valid, and nil is returned.
  #
  # It's possible to further restrict the use of a signed id with a purpose. This helps when you have a
  # general base model, like a User, which might have signed ids for several things, like password reset
  # or email verification. The purpose that was set during generation must match the purpose set when
  # finding. If there's a mismatch, nil is again returned.
  #
  # ==== Examples
  #
  #   signed_id = User.first.signed_id expires_in: 15.minutes, purpose: :password_reset
  #
  #   User.find_signed signed_id # => nil, since the purpose does not match
  #
  #   travel 16.minutes
  #   User.find_signed signed_id, purpose: :password_reset # => nil, since the signed id has expired
  #
  #   travel_back
  #   User.find_signed signed_id, purpose: :password_reset # => User.first
  #
  # @raise [UnknownPrimaryKey]
  #
  # source://activerecord//lib/active_record/signed_id.rb#42
  def find_signed(signed_id, purpose: T.unsafe(nil)); end

  # Works like find_signed, but will raise an +ActiveSupport::MessageVerifier::InvalidSignature+
  # exception if the +signed_id+ has either expired, has a purpose mismatch, is for another record,
  # or has been tampered with. It will also raise an +ActiveRecord::RecordNotFound+ exception if
  # the valid signed id can't find a record.
  #
  # === Examples
  #
  #   User.find_signed! "bad data" # => ActiveSupport::MessageVerifier::InvalidSignature
  #
  #   signed_id = User.first.signed_id
  #   User.first.destroy
  #   User.find_signed! signed_id # => ActiveRecord::RecordNotFound
  #
  # source://activerecord//lib/active_record/signed_id.rb#62
  def find_signed!(signed_id, purpose: T.unsafe(nil)); end

  # The verifier instance that all signed ids are generated and verified from. By default, it'll be initialized
  # with the class-level +signed_id_verifier_secret+, which within \Rails comes from the
  # Rails.application.key_generator. By default, it's SHA256 for the digest and JSON for the serialization.
  #
  # source://activerecord//lib/active_record/signed_id.rb#71
  def signed_id_verifier; end

  # Allows you to pass in a custom verifier used for the signed ids. This also allows you to use different
  # verifiers for different classes. This is also helpful if you need to rotate keys, as you can prepare
  # your custom verifier for that in advance. See +ActiveSupport::MessageVerifier+ for details.
  #
  # source://activerecord//lib/active_record/signed_id.rb#87
  def signed_id_verifier=(verifier); end
end

# Raised when Active Record finds multiple records but only expected one.
#
# source://activerecord//lib/active_record/errors.rb#171
class ActiveRecord::SoleRecordExceeded < ::ActiveRecord::ActiveRecordError
  # @return [SoleRecordExceeded] a new instance of SoleRecordExceeded
  #
  # source://activerecord//lib/active_record/errors.rb#174
  def initialize(record = T.unsafe(nil)); end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/errors.rb#172
  def record; end
end

# source://activerecord//lib/active_record/relation/spawn_methods.rb#8
module ActiveRecord::SpawnMethods
  # Removes from the query the condition(s) specified in +skips+.
  #
  #   Post.order('id asc').except(:order)                  # discards the order condition
  #   Post.where('id > 10').order('id asc').except(:where) # discards the where condition but keeps the order
  #
  # source://activerecord//lib/active_record/relation/spawn_methods.rb#75
  def except(*skips); end

  # Merges in the conditions from <tt>other</tt>, if <tt>other</tt> is an ActiveRecord::Relation.
  # Returns an array representing the intersection of the resulting records with <tt>other</tt>, if <tt>other</tt> is an array.
  #
  #   Post.where(published: true).joins(:comments).merge( Comment.where(spam: false) )
  #   # Performs a single join query with both where conditions.
  #
  #   recent_posts = Post.order('created_at DESC').first(5)
  #   Post.where(published: true).merge(recent_posts)
  #   # Returns the intersection of all published posts with the 5 most recently created posts.
  #   # (This is just an example. You'd probably want to do this with a single query!)
  #
  # Procs will be evaluated by merge:
  #
  #   Post.where(published: true).merge(-> { joins(:comments) })
  #   # => Post.where(published: true).joins(:comments)
  #
  # This is mainly intended for sharing common conditions between multiple associations.
  #
  # For conditions that exist in both relations, those from <tt>other</tt> will take precedence.
  # To find the intersection of two relations, use QueryMethods#and.
  #
  # source://activerecord//lib/active_record/relation/spawn_methods.rb#33
  def merge(other, *rest); end

  # source://activerecord//lib/active_record/relation/spawn_methods.rb#43
  def merge!(other, *rest); end

  # Removes any condition from the query other than the one(s) specified in +onlies+.
  #
  #   Post.order('id asc').only(:where)         # discards the order condition
  #   Post.order('id asc').only(:where, :order) # uses the specified order
  #
  # source://activerecord//lib/active_record/relation/spawn_methods.rb#83
  def only(*onlies); end

  # source://activerecord//lib/active_record/relation/spawn_methods.rb#9
  def spawn; end

  private

  # source://activerecord//lib/active_record/relation/spawn_methods.rb#88
  def relation_with(values); end
end

# Raised on attempt to save stale record. Record is stale when it's being saved in another query after
# instantiation, for example, when two users edit the same wiki page and one starts editing and saves
# the page before the other.
#
# Read more about optimistic locking in ActiveRecord::Locking module
# documentation.
#
# source://activerecord//lib/active_record/errors.rb#350
class ActiveRecord::StaleObjectError < ::ActiveRecord::ActiveRecordError
  # @return [StaleObjectError] a new instance of StaleObjectError
  #
  # source://activerecord//lib/active_record/errors.rb#353
  def initialize(record = T.unsafe(nil), attempted_action = T.unsafe(nil)); end

  # Returns the value of attribute attempted_action.
  #
  # source://activerecord//lib/active_record/errors.rb#351
  def attempted_action; end

  # Returns the value of attribute record.
  #
  # source://activerecord//lib/active_record/errors.rb#351
  def record; end
end

# Statement cache is used to cache a single statement in order to avoid creating the AST again.
# Initializing the cache is done by passing the statement in the create block:
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: "my book").where("author_id > 3")
#   end
#
# The cached statement is executed by using the
# {connection.execute}[rdoc-ref:ConnectionAdapters::DatabaseStatements#execute] method:
#
#   cache.execute([], Book.connection)
#
# The relation returned by the block is cached, and for each
# {execute}[rdoc-ref:ConnectionAdapters::DatabaseStatements#execute]
# call the cached relation gets duped. Database is queried when +to_a+ is called on the relation.
#
# If you want to cache the statement without the values you can use the +bind+ method of the
# block parameter.
#
#   cache = StatementCache.create(Book.connection) do |params|
#     Book.where(name: params.bind)
#   end
#
# And pass the bind values as the first argument of +execute+ call.
#
#   cache.execute(["my book"], Book.connection)
#
# source://activerecord//lib/active_record/statement_cache.rb#30
class ActiveRecord::StatementCache
  # @return [StatementCache] a new instance of StatementCache
  #
  # source://activerecord//lib/active_record/statement_cache.rb#139
  def initialize(query_builder, bind_map, klass); end

  # source://activerecord//lib/active_record/statement_cache.rb#145
  def execute(params, connection, &block); end

  private

  # Returns the value of attribute bind_map.
  #
  # source://activerecord//lib/active_record/statement_cache.rb#162
  def bind_map; end

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/statement_cache.rb#162
  def klass; end

  # Returns the value of attribute query_builder.
  #
  # source://activerecord//lib/active_record/statement_cache.rb#162
  def query_builder; end

  class << self
    # source://activerecord//lib/active_record/statement_cache.rb#132
    def create(connection, callable = T.unsafe(nil), &block); end

    # source://activerecord//lib/active_record/statement_cache.rb#101
    def partial_query(values); end

    # source://activerecord//lib/active_record/statement_cache.rb#105
    def partial_query_collector; end

    # source://activerecord//lib/active_record/statement_cache.rb#97
    def query(sql); end

    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/statement_cache.rb#155
    def unsupported_value?(value); end
  end
end

# source://activerecord//lib/active_record/statement_cache.rb#113
class ActiveRecord::StatementCache::BindMap
  # @return [BindMap] a new instance of BindMap
  #
  # source://activerecord//lib/active_record/statement_cache.rb#114
  def initialize(bound_attributes); end

  # source://activerecord//lib/active_record/statement_cache.rb#125
  def bind(values); end
end

# source://activerecord//lib/active_record/statement_cache.rb#109
class ActiveRecord::StatementCache::Params
  # source://activerecord//lib/active_record/statement_cache.rb#110
  def bind; end
end

# source://activerecord//lib/active_record/statement_cache.rb#43
class ActiveRecord::StatementCache::PartialQuery < ::ActiveRecord::StatementCache::Query
  # @return [PartialQuery] a new instance of PartialQuery
  #
  # source://activerecord//lib/active_record/statement_cache.rb#44
  def initialize(values); end

  # source://activerecord//lib/active_record/statement_cache.rb#51
  def sql_for(binds, connection); end
end

# source://activerecord//lib/active_record/statement_cache.rb#64
class ActiveRecord::StatementCache::PartialQueryCollector
  # @return [PartialQueryCollector] a new instance of PartialQueryCollector
  #
  # source://activerecord//lib/active_record/statement_cache.rb#67
  def initialize; end

  # source://activerecord//lib/active_record/statement_cache.rb#72
  def <<(str); end

  # source://activerecord//lib/active_record/statement_cache.rb#77
  def add_bind(obj); end

  # source://activerecord//lib/active_record/statement_cache.rb#83
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end

  # Returns the value of attribute preparable.
  #
  # source://activerecord//lib/active_record/statement_cache.rb#65
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  #
  # source://activerecord//lib/active_record/statement_cache.rb#65
  def preparable=(_arg0); end

  # source://activerecord//lib/active_record/statement_cache.rb#92
  def value; end
end

# source://activerecord//lib/active_record/statement_cache.rb#33
class ActiveRecord::StatementCache::Query
  # @return [Query] a new instance of Query
  #
  # source://activerecord//lib/active_record/statement_cache.rb#34
  def initialize(sql); end

  # source://activerecord//lib/active_record/statement_cache.rb#38
  def sql_for(binds, connection); end
end

# source://activerecord//lib/active_record/statement_cache.rb#31
class ActiveRecord::StatementCache::Substitute; end

# Superclass for all database execution errors.
#
# Wraps the underlying database error as +cause+.
#
# source://activerecord//lib/active_record/errors.rb#183
class ActiveRecord::StatementInvalid < ::ActiveRecord::AdapterError
  # @return [StatementInvalid] a new instance of StatementInvalid
  #
  # source://activerecord//lib/active_record/errors.rb#184
  def initialize(message = T.unsafe(nil), sql: T.unsafe(nil), binds: T.unsafe(nil), connection_pool: T.unsafe(nil)); end

  # Returns the value of attribute binds.
  #
  # source://activerecord//lib/active_record/errors.rb#190
  def binds; end

  # source://activerecord//lib/active_record/errors.rb#192
  def set_query(sql, binds); end

  # Returns the value of attribute sql.
  #
  # source://activerecord//lib/active_record/errors.rb#190
  def sql; end
end

# StatementTimeout will be raised when statement timeout exceeded.
#
# source://activerecord//lib/active_record/errors.rb#542
class ActiveRecord::StatementTimeout < ::ActiveRecord::QueryAborted; end

# = Active Record \Store
#
# Store gives you a thin wrapper around serialize for the purpose of storing hashes in a single column.
# It's like a simple key/value store baked into your record when you don't care about being able to
# query that store outside the context of a single record.
#
# You can then declare accessors to this store that are then accessible just like any other attribute
# of the model. This is very helpful for easily exposing store keys to a form or elsewhere that's
# already built around just accessing attributes on the model.
#
# Every accessor comes with dirty tracking methods (+key_changed?+, +key_was+ and +key_change+) and
# methods to access the changes made during the last save (+saved_change_to_key?+, +saved_change_to_key+ and
# +key_before_last_save+).
#
# NOTE: There is no +key_will_change!+ method for accessors, use +store_will_change!+ instead.
#
# Make sure that you declare the database column used for the serialized store as a text, so there's
# plenty of room.
#
# You can set custom coder to encode/decode your serialized attributes to/from different formats.
# JSON, YAML, Marshal are supported out of the box. Generally it can be any wrapper that provides +load+ and +dump+.
#
# NOTE: If you are using structured database data types (e.g. PostgreSQL +hstore+/+json+, or MySQL 5.7+
# +json+) there is no need for the serialization provided by {.store}[rdoc-ref:rdoc-ref:ClassMethods#store].
# Simply use {.store_accessor}[rdoc-ref:ClassMethods#store_accessor] instead to generate
# the accessor methods. Be aware that these columns use a string keyed hash and do not allow access
# using a symbol.
#
# NOTE: The default validations with the exception of +uniqueness+ will work.
# For example, if you want to check for +uniqueness+ with +hstore+ you will
# need to use a custom validation to handle it.
#
# Examples:
#
#   class User < ActiveRecord::Base
#     store :settings, accessors: [ :color, :homepage ], coder: JSON
#     store :parent, accessors: [ :name ], coder: JSON, prefix: true
#     store :spouse, accessors: [ :name ], coder: JSON, prefix: :partner
#     store :settings, accessors: [ :two_factor_auth ], suffix: true
#     store :settings, accessors: [ :login_retry ], suffix: :config
#   end
#
#   u = User.new(color: 'black', homepage: '37signals.com', parent_name: 'Mary', partner_name: 'Lily')
#   u.color                          # Accessor stored attribute
#   u.parent_name                    # Accessor stored attribute with prefix
#   u.partner_name                   # Accessor stored attribute with custom prefix
#   u.two_factor_auth_settings       # Accessor stored attribute with suffix
#   u.login_retry_config             # Accessor stored attribute with custom suffix
#   u.settings[:country] = 'Denmark' # Any attribute, even if not specified with an accessor
#
#   # There is no difference between strings and symbols for accessing custom attributes
#   u.settings[:country]  # => 'Denmark'
#   u.settings['country'] # => 'Denmark'
#
#   # Dirty tracking
#   u.color = 'green'
#   u.color_changed? # => true
#   u.color_was # => 'black'
#   u.color_change # => ['black', 'green']
#
#   # Add additional accessors to an existing store through store_accessor
#   class SuperUser < User
#     store_accessor :settings, :privileges, :servants
#     store_accessor :parent, :birthday, prefix: true
#     store_accessor :settings, :secret_question, suffix: :config
#   end
#
# The stored attribute names can be retrieved using {.stored_attributes}[rdoc-ref:rdoc-ref:ClassMethods#stored_attributes].
#
#   User.stored_attributes[:settings] # => [:color, :homepage, :two_factor_auth, :login_retry]
#
# == Overwriting default accessors
#
# All stored values are automatically available through accessors on the Active Record
# object, but sometimes you want to specialize this behavior. This can be done by overwriting
# the default accessors (using the same name as the attribute) and calling <tt>super</tt>
# to actually change things.
#
#   class Song < ActiveRecord::Base
#     # Uses a stored integer to hold the volume adjustment of the song
#     store :settings, accessors: [:volume_adjustment]
#
#     def volume_adjustment=(decibels)
#       super(decibels.to_i)
#     end
#
#     def volume_adjustment
#       super.to_i
#     end
#   end
#
# source://activerecord//lib/active_record/store.rb#96
module ActiveRecord::Store
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Store::ClassMethods

  private

  # source://activerecord//lib/active_record/store.rb#209
  def read_store_attribute(store_attribute, key); end

  # source://activerecord//lib/active_record/store.rb#219
  def store_accessor_for(store_attribute); end

  # source://activerecord//lib/active_record/store.rb#214
  def write_store_attribute(store_attribute, key, value); end
end

# source://activerecord//lib/active_record/store.rb#105
module ActiveRecord::Store::ClassMethods
  # source://activerecord//lib/active_record/store.rb#191
  def _store_accessors_module; end

  # source://activerecord//lib/active_record/store.rb#106
  def store(store_attribute, options = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/store.rb#112
  def store_accessor(store_attribute, *keys, prefix: T.unsafe(nil), suffix: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/store.rb#199
  def stored_attributes; end
end

# source://activerecord//lib/active_record/store.rb#223
class ActiveRecord::Store::HashAccessor
  class << self
    # source://activerecord//lib/active_record/store.rb#234
    def prepare(object, attribute); end

    # source://activerecord//lib/active_record/store.rb#224
    def read(object, attribute, key); end

    # source://activerecord//lib/active_record/store.rb#229
    def write(object, attribute, key, value); end
  end
end

# source://activerecord//lib/active_record/store.rb#260
class ActiveRecord::Store::IndifferentCoder
  # @return [IndifferentCoder] a new instance of IndifferentCoder
  #
  # source://activerecord//lib/active_record/store.rb#261
  def initialize(attr_name, coder_or_class_name); end

  # source://activerecord//lib/active_record/store.rb#270
  def dump(obj); end

  # source://activerecord//lib/active_record/store.rb#274
  def load(yaml); end

  private

  # source://activerecord//lib/active_record/store.rb#290
  def as_regular_hash(obj); end

  class << self
    # source://activerecord//lib/active_record/store.rb#278
    def as_indifferent_hash(obj); end
  end
end

# source://activerecord//lib/active_record/store.rb#249
class ActiveRecord::Store::IndifferentHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    # source://activerecord//lib/active_record/store.rb#250
    def prepare(object, store_attribute); end
  end
end

# source://activerecord//lib/active_record/store.rb#239
class ActiveRecord::Store::StringKeyedHashAccessor < ::ActiveRecord::Store::HashAccessor
  class << self
    # source://activerecord//lib/active_record/store.rb#240
    def read(object, attribute, key); end

    # source://activerecord//lib/active_record/store.rb#244
    def write(object, attribute, key, value); end
  end
end

# Raised on attempt to lazily load records that are marked as strict loading.
#
# source://activerecord//lib/active_record/errors.rb#377
class ActiveRecord::StrictLoadingViolationError < ::ActiveRecord::ActiveRecordError; end

# Raised when the single-table inheritance mechanism fails to locate the subclass
# (for example due to improper usage of column that
# {ActiveRecord::Base.inheritance_column}[rdoc-ref:ModelSchema::ClassMethods#inheritance_column]
# points to).
#
# source://activerecord//lib/active_record/errors.rb#22
class ActiveRecord::SubclassNotFound < ::ActiveRecord::ActiveRecordError; end

# = Active Record \Suppressor
#
# ActiveRecord::Suppressor prevents the receiver from being saved during
# a given block.
#
# For example, here's a pattern of creating notifications when new comments
# are posted. (The notification may in turn trigger an email, a push
# notification, or just appear in the UI somewhere):
#
#   class Comment < ActiveRecord::Base
#     belongs_to :commentable, polymorphic: true
#     after_create -> { Notification.create! comment: self,
#       recipients: commentable.recipients }
#   end
#
# That's what you want the bulk of the time. New comment creates a new
# Notification. But there may well be off cases, like copying a commentable
# and its comments, where you don't want that. So you'd have a concern
# something like this:
#
#   module Copyable
#     def copy_to(destination)
#       Notification.suppress do
#         # Copy logic that creates new comments that we do not want
#         # triggering notifications.
#       end
#     end
#   end
#
# source://activerecord//lib/active_record/suppressor.rb#32
module ActiveRecord::Suppressor
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Suppressor::ClassMethods

  # source://activerecord//lib/active_record/suppressor.rb#51
  def save(**_arg0); end

  # source://activerecord//lib/active_record/suppressor.rb#55
  def save!(**_arg0); end

  class << self
    # source://activerecord//lib/active_record/suppressor.rb#36
    def registry; end
  end
end

# source://activerecord//lib/active_record/suppressor.rb#41
module ActiveRecord::Suppressor::ClassMethods
  # source://activerecord//lib/active_record/suppressor.rb#42
  def suppress(&block); end
end

# source://activerecord//lib/active_record/table_metadata.rb#4
class ActiveRecord::TableMetadata
  # @return [TableMetadata] a new instance of TableMetadata
  #
  # source://activerecord//lib/active_record/table_metadata.rb#7
  def initialize(klass, arel_table, reflection = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/table_metadata.rb#74
  def aggregated_with?(aggregation_name); end

  # Returns the value of attribute arel_table.
  #
  # source://activerecord//lib/active_record/table_metadata.rb#89
  def arel_table; end

  # source://activerecord//lib/active_record/table_metadata.rb#38
  def associated_table(table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/table_metadata.rb#25
  def associated_with?(table_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/table_metadata.rb#21
  def has_column?(column_name); end

  # source://activerecord//lib/active_record/table_metadata.rb#5
  def join_foreign_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/table_metadata.rb#5
  def join_foreign_type(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/table_metadata.rb#5
  def join_primary_key(*_arg0, **_arg1, &_arg2); end

  # source://activerecord//lib/active_record/table_metadata.rb#5
  def join_primary_type(*_arg0, **_arg1, &_arg2); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/table_metadata.rb#62
  def polymorphic_association?; end

  # source://activerecord//lib/active_record/table_metadata.rb#66
  def polymorphic_name_association; end

  # source://activerecord//lib/active_record/table_metadata.rb#79
  def predicate_builder; end

  # source://activerecord//lib/active_record/table_metadata.rb#13
  def primary_key; end

  # source://activerecord//lib/active_record/table_metadata.rb#74
  def reflect_on_aggregation(aggregation_name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/table_metadata.rb#70
  def through_association?; end

  # source://activerecord//lib/active_record/table_metadata.rb#17
  def type(column_name); end

  private

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/table_metadata.rb#92
  def klass; end

  # Returns the value of attribute reflection.
  #
  # source://activerecord//lib/active_record/table_metadata.rb#92
  def reflection; end
end

# Raised when a model makes a query but it has not specified an associated table.
#
# source://activerecord//lib/active_record/errors.rb#50
class ActiveRecord::TableNotSpecified < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record.rb#168
module ActiveRecord::Tasks
  extend ::ActiveSupport::Autoload
end

# source://activerecord//lib/active_record/tasks/database_tasks.rb#7
class ActiveRecord::Tasks::DatabaseNotSupported < ::StandardError; end

# = Active Record \DatabaseTasks
#
# ActiveRecord::Tasks::DatabaseTasks is a utility class, which encapsulates
# logic behind common tasks used to manage database and migrations.
#
# The tasks defined here are used with \Rails commands provided by Active Record.
#
# In order to use DatabaseTasks, a few config values need to be set. All the needed
# config values are set by \Rails already, so it's necessary to do it only if you
# want to change the defaults or when you want to use Active Record outside of \Rails
# (in such case after configuring the database tasks, you can also use the rake tasks
# defined in Active Record).
#
# The possible config values are:
#
# * +env+: current environment (like Rails.env).
# * +database_configuration+: configuration of your databases (as in +config/database.yml+).
# * +db_dir+: your +db+ directory.
# * +fixtures_path+: a path to fixtures directory.
# * +migrations_paths+: a list of paths to directories with migrations.
# * +seed_loader+: an object which will load seeds, it needs to respond to the +load_seed+ method.
# * +root+: a path to the root of the application.
#
# Example usage of DatabaseTasks outside \Rails could look as such:
#
#   include ActiveRecord::Tasks
#   DatabaseTasks.database_configuration = YAML.load_file('my_database_config.yml')
#   DatabaseTasks.db_dir = 'db'
#   # other settings...
#
#   DatabaseTasks.create_current('production')
#
# source://activerecord//lib/active_record/tasks/database_tasks.rb#40
module ActiveRecord::Tasks::DatabaseTasks
  extend ::ActiveRecord::Tasks::DatabaseTasks

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#440
  def cache_dump_filename(db_config_name, schema_cache_path: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#305
  def charset(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#300
  def charset_current(env_name = T.unsafe(nil), db_name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#65
  def check_protected_environments!(environment = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#458
  def check_schema_file(filename); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#290
  def check_target_version; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#484
  def clear_schema_cache(filename); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#315
  def collation(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#310
  def collation_current(env_name = T.unsafe(nil), db_name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#115
  def create(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#127
  def create_all; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#170
  def create_current(environment = T.unsafe(nil), name = T.unsafe(nil)); end

  # Returns the value of attribute database_configuration.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#61
  def database_configuration; end

  # Sets the attribute database_configuration
  #
  # @param value the value to set the attribute database_configuration to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#61
  def database_configuration=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#258
  def db_configs_with_versions(db_configs); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#83
  def db_dir; end

  # Sets the attribute db_dir
  #
  # @param value the value to set the attribute db_dir to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def db_dir=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#204
  def drop(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#216
  def drop_all; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#220
  def drop_current(environment = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#403
  def dump_schema(db_config, format = T.unsafe(nil)); end

  # Dumps the schema cache in YAML format for the connection into the file
  #
  # ==== Examples
  #   ActiveRecord::Tasks::DatabaseTasks.dump_schema_cache(ActiveRecord::Base.connection, "tmp/schema_dump.yaml")
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#480
  def dump_schema_cache(conn, filename); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#103
  def env; end

  # Sets the attribute env
  #
  # @param value the value to set the attribute env to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def env=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#91
  def fixtures_path; end

  # Sets the attribute fixtures_path
  #
  # @param value the value to set the attribute fixtures_path to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def fixtures_path=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#141
  def for_each(databases); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#349
  def load_schema(db_config, format = T.unsafe(nil), file = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#450
  def load_schema_current(format = T.unsafe(nil), file = T.unsafe(nil), environment = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#466
  def load_seed; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#237
  def migrate(version = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#275
  def migrate_status; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#505
  def migration_class; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#509
  def migration_connection; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#87
  def migrations_paths; end

  # Sets the attribute migrations_paths
  #
  # @param value the value to set the attribute migrations_paths to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def migrations_paths=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#107
  def name; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#176
  def prepare_all; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#320
  def purge(configuration); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#325
  def purge_all; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#329
  def purge_current(environment = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#156
  def raise_for_multi_db(environment = T.unsafe(nil), command:); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#385
  def reconstruct_from_schema(db_config, format = T.unsafe(nil), file = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#73
  def register_task(pattern, task); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#99
  def root; end

  # Sets the attribute root
  #
  # @param value the value to set the attribute root to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def root=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#427
  def schema_dump_path(db_config, format = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#370
  def schema_up_to_date?(configuration, format = T.unsafe(nil), file = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#111
  def seed_loader; end

  # Sets the attribute seed_loader
  #
  # @param value the value to set the attribute seed_loader to.
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#60
  def seed_loader=(_arg0); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#135
  def setup_initial_database_yaml; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#335
  def structure_dump(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#342
  def structure_load(configuration, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#296
  def target_version; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#231
  def truncate_all(environment = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#499
  def with_temporary_connection(db_config, clobber: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#488
  def with_temporary_connection_for_each(env: T.unsafe(nil), name: T.unsafe(nil), clobber: T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#604
  def check_current_protected_environment!(db_config); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#546
  def class_for_adapter(adapter); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#523
  def configs_for(**options); end

  # Create a new instance for the specified db configuration object
  # For classes that have been converted to use db_config objects, pass a
  # `DatabaseConfig`, otherwise pass a `Hash`
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#538
  def database_adapter_for(db_config, *arguments); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#554
  def each_current_configuration(environment, name = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#567
  def each_local_configuration; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#579
  def local_database?(db_config); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#527
  def resolve_configuration(configuration); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#584
  def schema_sha1(file); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#588
  def structure_dump_flags_for(adapter); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#596
  def structure_load_flags_for(adapter); end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#224
  def truncate_tables(db_config); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/tasks/database_tasks.rb#531
  def verbose?; end

  # source://activerecord//lib/active_record/tasks/database_tasks.rb#514
  def with_temporary_pool(db_config, clobber: T.unsafe(nil)); end

  class << self
    # source://activerecord//lib/active_record/tasks/database_tasks.rb#50
    def structure_dump_flags; end

    # source://activerecord//lib/active_record/tasks/database_tasks.rb#50
    def structure_dump_flags=(val); end

    # source://activerecord//lib/active_record/tasks/database_tasks.rb#56
    def structure_load_flags; end

    # source://activerecord//lib/active_record/tasks/database_tasks.rb#56
    def structure_load_flags=(val); end
  end
end

# source://activerecord//lib/active_record/tasks/database_tasks.rb#63
ActiveRecord::Tasks::DatabaseTasks::LOCAL_HOSTS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#5
class ActiveRecord::Tasks::MySQLDatabaseTasks
  # @return [MySQLDatabaseTasks] a new instance of MySQLDatabaseTasks
  #
  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#12
  def initialize(db_config); end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#34
  def charset; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#38
  def collation; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#17
  def create; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#23
  def drop; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#28
  def purge; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#42
  def structure_dump(filename, extra_flags); end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#61
  def structure_load(filename, extra_flags); end

  private

  # Returns the value of attribute configuration_hash.
  #
  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#71
  def configuration_hash; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#81
  def configuration_hash_without_database; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#73
  def connection; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#85
  def creation_options; end

  # Returns the value of attribute db_config.
  #
  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#71
  def db_config; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#77
  def establish_connection(config = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#92
  def prepare_command_options; end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#111
  def run_cmd(cmd, args, action); end

  # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#115
  def run_cmd_error(cmd, args, action); end

  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#8
    def using_database_configurations?; end
  end
end

# source://activerecord//lib/active_record/tasks/mysql_database_tasks.rb#6
ActiveRecord::Tasks::MySQLDatabaseTasks::ER_DB_CREATE_EXISTS = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#7
class ActiveRecord::Tasks::PostgreSQLDatabaseTasks
  # @return [PostgreSQLDatabaseTasks] a new instance of PostgreSQLDatabaseTasks
  #
  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#16
  def initialize(db_config); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#32
  def charset; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#36
  def collation; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#21
  def create(connection_already_established = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#27
  def drop; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#40
  def purge; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#46
  def structure_dump(filename, extra_flags); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#80
  def structure_load(filename, extra_flags); end

  private

  # Returns the value of attribute configuration_hash.
  #
  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#88
  def configuration_hash; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#90
  def connection; end

  # Returns the value of attribute db_config.
  #
  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#88
  def db_config; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#98
  def encoding; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#94
  def establish_connection(config = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#106
  def psql_env; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#102
  def public_schema_config; end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#130
  def remove_sql_header_comments(filename); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#119
  def run_cmd(cmd, args, action); end

  # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#123
  def run_cmd_error(cmd, args, action); end

  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#12
    def using_database_configurations?; end
  end
end

# source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#8
ActiveRecord::Tasks::PostgreSQLDatabaseTasks::DEFAULT_ENCODING = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#9
ActiveRecord::Tasks::PostgreSQLDatabaseTasks::ON_ERROR_STOP_1 = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/tasks/postgresql_database_tasks.rb#10
ActiveRecord::Tasks::PostgreSQLDatabaseTasks::SQL_COMMENT_BEGIN = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#5
class ActiveRecord::Tasks::SQLiteDatabaseTasks
  # @return [SQLiteDatabaseTasks] a new instance of SQLiteDatabaseTasks
  #
  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#10
  def initialize(db_config, root = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#40
  def charset; end

  # @raise [DatabaseAlreadyExists]
  #
  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#15
  def create; end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#22
  def drop; end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#31
  def purge; end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#44
  def structure_dump(filename, extra_flags); end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#60
  def structure_load(filename, extra_flags); end

  private

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#68
  def connection; end

  # Returns the value of attribute db_config.
  #
  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#66
  def db_config; end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#72
  def establish_connection(config = T.unsafe(nil)); end

  # Returns the value of attribute root.
  #
  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#66
  def root; end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#76
  def run_cmd(cmd, args, out); end

  # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#80
  def run_cmd_error(cmd, args); end

  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/active_record/tasks/sqlite_database_tasks.rb#6
    def using_database_configurations?; end
  end
end

# source://activerecord//lib/active_record/test_databases.rb#6
module ActiveRecord::TestDatabases
  class << self
    # source://activerecord//lib/active_record/test_databases.rb#11
    def create_and_load_schema(i, env_name:); end
  end
end

# source://activerecord//lib/active_record/test_fixtures.rb#6
module ActiveRecord::TestFixtures
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::TestFixtures::ClassMethods

  # source://activerecord//lib/active_record/test_fixtures.rb#14
  def after_teardown; end

  # source://activerecord//lib/active_record/test_fixtures.rb#9
  def before_setup; end

  # source://activerecord//lib/active_record/test_fixtures.rb#205
  def enlist_fixture_connections; end

  # source://activerecord//lib/active_record/test_fixtures.rb#112
  def fixture_path; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#121
  def run_in_transaction?; end

  # source://activerecord//lib/active_record/test_fixtures.rb#126
  def setup_fixtures(config = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/test_fixtures.rb#188
  def teardown_fixtures; end

  private

  # source://activerecord//lib/active_record/test_fixtures.rb#290
  def access_fixture(fs_name, *fixture_names); end

  # source://activerecord//lib/active_record/test_fixtures.rb#258
  def instantiate_fixtures; end

  # source://activerecord//lib/active_record/test_fixtures.rb#254
  def load_fixtures(config); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#270
  def load_instances?; end

  # source://activerecord//lib/active_record/test_fixtures.rb#274
  def method_missing(name, *args, **kwargs, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#282
  def respond_to_missing?(name, include_private = T.unsafe(nil)); end

  # Shares the writing connection pool with connections on
  # other handlers.
  #
  # In an application with a primary and replica the test fixtures
  # need to share a connection pool so that the reading connection
  # can see data in the open transaction on the writing connection.
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#218
  def setup_shared_connection_pool; end

  # source://activerecord//lib/active_record/test_fixtures.rb#237
  def teardown_shared_connection_pool; end

  module GeneratedClassMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_paths; end
    def fixture_paths=(value); end
    def fixture_paths?; end
    def fixture_sets; end
    def fixture_sets=(value); end
    def fixture_sets?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end

  module GeneratedInstanceMethods
    def fixture_class_names; end
    def fixture_class_names=(value); end
    def fixture_class_names?; end
    def fixture_paths; end
    def fixture_paths?; end
    def fixture_sets; end
    def fixture_sets=(value); end
    def fixture_sets?; end
    def fixture_table_names; end
    def fixture_table_names=(value); end
    def fixture_table_names?; end
    def lock_threads; end
    def lock_threads=(value); end
    def lock_threads?; end
    def pre_loaded_fixtures; end
    def pre_loaded_fixtures=(value); end
    def pre_loaded_fixtures?; end
    def use_instantiated_fixtures; end
    def use_instantiated_fixtures=(value); end
    def use_instantiated_fixtures?; end
    def use_transactional_tests; end
    def use_transactional_tests=(value); end
    def use_transactional_tests?; end
  end
end

# source://activerecord//lib/active_record/test_fixtures.rb#42
module ActiveRecord::TestFixtures::ClassMethods
  # source://activerecord//lib/active_record/test_fixtures.rb#55
  def fixture_path; end

  # source://activerecord//lib/active_record/test_fixtures.rb#64
  def fixture_path=(path); end

  # source://activerecord//lib/active_record/test_fixtures.rb#69
  def fixtures(*fixture_set_names); end

  # Sets the model class for a fixture when the class name cannot be inferred from the fixture name.
  #
  # Examples:
  #
  #   set_fixture_class some_fixture:        SomeModel,
  #                     'namespaced/fixture' => Another::Model
  #
  # The keys must be the fixture names, that coincide with the short paths to the fixture files.
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#51
  def set_fixture_class(class_names = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/test_fixtures.rb#85
  def setup_fixture_accessors(fixture_set_names = T.unsafe(nil)); end

  # Prevents automatically wrapping each specified test in a transaction,
  # to allow application logic transactions to be tested in a top-level
  # (non-nested) context.
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#101
  def uses_transaction(*methods); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/test_fixtures.rb#106
  def uses_transaction?(method); end
end

# source://activerecord//lib/active_record/associations.rb#177
class ActiveRecord::ThroughCantAssociateThroughHasOneOrManyReflection < ::ActiveRecord::ActiveRecordError
  # @return [ThroughCantAssociateThroughHasOneOrManyReflection] a new instance of ThroughCantAssociateThroughHasOneOrManyReflection
  #
  # source://activerecord//lib/active_record/associations.rb#178
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/associations.rb#224
class ActiveRecord::ThroughNestedAssociationsAreReadonly < ::ActiveRecord::ActiveRecordError
  # @return [ThroughNestedAssociationsAreReadonly] a new instance of ThroughNestedAssociationsAreReadonly
  #
  # source://activerecord//lib/active_record/associations.rb#225
  def initialize(owner = T.unsafe(nil), reflection = T.unsafe(nil)); end
end

# = Active Record \Timestamp
#
# Active Record automatically timestamps create and update operations if the
# table has fields named <tt>created_at/created_on</tt> or
# <tt>updated_at/updated_on</tt>.
#
# Timestamping can be turned off by setting:
#
#   config.active_record.record_timestamps = false
#
# Timestamps are in UTC by default but you can use the local timezone by setting:
#
#   config.active_record.default_timezone = :local
#
# == Time Zone aware attributes
#
# Active Record keeps all the <tt>datetime</tt> and <tt>time</tt> columns
# timezone aware. By default, these values are stored in the database as UTC
# and converted back to the current <tt>Time.zone</tt> when pulled from the database.
#
# This feature can be turned off completely by setting:
#
#   config.active_record.time_zone_aware_attributes = false
#
# You can also specify that only <tt>datetime</tt> columns should be time-zone
# aware (while <tt>time</tt> should not) by setting:
#
#   ActiveRecord::Base.time_zone_aware_types = [:datetime]
#
# You can also add database-specific timezone aware types. For example, for PostgreSQL:
#
#   ActiveRecord::Base.time_zone_aware_types += [:tsrange, :tstzrange]
#
# Finally, you can indicate specific attributes of a model for which time zone
# conversion should not applied, for instance by setting:
#
#   class Topic < ActiveRecord::Base
#     self.skip_time_zone_conversion_for_attributes = [:written_on]
#   end
#
# source://activerecord//lib/active_record/timestamp.rb#43
module ActiveRecord::Timestamp
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::Timestamp::ClassMethods

  private

  # source://activerecord//lib/active_record/timestamp.rb#105
  def _create_record; end

  # source://activerecord//lib/active_record/timestamp.rb#117
  def _update_record; end

  # source://activerecord//lib/active_record/timestamp.rb#153
  def all_timestamp_attributes_in_model; end

  # Clear attributes and changed_attributes
  #
  # source://activerecord//lib/active_record/timestamp.rb#168
  def clear_timestamp_attributes; end

  # source://activerecord//lib/active_record/timestamp.rb#123
  def create_or_update(touch: T.unsafe(nil), **_arg1); end

  # source://activerecord//lib/active_record/timestamp.rb#157
  def current_time_from_proper_timezone; end

  # source://activerecord//lib/active_record/timestamp.rb#100
  def init_internals; end

  # source://activerecord//lib/active_record/timestamp.rb#50
  def initialize_dup(other); end

  # source://activerecord//lib/active_record/timestamp.rb#161
  def max_updated_column_timestamp; end

  # source://activerecord//lib/active_record/timestamp.rb#128
  def record_update_timestamps; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/timestamp.rb#141
  def should_record_timestamps?; end

  # source://activerecord//lib/active_record/timestamp.rb#145
  def timestamp_attributes_for_create_in_model; end

  # source://activerecord//lib/active_record/timestamp.rb#149
  def timestamp_attributes_for_update_in_model; end

  module GeneratedClassMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end

  module GeneratedInstanceMethods
    def record_timestamps; end
    def record_timestamps=(value); end
    def record_timestamps?; end
  end
end

# source://activerecord//lib/active_record/timestamp.rb#55
module ActiveRecord::Timestamp::ClassMethods
  # source://activerecord//lib/active_record/timestamp.rb#72
  def all_timestamp_attributes_in_model; end

  # source://activerecord//lib/active_record/timestamp.rb#77
  def current_time_from_proper_timezone; end

  # source://activerecord//lib/active_record/timestamp.rb#62
  def timestamp_attributes_for_create_in_model; end

  # source://activerecord//lib/active_record/timestamp.rb#67
  def timestamp_attributes_for_update_in_model; end

  # source://activerecord//lib/active_record/timestamp.rb#56
  def touch_attributes_with_time(*names, time: T.unsafe(nil)); end

  protected

  # source://activerecord//lib/active_record/timestamp.rb#82
  def reload_schema_from_cache(recursive = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/timestamp.rb#90
  def timestamp_attributes_for_create; end

  # source://activerecord//lib/active_record/timestamp.rb#94
  def timestamp_attributes_for_update; end
end

# source://activerecord//lib/active_record/token_for.rb#6
module ActiveRecord::TokenFor
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveRecord::TokenFor::ClassMethods

  # Generates a token for a predefined +purpose+.
  #
  # Use ClassMethods#generates_token_for to define a token purpose and
  # behavior.
  #
  # source://activerecord//lib/active_record/token_for.rb#109
  def generate_token_for(purpose); end

  module GeneratedClassMethods
    def generated_token_verifier; end
    def generated_token_verifier=(value); end
    def token_definitions; end
    def token_definitions=(value); end
  end

  module GeneratedInstanceMethods; end
end

# source://activerecord//lib/active_record/token_for.rb#38
module ActiveRecord::TokenFor::ClassMethods
  # Finds a record using a given +token+ for a predefined +purpose+. Returns
  # +nil+ if the token is invalid or the record was not found.
  #
  # @raise [UnknownPrimaryKey]
  #
  # source://activerecord//lib/active_record/token_for.rb#90
  def find_by_token_for(purpose, token); end

  # Finds a record using a given +token+ for a predefined +purpose+. Raises
  # ActiveSupport::MessageVerifier::InvalidSignature if the token is invalid
  # (e.g. expired, bad format, etc). Raises ActiveRecord::RecordNotFound if
  # the token is valid but the record was not found.
  #
  # source://activerecord//lib/active_record/token_for.rb#99
  def find_by_token_for!(purpose, token); end

  # Defines the behavior of tokens generated for a specific +purpose+.
  # A token can be generated by calling TokenFor#generate_token_for on a
  # record. Later, that record can be fetched by calling #find_by_token_for
  # (or #find_by_token_for!) with the same purpose and token.
  #
  # Tokens are signed so that they are tamper-proof. Thus they can be
  # exposed to outside world as, for example, password reset tokens.
  #
  # By default, tokens do not expire. They can be configured to expire by
  # specifying a duration via the +expires_in+ option. The duration becomes
  # part of the token's signature, so changing the value of +expires_in+
  # will automatically invalidate previously generated tokens.
  #
  # A block may also be specified. When generating a token with
  # TokenFor#generate_token_for, the block will be evaluated in the context
  # of the record, and its return value will be embedded in the token as
  # JSON. Later, when fetching the record with #find_by_token_for, the block
  # will be evaluated again in the context of the fetched record. If the two
  # JSON values do not match, the token will be treated as invalid. Note
  # that the value returned by the block <b>should not contain sensitive
  # information</b> because it will be embedded in the token as
  # <b>human-readable plaintext JSON</b>.
  #
  # ==== Examples
  #
  #   class User < ActiveRecord::Base
  #     has_secure_password
  #
  #     generates_token_for :password_reset, expires_in: 15.minutes do
  #       # Last 10 characters of password salt, which changes when password is updated:
  #       password_salt&.last(10)
  #     end
  #   end
  #
  #   user = User.first
  #
  #   token = user.generate_token_for(:password_reset)
  #   User.find_by_token_for(:password_reset, token) # => user
  #   # 16 minutes later...
  #   User.find_by_token_for(:password_reset, token) # => nil
  #
  #   token = user.generate_token_for(:password_reset)
  #   User.find_by_token_for(:password_reset, token) # => user
  #   user.update!(password: "new password")
  #   User.find_by_token_for(:password_reset, token) # => nil
  #
  # source://activerecord//lib/active_record/token_for.rb#84
  def generates_token_for(purpose, expires_in: T.unsafe(nil), &block); end
end

# source://activerecord//lib/active_record/token_for.rb#14
class ActiveRecord::TokenFor::TokenDefinition < ::Struct
  # Returns the value of attribute block
  #
  # @return [Object] the current value of block
  def block; end

  # Sets the attribute block
  #
  # @param value [Object] the value to set the attribute block to.
  # @return [Object] the newly set value
  def block=(_); end

  # Returns the value of attribute defining_class
  #
  # @return [Object] the current value of defining_class
  def defining_class; end

  # Sets the attribute defining_class
  #
  # @param value [Object] the value to set the attribute defining_class to.
  # @return [Object] the newly set value
  def defining_class=(_); end

  # Returns the value of attribute expires_in
  #
  # @return [Object] the current value of expires_in
  def expires_in; end

  # Sets the attribute expires_in
  #
  # @param value [Object] the value to set the attribute expires_in to.
  # @return [Object] the newly set value
  def expires_in=(_); end

  # source://activerecord//lib/active_record/token_for.rb#15
  def full_purpose; end

  # source://activerecord//lib/active_record/token_for.rb#27
  def generate_token(model); end

  # source://activerecord//lib/active_record/token_for.rb#19
  def message_verifier; end

  # source://activerecord//lib/active_record/token_for.rb#23
  def payload_for(model); end

  # Returns the value of attribute purpose
  #
  # @return [Object] the current value of purpose
  def purpose; end

  # Sets the attribute purpose
  #
  # @param value [Object] the value to set the attribute purpose to.
  # @return [Object] the newly set value
  def purpose=(_); end

  # source://activerecord//lib/active_record/token_for.rb#31
  def resolve_token(token); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# = Active Record Touch Later
#
# source://activerecord//lib/active_record/touch_later.rb#5
module ActiveRecord::TouchLater
  # source://activerecord//lib/active_record/touch_later.rb#6
  def before_committed!; end

  # source://activerecord//lib/active_record/touch_later.rb#38
  def touch(*names, time: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/touch_later.rb#11
  def touch_later(*names); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/touch_later.rb#66
  def has_defer_touch_attrs?; end

  # source://activerecord//lib/active_record/touch_later.rb#49
  def init_internals; end

  # source://activerecord//lib/active_record/touch_later.rb#54
  def surreptitiously_touch(attr_names); end

  # source://activerecord//lib/active_record/touch_later.rb#61
  def touch_deferred_attributes; end
end

# TransactionIsolationError will be raised under the following conditions:
#
# * The adapter does not support setting the isolation level
# * You are joining an existing open transaction
# * You are creating a nested (savepoint) transaction
#
# The mysql2, trilogy, and postgresql adapters support setting the transaction isolation level.
#
# source://activerecord//lib/active_record/errors.rb#481
class ActiveRecord::TransactionIsolationError < ::ActiveRecord::ActiveRecordError; end

# TransactionRollbackError will be raised when a transaction is rolled
# back by the database due to a serialization failure or a deadlock.
#
# These exceptions should not be generally rescued in nested transaction
# blocks, because they have side-effects in the actual enclosing transaction
# and internal Active Record state. They can be rescued if you are above the
# root transaction block, though.
#
# In that case, beware of transactional tests, however, because they run test
# cases in their own umbrella transaction. If you absolutely need to handle
# these exceptions in tests please consider disabling transactional tests in
# the affected test class (<tt>self.use_transactional_tests = false</tt>).
#
# Due to the aforementioned side-effects, this exception should not be raised
# manually by users.
#
# See the following:
#
# * https://www.postgresql.org/docs/current/static/transaction-iso.html
# * https://dev.mysql.com/doc/mysql-errors/en/server-error-reference.html#error_er_lock_deadlock
#
# source://activerecord//lib/active_record/errors.rb#504
class ActiveRecord::TransactionRollbackError < ::ActiveRecord::StatementInvalid; end

# See ActiveRecord::Transactions::ClassMethods for documentation.
#
# source://activerecord//lib/active_record/transactions.rb#5
module ActiveRecord::Transactions
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveRecord::Transactions::ClassMethods

  # source://activerecord//lib/active_record/transactions.rb#16
  def _new_record_before_last_commit; end

  # source://activerecord//lib/active_record/transactions.rb#16
  def _new_record_before_last_commit=(_arg0); end

  # source://activerecord//lib/active_record/transactions.rb#320
  def before_committed!; end

  # Call the #after_commit callbacks.
  #
  # Ensure that it is not called if the object was never persisted (failed create),
  # but call it after the commit of a destroyed object.
  #
  # source://activerecord//lib/active_record/transactions.rb#328
  def committed!(should_run_callbacks: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/transactions.rb#304
  def destroy; end

  # Call the #after_rollback callbacks. The +force_restore_state+ argument indicates if the record
  # state should be rolled back to the beginning or just to the last savepoint.
  #
  # source://activerecord//lib/active_record/transactions.rb#340
  def rolledback!(force_restore_state: T.unsafe(nil), should_run_callbacks: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/transactions.rb#308
  def save(**_arg0); end

  # source://activerecord//lib/active_record/transactions.rb#312
  def save!(**_arg0); end

  # source://activerecord//lib/active_record/transactions.rb#316
  def touch(*_arg0, **_arg1); end

  # See ActiveRecord::Transactions::ClassMethods for detailed documentation.
  #
  # source://activerecord//lib/active_record/transactions.rb#300
  def transaction(**options, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/transactions.rb#371
  def trigger_transactional_callbacks?; end

  # Executes a block within a transaction and captures its return value as a
  # status flag. If the status is true, the transaction is committed,
  # otherwise a ROLLBACK is issued. In any case, the status flag is returned.
  #
  # This method is available within the context of an ActiveRecord::Base
  # instance.
  #
  # source://activerecord//lib/active_record/transactions.rb#356
  def with_transaction_returning_status; end

  private

  # Returns the value of attribute _committed_already_called.
  #
  # source://activerecord//lib/active_record/transactions.rb#377
  def _committed_already_called; end

  # Returns the value of attribute _trigger_destroy_callback.
  #
  # source://activerecord//lib/active_record/transactions.rb#377
  def _trigger_destroy_callback; end

  # Returns the value of attribute _trigger_update_callback.
  #
  # source://activerecord//lib/active_record/transactions.rb#377
  def _trigger_update_callback; end

  # Add the record to the current transaction so that the #after_rollback and #after_commit
  # callbacks can be called.
  #
  # source://activerecord//lib/active_record/transactions.rb#459
  def add_to_transaction(ensure_finalize = T.unsafe(nil)); end

  # Clear the new record state and id of a record.
  #
  # source://activerecord//lib/active_record/transactions.rb#407
  def clear_transaction_record_state; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/transactions.rb#463
  def has_transactional_callbacks?; end

  # source://activerecord//lib/active_record/transactions.rb#379
  def init_internals; end

  # Save the new record state and id of a record so it can be restored later if a transaction fails.
  #
  # source://activerecord//lib/active_record/transactions.rb#387
  def remember_transaction_record_state; end

  # Restore the new record state and id of a record that was previously saved by a call to save_record_state.
  #
  # source://activerecord//lib/active_record/transactions.rb#414
  def restore_transaction_record_state(force_restore_state = T.unsafe(nil)); end

  # Determine if a transaction included an action for :create, :update, or :destroy. Used in filtering callbacks.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/transactions.rb#444
  def transaction_include_any_action?(actions); end
end

# source://activerecord//lib/active_record/transactions.rb#8
ActiveRecord::Transactions::ACTIONS = T.let(T.unsafe(nil), Array)

# = Active Record \Transactions
#
# \Transactions are protective blocks where SQL statements are only permanent
# if they can all succeed as one atomic action. The classic example is a
# transfer between two accounts where you can only have a deposit if the
# withdrawal succeeded and vice versa. \Transactions enforce the integrity of
# the database and guard the data against program errors or database
# break-downs. So basically you should use transaction blocks whenever you
# have a number of statements that must be executed together or not at all.
#
# For example:
#
#   ActiveRecord::Base.transaction do
#     david.withdrawal(100)
#     mary.deposit(100)
#   end
#
# This example will only take money from David and give it to Mary if neither
# +withdrawal+ nor +deposit+ raise an exception. Exceptions will force a
# ROLLBACK that returns the database to the state before the transaction
# began. Be aware, though, that the objects will _not_ have their instance
# data returned to their pre-transactional state.
#
# == Different Active Record classes in a single transaction
#
# Though the #transaction class method is called on some Active Record class,
# the objects within the transaction block need not all be instances of
# that class. This is because transactions are per-database connection, not
# per-model.
#
# In this example a +balance+ record is transactionally saved even
# though #transaction is called on the +Account+ class:
#
#   Account.transaction do
#     balance.save!
#     account.save!
#   end
#
# The #transaction method is also available as a model instance method.
# For example, you can also do this:
#
#   balance.transaction do
#     balance.save!
#     account.save!
#   end
#
# == Transactions are not distributed across database connections
#
# A transaction acts on a single database connection. If you have
# multiple class-specific databases, the transaction will not protect
# interaction among them. One workaround is to begin a transaction
# on each class whose models you alter:
#
#   Student.transaction do
#     Course.transaction do
#       course.enroll(student)
#       student.units += course.units
#     end
#   end
#
# This is a poor solution, but fully distributed transactions are beyond
# the scope of Active Record.
#
# == +save+ and +destroy+ are automatically wrapped in a transaction
#
# Both {#save}[rdoc-ref:Persistence#save] and
# {#destroy}[rdoc-ref:Persistence#destroy] come wrapped in a transaction that ensures
# that whatever you do in validations or callbacks will happen under its
# protected cover. So you can use validations to check for values that
# the transaction depends on or you can raise exceptions in the callbacks
# to rollback, including <tt>after_*</tt> callbacks.
#
# As a consequence changes to the database are not seen outside your connection
# until the operation is complete. For example, if you try to update the index
# of a search engine in +after_save+ the indexer won't see the updated record.
# The #after_commit callback is the only one that is triggered once the update
# is committed. See below.
#
# == Exception handling and rolling back
#
# Also have in mind that exceptions thrown within a transaction block will
# be propagated (after triggering the ROLLBACK), so you should be ready to
# catch those in your application code.
#
# One exception is the ActiveRecord::Rollback exception, which will trigger
# a ROLLBACK when raised, but not be re-raised by the transaction block. Any
# other exception will be re-raised.
#
# *Warning*: one should not catch ActiveRecord::StatementInvalid exceptions
# inside a transaction block. ActiveRecord::StatementInvalid exceptions indicate that an
# error occurred at the database level, for example when a unique constraint
# is violated. On some database systems, such as PostgreSQL, database errors
# inside a transaction cause the entire transaction to become unusable
# until it's restarted from the beginning. Here is an example which
# demonstrates the problem:
#
#   # Suppose that we have a Number model with a unique column called 'i'.
#   Number.transaction do
#     Number.create(i: 0)
#     begin
#       # This will raise a unique constraint error...
#       Number.create(i: 0)
#     rescue ActiveRecord::StatementInvalid
#       # ...which we ignore.
#     end
#
#     # On PostgreSQL, the transaction is now unusable. The following
#     # statement will cause a PostgreSQL error, even though the unique
#     # constraint is no longer violated:
#     Number.create(i: 1)
#     # => "PG::Error: ERROR:  current transaction is aborted, commands
#     #     ignored until end of transaction block"
#   end
#
# One should restart the entire transaction if an
# ActiveRecord::StatementInvalid occurred.
#
# == Nested transactions
#
# #transaction calls can be nested. By default, this makes all database
# statements in the nested transaction block become part of the parent
# transaction. For example, the following behavior may be surprising:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# creates both "Kotori" and "Nemu". Reason is the ActiveRecord::Rollback
# exception in the nested block does not issue a ROLLBACK. Since these exceptions
# are captured in transaction blocks, the parent block does not see it and the
# real transaction is committed.
#
# In order to get a ROLLBACK for the nested transaction you may ask for a real
# sub-transaction by passing <tt>requires_new: true</tt>. If anything goes wrong,
# the database rolls back to the beginning of the sub-transaction without rolling
# back the parent transaction. If we add it to the previous example:
#
#   User.transaction do
#     User.create(username: 'Kotori')
#     User.transaction(requires_new: true) do
#       User.create(username: 'Nemu')
#       raise ActiveRecord::Rollback
#     end
#   end
#
# only "Kotori" is created.
#
# Most databases don't support true nested transactions. At the time of
# writing, the only database that we're aware of that supports true nested
# transactions, is MS-SQL. Because of this, Active Record emulates nested
# transactions by using savepoints. See
# https://dev.mysql.com/doc/refman/en/savepoint.html
# for more information about savepoints.
#
# === \Callbacks
#
# There are two types of callbacks associated with committing and rolling back transactions:
# #after_commit and #after_rollback.
#
# #after_commit callbacks are called on every record saved or destroyed within a
# transaction immediately after the transaction is committed. #after_rollback callbacks
# are called on every record saved or destroyed within a transaction immediately after the
# transaction or savepoint is rolled back.
#
# These callbacks are useful for interacting with other systems since you will be guaranteed
# that the callback is only executed when the database is in a permanent state. For example,
# #after_commit is a good spot to put in a hook to clearing a cache since clearing it from
# within a transaction could trigger the cache to be regenerated before the database is updated.
#
# === Caveats
#
# If you're on MySQL, then do not use Data Definition Language (DDL) operations in nested
# transactions blocks that are emulated with savepoints. That is, do not execute statements
# like 'CREATE TABLE' inside such blocks. This is because MySQL automatically
# releases all savepoints upon executing a DDL operation. When +transaction+
# is finished and tries to release the savepoint it created earlier, a
# database error will occur because the savepoint has already been
# automatically released. The following example demonstrates the problem:
#
#   Model.connection.transaction do                           # BEGIN
#     Model.connection.transaction(requires_new: true) do     # CREATE SAVEPOINT active_record_1
#       Model.connection.create_table(...)                    # active_record_1 now automatically released
#     end                                                     # RELEASE SAVEPOINT active_record_1
#                                                             # ^^^^ BOOM! database error!
#   end
#
# Note that "TRUNCATE" is also a MySQL DDL statement!
#
# source://activerecord//lib/active_record/transactions.rb#209
module ActiveRecord::Transactions::ClassMethods
  # This callback is called after a record has been created, updated, or destroyed.
  #
  # You can specify that the callback should only be fired by a certain action with
  # the +:on+ option:
  #
  #   after_commit :do_foo, on: :create
  #   after_commit :do_bar, on: :update
  #   after_commit :do_baz, on: :destroy
  #
  #   after_commit :do_foo_bar, on: [:create, :update]
  #   after_commit :do_bar_baz, on: [:update, :destroy]
  #
  # source://activerecord//lib/active_record/transactions.rb#232
  def after_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :create</tt>.
  #
  # source://activerecord//lib/active_record/transactions.rb#244
  def after_create_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :destroy</tt>.
  #
  # source://activerecord//lib/active_record/transactions.rb#256
  def after_destroy_commit(*args, &block); end

  # This callback is called after a create, update, or destroy are rolled back.
  #
  # Please check the documentation of #after_commit for options.
  #
  # source://activerecord//lib/active_record/transactions.rb#264
  def after_rollback(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: [ :create, :update ]</tt>.
  #
  # source://activerecord//lib/active_record/transactions.rb#238
  def after_save_commit(*args, &block); end

  # Shortcut for <tt>after_commit :hook, on: :update</tt>.
  #
  # source://activerecord//lib/active_record/transactions.rb#250
  def after_update_commit(*args, &block); end

  # source://activerecord//lib/active_record/transactions.rb#215
  def before_commit(*args, &block); end

  # See the ConnectionAdapters::DatabaseStatements#transaction API docs.
  #
  # source://activerecord//lib/active_record/transactions.rb#211
  def transaction(**options, &block); end

  private

  # source://activerecord//lib/active_record/transactions.rb#292
  def assert_valid_transaction_action(actions); end

  # source://activerecord//lib/active_record/transactions.rb#270
  def prepend_option; end

  # source://activerecord//lib/active_record/transactions.rb#278
  def set_options_for_callbacks!(args, enforced_options = T.unsafe(nil)); end
end

# source://activerecord//lib/active_record/translation.rb#4
module ActiveRecord::Translation
  include ::ActiveModel::Naming
  include ::ActiveModel::Translation

  # Set the i18n scope to override ActiveModel.
  #
  # source://activerecord//lib/active_record/translation.rb#20
  def i18n_scope; end

  # Set the lookup ancestors for ActiveModel.
  #
  # source://activerecord//lib/active_record/translation.rb#8
  def lookup_ancestors; end
end

# :stopdoc:
#
# source://activerecord//lib/active_record/type/internal/timezone.rb#4
module ActiveRecord::Type
  class << self
    # source://activerecord//lib/active_record/type.rb#49
    def adapter_name_from(model); end

    # source://activerecord//lib/active_record/type.rb#27
    def add_modifier(*_arg0, **_arg1, &_arg2); end

    # source://activerecord//lib/active_record/type.rb#45
    def default_value; end

    # source://activerecord//lib/active_record/type.rb#41
    def lookup(*args, adapter: T.unsafe(nil), **kwargs); end

    # Add a new type to the registry, allowing it to be referenced as a
    # symbol by {ActiveRecord::Base.attribute}[rdoc-ref:Attributes::ClassMethods#attribute].
    # If your type is only meant to be used with a specific database adapter, you can
    # do so by passing <tt>adapter: :postgresql</tt>. If your type has the same
    # name as a native type for the current adapter, an exception will be
    # raised unless you specify an +:override+ option. <tt>override: true</tt> will
    # cause your type to be used instead of the native type. <tt>override:
    # false</tt> will cause the native type to be used over yours if one exists.
    #
    # source://activerecord//lib/active_record/type.rb#37
    def register(type_name, klass = T.unsafe(nil), **options, &block); end

    # source://activerecord//lib/active_record/type.rb#26
    def registry; end

    # source://activerecord//lib/active_record/type.rb#26
    def registry=(_arg0); end

    private

    # source://activerecord//lib/active_record/type.rb#54
    def current_adapter_name; end
  end
end

# source://activerecord//lib/active_record/type/adapter_specific_registry.rb#6
class ActiveRecord::Type::AdapterSpecificRegistry
  # @return [AdapterSpecificRegistry] a new instance of AdapterSpecificRegistry
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#7
  def initialize; end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#15
  def add_modifier(options, klass, **args); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#27
  def lookup(symbol, *args, **kwargs); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#19
  def register(type_name, klass = T.unsafe(nil), **options, &block); end

  private

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#40
  def find_registration(symbol, *args, **kwargs); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#11
  def initialize_copy(other); end

  # Returns the value of attribute registrations.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#38
  def registrations; end
end

# source://activerecord//lib/active_record/type.rb#59
ActiveRecord::Type::BigInteger = ActiveModel::Type::BigInteger

# source://activerecord//lib/active_record/type.rb#60
ActiveRecord::Type::Binary = ActiveModel::Type::Binary

# source://activerecord//lib/active_record/type.rb#61
ActiveRecord::Type::Boolean = ActiveModel::Type::Boolean

# source://activerecord//lib/active_record/type/date.rb#5
class ActiveRecord::Type::Date < ::ActiveModel::Type::Date
  include ::ActiveRecord::Type::Internal::Timezone
end

# source://activerecord//lib/active_record/type/date_time.rb#5
class ActiveRecord::Type::DateTime < ::ActiveModel::Type::DateTime
  include ::ActiveRecord::Type::Internal::Timezone
end

# source://activerecord//lib/active_record/type.rb#62
ActiveRecord::Type::Decimal = ActiveModel::Type::Decimal

# source://activerecord//lib/active_record/type/decimal_without_scale.rb#5
class ActiveRecord::Type::DecimalWithoutScale < ::ActiveModel::Type::BigInteger
  # source://activerecord//lib/active_record/type/decimal_without_scale.rb#6
  def type; end

  # source://activerecord//lib/active_record/type/decimal_without_scale.rb#10
  def type_cast_for_schema(value); end
end

# source://activerecord//lib/active_record/type/adapter_specific_registry.rb#110
class ActiveRecord::Type::DecorationRegistration < ::ActiveRecord::Type::Registration
  # @return [DecorationRegistration] a new instance of DecorationRegistration
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#111
  def initialize(options, klass, adapter: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#117
  def call(registry, *args, **kwargs); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#122
  def matches?(*args, **kwargs); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#126
  def priority; end

  private

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#131
  def klass; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#133
  def matches_options?(**kwargs); end

  # Returns the value of attribute options.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#131
  def options; end
end

# source://activerecord//lib/active_record/type.rb#63
ActiveRecord::Type::Float = ActiveModel::Type::Float

# source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#5
class ActiveRecord::Type::HashLookupTypeMap
  # @return [HashLookupTypeMap] a new instance of HashLookupTypeMap
  #
  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#6
  def initialize(parent = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#39
  def alias_type(type, alias_type); end

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#34
  def clear; end

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#17
  def fetch(lookup_key, *args, &block); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#43
  def key?(key); end

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#47
  def keys; end

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#13
  def lookup(lookup_key, *args); end

  # @raise [::ArgumentError]
  #
  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#23
  def register_type(key, value = T.unsafe(nil), &block); end

  private

  # source://activerecord//lib/active_record/type/hash_lookup_type_map.rb#52
  def perform_fetch(type, *args, &block); end
end

# source://activerecord//lib/active_record/type.rb#65
ActiveRecord::Type::ImmutableString = ActiveModel::Type::ImmutableString

# source://activerecord//lib/active_record/type.rb#64
ActiveRecord::Type::Integer = ActiveModel::Type::Integer

# source://activerecord//lib/active_record/type/internal/timezone.rb#5
module ActiveRecord::Type::Internal; end

# source://activerecord//lib/active_record/type/internal/timezone.rb#6
module ActiveRecord::Type::Internal::Timezone
  # source://activerecord//lib/active_record/type/internal/timezone.rb#7
  def initialize(timezone: T.unsafe(nil), **kwargs); end

  # source://activerecord//lib/active_record/type/internal/timezone.rb#16
  def default_timezone; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/internal/timezone.rb#12
  def is_utc?; end
end

# source://activerecord//lib/active_record/type/json.rb#5
class ActiveRecord::Type::Json < ::ActiveModel::Type::Value
  include ::ActiveModel::Type::Helpers::Mutable

  # source://activerecord//lib/active_record/type/json.rb#25
  def accessor; end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/json.rb#21
  def changed_in_place?(raw_old_value, new_value); end

  # source://activerecord//lib/active_record/type/json.rb#12
  def deserialize(value); end

  # source://activerecord//lib/active_record/type/json.rb#17
  def serialize(value); end

  # source://activerecord//lib/active_record/type/json.rb#8
  def type; end
end

# source://activerecord//lib/active_record/type/adapter_specific_registry.rb#47
class ActiveRecord::Type::Registration
  # @return [Registration] a new instance of Registration
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#48
  def initialize(name, block, adapter: T.unsafe(nil), override: T.unsafe(nil)); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#63
  def <=>(other); end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#55
  def call(_registry, *args, adapter: T.unsafe(nil), **kwargs); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#59
  def matches?(type_name, *args, **kwargs); end

  protected

  # Returns the value of attribute adapter.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#73
  def adapter; end

  # Returns the value of attribute block.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#73
  def block; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#73
  def name; end

  # Returns the value of attribute override.
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#73
  def override; end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#75
  def priority; end

  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#86
  def priority_except_adapter; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#95
  def conflicts_with?(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#104
  def has_adapter_conflict?(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#91
  def matches_adapter?(adapter: T.unsafe(nil), **_arg1); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/adapter_specific_registry.rb#100
  def same_priority_except_adapter?(other); end
end

# source://activerecord//lib/active_record/type/serialized.rb#5
class ActiveRecord::Type::Serialized
  include ::ActiveModel::Type::Helpers::Mutable

  # @return [Serialized] a new instance of Serialized
  #
  # source://activerecord//lib/active_record/type/serialized.rb#12
  def initialize(subtype, coder); end

  # source://activerecord//lib/active_record/type/serialized.rb#44
  def accessor; end

  # source://activerecord//lib/active_record/type/serialized.rb#48
  def assert_valid_value(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/serialized.rb#37
  def changed_in_place?(raw_old_value, value); end

  # Returns the value of attribute coder.
  #
  # source://activerecord//lib/active_record/type/serialized.rb#10
  def coder; end

  # source://activerecord//lib/active_record/type/serialized.rb#18
  def deserialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/serialized.rb#54
  def force_equality?(value); end

  # source://activerecord//lib/active_record/type/serialized.rb#33
  def inspect; end

  # source://activerecord//lib/active_record/type/serialized.rb#26
  def serialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/serialized.rb#58
  def serialized?; end

  # Returns the value of attribute subtype.
  #
  # source://activerecord//lib/active_record/type/serialized.rb#10
  def subtype; end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/type/serialized.rb#63
  def default_value?(value); end

  # source://activerecord//lib/active_record/type/serialized.rb#67
  def encoded(value); end
end

# source://activerecord//lib/active_record/type.rb#66
ActiveRecord::Type::String = ActiveModel::Type::String

# source://activerecord//lib/active_record/type/text.rb#5
class ActiveRecord::Type::Text < ::ActiveModel::Type::String
  # source://activerecord//lib/active_record/type/text.rb#6
  def type; end
end

# source://activerecord//lib/active_record/type/time.rb#5
class ActiveRecord::Type::Time < ::ActiveModel::Type::Time
  include ::ActiveRecord::Type::Internal::Timezone

  # source://activerecord//lib/active_record/type/time.rb#11
  def serialize(value); end

  # source://activerecord//lib/active_record/type/time.rb#20
  def serialize_cast_value(value); end

  private

  # source://activerecord//lib/active_record/type/time.rb#25
  def cast_value(value); end
end

# source://activerecord//lib/active_record/type/time.rb#8
class ActiveRecord::Type::Time::Value; end

# source://activerecord//lib/active_record/type/type_map.rb#7
class ActiveRecord::Type::TypeMap
  # @return [TypeMap] a new instance of TypeMap
  #
  # source://activerecord//lib/active_record/type/type_map.rb#8
  def initialize(parent = T.unsafe(nil)); end

  # source://activerecord//lib/active_record/type/type_map.rb#35
  def alias_type(key, target_key); end

  # source://activerecord//lib/active_record/type/type_map.rb#18
  def fetch(lookup_key, &block); end

  # source://activerecord//lib/active_record/type/type_map.rb#14
  def lookup(lookup_key); end

  # @raise [::ArgumentError]
  #
  # source://activerecord//lib/active_record/type/type_map.rb#24
  def register_type(key, value = T.unsafe(nil), &block); end

  protected

  # source://activerecord//lib/active_record/type/type_map.rb#43
  def perform_fetch(lookup_key, &block); end
end

# source://activerecord//lib/active_record/type/unsigned_integer.rb#5
class ActiveRecord::Type::UnsignedInteger < ::ActiveModel::Type::Integer
  private

  # source://activerecord//lib/active_record/type/unsigned_integer.rb#7
  def max_value; end

  # source://activerecord//lib/active_record/type/unsigned_integer.rb#11
  def min_value; end
end

# source://activerecord//lib/active_record/type.rb#67
ActiveRecord::Type::Value = ActiveModel::Type::Value

# source://activerecord//lib/active_record/type_caster/map.rb#4
module ActiveRecord::TypeCaster; end

# source://activerecord//lib/active_record/type_caster/connection.rb#5
class ActiveRecord::TypeCaster::Connection
  # @return [Connection] a new instance of Connection
  #
  # source://activerecord//lib/active_record/type_caster/connection.rb#6
  def initialize(klass, table_name); end

  # source://activerecord//lib/active_record/type_caster/connection.rb#11
  def type_cast_for_database(attr_name, value); end

  # source://activerecord//lib/active_record/type_caster/connection.rb#16
  def type_for_attribute(attr_name); end

  private

  # source://activerecord//lib/active_record/type_caster/connection.rb#27
  def connection(*_arg0, **_arg1, &_arg2); end

  # Returns the value of attribute table_name.
  #
  # source://activerecord//lib/active_record/type_caster/connection.rb#30
  def table_name; end
end

# source://activerecord//lib/active_record/type_caster/map.rb#5
class ActiveRecord::TypeCaster::Map
  # @return [Map] a new instance of Map
  #
  # source://activerecord//lib/active_record/type_caster/map.rb#6
  def initialize(klass); end

  # source://activerecord//lib/active_record/type_caster/map.rb#10
  def type_cast_for_database(attr_name, value); end

  # source://activerecord//lib/active_record/type_caster/map.rb#15
  def type_for_attribute(name); end

  private

  # Returns the value of attribute klass.
  #
  # source://activerecord//lib/active_record/type_caster/map.rb#20
  def klass; end
end

# source://activerecord//lib/active_record/type/adapter_specific_registry.rb#141
class ActiveRecord::TypeConflictError < ::StandardError; end

# Raised when unknown attributes are supplied via mass assignment.
#
# source://activerecord//lib/active_record/errors.rb#417
ActiveRecord::UnknownAttributeError = ActiveModel::UnknownAttributeError

# UnknownAttributeReference is raised when an unknown and potentially unsafe
# value is passed to a query method. For example, passing a non column name
# value to a relation's #order method might cause this exception.
#
# When working around this exception, caution should be taken to avoid SQL
# injection vulnerabilities when passing user-provided values to query
# methods. Known-safe values can be passed to query methods by wrapping them
# in Arel.sql.
#
# For example, the following code would raise this exception:
#
#   Post.order("REPLACE(title, 'misc', 'zzzz') asc").pluck(:id)
#
# The desired result can be accomplished by wrapping the known-safe string
# in Arel.sql:
#
#   Post.order(Arel.sql("REPLACE(title, 'misc', 'zzzz') asc")).pluck(:id)
#
# Again, such a workaround should *not* be used when passing user-provided
# values, such as request parameters or model attributes to query methods.
#
# source://activerecord//lib/active_record/errors.rb#578
class ActiveRecord::UnknownAttributeReference < ::ActiveRecord::ActiveRecordError; end

# source://activerecord//lib/active_record/migration.rb#114
class ActiveRecord::UnknownMigrationVersionError < ::ActiveRecord::MigrationError
  # @return [UnknownMigrationVersionError] a new instance of UnknownMigrationVersionError
  #
  # source://activerecord//lib/active_record/migration.rb#115
  def initialize(version = T.unsafe(nil)); end
end

# Raised when a primary key is needed, but not specified in the schema or model.
#
# source://activerecord//lib/active_record/errors.rb#445
class ActiveRecord::UnknownPrimaryKey < ::ActiveRecord::ActiveRecordError
  # @return [UnknownPrimaryKey] a new instance of UnknownPrimaryKey
  #
  # source://activerecord//lib/active_record/errors.rb#448
  def initialize(model = T.unsafe(nil), description = T.unsafe(nil)); end

  # Returns the value of attribute model.
  #
  # source://activerecord//lib/active_record/errors.rb#446
  def model; end
end

# source://activerecord//lib/active_record/gem_version.rb#9
module ActiveRecord::VERSION; end

# source://activerecord//lib/active_record/gem_version.rb#10
ActiveRecord::VERSION::MAJOR = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/gem_version.rb#11
ActiveRecord::VERSION::MINOR = T.let(T.unsafe(nil), Integer)

# source://activerecord//lib/active_record/gem_version.rb#13
ActiveRecord::VERSION::PRE = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/gem_version.rb#15
ActiveRecord::VERSION::STRING = T.let(T.unsafe(nil), String)

# source://activerecord//lib/active_record/gem_version.rb#12
ActiveRecord::VERSION::TINY = T.let(T.unsafe(nil), Integer)

# = Active Record \Validations
#
# Active Record includes the majority of its validations from ActiveModel::Validations.
#
# In Active Record, all validations are performed on save by default.
# Validations accept the <tt>:on</tt> argument to define the context where
# the validations are active. Active Record will pass either the context of
# <tt>:create</tt> or <tt>:update</tt> depending on whether the model is a
# {new_record?}[rdoc-ref:Persistence#new_record?].
#
# source://activerecord//lib/active_record/validations.rb#40
module ActiveRecord::Validations
  extend ::ActiveSupport::Concern
  include GeneratedInstanceMethods
  include ::ActiveSupport::Callbacks
  include ::ActiveModel::Validations::HelperMethods
  include ::ActiveModel::Validations

  mixes_in_class_methods GeneratedClassMethods
  mixes_in_class_methods ::ActiveModel::Validations::ClassMethods
  mixes_in_class_methods ::ActiveModel::Callbacks
  mixes_in_class_methods ::ActiveSupport::Callbacks::ClassMethods
  mixes_in_class_methods ::ActiveSupport::DescendantsTracker
  mixes_in_class_methods ::ActiveModel::Translation
  mixes_in_class_methods ::ActiveModel::Validations::HelperMethods
  mixes_in_class_methods ::ActiveRecord::Validations::ClassMethods

  # The validation process on save can be skipped by passing <tt>validate: false</tt>.
  # The validation context can be changed by passing <tt>context: context</tt>.
  # The regular {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] method is replaced
  # with this when the validations module is mixed in, which it is by default.
  #
  # source://activerecord//lib/active_record/validations.rb#48
  def save(**options); end

  # Attempts to save the record just like {ActiveRecord::Base#save}[rdoc-ref:Base#save] but
  # will raise an ActiveRecord::RecordInvalid exception instead of returning +false+ if the record is not valid.
  #
  # source://activerecord//lib/active_record/validations.rb#54
  def save!(**options); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  # If the argument is an array of contexts, <tt>post.valid?([:create, :update])</tt>, the validations are
  # run within multiple contexts.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/validations.rb#70
  def valid?(context = T.unsafe(nil)); end

  # Runs all the validations within the specified context. Returns +true+ if
  # no errors are found, +false+ otherwise.
  #
  # Aliased as #validate.
  #
  # If the argument is +false+ (default is +nil+), the context is set to <tt>:create</tt> if
  # {new_record?}[rdoc-ref:Persistence#new_record?] is +true+, and to <tt>:update</tt> if it is not.
  # If the argument is an array of contexts, <tt>post.valid?([:create, :update])</tt>, the validations are
  # run within multiple contexts.
  #
  # \Validations with no <tt>:on</tt> option will run no matter the context. \Validations with
  # some <tt>:on</tt> option will only run in the specified context.
  #
  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/validations.rb#70
  def validate(context = T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/validations.rb#79
  def default_validation_context; end

  # source://activerecord//lib/active_record/validations.rb#87
  def perform_validations(options = T.unsafe(nil)); end

  # @raise [RecordInvalid]
  #
  # source://activerecord//lib/active_record/validations.rb#83
  def raise_validation_error; end

  module GeneratedClassMethods
    def __callbacks; end
    def __callbacks=(value); end
    def __callbacks?; end
    def _validators; end
    def _validators=(value); end
    def _validators?; end
  end

  module GeneratedInstanceMethods
    def __callbacks; end
    def __callbacks?; end
    def _validators; end
    def _validators?; end
  end
end

# source://activerecord//lib/active_record/validations/absence.rb#5
class ActiveRecord::Validations::AbsenceValidator < ::ActiveModel::Validations::AbsenceValidator
  # source://activerecord//lib/active_record/validations/absence.rb#6
  def validate_each(record, attribute, association_or_value); end
end

# source://activerecord//lib/active_record/validations/associated.rb#5
class ActiveRecord::Validations::AssociatedValidator < ::ActiveModel::EachValidator
  # source://activerecord//lib/active_record/validations/associated.rb#6
  def validate_each(record, attribute, value); end

  private

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/validations/associated.rb#13
  def valid_object?(record); end
end

# source://activerecord//lib/active_record/validations/associated.rb#18
module ActiveRecord::Validations::ClassMethods
  # Validates that the specified attributes are not present (as defined by
  # Object#present?). If the attribute is an association, the associated object
  # is also considered not present if it is marked for destruction.
  #
  # See ActiveModel::Validations::HelperMethods.validates_absence_of for more information.
  #
  # source://activerecord//lib/active_record/validations/absence.rb#20
  def validates_absence_of(*attr_names); end

  # Validates whether the associated object or objects are all valid.
  # Works with any kind of association.
  #
  #   class Book < ActiveRecord::Base
  #     has_many :pages
  #     belongs_to :library
  #
  #     validates_associated :pages, :library
  #   end
  #
  # WARNING: This validation must not be used on both ends of an association.
  # Doing so will lead to a circular dependency and cause infinite recursion.
  #
  # NOTE: This validation will not fail if the association hasn't been
  # assigned. If you want to ensure that the association is both present and
  # guaranteed to be valid, you also need to use
  # {validates_presence_of}[rdoc-ref:Validations::ClassMethods#validates_presence_of].
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - A custom error message (default is: "is invalid").
  # * <tt>:on</tt> - Specifies the contexts where this validation is active.
  #   Runs in all validation contexts by default +nil+. You can pass a symbol
  #   or an array of symbols. (e.g. <tt>on: :create</tt> or
  #   <tt>on: :custom_validation_context</tt> or
  #   <tt>on: [:create, :custom_validation_context]</tt>)
  # * <tt>:if</tt> - Specifies a method, proc, or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc, or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc, or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # source://activerecord//lib/active_record/validations/associated.rb#54
  def validates_associated(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  #
  # source://activerecord//lib/active_record/validations/length.rb#19
  def validates_length_of(*attr_names); end

  # Validates whether the value of the specified attribute is numeric by
  # trying to convert it to a float with +Kernel.Float+ (if
  # <tt>only_integer</tt> is +false+) or applying it to the regular
  # expression <tt>/\A[\+\-]?\d+\z/</tt> (if <tt>only_integer</tt> is set to
  # +true+). +Kernel.Float+ precision defaults to the column's precision
  # value or 15.
  #
  # See ActiveModel::Validations::HelperMethods.validates_numericality_of for more information.
  #
  # source://activerecord//lib/active_record/validations/numericality.rb#31
  def validates_numericality_of(*attr_names); end

  # Validates that the specified attributes are not blank (as defined by
  # Object#blank?). If the attribute is an association, the associated object
  # is also considered blank if it is marked for destruction.
  #
  #   class Person < ActiveRecord::Base
  #     has_one :face
  #     validates_presence_of :face
  #   end
  #
  # The face attribute must be in the object and it cannot be blank or marked
  # for destruction.
  #
  # This validator defers to the Active Model validation for presence, adding the
  # check to see that an associated object is not marked for destruction. This
  # prevents the parent object from validating successfully and saving, which then
  # deletes the associated object, thus putting the parent object into an invalid
  # state.
  #
  # See ActiveModel::Validations::HelperMethods.validates_presence_of for
  # more information.
  #
  # NOTE: This validation will not fail while using it with an association
  # if the latter was assigned but not valid. If you want to ensure that
  # it is both present and valid, you also need to use
  # {validates_associated}[rdoc-ref:Validations::ClassMethods#validates_associated].
  #
  # source://activerecord//lib/active_record/validations/presence.rb#40
  def validates_presence_of(*attr_names); end

  # Validates that the specified attributes match the length restrictions supplied.
  # If the attribute is an association, records that are marked for destruction are not counted.
  #
  # See ActiveModel::Validations::HelperMethods.validates_length_of for more information.
  #
  # source://activerecord//lib/active_record/validations/length.rb#19
  def validates_size_of(*attr_names); end

  # Validates whether the value of the specified attributes are unique
  # across the system. Useful for making sure that only one user
  # can be named "davidhh".
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name
  #   end
  #
  # It can also validate whether the value of the specified attributes are
  # unique based on a <tt>:scope</tt> parameter:
  #
  #   class Person < ActiveRecord::Base
  #     validates_uniqueness_of :user_name, scope: :account_id
  #   end
  #
  # Or even multiple scope parameters. For example, making sure that a
  # teacher can only be on the schedule once per semester for a particular
  # class.
  #
  #   class TeacherSchedule < ActiveRecord::Base
  #     validates_uniqueness_of :teacher_id, scope: [:semester_id, :class_id]
  #   end
  #
  # It is also possible to limit the uniqueness constraint to a set of
  # records matching certain conditions. In this example archived articles
  # are not being taken into consideration when validating uniqueness
  # of the title attribute:
  #
  #   class Article < ActiveRecord::Base
  #     validates_uniqueness_of :title, conditions: -> { where.not(status: 'archived') }
  #   end
  #
  # To build conditions based on the record's state, define the conditions
  # callable with a parameter, which will be the record itself. This
  # example validates the title is unique for the year of publication:
  #
  #   class Article < ActiveRecord::Base
  #     validates_uniqueness_of :title, conditions: ->(article) {
  #       published_at = article.published_at
  #       where(published_at: published_at.beginning_of_year..published_at.end_of_year)
  #     }
  #   end
  #
  # When the record is created, a check is performed to make sure that no
  # record exists in the database with the given value for the specified
  # attribute (that maps to a column). When the record is updated,
  # the same check is made but disregarding the record itself.
  #
  # Configuration options:
  #
  # * <tt>:message</tt> - Specifies a custom error message (default is:
  #   "has already been taken").
  # * <tt>:scope</tt> - One or more columns by which to limit the scope of
  #   the uniqueness constraint.
  # * <tt>:conditions</tt> - Specify the conditions to be included as a
  #   <tt>WHERE</tt> SQL fragment to limit the uniqueness constraint lookup
  #   (e.g. <tt>conditions: -> { where(status: 'active') }</tt>).
  # * <tt>:case_sensitive</tt> - Looks for an exact match. Ignored by
  #   non-text columns. The default behavior respects the default database collation.
  # * <tt>:allow_nil</tt> - If set to +true+, skips this validation if the
  #   attribute is +nil+ (default is +false+).
  # * <tt>:allow_blank</tt> - If set to +true+, skips this validation if the
  #   attribute is blank (default is +false+).
  # * <tt>:if</tt> - Specifies a method, proc, or string to call to determine
  #   if the validation should occur (e.g. <tt>if: :allow_validation</tt>,
  #   or <tt>if: Proc.new { |user| user.signup_step > 2 }</tt>). The method,
  #   proc or string should return or evaluate to a +true+ or +false+ value.
  # * <tt>:unless</tt> - Specifies a method, proc, or string to call to
  #   determine if the validation should not occur (e.g. <tt>unless: :skip_validation</tt>,
  #   or <tt>unless: Proc.new { |user| user.signup_step <= 2 }</tt>). The
  #   method, proc, or string should return or evaluate to a +true+ or +false+
  #   value.
  #
  # === Concurrency and integrity
  #
  # Using this validation method in conjunction with
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save]
  # does not guarantee the absence of duplicate record insertions, because
  # uniqueness checks on the application level are inherently prone to race
  # conditions. For example, suppose that two users try to post a Comment at
  # the same time, and a Comment's title must be unique. At the database-level,
  # the actions performed by these users could be interleaved in the following manner:
  #
  #               User 1                 |               User 2
  #  ------------------------------------+--------------------------------------
  #  # User 1 checks whether there's     |
  #  # already a comment with the title  |
  #  # 'My Post'. This is not the case.  |
  #  SELECT * FROM comments              |
  #  WHERE title = 'My Post'             |
  #                                      |
  #                                      | # User 2 does the same thing and also
  #                                      | # infers that their title is unique.
  #                                      | SELECT * FROM comments
  #                                      | WHERE title = 'My Post'
  #                                      |
  #  # User 1 inserts their comment.     |
  #  INSERT INTO comments                |
  #  (title, content) VALUES             |
  #  ('My Post', 'hi!')                  |
  #                                      |
  #                                      | # User 2 does the same thing.
  #                                      | INSERT INTO comments
  #                                      | (title, content) VALUES
  #                                      | ('My Post', 'hello!')
  #                                      |
  #                                      | # ^^^^^^
  #                                      | # Boom! We now have a duplicate
  #                                      | # title!
  #
  # The best way to work around this problem is to add a unique index to the database table using
  # {connection.add_index}[rdoc-ref:ConnectionAdapters::SchemaStatements#add_index].
  # In the rare case that a race condition occurs, the database will guarantee
  # the field's uniqueness.
  #
  # When the database catches such a duplicate insertion,
  # {ActiveRecord::Base#save}[rdoc-ref:Persistence#save] will raise an ActiveRecord::StatementInvalid
  # exception. You can either choose to let this error propagate (which
  # will result in the default \Rails exception page being shown), or you
  # can catch it and restart the transaction (e.g. by telling the user
  # that the title already exists, and asking them to re-enter the title).
  # This technique is also known as
  # {optimistic concurrency control}[https://en.wikipedia.org/wiki/Optimistic_concurrency_control].
  #
  # The bundled ActiveRecord::ConnectionAdapters distinguish unique index
  # constraint errors from other types of database errors by throwing an
  # ActiveRecord::RecordNotUnique exception. For other adapters you will
  # have to parse the (database-specific) exception message to detect such
  # a case.
  #
  # The following bundled adapters throw the ActiveRecord::RecordNotUnique exception:
  #
  # * ActiveRecord::ConnectionAdapters::Mysql2Adapter.
  # * ActiveRecord::ConnectionAdapters::TrilogyAdapter.
  # * ActiveRecord::ConnectionAdapters::SQLite3Adapter.
  # * ActiveRecord::ConnectionAdapters::PostgreSQLAdapter.
  #
  # source://activerecord//lib/active_record/validations/uniqueness.rb#286
  def validates_uniqueness_of(*attr_names); end
end

# source://activerecord//lib/active_record/validations/length.rb#5
class ActiveRecord::Validations::LengthValidator < ::ActiveModel::Validations::LengthValidator
  # source://activerecord//lib/active_record/validations/length.rb#6
  def validate_each(record, attribute, association_or_value); end
end

# source://activerecord//lib/active_record/validations/numericality.rb#5
class ActiveRecord::Validations::NumericalityValidator < ::ActiveModel::Validations::NumericalityValidator
  # source://activerecord//lib/active_record/validations/numericality.rb#6
  def validate_each(record, attribute, value, precision: T.unsafe(nil), scale: T.unsafe(nil)); end

  private

  # source://activerecord//lib/active_record/validations/numericality.rb#13
  def column_precision_for(record, attribute); end

  # source://activerecord//lib/active_record/validations/numericality.rb#17
  def column_scale_for(record, attribute); end
end

# source://activerecord//lib/active_record/validations/presence.rb#5
class ActiveRecord::Validations::PresenceValidator < ::ActiveModel::Validations::PresenceValidator
  # source://activerecord//lib/active_record/validations/presence.rb#6
  def validate_each(record, attribute, association_or_value); end
end

# source://activerecord//lib/active_record/validations/uniqueness.rb#5
class ActiveRecord::Validations::UniquenessValidator < ::ActiveModel::EachValidator
  # @return [UniquenessValidator] a new instance of UniquenessValidator
  #
  # source://activerecord//lib/active_record/validations/uniqueness.rb#6
  def initialize(options); end

  # source://activerecord//lib/active_record/validations/uniqueness.rb#19
  def validate_each(record, attribute, value); end

  private

  # source://activerecord//lib/active_record/validations/uniqueness.rb#111
  def build_relation(klass, attribute, value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/validations/uniqueness.rb#82
  def covered_by_unique_index?(klass, record, attribute, scope); end

  # The check for an existing value should be run from a class that
  # isn't abstract. This means working down from the current class
  # (self), to the first non-abstract class. Since classes don't know
  # their subclasses, we have to build the hierarchy between self and
  # the record's class.
  #
  # source://activerecord//lib/active_record/validations/uniqueness.rb#59
  def find_finder_class_for(record); end

  # source://activerecord//lib/active_record/validations/uniqueness.rb#142
  def map_enum_attribute(klass, attribute, value); end

  # source://activerecord//lib/active_record/validations/uniqueness.rb#97
  def resolve_attributes(record, attributes); end

  # source://activerecord//lib/active_record/validations/uniqueness.rb#129
  def scope_relation(record, relation); end

  # @return [Boolean]
  #
  # source://activerecord//lib/active_record/validations/uniqueness.rb#69
  def validation_needed?(klass, record, attribute); end
end

# Raised when a record cannot be inserted or updated because a value too long for a column type.
#
# source://activerecord//lib/active_record/errors.rb#276
class ActiveRecord::ValueTooLong < ::ActiveRecord::StatementInvalid; end

# Defunct wrapper class kept for compatibility.
# StatementInvalid wraps the original exception now.
#
# source://activerecord//lib/active_record/errors.rb#204
class ActiveRecord::WrappedDatabaseException < ::ActiveRecord::StatementInvalid; end

# source://activerecord//lib/arel/errors.rb#3
module Arel
  class << self
    # @return [Boolean]
    #
    # source://activerecord//lib/arel.rb#60
    def arel_node?(value); end

    # source://activerecord//lib/arel.rb#64
    def fetch_attribute(value, &block); end

    # Wrap a known-safe SQL string for passing to query methods, e.g.
    #
    #   Post.order(Arel.sql("REPLACE(title, 'misc', 'zzzz') asc")).pluck(:id)
    #
    # Great caution should be taken to avoid SQL injection vulnerabilities.
    # This method should not be used with unsafe values such as request
    # parameters or model attributes.
    #
    # Take a look at the {security guide}[https://guides.rubyonrails.org/security.html#sql-injection]
    # for more information.
    #
    # To construct a more complex query fragment, including the possible
    # use of user-provided values, the +sql_string+ may contain <tt>?</tt> and
    # +:key+ placeholders, corresponding to the additional arguments. Note
    # that this behavior only applies when bind value parameters are
    # supplied in the call; without them, the placeholder tokens have no
    # special meaning, and will be passed through to the query as-is.
    #
    # source://activerecord//lib/arel.rb#48
    def sql(sql_string, *positional_binds, **named_binds); end

    # source://activerecord//lib/arel.rb#56
    def star; end
  end
end

# source://activerecord//lib/arel/alias_predication.rb#4
module Arel::AliasPredication
  # source://activerecord//lib/arel/alias_predication.rb#5
  def as(other); end
end

# source://activerecord//lib/arel/errors.rb#4
class Arel::ArelError < ::StandardError; end

# source://activerecord//lib/arel/attributes/attribute.rb#32
Arel::Attribute = Arel::Attributes::Attribute

# source://activerecord//lib/arel/attributes/attribute.rb#4
module Arel::Attributes; end

# source://activerecord//lib/arel/attributes/attribute.rb#5
class Arel::Attributes::Attribute < ::Struct
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/attributes/attribute.rb#26
  def able_to_type_cast?; end

  # Create a node for lowering this attribute
  #
  # source://activerecord//lib/arel/attributes/attribute.rb#18
  def lower; end

  # source://activerecord//lib/arel/attributes/attribute.rb#22
  def type_cast_for_database(value); end

  # source://activerecord//lib/arel/attributes/attribute.rb#12
  def type_caster; end
end

# source://activerecord//lib/arel/errors.rb#10
class Arel::BindError < ::Arel::ArelError
  # @return [BindError] a new instance of BindError
  #
  # source://activerecord//lib/arel/errors.rb#11
  def initialize(message, sql = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/collectors/plain_string.rb#4
module Arel::Collectors; end

# source://activerecord//lib/arel/collectors/bind.rb#5
class Arel::Collectors::Bind
  # @return [Bind] a new instance of Bind
  #
  # source://activerecord//lib/arel/collectors/bind.rb#6
  def initialize; end

  # source://activerecord//lib/arel/collectors/bind.rb#10
  def <<(str); end

  # source://activerecord//lib/arel/collectors/bind.rb#14
  def add_bind(bind); end

  # source://activerecord//lib/arel/collectors/bind.rb#19
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end

  # source://activerecord//lib/arel/collectors/bind.rb#24
  def value; end
end

# source://activerecord//lib/arel/collectors/composite.rb#5
class Arel::Collectors::Composite
  # @return [Composite] a new instance of Composite
  #
  # source://activerecord//lib/arel/collectors/composite.rb#8
  def initialize(left, right); end

  # source://activerecord//lib/arel/collectors/composite.rb#13
  def <<(str); end

  # source://activerecord//lib/arel/collectors/composite.rb#19
  def add_bind(bind, &block); end

  # source://activerecord//lib/arel/collectors/composite.rb#25
  def add_binds(binds, proc_for_binds = T.unsafe(nil), &block); end

  # Returns the value of attribute preparable.
  #
  # source://activerecord//lib/arel/collectors/composite.rb#6
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  #
  # source://activerecord//lib/arel/collectors/composite.rb#6
  def preparable=(_arg0); end

  # source://activerecord//lib/arel/collectors/composite.rb#31
  def value; end

  private

  # Returns the value of attribute left.
  #
  # source://activerecord//lib/arel/collectors/composite.rb#36
  def left; end

  # Returns the value of attribute right.
  #
  # source://activerecord//lib/arel/collectors/composite.rb#36
  def right; end
end

# source://activerecord//lib/arel/collectors/plain_string.rb#5
class Arel::Collectors::PlainString
  # @return [PlainString] a new instance of PlainString
  #
  # source://activerecord//lib/arel/collectors/plain_string.rb#6
  def initialize; end

  # source://activerecord//lib/arel/collectors/plain_string.rb#14
  def <<(str); end

  # source://activerecord//lib/arel/collectors/plain_string.rb#10
  def value; end
end

# source://activerecord//lib/arel/collectors/sql_string.rb#7
class Arel::Collectors::SQLString < ::Arel::Collectors::PlainString
  # @return [SQLString] a new instance of SQLString
  #
  # source://activerecord//lib/arel/collectors/sql_string.rb#10
  def initialize(*_arg0); end

  # source://activerecord//lib/arel/collectors/sql_string.rb#15
  def add_bind(bind); end

  # source://activerecord//lib/arel/collectors/sql_string.rb#21
  def add_binds(binds, proc_for_binds = T.unsafe(nil), &block); end

  # Returns the value of attribute preparable.
  #
  # source://activerecord//lib/arel/collectors/sql_string.rb#8
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  #
  # source://activerecord//lib/arel/collectors/sql_string.rb#8
  def preparable=(_arg0); end
end

# source://activerecord//lib/arel/collectors/substitute_binds.rb#5
class Arel::Collectors::SubstituteBinds
  # @return [SubstituteBinds] a new instance of SubstituteBinds
  #
  # source://activerecord//lib/arel/collectors/substitute_binds.rb#8
  def initialize(quoter, delegate_collector); end

  # source://activerecord//lib/arel/collectors/substitute_binds.rb#13
  def <<(str); end

  # source://activerecord//lib/arel/collectors/substitute_binds.rb#18
  def add_bind(bind); end

  # source://activerecord//lib/arel/collectors/substitute_binds.rb#23
  def add_binds(binds, proc_for_binds = T.unsafe(nil)); end

  # Returns the value of attribute preparable.
  #
  # source://activerecord//lib/arel/collectors/substitute_binds.rb#6
  def preparable; end

  # Sets the attribute preparable
  #
  # @param value the value to set the attribute preparable to.
  #
  # source://activerecord//lib/arel/collectors/substitute_binds.rb#6
  def preparable=(_arg0); end

  # source://activerecord//lib/arel/collectors/substitute_binds.rb#27
  def value; end

  private

  # Returns the value of attribute delegate.
  #
  # source://activerecord//lib/arel/collectors/substitute_binds.rb#32
  def delegate; end

  # Returns the value of attribute quoter.
  #
  # source://activerecord//lib/arel/collectors/substitute_binds.rb#32
  def quoter; end
end

# FIXME hopefully we can remove this
#
# source://activerecord//lib/arel/crud.rb#6
module Arel::Crud
  # source://activerecord//lib/arel/crud.rb#36
  def compile_delete(key = T.unsafe(nil), having_clause = T.unsafe(nil), group_values_columns = T.unsafe(nil)); end

  # source://activerecord//lib/arel/crud.rb#7
  def compile_insert(values); end

  # source://activerecord//lib/arel/crud.rb#17
  def compile_update(values, key = T.unsafe(nil), having_clause = T.unsafe(nil), group_values_columns = T.unsafe(nil)); end

  # source://activerecord//lib/arel/crud.rb#13
  def create_insert; end
end

# source://activerecord//lib/arel/delete_manager.rb#4
class Arel::DeleteManager < ::Arel::TreeManager
  include ::Arel::TreeManager::StatementMethods

  # @return [DeleteManager] a new instance of DeleteManager
  #
  # source://activerecord//lib/arel/delete_manager.rb#7
  def initialize(table = T.unsafe(nil)); end

  # source://activerecord//lib/arel/delete_manager.rb#11
  def from(relation); end

  # source://activerecord//lib/arel/delete_manager.rb#16
  def group(columns); end

  # source://activerecord//lib/arel/delete_manager.rb#27
  def having(expr); end
end

# source://activerecord//lib/arel/errors.rb#7
class Arel::EmptyJoinError < ::Arel::ArelError; end

# source://activerecord//lib/arel/expressions.rb#4
module Arel::Expressions
  # source://activerecord//lib/arel/expressions.rb#21
  def average; end

  # source://activerecord//lib/arel/expressions.rb#5
  def count(distinct = T.unsafe(nil)); end

  # source://activerecord//lib/arel/expressions.rb#25
  def extract(field); end

  # source://activerecord//lib/arel/expressions.rb#13
  def maximum; end

  # source://activerecord//lib/arel/expressions.rb#17
  def minimum; end

  # source://activerecord//lib/arel/expressions.rb#9
  def sum; end
end

# Methods for creating various nodes
#
# source://activerecord//lib/arel/factory_methods.rb#6
module Arel::FactoryMethods
  # source://activerecord//lib/arel/factory_methods.rb#49
  def cast(name, type); end

  # source://activerecord//lib/arel/factory_methods.rb#45
  def coalesce(*exprs); end

  # source://activerecord//lib/arel/factory_methods.rb#27
  def create_and(clauses); end

  # source://activerecord//lib/arel/factory_methods.rb#11
  def create_false; end

  # source://activerecord//lib/arel/factory_methods.rb#19
  def create_join(to, constraint = T.unsafe(nil), klass = T.unsafe(nil)); end

  # source://activerecord//lib/arel/factory_methods.rb#31
  def create_on(expr); end

  # source://activerecord//lib/arel/factory_methods.rb#23
  def create_string_join(to); end

  # source://activerecord//lib/arel/factory_methods.rb#15
  def create_table_alias(relation, name); end

  # source://activerecord//lib/arel/factory_methods.rb#7
  def create_true; end

  # source://activerecord//lib/arel/factory_methods.rb#35
  def grouping(expr); end

  # Create a LOWER() function
  #
  # source://activerecord//lib/arel/factory_methods.rb#41
  def lower(column); end
end

# source://activerecord//lib/arel/filter_predications.rb#4
module Arel::FilterPredications
  # source://activerecord//lib/arel/filter_predications.rb#5
  def filter(expr); end
end

# source://activerecord//lib/arel/insert_manager.rb#4
class Arel::InsertManager < ::Arel::TreeManager
  # @return [InsertManager] a new instance of InsertManager
  #
  # source://activerecord//lib/arel/insert_manager.rb#5
  def initialize(table = T.unsafe(nil)); end

  # source://activerecord//lib/arel/insert_manager.rb#14
  def columns; end

  # source://activerecord//lib/arel/insert_manager.rb#40
  def create_values(values); end

  # source://activerecord//lib/arel/insert_manager.rb#44
  def create_values_list(rows); end

  # source://activerecord//lib/arel/insert_manager.rb#21
  def insert(fields); end

  # source://activerecord//lib/arel/insert_manager.rb#9
  def into(table); end

  # source://activerecord//lib/arel/insert_manager.rb#17
  def select(select); end

  # source://activerecord//lib/arel/insert_manager.rb#15
  def values=(val); end
end

# source://activerecord//lib/arel/math.rb#4
module Arel::Math
  # source://activerecord//lib/arel/math.rb#21
  def &(other); end

  # source://activerecord//lib/arel/math.rb#5
  def *(other); end

  # source://activerecord//lib/arel/math.rb#9
  def +(other); end

  # source://activerecord//lib/arel/math.rb#13
  def -(other); end

  # source://activerecord//lib/arel/math.rb#17
  def /(other); end

  # source://activerecord//lib/arel/math.rb#33
  def <<(other); end

  # source://activerecord//lib/arel/math.rb#37
  def >>(other); end

  # source://activerecord//lib/arel/math.rb#29
  def ^(other); end

  # source://activerecord//lib/arel/math.rb#25
  def |(other); end

  # source://activerecord//lib/arel/math.rb#41
  def ~; end
end

# source://activerecord//lib/arel/nodes/node.rb#4
module Arel::Nodes
  class << self
    # source://activerecord//lib/arel/nodes/casted.rb#48
    def build_quoted(other, attribute = T.unsafe(nil)); end
  end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#32
class Arel::Nodes::Addition < ::Arel::Nodes::InfixOperation
  # @return [Addition] a new instance of Addition
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#33
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/and.rb#5
class Arel::Nodes::And < ::Arel::Nodes::NodeExpression
  # @return [And] a new instance of And
  #
  # source://activerecord//lib/arel/nodes/and.rb#8
  def initialize(children); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/and.rb#29
  def ==(other); end

  # Returns the value of attribute children.
  #
  # source://activerecord//lib/arel/nodes/and.rb#6
  def children; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/and.rb#29
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/and.rb#21
  def fetch_attribute(&block); end

  # source://activerecord//lib/arel/nodes/and.rb#25
  def hash; end

  # source://activerecord//lib/arel/nodes/and.rb#13
  def left; end

  # source://activerecord//lib/arel/nodes/and.rb#17
  def right; end
end

# source://activerecord//lib/arel/nodes/binary.rb#42
class Arel::Nodes::As < ::Arel::Nodes::Binary
  # source://activerecord//lib/arel/nodes/binary.rb#43
  def to_cte; end
end

# source://activerecord//lib/arel/nodes/ascending.rb#5
class Arel::Nodes::Ascending < ::Arel::Nodes::Ordering
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/ascending.rb#14
  def ascending?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/ascending.rb#18
  def descending?; end

  # source://activerecord//lib/arel/nodes/ascending.rb#10
  def direction; end

  # source://activerecord//lib/arel/nodes/ascending.rb#6
  def reverse; end
end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::Assignment < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/function.rb#42
class Arel::Nodes::Avg < ::Arel::Nodes::Function; end

# source://activerecord//lib/arel/nodes/binary.rb#48
class Arel::Nodes::Between < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Bin < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/binary.rb#5
class Arel::Nodes::Binary < ::Arel::Nodes::NodeExpression
  # @return [Binary] a new instance of Binary
  #
  # source://activerecord//lib/arel/nodes/binary.rb#8
  def initialize(left, right); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/binary.rb#24
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/binary.rb#24
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/binary.rb#20
  def hash; end

  # Returns the value of attribute left.
  #
  # source://activerecord//lib/arel/nodes/binary.rb#6
  def left; end

  # Sets the attribute left
  #
  # @param value the value to set the attribute left to.
  #
  # source://activerecord//lib/arel/nodes/binary.rb#6
  def left=(_arg0); end

  # Returns the value of attribute right.
  #
  # source://activerecord//lib/arel/nodes/binary.rb#6
  def right; end

  # Sets the attribute right
  #
  # @param value the value to set the attribute right to.
  #
  # source://activerecord//lib/arel/nodes/binary.rb#6
  def right=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/binary.rb#14
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/bind_param.rb#5
class Arel::Nodes::BindParam < ::Arel::Nodes::Node
  # @return [BindParam] a new instance of BindParam
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#8
  def initialize(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#17
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#17
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/bind_param.rb#13
  def hash; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#35
  def infinite?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#23
  def nil?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#39
  def unboundable?; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/arel/nodes/bind_param.rb#6
  def value; end

  # source://activerecord//lib/arel/nodes/bind_param.rb#27
  def value_before_type_cast; end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#62
class Arel::Nodes::BitwiseAnd < ::Arel::Nodes::InfixOperation
  # @return [BitwiseAnd] a new instance of BitwiseAnd
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#63
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/unary_operation.rb#14
class Arel::Nodes::BitwiseNot < ::Arel::Nodes::UnaryOperation
  # @return [BitwiseNot] a new instance of BitwiseNot
  #
  # source://activerecord//lib/arel/nodes/unary_operation.rb#15
  def initialize(operand); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#68
class Arel::Nodes::BitwiseOr < ::Arel::Nodes::InfixOperation
  # @return [BitwiseOr] a new instance of BitwiseOr
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#69
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#80
class Arel::Nodes::BitwiseShiftLeft < ::Arel::Nodes::InfixOperation
  # @return [BitwiseShiftLeft] a new instance of BitwiseShiftLeft
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#81
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#86
class Arel::Nodes::BitwiseShiftRight < ::Arel::Nodes::InfixOperation
  # @return [BitwiseShiftRight] a new instance of BitwiseShiftRight
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#87
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#74
class Arel::Nodes::BitwiseXor < ::Arel::Nodes::InfixOperation
  # @return [BitwiseXor] a new instance of BitwiseXor
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#75
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/bound_sql_literal.rb#5
class Arel::Nodes::BoundSqlLiteral < ::Arel::Nodes::NodeExpression
  # @return [BoundSqlLiteral] a new instance of BoundSqlLiteral
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#8
  def initialize(sql_with_placeholders, positional_binds, named_binds); end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#50
  def +(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#42
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#42
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#38
  def hash; end

  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#56
  def inspect; end

  # Returns the value of attribute named_binds.
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#6
  def named_binds; end

  # Returns the value of attribute positional_binds.
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#6
  def positional_binds; end

  # Returns the value of attribute sql_with_placeholders.
  #
  # source://activerecord//lib/arel/nodes/bound_sql_literal.rb#6
  def sql_with_placeholders; end
end

# source://activerecord//lib/arel/nodes/case.rb#5
class Arel::Nodes::Case < ::Arel::Nodes::NodeExpression
  # @return [Case] a new instance of Case
  #
  # source://activerecord//lib/arel/nodes/case.rb#8
  def initialize(expression = T.unsafe(nil), default = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/case.rb#40
  def ==(other); end

  # Returns the value of attribute case.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def case; end

  # Sets the attribute case
  #
  # @param value the value to set the attribute case to.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def case=(_arg0); end

  # Returns the value of attribute conditions.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def conditions; end

  # Sets the attribute conditions
  #
  # @param value the value to set the attribute conditions to.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def conditions=(_arg0); end

  # Returns the value of attribute default.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def default; end

  # Sets the attribute default
  #
  # @param value the value to set the attribute default to.
  #
  # source://activerecord//lib/arel/nodes/case.rb#6
  def default=(_arg0); end

  # source://activerecord//lib/arel/nodes/case.rb#24
  def else(expression); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/case.rb#40
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/case.rb#36
  def hash; end

  # source://activerecord//lib/arel/nodes/case.rb#19
  def then(expression); end

  # source://activerecord//lib/arel/nodes/case.rb#14
  def when(condition, expression = T.unsafe(nil)); end

  private

  # source://activerecord//lib/arel/nodes/case.rb#29
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/casted.rb#5
class Arel::Nodes::Casted < ::Arel::Nodes::NodeExpression
  # @return [Casted] a new instance of Casted
  #
  # source://activerecord//lib/arel/nodes/casted.rb#9
  def initialize(value, attribute); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/casted.rb#29
  def ==(other); end

  # Returns the value of attribute attribute.
  #
  # source://activerecord//lib/arel/nodes/casted.rb#6
  def attribute; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/casted.rb#29
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/casted.rb#25
  def hash; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/casted.rb#15
  def nil?; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/arel/nodes/casted.rb#6
  def value; end

  # Returns the value of attribute value.
  #
  # source://activerecord//lib/arel/nodes/casted.rb#6
  def value_before_type_cast; end

  # source://activerecord//lib/arel/nodes/casted.rb#17
  def value_for_database; end
end

# source://activerecord//lib/arel/nodes/comment.rb#5
class Arel::Nodes::Comment < ::Arel::Nodes::Node
  # @return [Comment] a new instance of Comment
  #
  # source://activerecord//lib/arel/nodes/comment.rb#8
  def initialize(values); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/comment.rb#22
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/comment.rb#22
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/comment.rb#18
  def hash; end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/arel/nodes/comment.rb#6
  def values; end

  private

  # source://activerecord//lib/arel/nodes/comment.rb#13
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#44
class Arel::Nodes::Concat < ::Arel::Nodes::InfixOperation
  # @return [Concat] a new instance of Concat
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#45
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#50
class Arel::Nodes::Contains < ::Arel::Nodes::InfixOperation
  # @return [Contains] a new instance of Contains
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#51
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/count.rb#5
class Arel::Nodes::Count < ::Arel::Nodes::Function
  # @return [Count] a new instance of Count
  #
  # source://activerecord//lib/arel/nodes/count.rb#6
  def initialize(expr, distinct = T.unsafe(nil), aliaz = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/cte.rb#5
class Arel::Nodes::Cte < ::Arel::Nodes::Binary
  # @return [Cte] a new instance of Cte
  #
  # source://activerecord//lib/arel/nodes/cte.rb#10
  def initialize(name, relation, materialized: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/cte.rb#19
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/cte.rb#19
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/cte.rb#15
  def hash; end

  # Returns the value of attribute materialized.
  #
  # source://activerecord//lib/arel/nodes/cte.rb#8
  def materialized; end

  # source://activerecord//lib/arel/nodes/binary.rb#6
  def name; end

  # source://activerecord//lib/arel/nodes/binary.rb#6
  def relation; end

  # source://activerecord//lib/arel/nodes/cte.rb#27
  def to_cte; end

  # source://activerecord//lib/arel/nodes/cte.rb#31
  def to_table; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Cube < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/window.rb#103
class Arel::Nodes::CurrentRow < ::Arel::Nodes::Node
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#108
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#108
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/window.rb#104
  def hash; end
end

# source://activerecord//lib/arel/nodes/delete_statement.rb#5
class Arel::Nodes::DeleteStatement < ::Arel::Nodes::Node
  # @return [DeleteStatement] a new instance of DeleteStatement
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#8
  def initialize(relation = T.unsafe(nil), wheres = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#30
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#30
  def eql?(other); end

  # Returns the value of attribute groups.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def groups; end

  # Sets the attribute groups
  #
  # @param value the value to set the attribute groups to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def groups=(_arg0); end

  # source://activerecord//lib/arel/nodes/delete_statement.rb#26
  def hash; end

  # Returns the value of attribute havings.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def havings; end

  # Sets the attribute havings
  #
  # @param value the value to set the attribute havings to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def havings=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def key=(_arg0); end

  # Returns the value of attribute limit.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def limit=(_arg0); end

  # Returns the value of attribute offset.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def orders=(_arg0); end

  # Returns the value of attribute relation.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def relation; end

  # Sets the attribute relation
  #
  # @param value the value to set the attribute relation to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def relation=(_arg0); end

  # Returns the value of attribute wheres.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def wheres; end

  # Sets the attribute wheres
  #
  # @param value the value to set the attribute wheres to.
  #
  # source://activerecord//lib/arel/nodes/delete_statement.rb#6
  def wheres=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/delete_statement.rb#20
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/descending.rb#5
class Arel::Nodes::Descending < ::Arel::Nodes::Ordering
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/descending.rb#14
  def ascending?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/descending.rb#18
  def descending?; end

  # source://activerecord//lib/arel/nodes/descending.rb#10
  def direction; end

  # source://activerecord//lib/arel/nodes/descending.rb#6
  def reverse; end
end

# source://activerecord//lib/arel/nodes/terminal.rb#5
class Arel::Nodes::Distinct < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/terminal.rb#10
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/terminal.rb#10
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/terminal.rb#6
  def hash; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::DistinctOn < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/infix_operation.rb#26
class Arel::Nodes::Division < ::Arel::Nodes::InfixOperation
  # @return [Division] a new instance of Division
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#27
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/matches.rb#16
class Arel::Nodes::DoesNotMatch < ::Arel::Nodes::Matches; end

# source://activerecord//lib/arel/nodes/case.rb#52
class Arel::Nodes::Else < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/equality.rb#5
class Arel::Nodes::Equality < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/equality.rb#8
  def equality?; end

  # source://activerecord//lib/arel/nodes/equality.rb#10
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::Except < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/function.rb#42
class Arel::Nodes::Exists < ::Arel::Nodes::Function; end

# source://activerecord//lib/arel/nodes/extract.rb#5
class Arel::Nodes::Extract < ::Arel::Nodes::Unary
  # @return [Extract] a new instance of Extract
  #
  # source://activerecord//lib/arel/nodes/extract.rb#8
  def initialize(expr, field); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/extract.rb#17
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/extract.rb#17
  def eql?(other); end

  # Returns the value of attribute field.
  #
  # source://activerecord//lib/arel/nodes/extract.rb#6
  def field; end

  # Sets the attribute field
  #
  # @param value the value to set the attribute field to.
  #
  # source://activerecord//lib/arel/nodes/extract.rb#6
  def field=(_arg0); end

  # source://activerecord//lib/arel/nodes/extract.rb#13
  def hash; end
end

# source://activerecord//lib/arel/nodes/false.rb#5
class Arel::Nodes::False < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/false.rb#10
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/false.rb#10
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/false.rb#6
  def hash; end
end

# source://activerecord//lib/arel/nodes/binary.rb#32
module Arel::Nodes::FetchAttribute
  # source://activerecord//lib/arel/nodes/binary.rb#33
  def fetch_attribute; end
end

# source://activerecord//lib/arel/nodes/filter.rb#5
class Arel::Nodes::Filter < ::Arel::Nodes::Binary
  include ::Arel::WindowPredications
end

# source://activerecord//lib/arel/nodes/window.rb#120
class Arel::Nodes::Following < ::Arel::Nodes::Unary
  # @return [Following] a new instance of Following
  #
  # source://activerecord//lib/arel/nodes/window.rb#121
  def initialize(expr = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/fragments.rb#5
class Arel::Nodes::Fragments < ::Arel::Nodes::Node
  # @return [Fragments] a new instance of Fragments
  #
  # source://activerecord//lib/arel/nodes/fragments.rb#8
  def initialize(values = T.unsafe(nil)); end

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/arel/nodes/fragments.rb#22
  def +(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/fragments.rb#28
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/fragments.rb#28
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/fragments.rb#18
  def hash; end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/arel/nodes/fragments.rb#6
  def values; end

  private

  # source://activerecord//lib/arel/nodes/fragments.rb#13
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/full_outer_join.rb#5
class Arel::Nodes::FullOuterJoin < ::Arel::Nodes::Join; end

# source://activerecord//lib/arel/nodes/function.rb#5
class Arel::Nodes::Function < ::Arel::Nodes::NodeExpression
  include ::Arel::WindowPredications
  include ::Arel::FilterPredications

  # @return [Function] a new instance of Function
  #
  # source://activerecord//lib/arel/nodes/function.rb#10
  def initialize(expr, aliaz = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/function.rb#26
  def ==(other); end

  # Returns the value of attribute alias.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def alias; end

  # Sets the attribute alias
  #
  # @param value the value to set the attribute alias to.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def alias=(_arg0); end

  # source://activerecord//lib/arel/nodes/function.rb#17
  def as(aliaz); end

  # Returns the value of attribute distinct.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def distinct; end

  # Sets the attribute distinct
  #
  # @param value the value to set the attribute distinct to.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def distinct=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/function.rb#26
  def eql?(other); end

  # Returns the value of attribute expressions.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def expressions; end

  # Sets the attribute expressions
  #
  # @param value the value to set the attribute expressions to.
  #
  # source://activerecord//lib/arel/nodes/function.rb#8
  def expressions=(_arg0); end

  # source://activerecord//lib/arel/nodes/function.rb#22
  def hash; end
end

# source://activerecord//lib/arel/nodes/binary.rb#50
class Arel::Nodes::GreaterThan < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#53
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#58
class Arel::Nodes::GreaterThanOrEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#61
  def invert; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Group < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/grouping.rb#5
class Arel::Nodes::Grouping < ::Arel::Nodes::Unary
  # source://activerecord//lib/arel/nodes/grouping.rb#6
  def fetch_attribute(&block); end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::GroupingElement < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::GroupingSet < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/homogeneous_in.rb#5
class Arel::Nodes::HomogeneousIn < ::Arel::Nodes::Node
  # @return [HomogeneousIn] a new instance of HomogeneousIn
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#8
  def initialize(values, attribute, type); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#18
  def ==(other); end

  # Returns the value of attribute attribute.
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#6
  def attribute; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#39
  def casted_values; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#18
  def eql?(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#23
  def equality?; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#54
  def fetch_attribute(&block); end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#14
  def hash; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#27
  def invert; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#31
  def left; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#50
  def proc_for_binds; end

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#35
  def right; end

  # Returns the value of attribute type.
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#6
  def type; end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#6
  def values; end

  protected

  # source://activerecord//lib/arel/nodes/homogeneous_in.rb#63
  def ivars; end
end

# source://activerecord//lib/arel/nodes/in.rb#5
class Arel::Nodes::In < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/in.rb#8
  def equality?; end

  # source://activerecord//lib/arel/nodes/in.rb#10
  def invert; end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#5
class Arel::Nodes::InfixOperation < ::Arel::Nodes::Binary
  # @return [InfixOperation] a new instance of InfixOperation
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#14
  def initialize(operator, left, right); end

  # Returns the value of attribute operator.
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#12
  def operator; end
end

# source://activerecord//lib/arel/nodes/inner_join.rb#5
class Arel::Nodes::InnerJoin < ::Arel::Nodes::Join; end

# source://activerecord//lib/arel/nodes/insert_statement.rb#5
class Arel::Nodes::InsertStatement < ::Arel::Nodes::Node
  # @return [InsertStatement] a new instance of InsertStatement
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#8
  def initialize(relation = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#27
  def ==(other); end

  # Returns the value of attribute columns.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def columns; end

  # Sets the attribute columns
  #
  # @param value the value to set the attribute columns to.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def columns=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#27
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/insert_statement.rb#23
  def hash; end

  # Returns the value of attribute relation.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def relation; end

  # Sets the attribute relation
  #
  # @param value the value to set the attribute relation to.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def relation=(_arg0); end

  # Returns the value of attribute select.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def select; end

  # Sets the attribute select
  #
  # @param value the value to set the attribute select to.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def select=(_arg0); end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  #
  # source://activerecord//lib/arel/nodes/insert_statement.rb#6
  def values=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/insert_statement.rb#16
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::Intersect < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/binary.rb#82
class Arel::Nodes::IsDistinctFrom < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#85
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#90
class Arel::Nodes::IsNotDistinctFrom < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#93
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::Join < ::Arel::Nodes::Binary; end

# Class that represents a join source
#
#   https://www.sqlite.org/syntaxdiagrams.html#join-source
#
# source://activerecord//lib/arel/nodes/join_source.rb#10
class Arel::Nodes::JoinSource < ::Arel::Nodes::Binary
  # @return [JoinSource] a new instance of JoinSource
  #
  # source://activerecord//lib/arel/nodes/join_source.rb#11
  def initialize(single_source, joinop = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/join_source.rb#15
  def empty?; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Lateral < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/leading_join.rb#5
class Arel::Nodes::LeadingJoin < ::Arel::Nodes::InnerJoin; end

# source://activerecord//lib/arel/nodes/binary.rb#66
class Arel::Nodes::LessThan < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#69
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#74
class Arel::Nodes::LessThanOrEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#77
  def invert; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Limit < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Lock < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/matches.rb#5
class Arel::Nodes::Matches < ::Arel::Nodes::Binary
  # @return [Matches] a new instance of Matches
  #
  # source://activerecord//lib/arel/nodes/matches.rb#9
  def initialize(left, right, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # Returns the value of attribute case_sensitive.
  #
  # source://activerecord//lib/arel/nodes/matches.rb#7
  def case_sensitive; end

  # Sets the attribute case_sensitive
  #
  # @param value the value to set the attribute case_sensitive to.
  #
  # source://activerecord//lib/arel/nodes/matches.rb#7
  def case_sensitive=(_arg0); end

  # Returns the value of attribute escape.
  #
  # source://activerecord//lib/arel/nodes/matches.rb#6
  def escape; end
end

# source://activerecord//lib/arel/nodes/function.rb#42
class Arel::Nodes::Max < ::Arel::Nodes::Function; end

# source://activerecord//lib/arel/nodes/function.rb#42
class Arel::Nodes::Min < ::Arel::Nodes::Function; end

# source://activerecord//lib/arel/nodes/infix_operation.rb#20
class Arel::Nodes::Multiplication < ::Arel::Nodes::InfixOperation
  # @return [Multiplication] a new instance of Multiplication
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#21
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/named_function.rb#5
class Arel::Nodes::NamedFunction < ::Arel::Nodes::Function
  # @return [NamedFunction] a new instance of NamedFunction
  #
  # source://activerecord//lib/arel/nodes/named_function.rb#8
  def initialize(name, expr, aliaz = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/named_function.rb#17
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/named_function.rb#17
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/named_function.rb#13
  def hash; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/arel/nodes/named_function.rb#6
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activerecord//lib/arel/nodes/named_function.rb#6
  def name=(_arg0); end
end

# source://activerecord//lib/arel/nodes/window.rb#68
class Arel::Nodes::NamedWindow < ::Arel::Nodes::Window
  # @return [NamedWindow] a new instance of NamedWindow
  #
  # source://activerecord//lib/arel/nodes/window.rb#71
  def initialize(name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#85
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#85
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/window.rb#81
  def hash; end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/arel/nodes/window.rb#69
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activerecord//lib/arel/nodes/window.rb#69
  def name=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/window.rb#76
  def initialize_copy(other); end
end

# = Using +Arel::Nodes::Node+
#
# Active Record uses Arel to compose SQL statements. Instead of building SQL strings directly, it's building an
# abstract syntax tree (AST) of the statement using various types of Arel::Nodes::Node. Each node represents a
# fragment of a SQL statement.
#
# The intermediate representation allows Arel to compile the statement into the database's specific SQL dialect
# only before sending it without having to care about the nuances of each database when building the statement.
# It also allows easier composition of statements without having to resort to (brittle and unsafe) string manipulation.
#
# == Building constraints
#
# One of the most common use cases of Arel is generating constraints for +SELECT+ statements. To help with that,
# most nodes include a couple of useful factory methods to create subtree structures for common constraints. For
# a full list of those, please refer to Arel::Predications.
#
# The following example creates an equality constraint where the value of the name column on the users table
# matches the value DHH.
#
#   users = Arel::Table.new(:users)
#   constraint = users[:name].eq("DHH")
#
#   # => Arel::Nodes::Equality.new(
#   #      Arel::Attributes::Attribute.new(users, "name"),
#   #      Arel::Nodes::Casted.new(
#   #        "DHH",
#   #        Arel::Attributes::Attribute.new(users, "name")
#   #      )
#   #    )
#
# The resulting SQL fragment will look like this:
#
#   "users"."name" = 'DHH'
#
# The constraint fragments can be used with regular ActiveRecord::Relation objects instead of a Hash. The
# following two examples show two ways of creating the same query.
#
#   User.where(name: 'DHH')
#
#   # SELECT "users".* FROM "users" WHERE "users"."name" = 'DHH'
#
#   users = User.arel_table
#
#   User.where(users[:name].eq('DHH'))
#
#   # SELECT "users".* FROM "users" WHERE "users"."name" = 'DHH'
#
# == Functions
#
# Arel comes with built-in support for SQL functions like +COUNT+, +SUM+, +MIN+, +MAX+, and +AVG+. The
# Arel::Expressions module includes factory methods for the default functions.
#
#   employees = Employee.arel_table
#
#   Employee.select(employees[:department_id], employees[:salary].average).group(employees[:department_id])
#
#   # SELECT "employees"."department_id", AVG("employees"."salary")
#   #   FROM "employees" GROUP BY "employees"."department_id"
#
# It’s also possible to use custom functions by using the Arel::Nodes::NamedFunction node type. It accepts a
# function name and an array of parameters.
#
#   Arel::Nodes::NamedFunction.new('date_trunc', [Arel::Nodes.build_quoted('day'), User.arel_table[:created_at]])
#
#   # date_trunc('day', "users"."created_at")
#
# == Quoting & bind params
#
# Values that you pass to Arel nodes need to be quoted or wrapped in bind params. This ensures they are properly
# converted into the correct format without introducing a possible SQL injection vulnerability. Most factory
# methods (like +eq+, +gt+, +lteq+, …) quote passed values automatically. When not using a factory method, it’s
# possible to convert a value and wrap it in an Arel::Nodes::Quoted node (if necessary) by calling +Arel::Nodes.
# build_quoted+.
#
#   Arel::Nodes.build_quoted("foo") # 'foo'
#   Arel::Nodes.build_quoted(12.3)  # 12.3
#
# Instead of quoting values and embedding them directly in the SQL statement, it’s also possible to create bind
# params. This keeps the actual values outside of the statement and allows using the prepared statement feature
# of some databases.
#
#   attribute = ActiveRecord::Relation::QueryAttribute.new(:name, "DHH", ActiveRecord::Type::String.new)
#   Arel::Nodes::BindParam.new(attribute)
#
# When ActiveRecord runs the query, bind params are replaced by placeholders (like +$1+) and the values are passed
# separately.
#
# == SQL Literals
#
# For cases where there is no way to represent a particular SQL fragment using Arel nodes, you can use an SQL
# literal. SQL literals are strings that Arel will treat “as is”.
#
#   Arel.sql('LOWER("users"."name")').eq('dhh')
#
#   # LOWER("users"."name") = 'dhh'
#
# Please keep in mind that passing data as raw SQL literals might introduce a possible SQL injection. However,
# `Arel.sql` supports binding parameters which will ensure proper quoting. This can be useful when you need to
# control the exact SQL you run, but you still have potentially user-supplied values.
#
#   Arel.sql('LOWER("users"."name") = ?', 'dhh')
#
#   # LOWER("users"."name") = 'dhh'
#
# You can also combine SQL literals.
#
#   sql = Arel.sql('SELECT * FROM "users" WHERE ')
#   sql += Arel.sql('LOWER("users"."name") = :name', name: 'dhh')
#   sql += Arel.sql('AND "users"."age" > :age', age: 35)
#
#   # SELECT * FROM "users" WHERE LOWER("users"."name") = 'dhh' AND "users"."age" > '35'
#
# source://activerecord//lib/arel/nodes/node.rb#116
class Arel::Nodes::Node
  include ::Arel::FactoryMethods

  # Factory method to create an Nodes::And node.
  #
  # source://activerecord//lib/arel/nodes/node.rb#135
  def and(right); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/node.rb#157
  def equality?; end

  # source://activerecord//lib/arel/nodes/node.rb#154
  def fetch_attribute; end

  # source://activerecord//lib/arel/nodes/node.rb#139
  def invert; end

  # Factory method to create a Nodes::Not node that has the recipient of
  # the caller as a child.
  #
  # source://activerecord//lib/arel/nodes/node.rb#122
  def not; end

  # Factory method to create a Nodes::Grouping node that has an Nodes::Or
  # node as a child.
  #
  # source://activerecord//lib/arel/nodes/node.rb#129
  def or(right); end

  # FIXME: this method should go away.  I don't like people calling
  # to_sql on non-head nodes.  This forces us to walk the AST until we
  # can find a node that has a "relation" member.
  #
  # Maybe we should just use `Table.engine`?  :'(
  #
  # source://activerecord//lib/arel/nodes/node.rb#148
  def to_sql(engine = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/node_expression.rb#5
class Arel::Nodes::NodeExpression < ::Arel::Nodes::Node
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications
  include ::Arel::Math
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Not < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/binary.rb#98
class Arel::Nodes::NotEqual < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#101
  def invert; end
end

# source://activerecord//lib/arel/nodes/binary.rb#106
class Arel::Nodes::NotIn < ::Arel::Nodes::Binary
  include ::Arel::Nodes::FetchAttribute

  # source://activerecord//lib/arel/nodes/binary.rb#109
  def invert; end
end

# source://activerecord//lib/arel/nodes/regexp.rb#14
class Arel::Nodes::NotRegexp < ::Arel::Nodes::Regexp; end

# source://activerecord//lib/arel/nodes/ordering.rb#15
class Arel::Nodes::NullsFirst < ::Arel::Nodes::Ordering
  # source://activerecord//lib/arel/nodes/ordering.rb#16
  def reverse; end
end

# source://activerecord//lib/arel/nodes/ordering.rb#21
class Arel::Nodes::NullsLast < ::Arel::Nodes::Ordering
  # source://activerecord//lib/arel/nodes/ordering.rb#22
  def reverse; end
end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::Offset < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::On < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::OptimizerHints < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/binary.rb#114
class Arel::Nodes::Or < ::Arel::Nodes::Binary
  # source://activerecord//lib/arel/nodes/binary.rb#115
  def fetch_attribute(&block); end
end

# source://activerecord//lib/arel/nodes/ordering.rb#5
class Arel::Nodes::Ordering < ::Arel::Nodes::Unary
  # source://activerecord//lib/arel/nodes/ordering.rb#6
  def nulls_first; end

  # source://activerecord//lib/arel/nodes/ordering.rb#10
  def nulls_last; end
end

# source://activerecord//lib/arel/nodes/outer_join.rb#5
class Arel::Nodes::OuterJoin < ::Arel::Nodes::Join; end

# source://activerecord//lib/arel/nodes/over.rb#5
class Arel::Nodes::Over < ::Arel::Nodes::Binary
  # @return [Over] a new instance of Over
  #
  # source://activerecord//lib/arel/nodes/over.rb#8
  def initialize(left, right = T.unsafe(nil)); end

  # source://activerecord//lib/arel/nodes/over.rb#12
  def operator; end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#56
class Arel::Nodes::Overlaps < ::Arel::Nodes::InfixOperation
  # @return [Overlaps] a new instance of Overlaps
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#57
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/window.rb#114
class Arel::Nodes::Preceding < ::Arel::Nodes::Unary
  # @return [Preceding] a new instance of Preceding
  #
  # source://activerecord//lib/arel/nodes/window.rb#115
  def initialize(expr = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/casted.rb#37
class Arel::Nodes::Quoted < ::Arel::Nodes::Unary
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/casted.rb#43
  def infinite?; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/casted.rb#41
  def nil?; end

  # source://activerecord//lib/arel/nodes/unary.rb#6
  def value_before_type_cast; end

  # source://activerecord//lib/arel/nodes/unary.rb#6
  def value_for_database; end
end

# source://activerecord//lib/arel/nodes/window.rb#97
class Arel::Nodes::Range < ::Arel::Nodes::Unary
  # @return [Range] a new instance of Range
  #
  # source://activerecord//lib/arel/nodes/window.rb#98
  def initialize(expr = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/regexp.rb#5
class Arel::Nodes::Regexp < ::Arel::Nodes::Binary
  # @return [Regexp] a new instance of Regexp
  #
  # source://activerecord//lib/arel/nodes/regexp.rb#8
  def initialize(left, right, case_sensitive = T.unsafe(nil)); end

  # Returns the value of attribute case_sensitive.
  #
  # source://activerecord//lib/arel/nodes/regexp.rb#6
  def case_sensitive; end

  # Sets the attribute case_sensitive
  #
  # @param value the value to set the attribute case_sensitive to.
  #
  # source://activerecord//lib/arel/nodes/regexp.rb#6
  def case_sensitive=(_arg0); end
end

# source://activerecord//lib/arel/nodes/right_outer_join.rb#5
class Arel::Nodes::RightOuterJoin < ::Arel::Nodes::Join; end

# source://activerecord//lib/arel/nodes/unary.rb#41
class Arel::Nodes::RollUp < ::Arel::Nodes::Unary; end

# source://activerecord//lib/arel/nodes/window.rb#91
class Arel::Nodes::Rows < ::Arel::Nodes::Unary
  # @return [Rows] a new instance of Rows
  #
  # source://activerecord//lib/arel/nodes/window.rb#92
  def initialize(expr = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/select_core.rb#5
class Arel::Nodes::SelectCore < ::Arel::Nodes::Node
  # @return [SelectCore] a new instance of SelectCore
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#9
  def initialize(relation = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#52
  def ==(other); end

  # Returns the value of attribute comment.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def comment; end

  # Sets the attribute comment
  #
  # @param value the value to set the attribute comment to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def comment=(_arg0); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#52
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/select_core.rb#24
  def from; end

  # source://activerecord//lib/arel/nodes/select_core.rb#28
  def from=(value); end

  # source://activerecord//lib/arel/nodes/select_core.rb#24
  def froms; end

  # source://activerecord//lib/arel/nodes/select_core.rb#28
  def froms=(value); end

  # Returns the value of attribute groups.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def groups; end

  # Sets the attribute groups
  #
  # @param value the value to set the attribute groups to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def groups=(_arg0); end

  # source://activerecord//lib/arel/nodes/select_core.rb#45
  def hash; end

  # Returns the value of attribute havings.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def havings; end

  # Sets the attribute havings
  #
  # @param value the value to set the attribute havings to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def havings=(_arg0); end

  # Returns the value of attribute optimizer_hints.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def optimizer_hints; end

  # Sets the attribute optimizer_hints
  #
  # @param value the value to set the attribute optimizer_hints to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def optimizer_hints=(_arg0); end

  # Returns the value of attribute projections.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def projections; end

  # Sets the attribute projections
  #
  # @param value the value to set the attribute projections to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def projections=(_arg0); end

  # Returns the value of attribute set_quantifier.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def set_quantifier; end

  # Sets the attribute set_quantifier
  #
  # @param value the value to set the attribute set_quantifier to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def set_quantifier=(_arg0); end

  # Returns the value of attribute source.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def source; end

  # Sets the attribute source
  #
  # @param value the value to set the attribute source to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#7
  def source=(_arg0); end

  # Returns the value of attribute wheres.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def wheres; end

  # Sets the attribute wheres
  #
  # @param value the value to set the attribute wheres to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def wheres=(_arg0); end

  # Returns the value of attribute windows.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def windows; end

  # Sets the attribute windows
  #
  # @param value the value to set the attribute windows to.
  #
  # source://activerecord//lib/arel/nodes/select_core.rb#6
  def windows=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/select_core.rb#35
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/select_statement.rb#5
class Arel::Nodes::SelectStatement < ::Arel::Nodes::NodeExpression
  # @return [SelectStatement] a new instance of SelectStatement
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#9
  def initialize(relation = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#29
  def ==(other); end

  # Returns the value of attribute cores.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#6
  def cores; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#29
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/select_statement.rb#25
  def hash; end

  # Returns the value of attribute limit.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def limit=(_arg0); end

  # Returns the value of attribute lock.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def lock; end

  # Sets the attribute lock
  #
  # @param value the value to set the attribute lock to.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def lock=(_arg0); end

  # Returns the value of attribute offset.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def orders=(_arg0); end

  # Returns the value of attribute with.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def with; end

  # Sets the attribute with
  #
  # @param value the value to set the attribute with to.
  #
  # source://activerecord//lib/arel/nodes/select_statement.rb#7
  def with=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/select_statement.rb#19
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/sql_literal.rb#5
class Arel::Nodes::SqlLiteral < ::String
  include ::Arel::Expressions
  include ::Arel::Predications
  include ::Arel::AliasPredication
  include ::Arel::OrderPredications

  # @raise [ArgumentError]
  #
  # source://activerecord//lib/arel/nodes/sql_literal.rb#18
  def +(other); end

  # source://activerecord//lib/arel/nodes/sql_literal.rb#11
  def encode_with(coder); end

  # source://activerecord//lib/arel/nodes/sql_literal.rb#15
  def fetch_attribute; end
end

# source://activerecord//lib/arel/nodes/string_join.rb#5
class Arel::Nodes::StringJoin < ::Arel::Nodes::Join
  # @return [StringJoin] a new instance of StringJoin
  #
  # source://activerecord//lib/arel/nodes/string_join.rb#6
  def initialize(left, right = T.unsafe(nil)); end
end

# source://activerecord//lib/arel/nodes/infix_operation.rb#38
class Arel::Nodes::Subtraction < ::Arel::Nodes::InfixOperation
  # @return [Subtraction] a new instance of Subtraction
  #
  # source://activerecord//lib/arel/nodes/infix_operation.rb#39
  def initialize(left, right); end
end

# source://activerecord//lib/arel/nodes/function.rb#42
class Arel::Nodes::Sum < ::Arel::Nodes::Function; end

# source://activerecord//lib/arel/nodes/table_alias.rb#5
class Arel::Nodes::TableAlias < ::Arel::Nodes::Binary
  # source://activerecord//lib/arel/nodes/table_alias.rb#10
  def [](name); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/table_alias.rb#26
  def able_to_type_cast?; end

  # source://activerecord//lib/arel/nodes/binary.rb#6
  def name; end

  # source://activerecord//lib/arel/nodes/binary.rb#6
  def relation; end

  # source://activerecord//lib/arel/nodes/binary.rb#6
  def table_alias; end

  # source://activerecord//lib/arel/nodes/table_alias.rb#14
  def table_name; end

  # source://activerecord//lib/arel/nodes/table_alias.rb#30
  def to_cte; end

  # source://activerecord//lib/arel/nodes/table_alias.rb#18
  def type_cast_for_database(attr_name, value); end

  # source://activerecord//lib/arel/nodes/table_alias.rb#22
  def type_for_attribute(name); end
end

# source://activerecord//lib/arel/nodes/true.rb#5
class Arel::Nodes::True < ::Arel::Nodes::NodeExpression
  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/true.rb#10
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/true.rb#10
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/true.rb#6
  def hash; end
end

# source://activerecord//lib/arel/nodes/unary.rb#5
class Arel::Nodes::Unary < ::Arel::Nodes::NodeExpression
  # @return [Unary] a new instance of Unary
  #
  # source://activerecord//lib/arel/nodes/unary.rb#9
  def initialize(expr); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/unary.rb#18
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/unary.rb#18
  def eql?(other); end

  # Returns the value of attribute expr.
  #
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def expr; end

  # Sets the attribute expr
  #
  # @param value the value to set the attribute expr to.
  #
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def expr=(_arg0); end

  # source://activerecord//lib/arel/nodes/unary.rb#14
  def hash; end

  # Returns the value of attribute expr.
  #
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def value; end
end

# source://activerecord//lib/arel/nodes/unary_operation.rb#5
class Arel::Nodes::UnaryOperation < ::Arel::Nodes::Unary
  # @return [UnaryOperation] a new instance of UnaryOperation
  #
  # source://activerecord//lib/arel/nodes/unary_operation.rb#8
  def initialize(operator, operand); end

  # Returns the value of attribute operator.
  #
  # source://activerecord//lib/arel/nodes/unary_operation.rb#6
  def operator; end
end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::Union < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/binary.rb#128
class Arel::Nodes::UnionAll < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/unqualified_column.rb#5
class Arel::Nodes::UnqualifiedColumn < ::Arel::Nodes::Unary
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def attribute; end

  # source://activerecord//lib/arel/nodes/unary.rb#6
  def attribute=(_arg0); end

  # source://activerecord//lib/arel/nodes/unqualified_column.rb#13
  def column; end

  # source://activerecord//lib/arel/nodes/unqualified_column.rb#17
  def name; end

  # source://activerecord//lib/arel/nodes/unqualified_column.rb#9
  def relation; end
end

# source://activerecord//lib/arel/nodes/update_statement.rb#5
class Arel::Nodes::UpdateStatement < ::Arel::Nodes::Node
  # @return [UpdateStatement] a new instance of UpdateStatement
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#8
  def initialize(relation = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#31
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#31
  def eql?(other); end

  # Returns the value of attribute groups.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def groups; end

  # Sets the attribute groups
  #
  # @param value the value to set the attribute groups to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def groups=(_arg0); end

  # source://activerecord//lib/arel/nodes/update_statement.rb#27
  def hash; end

  # Returns the value of attribute havings.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def havings; end

  # Sets the attribute havings
  #
  # @param value the value to set the attribute havings to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def havings=(_arg0); end

  # Returns the value of attribute key.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def key; end

  # Sets the attribute key
  #
  # @param value the value to set the attribute key to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def key=(_arg0); end

  # Returns the value of attribute limit.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def limit; end

  # Sets the attribute limit
  #
  # @param value the value to set the attribute limit to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def limit=(_arg0); end

  # Returns the value of attribute offset.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def offset; end

  # Sets the attribute offset
  #
  # @param value the value to set the attribute offset to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def offset=(_arg0); end

  # Returns the value of attribute orders.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def orders=(_arg0); end

  # Returns the value of attribute relation.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def relation; end

  # Sets the attribute relation
  #
  # @param value the value to set the attribute relation to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def relation=(_arg0); end

  # Returns the value of attribute values.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def values; end

  # Sets the attribute values
  #
  # @param value the value to set the attribute values to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def values=(_arg0); end

  # Returns the value of attribute wheres.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def wheres; end

  # Sets the attribute wheres
  #
  # @param value the value to set the attribute wheres to.
  #
  # source://activerecord//lib/arel/nodes/update_statement.rb#6
  def wheres=(_arg0); end

  private

  # source://activerecord//lib/arel/nodes/update_statement.rb#21
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/values_list.rb#5
class Arel::Nodes::ValuesList < ::Arel::Nodes::Unary
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def rows; end
end

# source://activerecord//lib/arel/nodes/case.rb#49
class Arel::Nodes::When < ::Arel::Nodes::Binary; end

# source://activerecord//lib/arel/nodes/window.rb#5
class Arel::Nodes::Window < ::Arel::Nodes::Node
  # @return [Window] a new instance of Window
  #
  # source://activerecord//lib/arel/nodes/window.rb#8
  def initialize; end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#59
  def ==(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/nodes/window.rb#59
  def eql?(other); end

  # source://activerecord//lib/arel/nodes/window.rb#30
  def frame(expr); end

  # Returns the value of attribute framing.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def framing; end

  # Sets the attribute framing
  #
  # @param value the value to set the attribute framing to.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def framing=(_arg0); end

  # source://activerecord//lib/arel/nodes/window.rb#55
  def hash; end

  # source://activerecord//lib/arel/nodes/window.rb#14
  def order(*expr); end

  # Returns the value of attribute orders.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def orders; end

  # Sets the attribute orders
  #
  # @param value the value to set the attribute orders to.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def orders=(_arg0); end

  # source://activerecord//lib/arel/nodes/window.rb#22
  def partition(*expr); end

  # Returns the value of attribute partitions.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def partitions; end

  # Sets the attribute partitions
  #
  # @param value the value to set the attribute partitions to.
  #
  # source://activerecord//lib/arel/nodes/window.rb#6
  def partitions=(_arg0); end

  # source://activerecord//lib/arel/nodes/window.rb#42
  def range(expr = T.unsafe(nil)); end

  # source://activerecord//lib/arel/nodes/window.rb#34
  def rows(expr = T.unsafe(nil)); end

  private

  # source://activerecord//lib/arel/nodes/window.rb#50
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/nodes/with.rb#5
class Arel::Nodes::With < ::Arel::Nodes::Unary
  # source://activerecord//lib/arel/nodes/unary.rb#6
  def children; end
end

# source://activerecord//lib/arel/nodes/with.rb#9
class Arel::Nodes::WithRecursive < ::Arel::Nodes::With; end

# source://activerecord//lib/arel/order_predications.rb#4
module Arel::OrderPredications
  # source://activerecord//lib/arel/order_predications.rb#5
  def asc; end

  # source://activerecord//lib/arel/order_predications.rb#9
  def desc; end
end

# source://activerecord//lib/arel/predications.rb#4
module Arel::Predications
  # source://activerecord//lib/arel/predications.rb#37
  def between(other); end

  # source://activerecord//lib/arel/predications.rb#215
  def concat(other); end

  # source://activerecord//lib/arel/predications.rb#219
  def contains(other); end

  # source://activerecord//lib/arel/predications.rb#147
  def does_not_match(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#159
  def does_not_match_all(others, escape = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#155
  def does_not_match_any(others, escape = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#151
  def does_not_match_regexp(other, case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#17
  def eq(other); end

  # source://activerecord//lib/arel/predications.rb#33
  def eq_all(others); end

  # source://activerecord//lib/arel/predications.rb#29
  def eq_any(others); end

  # source://activerecord//lib/arel/predications.rb#175
  def gt(right); end

  # source://activerecord//lib/arel/predications.rb#183
  def gt_all(others); end

  # source://activerecord//lib/arel/predications.rb#179
  def gt_any(others); end

  # source://activerecord//lib/arel/predications.rb#163
  def gteq(right); end

  # source://activerecord//lib/arel/predications.rb#171
  def gteq_all(others); end

  # source://activerecord//lib/arel/predications.rb#167
  def gteq_any(others); end

  # source://activerecord//lib/arel/predications.rb#65
  def in(other); end

  # source://activerecord//lib/arel/predications.rb#80
  def in_all(others); end

  # source://activerecord//lib/arel/predications.rb#76
  def in_any(others); end

  # source://activerecord//lib/arel/predications.rb#25
  def is_distinct_from(other); end

  # source://activerecord//lib/arel/predications.rb#21
  def is_not_distinct_from(other); end

  # source://activerecord//lib/arel/predications.rb#187
  def lt(right); end

  # source://activerecord//lib/arel/predications.rb#195
  def lt_all(others); end

  # source://activerecord//lib/arel/predications.rb#191
  def lt_any(others); end

  # source://activerecord//lib/arel/predications.rb#199
  def lteq(right); end

  # source://activerecord//lib/arel/predications.rb#207
  def lteq_all(others); end

  # source://activerecord//lib/arel/predications.rb#203
  def lteq_any(others); end

  # source://activerecord//lib/arel/predications.rb#131
  def matches(other, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#143
  def matches_all(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#139
  def matches_any(others, escape = T.unsafe(nil), case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#135
  def matches_regexp(other, case_sensitive = T.unsafe(nil)); end

  # source://activerecord//lib/arel/predications.rb#84
  def not_between(other); end

  # source://activerecord//lib/arel/predications.rb#5
  def not_eq(other); end

  # source://activerecord//lib/arel/predications.rb#13
  def not_eq_all(others); end

  # source://activerecord//lib/arel/predications.rb#9
  def not_eq_any(others); end

  # source://activerecord//lib/arel/predications.rb#112
  def not_in(other); end

  # source://activerecord//lib/arel/predications.rb#127
  def not_in_all(others); end

  # source://activerecord//lib/arel/predications.rb#123
  def not_in_any(others); end

  # source://activerecord//lib/arel/predications.rb#223
  def overlaps(other); end

  # source://activerecord//lib/arel/predications.rb#227
  def quoted_array(others); end

  # source://activerecord//lib/arel/predications.rb#211
  def when(right); end

  private

  # source://activerecord//lib/arel/predications.rb#239
  def grouping_all(method_id, others, *extras); end

  # source://activerecord//lib/arel/predications.rb#232
  def grouping_any(method_id, others, *extras); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/predications.rb#248
  def infinity?(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/predications.rb#256
  def open_ended?(value); end

  # source://activerecord//lib/arel/predications.rb#244
  def quoted_node(other); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/predications.rb#252
  def unboundable?(value); end
end

# source://activerecord//lib/arel/select_manager.rb#4
class Arel::SelectManager < ::Arel::TreeManager
  include ::Arel::Crud

  # @return [SelectManager] a new instance of SelectManager
  #
  # source://activerecord//lib/arel/select_manager.rb#9
  def initialize(table = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#48
  def as(other); end

  # source://activerecord//lib/arel/select_manager.rb#252
  def comment(*values); end

  # source://activerecord//lib/arel/select_manager.rb#24
  def constraints; end

  # source://activerecord//lib/arel/select_manager.rb#154
  def distinct(value = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#163
  def distinct_on(value); end

  # source://activerecord//lib/arel/select_manager.rb#213
  def except(other); end

  # Produces an Arel::Nodes::Exists node
  #
  # source://activerecord//lib/arel/select_manager.rb#44
  def exists; end

  # source://activerecord//lib/arel/select_manager.rb#85
  def from(table); end

  # source://activerecord//lib/arel/select_manager.rb#98
  def froms; end

  # source://activerecord//lib/arel/select_manager.rb#74
  def group(*columns); end

  # source://activerecord//lib/arel/select_manager.rb#119
  def having(expr); end

  # source://activerecord//lib/arel/select_manager.rb#209
  def intersect(other); end

  # source://activerecord//lib/arel/select_manager.rb#102
  def join(relation, klass = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#244
  def join_sources; end

  # source://activerecord//lib/arel/select_manager.rb#218
  def lateral(table_name = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#19
  def limit; end

  # source://activerecord//lib/arel/select_manager.rb#234
  def limit=(limit); end

  # source://activerecord//lib/arel/select_manager.rb#52
  def lock(locking = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#65
  def locked; end

  # source://activerecord//lib/arel/select_manager.rb#213
  def minus(other); end

  # source://activerecord//lib/arel/select_manager.rb#28
  def offset; end

  # source://activerecord//lib/arel/select_manager.rb#32
  def offset=(amount); end

  # source://activerecord//lib/arel/select_manager.rb#69
  def on(*exprs); end

  # source://activerecord//lib/arel/select_manager.rb#147
  def optimizer_hints(*hints); end

  # source://activerecord//lib/arel/select_manager.rb#172
  def order(*expr); end

  # source://activerecord//lib/arel/select_manager.rb#180
  def orders; end

  # source://activerecord//lib/arel/select_manager.rb#115
  def outer_join(relation); end

  # source://activerecord//lib/arel/select_manager.rb#130
  def project(*projections); end

  # source://activerecord//lib/arel/select_manager.rb#139
  def projections; end

  # source://activerecord//lib/arel/select_manager.rb#143
  def projections=(projections); end

  # source://activerecord//lib/arel/select_manager.rb#32
  def skip(amount); end

  # source://activerecord//lib/arel/select_manager.rb#248
  def source; end

  # source://activerecord//lib/arel/select_manager.rb#234
  def take(limit); end

  # source://activerecord//lib/arel/select_manager.rb#19
  def taken; end

  # source://activerecord//lib/arel/select_manager.rb#198
  def union(operation, other = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#184
  def where(expr); end

  # source://activerecord//lib/arel/select_manager.rb#192
  def where_sql(engine = T.unsafe(nil)); end

  # source://activerecord//lib/arel/select_manager.rb#124
  def window(name); end

  # source://activerecord//lib/arel/select_manager.rb#223
  def with(*subqueries); end

  private

  # source://activerecord//lib/arel/select_manager.rb#258
  def collapse(exprs); end

  # source://activerecord//lib/arel/select_manager.rb#14
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/select_manager.rb#7
Arel::SelectManager::STRING_OR_SYMBOL_CLASS = T.let(T.unsafe(nil), Array)

# source://activerecord//lib/arel/table.rb#4
class Arel::Table
  include ::Arel::FactoryMethods
  include ::Arel::AliasPredication

  # @return [Table] a new instance of Table
  #
  # source://activerecord//lib/arel/table.rb#14
  def initialize(name, as: T.unsafe(nil), klass: T.unsafe(nil), type_caster: T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/table.rb#99
  def ==(other); end

  # source://activerecord//lib/arel/table.rb#86
  def [](name, table = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/table.rb#114
  def able_to_type_cast?; end

  # source://activerecord//lib/arel/table.rb#34
  def alias(name = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/table.rb#99
  def eql?(other); end

  # source://activerecord//lib/arel/table.rb#38
  def from; end

  # source://activerecord//lib/arel/table.rb#58
  def group(*columns); end

  # source://activerecord//lib/arel/table.rb#92
  def hash; end

  # source://activerecord//lib/arel/table.rb#82
  def having(expr); end

  # source://activerecord//lib/arel/table.rb#42
  def join(relation, klass = T.unsafe(nil)); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/arel/table.rb#11
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activerecord//lib/arel/table.rb#11
  def name=(_arg0); end

  # source://activerecord//lib/arel/table.rb#62
  def order(*expr); end

  # source://activerecord//lib/arel/table.rb#54
  def outer_join(relation); end

  # source://activerecord//lib/arel/table.rb#70
  def project(*things); end

  # source://activerecord//lib/arel/table.rb#78
  def skip(amount); end

  # Returns the value of attribute table_alias.
  #
  # source://activerecord//lib/arel/table.rb#12
  def table_alias; end

  # source://activerecord//lib/arel/table.rb#74
  def take(amount); end

  # source://activerecord//lib/arel/table.rb#106
  def type_cast_for_database(attr_name, value); end

  # source://activerecord//lib/arel/table.rb#110
  def type_for_attribute(name); end

  # source://activerecord//lib/arel/table.rb#66
  def where(condition); end

  private

  # Returns the value of attribute type_caster.
  #
  # source://activerecord//lib/arel/table.rb#119
  def type_caster; end

  class << self
    # Returns the value of attribute engine.
    #
    # source://activerecord//lib/arel/table.rb#9
    def engine; end

    # Sets the attribute engine
    #
    # @param value the value to set the attribute engine to.
    #
    # source://activerecord//lib/arel/table.rb#9
    def engine=(_arg0); end
  end
end

# source://activerecord//lib/arel/tree_manager.rb#4
class Arel::TreeManager
  include ::Arel::FactoryMethods

  # Returns the value of attribute ast.
  #
  # source://activerecord//lib/arel/tree_manager.rb#41
  def ast; end

  # source://activerecord//lib/arel/tree_manager.rb#43
  def to_dot; end

  # source://activerecord//lib/arel/tree_manager.rb#49
  def to_sql(engine = T.unsafe(nil)); end

  private

  # source://activerecord//lib/arel/tree_manager.rb#55
  def initialize_copy(other); end
end

# source://activerecord//lib/arel/tree_manager.rb#7
module Arel::TreeManager::StatementMethods
  # source://activerecord//lib/arel/tree_manager.rb#27
  def key; end

  # source://activerecord//lib/arel/tree_manager.rb#23
  def key=(key); end

  # source://activerecord//lib/arel/tree_manager.rb#13
  def offset(offset); end

  # source://activerecord//lib/arel/tree_manager.rb#18
  def order(*expr); end

  # source://activerecord//lib/arel/tree_manager.rb#8
  def take(limit); end

  # source://activerecord//lib/arel/tree_manager.rb#35
  def where(expr); end

  # source://activerecord//lib/arel/tree_manager.rb#31
  def wheres=(exprs); end
end

# source://activerecord//lib/arel/update_manager.rb#4
class Arel::UpdateManager < ::Arel::TreeManager
  include ::Arel::TreeManager::StatementMethods

  # @return [UpdateManager] a new instance of UpdateManager
  #
  # source://activerecord//lib/arel/update_manager.rb#7
  def initialize(table = T.unsafe(nil)); end

  # source://activerecord//lib/arel/update_manager.rb#32
  def group(columns); end

  # source://activerecord//lib/arel/update_manager.rb#43
  def having(expr); end

  # source://activerecord//lib/arel/update_manager.rb#18
  def set(values); end

  # UPDATE +table+
  #
  # source://activerecord//lib/arel/update_manager.rb#13
  def table(table); end
end

# source://activerecord//lib/arel.rb#29
Arel::VERSION = T.let(T.unsafe(nil), String)

# source://activerecord//lib/arel/visitors/visitor.rb#4
module Arel::Visitors; end

# source://activerecord//lib/arel/visitors/dot.rb#5
class Arel::Visitors::Dot < ::Arel::Visitors::Visitor
  # @return [Dot] a new instance of Dot
  #
  # source://activerecord//lib/arel/visitors/dot.rb#19
  def initialize; end

  # source://activerecord//lib/arel/visitors/dot.rb#28
  def accept(object, collector); end

  private

  # source://activerecord//lib/arel/visitors/dot.rb#260
  def edge(name); end

  # source://activerecord//lib/arel/visitors/dot.rb#278
  def quote(string); end

  # source://activerecord//lib/arel/visitors/dot.rb#282
  def to_dot; end

  # source://activerecord//lib/arel/visitors/dot.rb#246
  def visit(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#215
  def visit_ActiveModel_Attribute(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#183
  def visit_Arel_Attributes_Attribute(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#188
  def visit_Arel_Nodes_And(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#44
  def visit_Arel_Nodes_Binary(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#211
  def visit_Arel_Nodes_BindParam(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#236
  def visit_Arel_Nodes_Case(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#172
  def visit_Arel_Nodes_Casted(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#232
  def visit_Arel_Nodes_Comment(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#77
  def visit_Arel_Nodes_Count(o); end

  # intentionally left blank
  #
  # source://activerecord//lib/arel/visitors/dot.rb#103
  def visit_Arel_Nodes_CurrentRow(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#159
  def visit_Arel_Nodes_DeleteStatement(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#103
  def visit_Arel_Nodes_Distinct(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#109
  def visit_Arel_Nodes_Extract(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#34
  def visit_Arel_Nodes_Function(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#177
  def visit_Arel_Nodes_HomogeneousIn(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#54
  def visit_Arel_Nodes_InfixOperation(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#121
  def visit_Arel_Nodes_InsertStatement(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#114
  def visit_Arel_Nodes_NamedFunction(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#96
  def visit_Arel_Nodes_NamedWindow(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#60
  def visit_Arel_Nodes_NotRegexp(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#68
  def visit_Arel_Nodes_Ordering(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#60
  def visit_Arel_Nodes_Regexp(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#128
  def visit_Arel_Nodes_SelectCore(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#140
  def visit_Arel_Nodes_SelectStatement(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Arel_Nodes_SqlLiteral(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#86
  def visit_Arel_Nodes_StringJoin(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#72
  def visit_Arel_Nodes_TableAlias(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#40
  def visit_Arel_Nodes_Unary(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#49
  def visit_Arel_Nodes_UnaryOperation(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#149
  def visit_Arel_Nodes_UpdateStatement(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#82
  def visit_Arel_Nodes_ValuesList(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#90
  def visit_Arel_Nodes_Window(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#188
  def visit_Arel_Nodes_With(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#168
  def visit_Arel_Table(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#225
  def visit_Array(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_BigDecimal(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Date(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_DateTime(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_FalseClass(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Float(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#219
  def visit_Hash(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Integer(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_NilClass(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#225
  def visit_Set(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_String(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Symbol(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_Time(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#196
  def visit_TrueClass(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#188
  def visit__children(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#103
  def visit__no_edges(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#60
  def visit__regexp(o); end

  # source://activerecord//lib/arel/visitors/dot.rb#242
  def visit_edge(o, method); end

  # source://activerecord//lib/arel/visitors/dot.rb#268
  def with_node(node); end
end

# source://activerecord//lib/arel/visitors/dot.rb#16
class Arel::Visitors::Dot::Edge < ::Struct; end

# source://activerecord//lib/arel/visitors/dot.rb#6
class Arel::Visitors::Dot::Node
  # @return [Node] a new instance of Node
  #
  # source://activerecord//lib/arel/visitors/dot.rb#9
  def initialize(name, id, fields = T.unsafe(nil)); end

  # Returns the value of attribute fields.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def fields; end

  # Sets the attribute fields
  #
  # @param value the value to set the attribute fields to.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def fields=(_arg0); end

  # Returns the value of attribute id.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def id; end

  # Sets the attribute id
  #
  # @param value the value to set the attribute id to.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def id=(_arg0); end

  # Returns the value of attribute name.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def name; end

  # Sets the attribute name
  #
  # @param value the value to set the attribute name to.
  #
  # source://activerecord//lib/arel/visitors/dot.rb#7
  def name=(_arg0); end
end

# source://activerecord//lib/arel/visitors/mysql.rb#5
class Arel::Visitors::MySQL < ::Arel::Visitors::ToSql
  private

  # MySQL doesn't automatically create a temporary table for use subquery, so we have
  # to give it some prompting in the form of a subsubquery.
  #
  # source://activerecord//lib/arel/visitors/mysql.rb#88
  def build_subselect(key, o); end

  # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
  # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
  # these, we must use a subquery.
  #
  # source://activerecord//lib/arel/visitors/mysql.rb#76
  def prepare_delete_statement(o); end

  # In the simple case, MySQL allows us to place JOINs directly into the UPDATE
  # query. However, this does not allow for LIMIT, OFFSET and ORDER. To support
  # these, we must use a subquery.
  #
  # source://activerecord//lib/arel/visitors/mysql.rb#76
  def prepare_update_statement(o); end

  # source://activerecord//lib/arel/visitors/mysql.rb#7
  def visit_Arel_Nodes_Bin(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#34
  def visit_Arel_Nodes_Concat(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#67
  def visit_Arel_Nodes_Cte(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#49
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#43
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#58
  def visit_Arel_Nodes_NotRegexp(o, collector); end

  # no-op
  #
  # source://activerecord//lib/arel/visitors/mysql.rb#63
  def visit_Arel_Nodes_NullsFirst(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#54
  def visit_Arel_Nodes_Regexp(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#29
  def visit_Arel_Nodes_SelectCore(o, collector); end

  # :'(
  # To retrieve all rows from a certain offset up to the end of the result set,
  # you can use some large number for the second parameter.
  # https://dev.mysql.com/doc/refman/en/select.html
  #
  # source://activerecord//lib/arel/visitors/mysql.rb#22
  def visit_Arel_Nodes_SelectStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/mysql.rb#13
  def visit_Arel_Nodes_UnqualifiedColumn(o, collector); end
end

# source://activerecord//lib/arel/visitors/postgresql.rb#5
class Arel::Visitors::PostgreSQL < ::Arel::Visitors::ToSql
  private

  # source://activerecord//lib/arel/visitors/postgresql.rb#84
  def bind_block; end

  # Utilized by GroupingSet, Cube & RollUp visitors to
  # handle grouping aggregation semantics
  #
  # source://activerecord//lib/arel/visitors/postgresql.rb#99
  def grouping_array_or_grouping_element(o, collector); end

  # Used by Lateral visitor to enclose select queries in parentheses
  #
  # source://activerecord//lib/arel/visitors/postgresql.rb#87
  def grouping_parentheses(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#49
  def visit_Arel_Nodes_Cube(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#39
  def visit_Arel_Nodes_DistinctOn(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#18
  def visit_Arel_Nodes_DoesNotMatch(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#44
  def visit_Arel_Nodes_GroupingElement(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#59
  def visit_Arel_Nodes_GroupingSet(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#75
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#69
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#64
  def visit_Arel_Nodes_Lateral(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#7
  def visit_Arel_Nodes_Matches(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#34
  def visit_Arel_Nodes_NotRegexp(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#29
  def visit_Arel_Nodes_Regexp(o, collector); end

  # source://activerecord//lib/arel/visitors/postgresql.rb#54
  def visit_Arel_Nodes_RollUp(o, collector); end
end

# source://activerecord//lib/arel/visitors/postgresql.rb#81
Arel::Visitors::PostgreSQL::BIND_BLOCK = T.let(T.unsafe(nil), Proc)

# source://activerecord//lib/arel/visitors/sqlite.rb#5
class Arel::Visitors::SQLite < ::Arel::Visitors::ToSql
  private

  # source://activerecord//lib/arel/visitors/sqlite.rb#21
  def visit_Arel_Nodes_False(o, collector); end

  # source://activerecord//lib/arel/visitors/sqlite.rb#31
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/sqlite.rb#25
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end

  # Locks are not supported in SQLite
  #
  # source://activerecord//lib/arel/visitors/sqlite.rb#8
  def visit_Arel_Nodes_Lock(o, collector); end

  # source://activerecord//lib/arel/visitors/sqlite.rb#12
  def visit_Arel_Nodes_SelectStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/sqlite.rb#17
  def visit_Arel_Nodes_True(o, collector); end
end

# source://activerecord//lib/arel/visitors/to_sql.rb#11
class Arel::Visitors::ToSql < ::Arel::Visitors::Visitor
  # @return [ToSql] a new instance of ToSql
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#12
  def initialize(connection); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#17
  def compile(node, collector = T.unsafe(nil)); end

  private

  # source://activerecord//lib/arel/visitors/to_sql.rb#982
  def aggregate(name, o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#759
  def bind_block; end

  # FIXME: we should probably have a 2-pass visitor for this
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#945
  def build_subselect(key, o); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#1009
  def collect_ctes(children, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#176
  def collect_nodes_for(nodes, collector, spacer, connector = T.unsafe(nil)); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#890
  def collect_optimizer_hints(o, collector); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#920
  def has_group_by_and_having?(o); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#912
  def has_join_sources?(o); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#916
  def has_limit_or_offset_or_orders?(o); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#959
  def infix_value(o, collector, value); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#965
  def infix_value_with_paren(o, collector, value, suppress_parens = T.unsafe(nil)); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#900
  def inject_join(list, collector, join_str); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#996
  def is_distinct_from(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#894
  def maybe_visit(thing, collector); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL visitor we redefine this to do that.
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#927
  def prepare_delete_statement(o); end

  # The default strategy for an UPDATE with joins is to use a subquery. This doesn't work
  # on MySQL (even when aliasing the tables), but MySQL allows using JOIN directly in
  # an UPDATE statement, so in the MySQL visitor we redefine this to do that.
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#927
  def prepare_update_statement(o); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#870
  def quote(value); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#880
  def quote_column_name(name); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#875
  def quote_table_name(name); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#885
  def sanitize_as_sql_comment(value); end

  # @return [Boolean]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#908
  def unboundable?(value); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def unsupported(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#761
  def visit_ActiveModel_Attribute(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_ActiveSupport_Multibyte_Chars(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_ActiveSupport_StringInquirer(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#751
  def visit_Arel_Attributes_Attribute(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#616
  def visit_Arel_Nodes_And(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#698
  def visit_Arel_Nodes_As(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#360
  def visit_Arel_Nodes_Ascending(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#635
  def visit_Arel_Nodes_Assignment(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#417
  def visit_Arel_Nodes_Avg(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#427
  def visit_Arel_Nodes_Between(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#183
  def visit_Arel_Nodes_Bin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#765
  def visit_Arel_Nodes_BindParam(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#774
  def visit_Arel_Nodes_BoundSqlLiteral(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#704
  def visit_Arel_Nodes_Case(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#84
  def visit_Arel_Nodes_Casted(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#172
  def visit_Arel_Nodes_Comment(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#401
  def visit_Arel_Nodes_Count(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#737
  def visit_Arel_Nodes_Cte(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#293
  def visit_Arel_Nodes_CurrentRow(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#22
  def visit_Arel_Nodes_DeleteStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#364
  def visit_Arel_Nodes_Descending(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#187
  def visit_Arel_Nodes_Distinct(o, collector); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#191
  def visit_Arel_Nodes_DistinctOn(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#493
  def visit_Arel_Nodes_DoesNotMatch(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#728
  def visit_Arel_Nodes_Else(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#648
  def visit_Arel_Nodes_Equality(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#218
  def visit_Arel_Nodes_Except(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#73
  def visit_Arel_Nodes_Exists(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#396
  def visit_Arel_Nodes_Extract(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#93
  def visit_Arel_Nodes_False(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#248
  def visit_Arel_Nodes_Filter(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#283
  def visit_Arel_Nodes_Following(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#866
  def visit_Arel_Nodes_Fragments(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#528
  def visit_Arel_Nodes_FullOuterJoin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#445
  def visit_Arel_Nodes_GreaterThan(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#433
  def visit_Arel_Nodes_GreaterThanOrEqual(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#379
  def visit_Arel_Nodes_Group(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#324
  def visit_Arel_Nodes_Grouping(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#333
  def visit_Arel_Nodes_HomogeneousIn(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#584
  def visit_Arel_Nodes_In(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#850
  def visit_Arel_Nodes_InfixOperation(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#549
  def visit_Arel_Nodes_InnerJoin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#51
  def visit_Arel_Nodes_InsertStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#213
  def visit_Arel_Nodes_Intersect(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#673
  def visit_Arel_Nodes_IsDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#663
  def visit_Arel_Nodes_IsNotDistinctFrom(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#505
  def visit_Arel_Nodes_JoinSource(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#469
  def visit_Arel_Nodes_LessThan(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#457
  def visit_Arel_Nodes_LessThanOrEqual(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#315
  def visit_Arel_Nodes_Limit(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#320
  def visit_Arel_Nodes_Lock(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#481
  def visit_Arel_Nodes_Matches(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#409
  def visit_Arel_Nodes_Max(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#413
  def visit_Arel_Nodes_Min(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#383
  def visit_Arel_Nodes_NamedFunction(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#223
  def visit_Arel_Nodes_NamedWindow(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#565
  def visit_Arel_Nodes_Not(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#683
  def visit_Arel_Nodes_NotEqual(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#600
  def visit_Arel_Nodes_NotIn(o, collector); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#520
  def visit_Arel_Nodes_NotRegexp(o, collector); end

  # NullsFirst is available on all but MySQL, where it is redefined.
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#369
  def visit_Arel_Nodes_NullsFirst(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#374
  def visit_Arel_Nodes_NullsLast(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#310
  def visit_Arel_Nodes_Offset(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#560
  def visit_Arel_Nodes_On(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#167
  def visit_Arel_Nodes_OptimizerHints(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#620
  def visit_Arel_Nodes_Or(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#535
  def visit_Arel_Nodes_OuterJoin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#297
  def visit_Arel_Nodes_Over(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#273
  def visit_Arel_Nodes_Preceding(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#84
  def visit_Arel_Nodes_Quoted(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#264
  def visit_Arel_Nodes_Range(o, collector); end

  # @raise [NotImplementedError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#516
  def visit_Arel_Nodes_Regexp(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#542
  def visit_Arel_Nodes_RightOuterJoin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#255
  def visit_Arel_Nodes_Rows(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#146
  def visit_Arel_Nodes_SelectCore(o, collector); end

  # The Oracle enhanced adapter uses this private method,
  # see https://github.com/rsim/oracle-enhanced/issues/2186
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#140
  def visit_Arel_Nodes_SelectOptions(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#117
  def visit_Arel_Nodes_SelectStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#769
  def visit_Arel_Nodes_SqlLiteral(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#524
  def visit_Arel_Nodes_StringJoin(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#405
  def visit_Arel_Nodes_Sum(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#421
  def visit_Arel_Nodes_TableAlias(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#89
  def visit_Arel_Nodes_True(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#856
  def visit_Arel_Nodes_UnaryOperation(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#205
  def visit_Arel_Nodes_Union(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#209
  def visit_Arel_Nodes_UnionAll(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#733
  def visit_Arel_Nodes_UnqualifiedColumn(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#39
  def visit_Arel_Nodes_UpdateStatement(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#97
  def visit_Arel_Nodes_ValuesList(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#721
  def visit_Arel_Nodes_When(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#229
  def visit_Arel_Nodes_Window(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#195
  def visit_Arel_Nodes_With(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#200
  def visit_Arel_Nodes_WithRecursive(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#355
  def visit_Arel_SelectManager(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#570
  def visit_Arel_Table(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#861
  def visit_Array(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_BigDecimal(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Class(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Date(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_DateTime(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_FalseClass(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Float(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Hash(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#827
  def visit_Integer(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_NilClass(o, collector); end

  # source://activerecord//lib/arel/visitors/to_sql.rb#861
  def visit_Set(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_String(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Symbol(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_Time(o, collector); end

  # @raise [UnsupportedVisitError]
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#831
  def visit_TrueClass(o, collector); end
end

# source://activerecord//lib/arel/visitors/to_sql.rb#756
Arel::Visitors::ToSql::BIND_BLOCK = T.let(T.unsafe(nil), Proc)

# source://activerecord//lib/arel/visitors/to_sql.rb#5
class Arel::Visitors::UnsupportedVisitError < ::StandardError
  # @return [UnsupportedVisitError] a new instance of UnsupportedVisitError
  #
  # source://activerecord//lib/arel/visitors/to_sql.rb#6
  def initialize(object); end
end

# source://activerecord//lib/arel/visitors/visitor.rb#5
class Arel::Visitors::Visitor
  # @return [Visitor] a new instance of Visitor
  #
  # source://activerecord//lib/arel/visitors/visitor.rb#6
  def initialize; end

  # source://activerecord//lib/arel/visitors/visitor.rb#10
  def accept(object, collector = T.unsafe(nil)); end

  private

  # Returns the value of attribute dispatch.
  #
  # source://activerecord//lib/arel/visitors/visitor.rb#15
  def dispatch; end

  # source://activerecord//lib/arel/visitors/visitor.rb#23
  def get_dispatch_cache; end

  # source://activerecord//lib/arel/visitors/visitor.rb#27
  def visit(object, collector = T.unsafe(nil)); end

  class << self
    # source://activerecord//lib/arel/visitors/visitor.rb#17
    def dispatch_cache; end
  end
end

# source://activerecord//lib/arel/window_predications.rb#4
module Arel::WindowPredications
  # source://activerecord//lib/arel/window_predications.rb#5
  def over(expr = T.unsafe(nil)); end
end
