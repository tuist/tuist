# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `httpx` gem.
# Please instead update this file by running `bin/tapioca gem httpx`.

# Top-Level Namespace
#
# source://httpx//lib/httpx/version.rb#3
module HTTPX
  extend ::HTTPX::Chainable
end

# source://httpx//lib/httpx/altsvc.rb#6
module HTTPX::AltSvc
  private

  # source://httpx//lib/httpx/altsvc.rb#64
  def cached_altsvc(origin); end

  # source://httpx//lib/httpx/altsvc.rb#71
  def cached_altsvc_set(origin, entry); end

  # source://httpx//lib/httpx/altsvc.rb#91
  def emit(request, response); end

  # source://httpx//lib/httpx/altsvc.rb#82
  def lookup(origin, ttl); end

  # source://httpx//lib/httpx/altsvc.rb#120
  def parse(altsvc); end

  # source://httpx//lib/httpx/altsvc.rb#153
  def parse_altsvc_origin(alt_proto, alt_origin); end

  # source://httpx//lib/httpx/altsvc.rb#144
  def parse_altsvc_scheme(alt_proto); end

  class << self
    # source://httpx//lib/httpx/altsvc.rb#64
    def cached_altsvc(origin); end

    # source://httpx//lib/httpx/altsvc.rb#71
    def cached_altsvc_set(origin, entry); end

    # source://httpx//lib/httpx/altsvc.rb#91
    def emit(request, response); end

    # source://httpx//lib/httpx/altsvc.rb#82
    def lookup(origin, ttl); end

    # source://httpx//lib/httpx/altsvc.rb#120
    def parse(altsvc); end

    # source://httpx//lib/httpx/altsvc.rb#153
    def parse_altsvc_origin(alt_proto, alt_origin); end

    # source://httpx//lib/httpx/altsvc.rb#144
    def parse_altsvc_scheme(alt_proto); end
  end
end

# makes connections able to accept requests destined to primary service.
#
# source://httpx//lib/httpx/altsvc.rb#8
module HTTPX::AltSvc::ConnectionMixin
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#17
  def match?(uri, options); end

  # source://httpx//lib/httpx/altsvc.rb#11
  def send(request); end

  private

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#43
  def altsvc_match?(uri, other_uri); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#35
  def match_altsvc_options?(uri, options); end

  # checks if this is connection is an alternative service of
  # +uri+
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/altsvc.rb#27
  def match_altsvcs?(uri); end
end

# source://httpx//lib/httpx/extensions.rb#6
module HTTPX::ArrayExtensions; end

# source://httpx//lib/httpx/extensions.rb#7
module HTTPX::ArrayExtensions::FilterMap; end

# source://httpx//lib/httpx/extensions.rb#21
module HTTPX::ArrayExtensions::Intersect; end

# Internal class to abstract a string buffer, by wrapping a string and providing the
# minimum possible API and functionality required.
#
#     buffer = Buffer.new(640)
#     buffer.full? #=> false
#     buffer << "aa"
#     buffer.capacity #=> 638
#
# source://httpx//lib/httpx/buffer.rb#14
class HTTPX::Buffer
  extend ::Forwardable

  # @return [Buffer] a new instance of Buffer
  #
  # source://httpx//lib/httpx/buffer.rb#33
  def initialize(limit); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#42
  def capacity; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/buffer.rb#38
  def full?; end

  # Returns the value of attribute limit.
  #
  # source://httpx//lib/httpx/buffer.rb#31
  def limit; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def replace(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/buffer.rb#46
  def shift!(fin); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/callbacks.rb#4
module HTTPX::Callbacks
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/callbacks.rb#27
  def callbacks_for?(type); end

  # source://httpx//lib/httpx/callbacks.rb#23
  def emit(type, *args); end

  # source://httpx//lib/httpx/callbacks.rb#5
  def on(type, &action); end

  # source://httpx//lib/httpx/callbacks.rb#10
  def once(type, &block); end

  # source://httpx//lib/httpx/callbacks.rb#18
  def only(type, &block); end

  protected

  # source://httpx//lib/httpx/callbacks.rb#33
  def callbacks(type = T.unsafe(nil)); end
end

# Session mixin, implements most of the APIs that the users call.
# delegates to a default session when extended.
#
# source://httpx//lib/httpx/chainable.rb#6
module HTTPX::Chainable
  # source://httpx//lib/httpx/chainable.rb#20
  def accept(type); end

  # source://httpx//lib/httpx/chainable.rb#9
  def connect(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def delete(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def get(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def head(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def options(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def patch(*uri, **options); end

  # returns a new instance loaded with the +pl+ plugin and +options+.
  #
  # source://httpx//lib/httpx/chainable.rb#30
  def plugin(pl, options = T.unsafe(nil), &blk); end

  # source://httpx//lib/httpx/chainable.rb#9
  def post(*uri, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def put(*uri, **options); end

  # delegates to the default session (see HTTPX::Session#request).
  #
  # source://httpx//lib/httpx/chainable.rb#16
  def request(*args, **options); end

  # source://httpx//lib/httpx/chainable.rb#9
  def trace(*uri, **options); end

  # returns a new instance loaded with +options+.
  #
  # source://httpx//lib/httpx/chainable.rb#38
  def with(options, &blk); end

  # delegates to the default session (see HTTPX::Session#wrap).
  #
  # source://httpx//lib/httpx/chainable.rb#25
  def wrap(&blk); end

  private

  # returns a default instance of HTTPX::Session.
  #
  # source://httpx//lib/httpx/chainable.rb#50
  def branch(options, &blk); end

  # returns default instance of HTTPX::Options.
  #
  # source://httpx//lib/httpx/chainable.rb#45
  def default_options; end

  # source://httpx//lib/httpx/chainable.rb#56
  def method_missing(meth, *args, **options, &blk); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/chainable.rb#84
  def respond_to_missing?(meth, *_arg1); end
end

# Error raised when there was a timeout establishing the connection to a server.
# This may be raised due to timeouts during TCP and TLS (when applicable) connection
# establishment.
#
# source://httpx//lib/httpx/errors.rb#35
class HTTPX::ConnectTimeoutError < ::HTTPX::TimeoutError; end

# The Connection can be watched for IO events.
#
# It contains the +io+ object to read/write from, and knows what to do when it can.
#
# It defers connecting until absolutely necessary. Connection should be triggered from
# the IO selector (until then, any request will be queued).
#
# A connection boots up its parser after connection is established. All pending requests
# will be redirected there after connection.
#
# A connection can be prevented from closing by the parser, that is, if there are pending
# requests. This will signal that the connection was prematurely closed, due to a possible
# number of conditions:
#
# * Remote peer closed the connection ("Connection: close");
# * Remote peer doesn't support pipelining;
#
# A connection may also route requests for a different host for which the +io+ was connected
# to, provided that the IP is the same and the port and scheme as well. This will allow to
# share the same socket to send HTTP/2 requests to different hosts.
#
# source://httpx//lib/httpx/connection.rb#30
class HTTPX::Connection
  include ::HTTPX::Loggable
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # @return [Connection] a new instance of Connection
  #
  # source://httpx//lib/httpx/connection.rb#50
  def initialize(uri, options); end

  # source://httpx//lib/httpx/connection.rb#88
  def addresses; end

  # this is a semi-private method, to be used by the resolver
  # to initiate the io object.
  #
  # source://httpx//lib/httpx/connection.rb#80
  def addresses=(addrs); end

  # source://httpx//lib/httpx/connection.rb#192
  def call; end

  # source://httpx//lib/httpx/connection.rb#208
  def close; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def closed?(*args, **_arg1, &block); end

  # coalescable connections need to be mergeable!
  # but internally, #mergeable? is called before #coalescable?
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#124
  def coalescable?(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#164
  def connecting?; end

  # source://httpx//lib/httpx/connection.rb#135
  def create_idle(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#274
  def deactivate; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#105
  def expired?; end

  # Returns the value of attribute family.
  #
  # source://httpx//lib/httpx/connection.rb#48
  def family; end

  # Sets the attribute family
  #
  # @param value the value to set the attribute family to.
  #
  # source://httpx//lib/httpx/connection.rb#48
  def family=(_arg0); end

  # bypasses the state machine to force closing of connections still connecting.
  # **only** used for Happy Eyeballs v2.
  #
  # source://httpx//lib/httpx/connection.rb#222
  def force_reset; end

  # source://httpx//lib/httpx/connection.rb#282
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/connection.rb#263
  def idling; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#168
  def inflight?; end

  # source://httpx//lib/httpx/connection.rb#172
  def interests; end

  # Returns the value of attribute io.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def io; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#92
  def match?(uri, options); end

  # source://httpx//lib/httpx/connection.rb#139
  def merge(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#111
  def mergeable?(connection); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#278
  def open?; end

  # Returns the value of attribute options.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def options; end

  # Returns the value of attribute origin.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def origin; end

  # Returns the value of attribute origins.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def origins; end

  # Returns the value of attribute pending.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def pending; end

  # source://httpx//lib/httpx/connection.rb#152
  def purge_pending(&block); end

  # source://httpx//lib/httpx/connection.rb#227
  def reset; end

  # source://httpx//lib/httpx/connection.rb#235
  def send(request); end

  # Returns the value of attribute ssl_session.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def ssl_session; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def state; end

  # source://httpx//lib/httpx/connection.rb#214
  def terminate; end

  # source://httpx//lib/httpx/connection.rb#255
  def timeout; end

  # Sets the attribute timers
  #
  # @param value the value to set the attribute timers to.
  #
  # source://httpx//lib/httpx/connection.rb#46
  def timers=(_arg0); end

  # source://httpx//lib/httpx/connection.rb#188
  def to_io; end

  # Returns the value of attribute type.
  #
  # source://httpx//lib/httpx/connection.rb#44
  def type; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/connection.rb#270
  def used?; end

  private

  # source://httpx//lib/httpx/connection.rb#451
  def build_parser(protocol = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#615
  def build_socket(addrs = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#298
  def connect; end

  # source://httpx//lib/httpx/connection.rb#302
  def consume; end

  # source://httpx//lib/httpx/connection.rb#653
  def handle_error(error); end

  # source://httpx//lib/httpx/connection.rb#541
  def handle_transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#602
  def initialize_type(uri, options); end

  # source://httpx//lib/httpx/connection.rb#635
  def on_error(error); end

  # source://httpx//lib/httpx/connection.rb#435
  def parser; end

  # source://httpx//lib/httpx/connection.rb#596
  def purge_after_closed; end

  # source://httpx//lib/httpx/connection.rb#694
  def read_timeout_callback(request, read_timeout, error_type = T.unsafe(nil)); end

  # source://httpx//lib/httpx/connection.rb#429
  def send_pending; end

  # source://httpx//lib/httpx/connection.rb#439
  def send_request_to_parser(request); end

  # source://httpx//lib/httpx/connection.rb#457
  def set_parser_callbacks(parser); end

  # source://httpx//lib/httpx/connection.rb#704
  def set_request_timeout(request, timeout, start_event, finish_events, &callback); end

  # source://httpx//lib/httpx/connection.rb#662
  def set_request_timeouts(request); end

  # source://httpx//lib/httpx/connection.rb#514
  def transition(nextstate); end

  # source://httpx//lib/httpx/connection.rb#686
  def write_timeout_callback(request, write_timeout); end

  class << self
    # source://httpx//lib/httpx/connection.rb#723
    def parser_type(protocol); end
  end
end

# source://httpx//lib/httpx/connection/http1.rb#6
class HTTPX::Connection::HTTP1
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http1.rb#17
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http1.rb#75
  def <<(data); end

  # source://httpx//lib/httpx/connection/http1.rb#55
  def close; end

  # source://httpx//lib/httpx/connection/http1.rb#91
  def consume; end

  # source://httpx//lib/httpx/connection/http1.rb#163
  def dispatch; end

  # source://httpx//lib/httpx/connection/http1.rb#64
  def empty?; end

  # source://httpx//lib/httpx/connection/http1.rb#60
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http1.rb#200
  def handle_error(ex); end

  # source://httpx//lib/httpx/connection/http1.rb#33
  def interests; end

  # source://httpx//lib/httpx/connection/http1.rb#15
  def max_concurrent_requests; end

  # source://httpx//lib/httpx/connection/http1.rb#15
  def max_concurrent_requests=(_arg0); end

  # source://httpx//lib/httpx/connection/http1.rb#154
  def on_complete; end

  # source://httpx//lib/httpx/connection/http1.rb#138
  def on_data(chunk); end

  # source://httpx//lib/httpx/connection/http1.rb#110
  def on_headers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#106
  def on_start; end

  # source://httpx//lib/httpx/connection/http1.rb#128
  def on_trailers(h); end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def pending; end

  # source://httpx//lib/httpx/connection/http1.rb#223
  def ping; end

  # source://httpx//lib/httpx/connection/http1.rb#13
  def requests; end

  # source://httpx//lib/httpx/connection/http1.rb#48
  def reset; end

  # source://httpx//lib/httpx/connection/http1.rb#79
  def send(request); end

  # source://httpx//lib/httpx/connection/http1.rb#29
  def timeout; end

  private

  # source://httpx//lib/httpx/connection/http1.rb#392
  def capitalized(field); end

  # source://httpx//lib/httpx/connection/http1.rb#267
  def disable; end

  # source://httpx//lib/httpx/connection/http1.rb#274
  def disable_pipelining; end

  # source://httpx//lib/httpx/connection/http1.rb#329
  def handle(request); end

  # source://httpx//lib/httpx/connection/http1.rb#356
  def join_body(request); end

  # source://httpx//lib/httpx/connection/http1.rb#346
  def join_headers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#379
  def join_headers2(headers); end

  # source://httpx//lib/httpx/connection/http1.rb#342
  def join_headline(request); end

  # source://httpx//lib/httpx/connection/http1.rb#371
  def join_trailers(request); end

  # source://httpx//lib/httpx/connection/http1.rb#231
  def manage_connection(request, response); end

  # source://httpx//lib/httpx/connection/http1.rb#294
  def set_protocol_headers(request); end
end

# source://httpx//lib/httpx/connection/http1.rb#11
HTTPX::Connection::HTTP1::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/connection/http1.rb#10
HTTPX::Connection::HTTP1::MAX_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/connection/http1.rb#387
HTTPX::Connection::HTTP1::UPCASED = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/connection/http2.rb#7
class HTTPX::Connection::HTTP2
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/connection/http2.rb#27
  def initialize(buffer, options); end

  # source://httpx//lib/httpx/connection/http2.rb#91
  def <<(data); end

  # source://httpx//lib/httpx/connection/http2.rb#95
  def can_buffer_more_requests?; end

  # source://httpx//lib/httpx/connection/http2.rb#75
  def close; end

  # source://httpx//lib/httpx/connection/http2.rb#118
  def consume; end

  # source://httpx//lib/httpx/connection/http2.rb#83
  def empty?; end

  # source://httpx//lib/httpx/connection/http2.rb#87
  def exhausted?; end

  # source://httpx//lib/httpx/connection/http2.rb#126
  def handle_error(ex); end

  # source://httpx//lib/httpx/connection/http2.rb#48
  def interests; end

  # source://httpx//lib/httpx/connection/http2.rb#25
  def pending; end

  # source://httpx//lib/httpx/connection/http2.rb#142
  def ping; end

  # source://httpx//lib/httpx/connection/http2.rb#170
  def reset; end

  # source://httpx//lib/httpx/connection/http2.rb#101
  def send(request); end

  # source://httpx//lib/httpx/connection/http2.rb#25
  def streams; end

  # source://httpx//lib/httpx/connection/http2.rb#42
  def timeout; end

  private

  # source://httpx//lib/httpx/connection/http2.rb#158
  def handle(request, stream); end

  # source://httpx//lib/httpx/connection/http2.rb#193
  def handle_stream(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#170
  def init_connection; end

  # source://httpx//lib/httpx/connection/http2.rb#239
  def join_body(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#213
  def join_headers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#227
  def join_trailers(stream, request); end

  # source://httpx//lib/httpx/connection/http2.rb#381
  def on_altsvc(origin, frame); end

  # source://httpx//lib/httpx/connection/http2.rb#343
  def on_close(_last_frame, error, _payload); end

  # source://httpx//lib/httpx/connection/http2.rb#332
  def on_frame(bytes); end

  # source://httpx//lib/httpx/connection/http2.rb#372
  def on_frame_received(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#363
  def on_frame_sent(frame); end

  # source://httpx//lib/httpx/connection/http2.rb#393
  def on_origin(origin); end

  # source://httpx//lib/httpx/connection/http2.rb#397
  def on_pong(ping); end

  # source://httpx//lib/httpx/connection/http2.rb#389
  def on_promise(stream); end

  # source://httpx//lib/httpx/connection/http2.rb#336
  def on_settings(*_arg0); end

  # source://httpx//lib/httpx/connection/http2.rb#302
  def on_stream_close(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#291
  def on_stream_data(stream, request, data); end

  # source://httpx//lib/httpx/connection/http2.rb#264
  def on_stream_headers(stream, request, h); end

  # source://httpx//lib/httpx/connection/http2.rb#297
  def on_stream_refuse(stream, request, error); end

  # source://httpx//lib/httpx/connection/http2.rb#284
  def on_stream_trailers(stream, response, h); end

  # source://httpx//lib/httpx/connection/http2.rb#151
  def send_pending; end

  # source://httpx//lib/httpx/connection/http2.rb#204
  def set_protocol_headers(request); end
end

# source://httpx//lib/httpx/connection/http2.rb#13
class HTTPX::Connection::HTTP2::Error < ::HTTPX::Error
  # source://httpx//lib/httpx/connection/http2.rb#14
  def initialize(id, code); end
end

# source://httpx//lib/httpx/connection/http2.rb#19
class HTTPX::Connection::HTTP2::GoawayError < ::HTTPX::Connection::HTTP2::Error
  # source://httpx//lib/httpx/connection/http2.rb#20
  def initialize; end
end

# source://httpx//lib/httpx/connection/http2.rb#11
HTTPX::Connection::HTTP2::MAX_CONCURRENT_REQUESTS = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/errors.rb#9
class HTTPX::ConnectionError < ::HTTPX::Error; end

# Helper class which decodes the HTTP "content-type" header.
#
# source://httpx//lib/httpx/response.rb#181
class HTTPX::ContentType
  # @return [ContentType] a new instance of ContentType
  #
  # source://httpx//lib/httpx/response.rb#185
  def initialize(header_value); end

  # returns the charset declared in the header.
  #
  #   ContentType.new("application/json; charset=utf-8").charset #=> "utf-8"
  #   ContentType.new("text/plain").charset #=> nil
  #
  # source://httpx//lib/httpx/response.rb#203
  def charset; end

  # returns the mime type declared in the header.
  #
  #   ContentType.new("application/json; charset=utf-8").mime_type #=> "application/json"
  #
  # source://httpx//lib/httpx/response.rb#192
  def mime_type; end
end

# source://httpx//lib/httpx/response.rb#183
HTTPX::ContentType::CHARSET_RE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/response.rb#182
HTTPX::ContentType::MIME_TYPE_RE = T.let(T.unsafe(nil), Regexp)

# Represents a domain name ready for extracting its registered domain
# and TLD.
#
# source://httpx//lib/httpx/domain_name.rb#34
class HTTPX::DomainName
  include ::Comparable

  # Parses _hostname_ into a DomainName object.  An IP address is also
  # accepted.  An IPv6 address may be enclosed in square brackets.
  #
  # @raise [ArgumentError]
  # @return [DomainName] a new instance of DomainName
  #
  # source://httpx//lib/httpx/domain_name.rb#75
  def initialize(hostname); end

  # source://httpx//lib/httpx/domain_name.rb#131
  def <=>(other); end

  # Checks if the server represented by this domain is qualified to
  # send and receive cookies with a domain attribute value of
  # _domain_.  A true value given as the second argument represents
  # cookies without a domain attribute value, in which case only
  # hostname equality is checked.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/domain_name.rb#115
  def cookie_domain?(domain, host_only = T.unsafe(nil)); end

  # The least "universally original" domain part of this domain name.
  # For example, "example.co.uk" for "www.sub.example.co.uk".  This
  # may be nil if the hostname does not have one, like when it is an
  # IP address, an effective TLD or higher itself, or of a
  # non-canonical domain.
  #
  # source://httpx//lib/httpx/domain_name.rb#52
  def domain; end

  # The full host name normalized, ASCII-ized and downcased using the
  # Unicode NFC rules and the Punycode algorithm.  If initialized with
  # an IP address, the string representation of the IP address
  # suitable for opening a connection to.
  #
  # source://httpx//lib/httpx/domain_name.rb#41
  def hostname; end

  class << self
    # source://httpx//lib/httpx/domain_name.rb#55
    def new(domain); end

    # Normalizes a _domain_ using the Punycode algorithm as necessary.
    # The result will be a downcased, ASCII-only string.
    #
    # source://httpx//lib/httpx/domain_name.rb#63
    def normalize(domain); end
  end
end

# source://httpx//lib/httpx.rb#26
HTTPX::EMPTY = T.let(T.unsafe(nil), Array)

# the default exception class for exceptions raised by HTTPX.
#
# source://httpx//lib/httpx/errors.rb#5
class HTTPX::Error < ::StandardError; end

# Wraps an error which has happened while processing an HTTP Request. It has partial
# public API parity with HTTPX::Response, so users should rely on it to infer whether
# the returned response is one or the other.
#
#   response = HTTPX.get("https://some-domain/path") #=> response is HTTPX::Response or HTTPX::ErrorResponse
#   response.raise_for_status #=> raises if it wraps an error
#
# source://httpx//lib/httpx/response.rb#217
class HTTPX::ErrorResponse
  include ::HTTPX::Loggable
  include ::HTTPX::ErrorResponsePatternMatchExtensions
  extend ::Forwardable

  # @return [ErrorResponse] a new instance of ErrorResponse
  #
  # source://httpx//lib/httpx/response.rb#236
  def initialize(request, error, options); end

  # closes the error resources.
  #
  # source://httpx//lib/httpx/response.rb#250
  def close; end

  # the wrapped exception.
  #
  # source://httpx//lib/httpx/response.rb#228
  def error; end

  # always true for error responses.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#255
  def finished?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_address(*args, **_arg1, &block); end

  # raises the wrapped exception.
  #
  # @raise [@error]
  #
  # source://httpx//lib/httpx/response.rb#260
  def raise_for_status; end

  # the corresponding HTTPX::Request instance.
  #
  # source://httpx//lib/httpx/response.rb#222
  def request; end

  # the HTTPX::Response instance, when there is one (i.e. error happens fetching the response).
  #
  # source://httpx//lib/httpx/response.rb#225
  def response; end

  # returns the exception full message.
  #
  # source://httpx//lib/httpx/response.rb#245
  def to_s; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uri(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#14
module HTTPX::ErrorResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#15
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#19
  def deconstruct_keys(_keys); end
end

# The exception class for HTTP responses with 4xx or 5xx status.
#
# source://httpx//lib/httpx/errors.rb#86
class HTTPX::HTTPError < ::HTTPX::Error
  # Creates the instance and assigns the HTTPX::Response +response+.
  #
  # @return [HTTPError] a new instance of HTTPError
  #
  # source://httpx//lib/httpx/errors.rb#91
  def initialize(response); end

  # The HTTPX::Response response object this exception refers to.
  #
  # source://httpx//lib/httpx/errors.rb#88
  def response; end

  # The HTTP response status.
  #
  #   error.status #=> 404
  #
  # source://httpx//lib/httpx/errors.rb#99
  def status; end
end

# source://httpx//lib/httpx/headers.rb#4
class HTTPX::Headers
  include ::HTTPX::HeadersPatternMatchExtensions

  # @return [Headers] a new instance of Headers
  #
  # source://httpx//lib/httpx/headers.rb#13
  def initialize(headers = T.unsafe(nil)); end

  # source://httpx//lib/httpx/headers.rb#118
  def ==(other); end

  # returns the comma-separated values of the header field
  # identified by +field+, or nil otherwise.
  #
  # source://httpx//lib/httpx/headers.rb#68
  def [](field); end

  # sets +value+ (if not nil) as single value for the +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#75
  def []=(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  #
  # source://httpx//lib/httpx/headers.rb#90
  def add(field, value); end

  # adds additional +value+ to the existing, for header +field+.
  # helper to be used when adding an header field as a value to another field
  #
  #     h2_headers.add_header("vary", "accept-encoding")
  #     h2_headers["vary"] #=> "accept-encoding"
  #     h1_headers.add_header("vary", "accept-encoding")
  #     h1_headers["vary"] #=> "Accept-Encoding"
  #
  # source://httpx//lib/httpx/headers.rb#90
  def add_header(field, value); end

  # deletes all values associated with +field+ header.
  #
  # source://httpx//lib/httpx/headers.rb#83
  def delete(field); end

  # returns the enumerable headers store in pairs of header field + the values in
  # the comma-separated string format
  #
  # source://httpx//lib/httpx/headers.rb#106
  def each(extra_headers = T.unsafe(nil)); end

  # freezes the headers hash
  #
  # source://httpx//lib/httpx/headers.rb#37
  def freeze; end

  # returns the values for the +field+ header in array format.
  # This method is more internal, and for this reason doesn't try
  # to "correct" the user input, i.e. it doesn't downcase the key.
  #
  # source://httpx//lib/httpx/headers.rb#156
  def get(field); end

  # :nocov:
  #
  # source://httpx//lib/httpx/headers.rb#139
  def inspect; end

  # this is internal API and doesn't abide to other public API
  # guarantees, like downcasing strings.
  # Please do not use this outside of core!
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#148
  def key?(downcased_key); end

  # merges headers with another header-quack.
  # the merge rule is, if the header already exists,
  # ignore what the +other+ headers has. Otherwise, set
  #
  # source://httpx//lib/httpx/headers.rb#57
  def merge(other); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/headers.rb#42
  def same_headers?(headers); end

  # the headers store in array of pairs format
  #
  # source://httpx//lib/httpx/headers.rb#129
  def to_a; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#123
  def to_h; end

  # the headers store in Hash format
  #
  # source://httpx//lib/httpx/headers.rb#123
  def to_hash; end

  # headers as string
  #
  # source://httpx//lib/httpx/headers.rb#134
  def to_s; end

  private

  # source://httpx//lib/httpx/headers.rb#162
  def array_value(value); end

  # source://httpx//lib/httpx/headers.rb#171
  def downcased(field); end

  # cloned initialization
  #
  # source://httpx//lib/httpx/headers.rb#25
  def initialize_clone(orig); end

  # dupped initialization
  #
  # source://httpx//lib/httpx/headers.rb#31
  def initialize_dup(orig); end

  class << self
    # source://httpx//lib/httpx/headers.rb#6
    def new(headers = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#24
module HTTPX::HeadersPatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#25
  def deconstruct; end
end

# source://httpx//lib/httpx/loggable.rb#4
module HTTPX::Loggable
  # source://httpx//lib/httpx/loggable.rb#16
  def log(level: T.unsafe(nil), color: T.unsafe(nil), &msg); end

  # source://httpx//lib/httpx/loggable.rb#27
  def log_exception(ex, level: T.unsafe(nil), color: T.unsafe(nil)); end
end

# source://httpx//lib/httpx/loggable.rb#5
HTTPX::Loggable::COLORS = T.let(T.unsafe(nil), Hash)

# error raised when a request was sent a server which can't reproduce a response, and
# has therefore returned an HTTP response using the 421 status code.
#
# source://httpx//lib/httpx/errors.rb#106
class HTTPX::MisdirectedRequestError < ::HTTPX::HTTPError; end

# Error raised when there was an error while resolving a domain to an IP
# using a HTTPX::Resolver::Native resolver.
#
# source://httpx//lib/httpx/errors.rb#73
class HTTPX::NativeResolveError < ::HTTPX::ResolveError
  # initializes the exception with the +connection+ it refers to, the +host+ domain
  # which failed to resolve, and the error +message+.
  #
  # @return [NativeResolveError] a new instance of NativeResolveError
  #
  # source://httpx//lib/httpx/errors.rb#78
  def initialize(connection, host, message = T.unsafe(nil)); end

  # Returns the value of attribute connection.
  #
  # source://httpx//lib/httpx/errors.rb#74
  def connection; end

  # Returns the value of attribute host.
  #
  # source://httpx//lib/httpx/errors.rb#74
  def host; end
end

# Contains a set of options which are passed and shared across from session to its requests or
# responses.
#
# source://httpx//lib/httpx/options.rb#8
class HTTPX::Options
  # creates a new options instance from a given hash, which optionally define the following:
  #
  # :debug :: an object which log messages are written to (must respond to <tt><<</tt>)
  # :debug_level :: the log level of messages (can be 1, 2, or 3).
  # :ssl :: a hash of options which can be set as params of OpenSSL::SSL::SSLContext (see HTTPX::IO::SSL)
  # :http2_settings :: a hash of options to be passed to a HTTP2Next::Connection (ex: <tt>{ max_concurrent_streams: 2 }</tt>)
  # :fallback_protocol :: version of HTTP protocol to use by default in the absence of protocol negotiation
  #                       like ALPN (defaults to <tt>"http/1.1"</tt>)
  # :supported_compression_formats :: list of compressions supported by the transcoder layer (defaults to <tt>%w[gzip deflate]</tt>).
  # :decompress_response_body :: whether to auto-decompress response body (defaults to <tt>true</tt>).
  # :compress_request_body :: whether to auto-decompress response body (defaults to <tt>true</tt>)
  # :timeout :: hash of timeout configurations (supports <tt>:connect_timeout</tt>, <tt>:settings_timeout</tt>,
  #             <tt>:operation_timeout</tt>, <tt>:keep_alive_timeout</tt>,  <tt>:read_timeout</tt>,  <tt>:write_timeout</tt>
  #             and <tt>:request_timeout</tt>
  # :headers :: hash of HTTP headers (ex: <tt>{ "x-custom-foo" => "bar" }</tt>)
  # :window_size :: number of bytes to read from a socket
  # :buffer_size :: internal read and write buffer size in bytes
  # :body_threshold_size :: maximum size in bytes of response payload that is buffered in memory.
  # :request_class :: class used to instantiate a request
  # :response_class :: class used to instantiate a response
  # :headers_class :: class used to instantiate headers
  # :request_body_class :: class used to instantiate a request body
  # :response_body_class :: class used to instantiate a response body
  # :connection_class :: class used to instantiate connections
  # :options_class :: class used to instantiate options
  # :transport :: type of transport to use (set to "unix" for UNIX sockets)
  # :addresses :: bucket of peer addresses (can be a list of IP addresses, a hash of domain to list of adddresses;
  #               paths should be used for UNIX sockets instead)
  # :io :: open socket, or domain/ip-to-socket hash, which requests should be sent to
  # :persistent :: whether to persist connections in between requests (defaults to <tt>true</tt>)
  # :resolver_class :: which resolver to use (defaults to <tt>:native</tt>, can also be <tt>:system<tt> for
  #                    using getaddrinfo or <tt>:https</tt> for DoH resolver, or a custom class)
  # :resolver_options :: hash of options passed to the resolver
  # :ip_families :: which socket families are supported (system-dependent)
  # :origin :: HTTP origin to set on requests with relative path (ex: "https://api.serv.com")
  # :base_path :: path to prefix given relative paths with (ex: "/v2")
  # :max_concurrent_requests :: max number of requests which can be set concurrently
  # :max_requests :: max number of requests which can be made on socket before it reconnects.
  # :params :: hash or array of key-values which will be encoded and set in the query string of request uris.
  # :form :: hash of array of key-values which will be form-or-multipart-encoded in requests body payload.
  # :json :: hash of array of key-values which will be JSON-encoded in requests body payload.
  # :xml :: Nokogiri XML nodes which will be encoded in requests body payload.
  #
  # This list of options are enhanced with each loaded plugin, see the plugin docs for details.
  #
  # @return [Options] a new instance of Options
  #
  # source://httpx//lib/httpx/options.rb#133
  def initialize(options = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#233
  def ==(other); end

  # source://httpx//lib/httpx/options.rb#85
  def addresses; end

  # source://httpx//lib/httpx/options.rb#85
  def base_path; end

  # source://httpx//lib/httpx/options.rb#85
  def body; end

  # source://httpx//lib/httpx/options.rb#85
  def body_threshold_size; end

  # source://httpx//lib/httpx/options.rb#85
  def buffer_size; end

  # source://httpx//lib/httpx/options.rb#85
  def compress_request_body; end

  # source://httpx//lib/httpx/options.rb#85
  def connection_class; end

  # source://httpx//lib/httpx/options.rb#85
  def debug; end

  # source://httpx//lib/httpx/options.rb#85
  def debug_level; end

  # source://httpx//lib/httpx/options.rb#85
  def decompress_response_body; end

  # source://httpx//lib/httpx/options.rb#302
  def extend_with_plugin_classes(pl); end

  # source://httpx//lib/httpx/options.rb#85
  def fallback_protocol; end

  # source://httpx//lib/httpx/options.rb#85
  def form; end

  # source://httpx//lib/httpx/options.rb#138
  def freeze; end

  # source://httpx//lib/httpx/options.rb#85
  def headers; end

  # source://httpx//lib/httpx/options.rb#85
  def headers_class; end

  # source://httpx//lib/httpx/options.rb#85
  def http2_settings; end

  # source://httpx//lib/httpx/options.rb#85
  def io; end

  # source://httpx//lib/httpx/options.rb#85
  def ip_families; end

  # source://httpx//lib/httpx/options.rb#85
  def json; end

  # source://httpx//lib/httpx/options.rb#85
  def max_concurrent_requests; end

  # source://httpx//lib/httpx/options.rb#85
  def max_requests; end

  # source://httpx//lib/httpx/options.rb#260
  def merge(other); end

  # source://httpx//lib/httpx/options.rb#210
  def option_addresses(value); end

  # source://httpx//lib/httpx/options.rb#152
  def option_base_path(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_body(v); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#196
  def option_body_threshold_size(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#188
  def option_buffer_size(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_compress_request_body(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_connection_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_debug(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_debug_level(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_decompress_response_body(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_fallback_protocol(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_form(v); end

  # source://httpx//lib/httpx/options.rb#156
  def option_headers(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_headers_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_http2_settings(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_io(v); end

  # source://httpx//lib/httpx/options.rb#214
  def option_ip_families(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_json(v); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#168
  def option_max_concurrent_requests(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#174
  def option_max_requests(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_options_class(v); end

  # source://httpx//lib/httpx/options.rb#148
  def option_origin(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_params(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_persistent(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_request_body_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_request_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_resolver_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_resolver_options(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_response_body_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_response_class(v); end

  # source://httpx//lib/httpx/options.rb#227
  def option_ssl(v); end

  # source://httpx//lib/httpx/options.rb#164
  def option_supported_compression_formats(value); end

  # source://httpx//lib/httpx/options.rb#160
  def option_timeout(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#203
  def option_transport(value); end

  # @raise [TypeError]
  #
  # source://httpx//lib/httpx/options.rb#180
  def option_window_size(value); end

  # source://httpx//lib/httpx/options.rb#227
  def option_xml(v); end

  # source://httpx//lib/httpx/options.rb#85
  def options_class; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/options.rb#237
  def options_equals?(other, ignore_ivars = T.unsafe(nil)); end

  # source://httpx//lib/httpx/options.rb#85
  def origin; end

  # source://httpx//lib/httpx/options.rb#85
  def params; end

  # source://httpx//lib/httpx/options.rb#85
  def persistent; end

  # source://httpx//lib/httpx/options.rb#85
  def request_body_class; end

  # source://httpx//lib/httpx/options.rb#85
  def request_class; end

  # source://httpx//lib/httpx/options.rb#85
  def resolver_class; end

  # source://httpx//lib/httpx/options.rb#85
  def resolver_options; end

  # source://httpx//lib/httpx/options.rb#85
  def response_body_class; end

  # source://httpx//lib/httpx/options.rb#85
  def response_class; end

  # source://httpx//lib/httpx/options.rb#85
  def ssl; end

  # source://httpx//lib/httpx/options.rb#85
  def supported_compression_formats; end

  # source://httpx//lib/httpx/options.rb#85
  def timeout; end

  # source://httpx//lib/httpx/options.rb#296
  def to_hash; end

  # source://httpx//lib/httpx/options.rb#85
  def transport; end

  # source://httpx//lib/httpx/options.rb#85
  def window_size; end

  # source://httpx//lib/httpx/options.rb#85
  def xml; end

  private

  # source://httpx//lib/httpx/options.rb#340
  def do_initialize(options = T.unsafe(nil)); end

  class << self
    # @private
    #
    # source://httpx//lib/httpx/options.rb#78
    def method_added(meth); end

    # source://httpx//lib/httpx/options.rb#70
    def new(options = T.unsafe(nil)); end
  end
end

# source://httpx//lib/httpx/options.rb#9
HTTPX::Options::BUFFER_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#14
HTTPX::Options::CLOSE_HANDSHAKE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#15
HTTPX::Options::CONNECT_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#30
HTTPX::Options::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/options.rb#12
HTTPX::Options::KEEP_ALIVE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# 112K
#
# source://httpx//lib/httpx/options.rb#11
HTTPX::Options::MAX_BODY_THRESHOLD_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#16
HTTPX::Options::OPERATION_TIMEOUT = T.let(T.unsafe(nil), T.untyped)

# source://httpx//lib/httpx/options.rb#252
HTTPX::Options::OTHER_LOOKUP = T.let(T.unsafe(nil), Proc)

# source://httpx//lib/httpx/options.rb#15
HTTPX::Options::READ_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#231
HTTPX::Options::REQUEST_BODY_IVARS = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/options.rb#16
HTTPX::Options::REQUEST_TIMEOUT = T.let(T.unsafe(nil), T.untyped)

# source://httpx//lib/httpx/options.rb#13
HTTPX::Options::SETTINGS_TIMEOUT = T.let(T.unsafe(nil), Integer)

# 16K
#
# source://httpx//lib/httpx/options.rb#10
HTTPX::Options::WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/options.rb#15
HTTPX::Options::WRITE_TIMEOUT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/parser/http1.rb#4
module HTTPX::Parser; end

# source://httpx//lib/httpx/parser/http1.rb#5
class HTTPX::Parser::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/parser/http1.rb#7
class HTTPX::Parser::HTTP1
  # @return [HTTP1] a new instance of HTTP1
  #
  # source://httpx//lib/httpx/parser/http1.rb#12
  def initialize(observer); end

  # source://httpx//lib/httpx/parser/http1.rb#19
  def <<(chunk); end

  # Returns the value of attribute headers.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def headers; end

  # Returns the value of attribute http_version.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def http_version; end

  # source://httpx//lib/httpx/parser/http1.rb#24
  def reset!; end

  # Returns the value of attribute status_code.
  #
  # source://httpx//lib/httpx/parser/http1.rb#10
  def status_code; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#31
  def upgrade?; end

  # source://httpx//lib/httpx/parser/http1.rb#35
  def upgrade_data; end

  private

  # source://httpx//lib/httpx/parser/http1.rb#169
  def nextstate(state); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/parser/http1.rb#159
  def no_more_data?; end

  # source://httpx//lib/httpx/parser/http1.rb#41
  def parse; end

  # source://httpx//lib/httpx/parser/http1.rb#115
  def parse_data; end

  # source://httpx//lib/httpx/parser/http1.rb#73
  def parse_headers; end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/parser/http1.rb#56
  def parse_headline; end

  # source://httpx//lib/httpx/parser/http1.rb#140
  def prepare_data(headers); end
end

# source://httpx//lib/httpx/parser/http1.rb#8
HTTPX::Parser::HTTP1::VERSIONS = T.let(T.unsafe(nil), Array)

# All plugins should be stored under this module/namespace. Can register and load
# plugins.
#
# source://httpx//lib/httpx.rb#31
module HTTPX::Plugins
  class << self
    # Loads a plugin based on a name. If the plugin hasn't been loaded, tries to load
    # it from the load path under "httpx/plugins/" directory.
    #
    # source://httpx//lib/httpx.rb#38
    def load_plugin(name); end

    # Registers a plugin (+mod+) in the central store indexed by +name+.
    #
    # source://httpx//lib/httpx.rb#50
    def register_plugin(name, mod); end
  end
end

# source://httpx//lib/httpx/pool.rb#9
class HTTPX::Pool
  extend ::Forwardable

  # @return [Pool] a new instance of Pool
  #
  # source://httpx//lib/httpx/pool.rb#15
  def initialize; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def after(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/pool.rb#61
  def close(connections = T.unsafe(nil)); end

  # source://httpx//lib/httpx/pool.rb#111
  def deactivate(connections); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/pool.rb#33
  def empty?; end

  # opens a connection to the IP reachable through +uri+.
  # Many hostnames are reachable through the same IP, so we try to
  # maximize pipelining by opening as few connections as possible.
  #
  # source://httpx//lib/httpx/pool.rb#122
  def find_connection(uri, options); end

  # source://httpx//lib/httpx/pool.rb#83
  def init_connection(connection, _options); end

  # source://httpx//lib/httpx/pool.rb#37
  def next_tick; end

  # source://httpx//lib/httpx/pool.rb#22
  def wrap; end

  private

  # source://httpx//lib/httpx/pool.rb#258
  def coalesce_connections(conn1, conn2); end

  # source://httpx//lib/httpx/pool.rb#254
  def deselect_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#274
  def find_resolver_for(connection); end

  # source://httpx//lib/httpx/pool.rb#266
  def next_timeout; end

  # source://httpx//lib/httpx/pool.rb#231
  def on_resolver_close(resolver); end

  # source://httpx//lib/httpx/pool.rb#208
  def on_resolver_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#225
  def on_resolver_error(connection, error); end

  # source://httpx//lib/httpx/pool.rb#241
  def register_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#145
  def resolve_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#250
  def select_connection(connection); end

  # source://httpx//lib/httpx/pool.rb#170
  def try_clone_connection(connection, family); end

  # source://httpx//lib/httpx/pool.rb#245
  def unregister_connection(connection, cleanup = T.unsafe(nil)); end
end

# Wrapper yielder which can be used with functions which expect an IO writer.
#
# source://httpx//lib/httpx/request/body.rb#147
class HTTPX::ProcIO
  # @return [ProcIO] a new instance of ProcIO
  #
  # source://httpx//lib/httpx/request/body.rb#148
  def initialize(block); end

  # Implementation the IO write protocol, which yield the given chunk to +@block+.
  #
  # source://httpx//lib/httpx/request/body.rb#153
  def write(data); end
end

# source://httpx//lib/httpx/punycode.rb#4
module HTTPX::Punycode
  private

  # source://httpx//lib/httpx/punycode.rb#14
  def encode_hostname(hostname); end

  class << self
    # source://httpx//lib/httpx/punycode.rb#14
    def encode_hostname(hostname); end
  end
end

# Error raised when there was a timeout while receiving a response from the server.
#
# source://httpx//lib/httpx/errors.rb#57
class HTTPX::ReadTimeoutError < ::HTTPX::RequestTimeoutError; end

# Defines how an HTTP request is handled internally, both in terms of making attributes accessible,
# as well as maintaining the state machine which manages streaming the request onto the wire.
#
# source://httpx//lib/httpx/request.rb#9
class HTTPX::Request
  include ::HTTPX::Callbacks
  extend ::Forwardable

  # initializes the instance with the given +verb+, an absolute or relative +uri+, and the
  # request options.
  #
  # @return [Request] a new instance of Request
  #
  # source://httpx//lib/httpx/request.rb#51
  def initialize(verb, uri, options = T.unsafe(nil)); end

  # returs the URI authority of the request.
  #
  #   session.build_request("GET", "https://google.com/query").authority #=> "google.com"
  #   session.build_request("GET", "http://internal:3182/a").authority #=> "internal:3182"
  #
  # source://httpx//lib/httpx/request.rb#153
  def authority; end

  # an HTTPX::Request::Body object containing the request body payload (or +nil+, whenn there is none).
  #
  # source://httpx//lib/httpx/request.rb#27
  def body; end

  # consumes and returns the next available chunk of request body that can be sent
  #
  # source://httpx//lib/httpx/request.rb#183
  def drain_body; end

  # Exception raised during enumerable body writes.
  #
  # source://httpx//lib/httpx/request.rb#39
  def drain_error; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # whether the request supports the 100-continue handshake and already processed the 100 response.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#244
  def expects?; end

  # an HTTPX::Headers object containing the request HTTP headers.
  #
  # source://httpx//lib/httpx/request.rb#24
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/request.rb#199
  def inspect; end

  # returns +:r+ or +:w+, depending on whether the request is waiting for a response or flushing.
  #
  # source://httpx//lib/httpx/request.rb#103
  def interests; end

  # source://httpx//lib/httpx/request.rb#109
  def merge_headers(h); end

  # an HTTPX::Options object containing request options.
  #
  # source://httpx//lib/httpx/request.rb#33
  def options; end

  # returs the URI origin of the request.
  #
  #   session.build_request("GET", "https://google.com/query").authority #=> "https://google.com"
  #   session.build_request("GET", "http://internal:3182/a").authority #=> "http://internal:3182"
  #
  # source://httpx//lib/httpx/request.rb#161
  def origin; end

  # returnns the URI path of the request +uri+.
  #
  # source://httpx//lib/httpx/request.rb#141
  def path; end

  # The IP address from the peer server.
  #
  # source://httpx//lib/httpx/request.rb#42
  def peer_address; end

  # The IP address from the peer server.
  #
  # source://httpx//lib/httpx/request.rb#42
  def peer_address=(_arg0); end

  # Sets the attribute persistent
  #
  # @param value the value to set the attribute persistent to.
  #
  # source://httpx//lib/httpx/request.rb#44
  def persistent=(_arg0); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#90
  def persistent?; end

  # returs the URI query string of the request (when available).
  #
  #   session.build_request("GET", "https://search.com").query #=> ""
  #   session.build_request("GET", "https://search.com?q=a").query #=> "q=a"
  #   session.build_request("GET", "https://search.com", params: { q: "a"}).query #=> "q=a"
  #   session.build_request("GET", "https://search.com?q=a", params: { foo: "bar"}).query #=> "q=a&foo&bar"
  #
  # source://httpx//lib/httpx/request.rb#171
  def query; end

  # the read timeout defied for this requet.
  #
  # source://httpx//lib/httpx/request.rb#76
  def read_timeout; end

  # the request timeout defied for this requet.
  #
  # source://httpx//lib/httpx/request.rb#86
  def request_timeout; end

  # the corresponding HTTPX::Response object, when there is one.
  #
  # source://httpx//lib/httpx/request.rb#36
  def response; end

  # sets the +response+ on this request.
  #
  # source://httpx//lib/httpx/request.rb#119
  def response=(response); end

  # the URI scheme of the request +uri+.
  #
  # source://httpx//lib/httpx/request.rb#114
  def scheme; end

  # a symbol describing which frame is currently being flushed.
  #
  # source://httpx//lib/httpx/request.rb#30
  def state; end

  # source://httpx//lib/httpx/request.rb#98
  def trailers; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/request.rb#94
  def trailers?; end

  # moves on to the +nextstate+ of the request state machine (when all preconditions are met)
  #
  # source://httpx//lib/httpx/request.rb#209
  def transition(nextstate); end

  # the absolute URI object for this request.
  #
  # source://httpx//lib/httpx/request.rb#21
  def uri; end

  # the upcased string HTTP verb for this request.
  #
  # source://httpx//lib/httpx/request.rb#18
  def verb; end

  # the write timeout defied for this requet.
  #
  # source://httpx//lib/httpx/request.rb#81
  def write_timeout; end
end

# source://httpx//lib/httpx/request/body.rb#5
class HTTPX::Request::Body < ::SimpleDelegator
  # source://httpx//lib/httpx/request/body.rb#15
  def initialize(headers, options); end

  # source://httpx//lib/httpx/request/body.rb#65
  def bytesize; end

  # source://httpx//lib/httpx/request/body.rb#91
  def chunk!; end

  # source://httpx//lib/httpx/request/body.rb#86
  def chunked?; end

  # source://httpx//lib/httpx/request/body.rb#35
  def each(&block); end

  # source://httpx//lib/httpx/request/body.rb#57
  def empty?; end

  # source://httpx//lib/httpx/request/body.rb#96
  def inspect; end

  # source://httpx//lib/httpx/request/body.rb#50
  def rewind; end

  # source://httpx//lib/httpx/request/body.rb#72
  def stream(body); end

  # source://httpx//lib/httpx/request/body.rb#79
  def unbounded_body?; end

  private

  # source://httpx//lib/httpx/request/body.rb#111
  def initialize_body(options); end

  class << self
    # source://httpx//lib/httpx/request/body.rb#131
    def initialize_deflater_body(body, encoding); end

    # source://httpx//lib/httpx/request/body.rb#7
    def new(_, options); end
  end
end

# default value used for "user-agent" header, when not overridden.
#
# source://httpx//lib/httpx/request.rb#15
HTTPX::Request::USER_AGENT = T.let(T.unsafe(nil), String)

# Error raised when there was a timeout while sending a request, or receiving a response
# from the server.
#
# source://httpx//lib/httpx/errors.rb#39
class HTTPX::RequestTimeoutError < ::HTTPX::TimeoutError
  # initializes the exception with the +request+ and +response+ it refers to, and the
  # +timeout+ causing the error, and the
  #
  # @return [RequestTimeoutError] a new instance of RequestTimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#45
  def initialize(request, response, timeout); end

  # source://httpx//lib/httpx/errors.rb#51
  def marshal_dump; end

  # The HTTPX::Request request object this exception refers to.
  #
  # source://httpx//lib/httpx/errors.rb#41
  def request; end
end

# Error raised when there was an error while resolving a domain to an IP.
#
# source://httpx//lib/httpx/errors.rb#69
class HTTPX::ResolveError < ::HTTPX::Error; end

# Error raised when there was a timeout while resolving a domain to an IP.
#
# source://httpx//lib/httpx/errors.rb#66
class HTTPX::ResolveTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/resolver.rb#7
module HTTPX::Resolver
  private

  # source://httpx//lib/httpx/resolver.rb#54
  def cached_lookup(hostname); end

  # source://httpx//lib/httpx/resolver.rb#61
  def cached_lookup_set(hostname, family, entries); end

  # source://httpx//lib/httpx/resolver.rb#117
  def decode_dns_answer(payload); end

  # source://httpx//lib/httpx/resolver.rb#109
  def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver.rb#105
  def generate_id; end

  # source://httpx//lib/httpx/resolver.rb#41
  def ip_resolve(hostname); end

  # do not use directly!
  #
  # source://httpx//lib/httpx/resolver.rb#87
  def lookup(hostname, ttl); end

  # source://httpx//lib/httpx/resolver.rb#37
  def nolookup_resolve(hostname); end

  # source://httpx//lib/httpx/resolver.rb#25
  def resolver_for(resolver_type); end

  # source://httpx//lib/httpx/resolver.rb#46
  def system_resolve(hostname); end

  class << self
    # source://httpx//lib/httpx/resolver.rb#54
    def cached_lookup(hostname); end

    # source://httpx//lib/httpx/resolver.rb#61
    def cached_lookup_set(hostname, family, entries); end

    # source://httpx//lib/httpx/resolver.rb#117
    def decode_dns_answer(payload); end

    # source://httpx//lib/httpx/resolver.rb#109
    def encode_dns_query(hostname, type: T.unsafe(nil), message_id: T.unsafe(nil)); end

    # source://httpx//lib/httpx/resolver.rb#105
    def generate_id; end

    # source://httpx//lib/httpx/resolver.rb#41
    def ip_resolve(hostname); end

    # do not use directly!
    #
    # source://httpx//lib/httpx/resolver.rb#87
    def lookup(hostname, ttl); end

    # source://httpx//lib/httpx/resolver.rb#37
    def nolookup_resolve(hostname); end

    # source://httpx//lib/httpx/resolver.rb#25
    def resolver_for(resolver_type); end

    # source://httpx//lib/httpx/resolver.rb#46
    def system_resolve(hostname); end
  end
end

# source://httpx//lib/httpx/resolver/https.rb#10
class HTTPX::Resolver::HTTPS < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/https.rb#32
  def initialize(_, options); end

  # source://httpx//lib/httpx/resolver/https.rb#45
  def <<(connection); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def call(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#60
  def closed?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def connecting?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/https.rb#64
  def empty?; end

  # source://httpx//lib/httpx/resolver/https.rb#68
  def resolver_connection; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def state(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def terminate(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_io(*args, **_arg1, &block); end

  private

  # source://httpx//lib/httpx/resolver/https.rb#210
  def build_request(hostname); end

  # source://httpx//lib/httpx/resolver/https.rb#229
  def decode_response_body(response); end

  # source://httpx//lib/httpx/resolver/https.rb#126
  def on_promise(_, stream); end

  # source://httpx//lib/httpx/resolver/https.rb#113
  def on_response(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#131
  def parse(request, response); end

  # source://httpx//lib/httpx/resolver/https.rb#161
  def parse_addresses(answers, request); end

  # source://httpx//lib/httpx/resolver/https.rb#239
  def reset_hostname(hostname, reset_candidates: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/https.rb#82
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/resolver/https.rb#25
HTTPX::Resolver::HTTPS::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/https.rb#14
module HTTPX::Resolver::HTTPS::DNSExtensions; end

# source://httpx//lib/httpx/resolver/https.rb#23
HTTPX::Resolver::HTTPS::NAMESERVER = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/resolver/multi.rb#7
class HTTPX::Resolver::Multi
  include ::HTTPX::Callbacks

  # source://httpx//lib/httpx/resolver/multi.rb#13
  def initialize(resolver_type, options); end

  # source://httpx//lib/httpx/resolver/multi.rb#36
  def close; end

  # source://httpx//lib/httpx/resolver/multi.rb#28
  def closed?; end

  # source://httpx//lib/httpx/resolver/multi.rb#40
  def connections; end

  # source://httpx//lib/httpx/resolver/multi.rb#44
  def early_resolve(connection); end

  # source://httpx//lib/httpx/resolver/multi.rb#11
  def resolvers; end

  # source://httpx//lib/httpx/resolver/multi.rb#32
  def timeout; end

  private

  # source://httpx//lib/httpx/resolver/multi.rb#71
  def on_resolver_close(resolver); end

  # source://httpx//lib/httpx/resolver/multi.rb#63
  def on_resolver_connection(connection); end

  # source://httpx//lib/httpx/resolver/multi.rb#67
  def on_resolver_error(connection, error); end
end

# source://httpx//lib/httpx/resolver/native.rb#7
class HTTPX::Resolver::Native < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/native.rb#24
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/native.rb#87
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/native.rb#56
  def call; end

  # source://httpx//lib/httpx/resolver/native.rb#44
  def close; end

  # source://httpx//lib/httpx/resolver/native.rb#48
  def closed?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/native.rb#107
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/resolver/native.rb#75
  def interests; end

  # source://httpx//lib/httpx/resolver/native.rb#22
  def state; end

  # source://httpx//lib/httpx/resolver/native.rb#99
  def timeout; end

  # source://httpx//lib/httpx/resolver/native.rb#52
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/native.rb#374
  def build_socket; end

  # source://httpx//lib/httpx/resolver/native.rb#113
  def calculate_interests; end

  # source://httpx//lib/httpx/resolver/native.rb#121
  def consume; end

  # source://httpx//lib/httpx/resolver/native.rb#127
  def do_retry(loop_time = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#167
  def dread(wsize = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#217
  def dwrite; end

  # source://httpx//lib/httpx/resolver/native.rb#354
  def encode_dns_query(hostname); end

  # source://httpx//lib/httpx/resolver/native.rb#361
  def generate_candidates(name); end

  # source://httpx//lib/httpx/resolver/native.rb#417
  def handle_error(error); end

  # source://httpx//lib/httpx/resolver/native.rb#235
  def parse(buffer); end

  # source://httpx//lib/httpx/resolver/native.rb#277
  def parse_addresses(addresses); end

  # source://httpx//lib/httpx/resolver/native.rb#428
  def reset_hostname(hostname, connection: T.unsafe(nil), reset_candidates: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#329
  def resolve(connection = T.unsafe(nil), hostname = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/native.rb#389
  def transition(nextstate); end
end

# source://httpx//lib/httpx/resolver/native.rb#11
HTTPX::Resolver::Native::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/native.rb#18
HTTPX::Resolver::Native::DNS_PORT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver.rb#8
HTTPX::Resolver::RESOLVE_TIMEOUT = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/resolver/resolver.rb#7
class HTTPX::Resolver::Resolver
  include ::HTTPX::Callbacks
  include ::HTTPX::Loggable

  # source://httpx//lib/httpx/resolver/resolver.rb#33
  def initialize(family, options); end

  # source://httpx//lib/httpx/resolver/resolver.rb#39
  def close; end

  # source://httpx//lib/httpx/resolver/resolver.rb#43
  def closed?; end

  # source://httpx//lib/httpx/resolver/resolver.rb#51
  def emit_addresses(connection, family, addresses, early_resolve = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#47
  def empty?; end

  # source://httpx//lib/httpx/resolver/resolver.rb#29
  def family; end

  # source://httpx//lib/httpx/resolver/resolver.rb#31
  def pool=(_arg0); end

  # source://httpx//lib/httpx/resolver/resolver.rb#39
  def terminate; end

  private

  # source://httpx//lib/httpx/resolver/resolver.rb#95
  def early_resolve(connection, hostname: T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#107
  def emit_resolve_error(connection, hostname = T.unsafe(nil), ex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/resolver.rb#80
  def emit_resolved_connection(connection, addresses, early_resolve); end

  # source://httpx//lib/httpx/resolver/resolver.rb#111
  def resolve_error(hostname, ex = T.unsafe(nil)); end

  class << self
    # source://httpx//lib/httpx/resolver/resolver.rb#24
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/resolver.rb#18
HTTPX::Resolver::Resolver::FAMILY_TYPES = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/resolver.rb#13
HTTPX::Resolver::Resolver::RECORD_TYPES = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/resolver/system.rb#7
class HTTPX::Resolver::System < ::HTTPX::Resolver::Resolver
  extend ::Forwardable

  # source://httpx//lib/httpx/resolver/system.rb#29
  def initialize(options); end

  # source://httpx//lib/httpx/resolver/system.rb#90
  def <<(connection); end

  # source://httpx//lib/httpx/resolver/system.rb#66
  def call; end

  # source://httpx//lib/httpx/resolver/system.rb#54
  def close; end

  # source://httpx//lib/httpx/resolver/system.rb#58
  def closed?; end

  # source://httpx//lib/httpx/resolver/system.rb#50
  def connections; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/resolver/system.rb#95
  def handle_socket_timeout(interval); end

  # source://httpx//lib/httpx/resolver/system.rb#74
  def interests; end

  # source://httpx//lib/httpx/resolver/system.rb#44
  def resolvers; end

  # source://httpx//lib/httpx/resolver/system.rb#25
  def state; end

  # source://httpx//lib/httpx/resolver/system.rb#80
  def timeout; end

  # source://httpx//lib/httpx/resolver/system.rb#62
  def to_io; end

  private

  # source://httpx//lib/httpx/resolver/system.rb#210
  def __addrinfo_resolve(host, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#164
  def async_resolve(connection, hostname, scheme); end

  # source://httpx//lib/httpx/resolver/system.rb#120
  def consume; end

  # source://httpx//lib/httpx/resolver/system.rb#147
  def resolve(connection = T.unsafe(nil)); end

  # source://httpx//lib/httpx/resolver/system.rb#103
  def transition(nextstate); end

  class << self
    # source://httpx//lib/httpx/resolver/system.rb#20
    def multi?; end
  end
end

# source://httpx//lib/httpx/resolver/system.rb#16
HTTPX::Resolver::System::DONE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#17
HTTPX::Resolver::System::ERROR = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/resolver/system.rb#11
HTTPX::Resolver::System::RESOLV_ERRORS = T.let(T.unsafe(nil), Array)

# Defines a HTTP response is handled internally, with a few properties exposed as attributes,
# implements (indirectly, via the +body+) the IO write protocol to internally buffer payloads,
# implements the IO reader protocol in order for users to buffer/stream it, acts as an enumerable
# (of payload chunks).
#
# source://httpx//lib/httpx/response.rb#14
class HTTPX::Response
  include ::HTTPX::Callbacks
  include ::HTTPX::ResponsePatternMatchExtensions
  extend ::Forwardable

  # inits the instance with the corresponding +request+ to this response, an the
  # response HTTP +status+, +version+ and HTTPX::Headers instance of +headers+.
  #
  # @return [Response] a new instance of Response
  #
  # source://httpx//lib/httpx/response.rb#52
  def initialize(request, status, version, headers); end

  # writes +data+ chunk into the response body.
  #
  # source://httpx//lib/httpx/response.rb#69
  def <<(data); end

  # a HTTPX::Response::Body object wrapping the response body.
  #
  # source://httpx//lib/httpx/response.rb#25
  def body; end

  # returns whether the response contains body payload.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#93
  def bodyless?; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def close(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#106
  def complete?; end

  # returns the HTTPX::ContentType for the response, as per what's declared in the content-type header.
  #
  #   response.content_type #=> #<HTTPX::ContentType:xxx @header_value="text/plain">
  #   response.content_type.mime_type #=> "text/plain"
  #
  # source://httpx//lib/httpx/response.rb#77
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def copy_to(*args, **_arg1, &block); end

  # returns an instance of HTTPX::HTTPError if the response has a 4xx or 5xx
  # status code, or nothing.
  #
  #   ok_response.error #=> nil
  #   not_found_response.error #=> HTTPX::HTTPError instance, status 404
  #
  # source://httpx//lib/httpx/response.rb#125
  def error; end

  # marks the response as finished, freezes the headers.
  #
  # source://httpx//lib/httpx/response.rb#87
  def finish!; end

  # returns whether the response has been fully fetched.
  #
  # @return [Boolean]
  #
  # source://httpx//lib/httpx/response.rb#82
  def finished?; end

  # decodes the response payload into a ruby object **if** the payload is valid
  # "application/x-www-urlencoded" or "multipart/form-data".
  #
  # source://httpx//lib/httpx/response.rb#151
  def form; end

  # an HTTPX::Headers object containing the response HTTP headers.
  #
  # source://httpx//lib/httpx/response.rb#22
  def headers; end

  # :nocov:
  #
  # source://httpx//lib/httpx/response.rb#111
  def inspect; end

  # decodes the response payload into a ruby object **if** the payload is valid json.
  #
  #   response.json #> { "foo" => "bar" } for "{\"foo\":\"bar\"}" payload
  #   response.json(symbolize_names: true) #> { foo: "bar" } for "{\"foo\":\"bar\"}" payload
  #
  # source://httpx//lib/httpx/response.rb#145
  def json(*args); end

  # merges headers defined in +h+ into the response headers.
  #
  # source://httpx//lib/httpx/response.rb#64
  def merge_headers(h); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def peer_address(*args, **_arg1, &block); end

  # it raises the exception returned by +error+, or itself otherwise.
  #
  #   ok_response.raise_for_status #=> ok_response
  #   not_found_response.raise_for_status #=> raises HTTPX::HTTPError exception
  #
  # source://httpx//lib/httpx/response.rb#135
  def raise_for_status; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def read(*args, **_arg1, &block); end

  # the HTTP response status code
  #
  # source://httpx//lib/httpx/response.rb#19
  def status; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def uri(*args, **_arg1, &block); end

  # The HTTP protocol version used to fetch the response.
  #
  # source://httpx//lib/httpx/response.rb#28
  def version; end

  # decodes the response payload into a Nokogiri::XML::Node object **if** the payload is valid
  # "application/xml" (requires the "nokogiri" gem).
  #
  # source://httpx//lib/httpx/response.rb#157
  def xml; end

  private

  # decodes the response payload using the given +transcoder+, which implements the decoding logic.
  #
  # +transcoder+ must implement the internal transcoder API, i.e. respond to <tt>decode(HTTPX::Response response)</tt>,
  # which returns a decoder which responds to <tt>call(HTTPX::Response response, **kwargs)</tt>
  #
  # @raise [Error]
  #
  # source://httpx//lib/httpx/response.rb#167
  def decode(transcoder, *args); end
end

# source://httpx//lib/httpx/response/body.rb#7
class HTTPX::Response::Body
  # source://httpx//lib/httpx/response/body.rb#15
  def initialize(response, options); end

  # source://httpx//lib/httpx/response/body.rb#139
  def ==(other); end

  # source://httpx//lib/httpx/response/body.rb#71
  def bytesize; end

  # source://httpx//lib/httpx/response/body.rb#130
  def close; end

  # source://httpx//lib/httpx/response/body.rb#35
  def closed?; end

  # source://httpx//lib/httpx/response/body.rb#117
  def copy_to(dest); end

  # source://httpx//lib/httpx/response/body.rb#76
  def each; end

  # source://httpx//lib/httpx/response/body.rb#108
  def empty?; end

  # source://httpx//lib/httpx/response/body.rb#9
  def encoding; end

  # source://httpx//lib/httpx/response/body.rb#12
  def encodings; end

  # source://httpx//lib/httpx/response/body.rb#92
  def filename; end

  # source://httpx//lib/httpx/response/body.rb#150
  def inspect; end

  # source://httpx//lib/httpx/response/body.rb#58
  def read(*args); end

  # source://httpx//lib/httpx/response/body.rb#158
  def rewind; end

  # source://httpx//lib/httpx/response/body.rb#99
  def to_s; end

  # source://httpx//lib/httpx/response/body.rb#99
  def to_str; end

  # source://httpx//lib/httpx/response/body.rb#41
  def write(chunk); end

  private

  # source://httpx//lib/httpx/response/body.rb#218
  def _with_same_buffer_pos; end

  # source://httpx//lib/httpx/response/body.rb#192
  def decode_chunk(chunk); end

  # source://httpx//lib/httpx/response/body.rb#29
  def initialize_dup(other); end

  # source://httpx//lib/httpx/response/body.rb#170
  def initialize_inflaters; end

  # source://httpx//lib/httpx/response/body.rb#201
  def transition(nextstate); end

  class << self
    # source://httpx//lib/httpx/response/body.rb#232
    def initialize_inflater_by_encoding(encoding, response, **kwargs); end
  end
end

# source://httpx//lib/httpx/response/buffer.rb#9
class HTTPX::Response::Buffer < ::SimpleDelegator
  # source://httpx//lib/httpx/response/buffer.rb#12
  def initialize(threshold_size:, bytesize: T.unsafe(nil), encoding: T.unsafe(nil)); end

  # source://httpx//lib/httpx/response/buffer.rb#59
  def close; end

  # source://httpx//lib/httpx/response/buffer.rb#27
  def size; end

  # source://httpx//lib/httpx/response/buffer.rb#39
  def to_s; end

  # source://httpx//lib/httpx/response/buffer.rb#32
  def write(chunk); end

  private

  # source://httpx//lib/httpx/response/buffer.rb#86
  def _with_same_buffer_pos; end

  # source://httpx//lib/httpx/response/buffer.rb#20
  def initialize_dup(other); end

  # source://httpx//lib/httpx/response/buffer.rb#68
  def try_upgrade_buffer; end
end

# source://httpx//lib/httpx/pmatch_extensions.rb#4
module HTTPX::ResponsePatternMatchExtensions
  # source://httpx//lib/httpx/pmatch_extensions.rb#5
  def deconstruct; end

  # source://httpx//lib/httpx/pmatch_extensions.rb#9
  def deconstruct_keys(_keys); end
end

# session may be overridden by certain adapters.
#
# source://httpx//lib/httpx/session.rb#345
HTTPX::S = HTTPX::Session

# source://httpx//lib/httpx/io/ssl.rb#8
class HTTPX::SSL < ::HTTPX::TCP
  # @return [SSL] a new instance of SSL
  #
  # source://httpx//lib/httpx/io/ssl.rb#18
  def initialize(_, _, options); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#71
  def can_verify_peer?; end

  # source://httpx//lib/httpx/io/ssl.rb#94
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#82
  def connected?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#86
  def expired?; end

  # in jruby, alpn_protocol may return ""
  # https://github.com/jruby/jruby-openssl/issues/287
  #
  # source://httpx//lib/httpx/io/ssl.rb#51
  def protocol; end

  # session_new_cb not implemented under JRuby
  #
  # source://httpx//lib/httpx/io/ssl.rb#43
  def session_new_cb(&pr); end

  # Sets the attribute ssl_session
  #
  # @param value the value to set the attribute ssl_session to.
  #
  # source://httpx//lib/httpx/io/ssl.rb#16
  def ssl_session=(_arg0); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/ssl.rb#90
  def ssl_session_expired?; end

  # source://httpx//lib/httpx/io/ssl.rb#116
  def try_ssl_connect; end

  # source://httpx//lib/httpx/io/ssl.rb#75
  def verify_hostname(host); end

  private

  # source://httpx//lib/httpx/io/ssl.rb#146
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/ssl.rb#134
  def transition(nextstate); end
end

# source://httpx//lib/httpx/io/ssl.rb#10
HTTPX::SSL::TLS_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://httpx//lib/httpx/selector.rb#5
class HTTPX::Selector
  # @return [Selector] a new instance of Selector
  #
  # source://httpx//lib/httpx/selector.rb#12
  def initialize; end

  # deregisters +io+ from selectables.
  #
  # source://httpx//lib/httpx/selector.rb#17
  def deregister(io); end

  # register +io+.
  #
  # source://httpx//lib/httpx/selector.rb#22
  def register(io); end

  # source://httpx//lib/httpx/selector.rb#124
  def select(interval, &block); end

  private

  # source://httpx//lib/httpx/selector.rb#30
  def select_many(interval, &block); end

  # source://httpx//lib/httpx/selector.rb#98
  def select_one(interval); end
end

# source://httpx//lib/httpx/selector.rb#6
HTTPX::Selector::READABLE = T.let(T.unsafe(nil), Array)

# source://httpx//lib/httpx/selector.rb#7
HTTPX::Selector::WRITABLE = T.let(T.unsafe(nil), Array)

# Class implementing the APIs being used publicly.
#
#   HTTPX.get(..) #=> delegating to an internal HTTPX::Session object.
#   HTTPX.plugin(..).get(..) #=> creating an intermediate HTTPX::Session with plugin, then sending the GET request
#
# source://httpx//lib/httpx/session.rb#8
class HTTPX::Session
  include ::HTTPX::Loggable
  include ::HTTPX::Chainable

  # initializes the session with a set of +options+, which will be shared by all
  # requests sent from it.
  #
  # When pass a block, it'll yield itself to it, then closes after the block is evaluated.
  #
  # @return [Session] a new instance of Session
  #
  # source://httpx//lib/httpx/session.rb#18
  def initialize(options = T.unsafe(nil), &blk); end

  # returns a HTTP::Request instance built from the HTTP +verb+, the request +uri+, and
  # the optional set of request-specific +options+. This request **must** be sent through
  # the same session it was built from.
  #
  #   req = session.build_request("GET", "https://server.com")
  #   resp = session.request(req)
  #
  # source://httpx//lib/httpx/session.rb#84
  def build_request(verb, uri, options = T.unsafe(nil)); end

  # closes all the active connections from the session
  #
  # source://httpx//lib/httpx/session.rb#44
  def close(*args); end

  # performs one, or multple requests; it accepts:
  #
  # 1. one or multiple HTTPX::Request objects;
  # 2. an HTTP verb, then a sequence of URIs or URI/options tuples;
  # 3. one or multiple HTTP verb / uri / (optional) options tuples;
  #
  # when present, the set of +options+ kwargs is applied to all of the
  # sent requests.
  #
  # respectively returns a single HTTPX::Response response, or all of them in an Array, in the same order.
  #
  #  resp1 = session.request(req1)
  #  resp1, resp2 = session.request(req1, req2)
  #  resp1 = session.request("GET", "https://server.org/a")
  #  resp1, resp2 = session.request("GET", ["https://server.org/a", "https://server.org/b"])
  #  resp1, resp2 = session.request(["GET", "https://server.org/a"], ["GET", "https://server.org/b"])
  #  resp1 = session.request("POST", "https://server.org/a", form: { "foo" => "bar" })
  #  resp1, resp2 = session.request(["POST", "https://server.org/a", form: { "foo" => "bar" }], ["GET", "https://server.org/b"])
  #  resp1, resp2 = session.request("GET", ["https://server.org/a", "https://server.org/b"], headers: { "x-api-token" => "TOKEN" })
  #
  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#68
  def request(*args, **options); end

  # Yields itself the block, then closes it after the block is evaluated.
  #
  #   session.wrap do |http|
  #     http.get("https://wikipedia.com")
  #   end # wikipedia connection closes here
  #
  # source://httpx//lib/httpx/session.rb#30
  def wrap; end

  private

  # sends an array of HTTPX::Request objects
  #
  # source://httpx//lib/httpx/session.rb#234
  def _send_requests(requests); end

  # returns an HTTPX::Connection for the negotiated Alternative Service (or none).
  #
  # source://httpx//lib/httpx/session.rb#160
  def build_altsvc_connection(existing_connection, connections, alt_origin, origin, alt_params, options); end

  # returns a set of HTTPX::Request objects built from the given +args+ and +options+.
  #
  # @raise [ArgumentError]
  #
  # source://httpx//lib/httpx/session.rb#191
  def build_requests(*args, options); end

  # returns the corresponding HTTP::Response to the given +request+ if it has been received.
  #
  # source://httpx//lib/httpx/session.rb#113
  def fetch_response(request, _, _); end

  # returns the HTTPX::Connection through which the +request+ should be sent through.
  #
  # source://httpx//lib/httpx/session.rb#118
  def find_connection(request, connections, options); end

  # source://httpx//lib/httpx/session.rb#219
  def init_connection(uri, options); end

  # callback executed when an HTTP/2 promise frame has been received.
  #
  # source://httpx//lib/httpx/session.rb#107
  def on_promise(_, stream); end

  # callback executed when a response for a given request has been received.
  #
  # source://httpx//lib/httpx/session.rb#102
  def on_response(request, response); end

  # returns the HTTPX::Pool object which manages the networking required to
  # perform requests.
  #
  # source://httpx//lib/httpx/session.rb#97
  def pool; end

  # returns the array of HTTPX::Response objects corresponding to the array of HTTPX::Request +requests+.
  #
  # source://httpx//lib/httpx/session.rb#245
  def receive_requests(requests, connections); end

  # source://httpx//lib/httpx/session.rb#129
  def send_request(request, connections, options = T.unsafe(nil)); end

  # sends an array of HTTPX::Request +requests+, returns the respective array of HTTPX::Response objects.
  #
  # source://httpx//lib/httpx/session.rb#228
  def send_requests(*requests); end

  # sets the callbacks on the +connection+ required to process certain specific
  # connection lifecycle events which deal with request rerouting.
  #
  # source://httpx//lib/httpx/session.rb#141
  def set_connection_callbacks(connection, connections, options); end

  # source://httpx//lib/httpx/session.rb#214
  def set_request_callbacks(request); end

  class << self
    # Returns the value of attribute default_options.
    #
    # source://httpx//lib/httpx/session.rb#289
    def default_options; end

    # @private
    #
    # source://httpx//lib/httpx/session.rb#291
    def inherited(klass); end

    # returns a new HTTPX::Session instance, with the plugin pointed by +pl+ loaded.
    #
    #   session_with_retries = session.plugin(:retries)
    #   session_with_custom = session.plugin(CustomPlugin)
    #
    # source://httpx//lib/httpx/session.rb#303
    def plugin(pl, options = T.unsafe(nil), &block); end
  end
end

# source://httpx//lib/httpx/session.rb#12
HTTPX::Session::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Error raised when there was a timeout while waiting for the HTTP/2 settings frame from the server.
#
# source://httpx//lib/httpx/errors.rb#63
class HTTPX::SettingsTimeoutError < ::HTTPX::TimeoutError; end

# source://httpx//lib/httpx/io/tcp.rb#7
class HTTPX::TCP
  include ::HTTPX::Loggable

  # @return [TCP] a new instance of TCP
  #
  # source://httpx//lib/httpx/io/tcp.rb#16
  def initialize(origin, addresses, options); end

  # source://httpx//lib/httpx/io/tcp.rb#47
  def add_addresses(addrs); end

  # Returns the value of attribute addresses.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def addresses; end

  # source://httpx//lib/httpx/io/tcp.rb#139
  def close; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#153
  def closed?; end

  # source://httpx//lib/httpx/io/tcp.rb#70
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#149
  def connected?; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/tcp.rb#157
  def expired?; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/tcp.rb#169
  def inspect; end

  # Returns the value of attribute interests.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def interests; end

  # Returns the value of attribute ip.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def ip; end

  # Returns the value of attribute port.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def port; end

  # source://httpx//lib/httpx/io/tcp.rb#66
  def protocol; end

  # source://httpx//lib/httpx/io/tcp.rb#116
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/tcp.rb#43
  def socket; end

  # Returns the value of attribute state.
  #
  # source://httpx//lib/httpx/io/tcp.rb#12
  def state; end

  # source://httpx//lib/httpx/io/tcp.rb#62
  def to_io; end

  # source://httpx//lib/httpx/io/tcp.rb#128
  def write(buffer); end

  private

  # source://httpx//lib/httpx/io/tcp.rb#176
  def build_socket; end

  # source://httpx//lib/httpx/io/tcp.rb#192
  def do_transition(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#197
  def log_transition_state(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#181
  def transition(nextstate); end

  # source://httpx//lib/httpx/io/tcp.rb#98
  def try_connect; end
end

# source://httpx//lib/httpx/io/ssl.rb#6
HTTPX::TLSError = OpenSSL::SSL::SSLError

# Error raised when there was a timeout. Its subclasses allow for finer-grained
# control of which timeout happened.
#
# source://httpx//lib/httpx/errors.rb#13
class HTTPX::TimeoutError < ::HTTPX::Error
  # initializes the timeout exception with the +timeout+ causing the error, and the
  # error +message+ for it.
  #
  # @return [TimeoutError] a new instance of TimeoutError
  #
  # source://httpx//lib/httpx/errors.rb#19
  def initialize(timeout, message); end

  # The timeout value which caused this error to be raised.
  #
  # source://httpx//lib/httpx/errors.rb#15
  def timeout; end

  # clones this error into a HTTPX::ConnectionTimeoutError.
  #
  # source://httpx//lib/httpx/errors.rb#25
  def to_connection_error; end
end

# source://httpx//lib/httpx/timers.rb#4
class HTTPX::Timers
  # @return [Timers] a new instance of Timers
  #
  # source://httpx//lib/httpx/timers.rb#5
  def initialize; end

  # source://httpx//lib/httpx/timers.rb#9
  def after(interval_in_secs, cb = T.unsafe(nil), &blk); end

  # source://httpx//lib/httpx/timers.rb#40
  def fire(error = T.unsafe(nil)); end

  # source://httpx//lib/httpx/timers.rb#32
  def wait_interval; end
end

# source://httpx//lib/httpx/timers.rb#51
class HTTPX::Timers::Interval
  include ::Comparable

  # @return [Interval] a new instance of Interval
  #
  # source://httpx//lib/httpx/timers.rb#56
  def initialize(interval); end

  # source://httpx//lib/httpx/timers.rb#80
  def <<(callback); end

  # source://httpx//lib/httpx/timers.rb#66
  def <=>(other); end

  # source://httpx//lib/httpx/timers.rb#70
  def ==(other); end

  # source://httpx//lib/httpx/timers.rb#84
  def delete(callback); end

  # source://httpx//lib/httpx/timers.rb#97
  def elapse(elapsed); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/timers.rb#93
  def elapsed?; end

  # Returns the value of attribute interval.
  #
  # source://httpx//lib/httpx/timers.rb#54
  def interval; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/timers.rb#89
  def no_callbacks?; end

  # source://httpx//lib/httpx/timers.rb#62
  def on_empty(&blk); end

  # source://httpx//lib/httpx/timers.rb#76
  def to_f; end
end

# source://httpx//lib/httpx/transcoder.rb#4
module HTTPX::Transcoder
  private

  # source://httpx//lib/httpx/transcoder.rb#7
  def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

  # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
  #
  # source://httpx//lib/httpx/transcoder.rb#28
  def normalize_query(params, name, v, depth); end

  # source://httpx//lib/httpx/transcoder.rb#71
  def params_hash_has_key?(hash, key); end

  class << self
    # source://httpx//lib/httpx/transcoder.rb#7
    def normalize_keys(key, value, cond = T.unsafe(nil), &block); end

    # based on https://github.com/rack/rack/blob/d15dd728440710cfc35ed155d66a98dc2c07ae42/lib/rack/query_parser.rb#L82
    #
    # @raise [Error]
    #
    # source://httpx//lib/httpx/transcoder.rb#28
    def normalize_query(params, name, v, depth); end

    # @return [Boolean]
    #
    # source://httpx//lib/httpx/transcoder.rb#71
    def params_hash_has_key?(hash, key); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#6
module HTTPX::Transcoder::Body
  private

  # source://httpx//lib/httpx/transcoder/body.rb#53
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/body.rb#53
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/body.rb#11
class HTTPX::Transcoder::Body::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/body.rb#16
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/body.rb#20
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/body.rb#36
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  private

  # source://httpx//lib/httpx/transcoder/body.rb#46
  def method_missing(meth, *args, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/body.rb#42
  def respond_to_missing?(meth, *args); end
end

# source://httpx//lib/httpx/transcoder/body.rb#7
class HTTPX::Transcoder::Body::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/utils/body_reader.rb#7
class HTTPX::Transcoder::BodyReader
  # @return [BodyReader] a new instance of BodyReader
  #
  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#8
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#19
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#41
  def close; end

  # source://httpx//lib/httpx/transcoder/utils/body_reader.rb#25
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#6
module HTTPX::Transcoder::Chunker
  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#111
  def encode(chunks); end

  class << self
    # source://httpx//lib/httpx/transcoder/chunker.rb#111
    def encode(chunks); end
  end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#9
HTTPX::Transcoder::Chunker::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/chunker.rb#32
class HTTPX::Transcoder::Chunker::Decoder
  extend ::Forwardable

  # @return [Decoder] a new instance of Decoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#41
  def initialize(buffer, trailers = T.unsafe(nil)); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def <<(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def clear(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/chunker.rb#53
  def each; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def empty?(*args, **_arg1, &block); end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#98
  def finished?; end

  # source://httpx//lib/httpx/transcoder/chunker.rb#49
  def to_s; end

  private

  # source://httpx//lib/httpx/transcoder/chunker.rb#104
  def nextstate(state); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#11
class HTTPX::Transcoder::Chunker::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#14
  def initialize(body); end

  # @yield ["0#{CRLF}"]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#18
  def each; end

  private

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/transcoder/chunker.rb#27
  def respond_to_missing?(meth, *args); end
end

# source://httpx//lib/httpx/transcoder/chunker.rb#7
class HTTPX::Transcoder::Chunker::Error < ::HTTPX::Error; end

# source://httpx//lib/httpx/transcoder/deflate.rb#8
module HTTPX::Transcoder::Deflate
  private

  # source://httpx//lib/httpx/transcoder/deflate.rb#31
  def decode(response, bytesize: T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/deflate.rb#27
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/deflate.rb#31
    def decode(response, bytesize: T.unsafe(nil)); end

    # source://httpx//lib/httpx/transcoder/deflate.rb#27
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/deflate.rb#9
class HTTPX::Transcoder::Deflate::Deflater < ::HTTPX::Transcoder::Deflater
  # source://httpx//lib/httpx/transcoder/deflate.rb#10
  def deflate(chunk); end
end

# source://httpx//lib/httpx/transcoder/utils/deflater.rb#8
class HTTPX::Transcoder::Deflater
  extend ::Forwardable

  # @return [Deflater] a new instance of Deflater
  #
  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#13
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#19
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#44
  def close; end

  # Returns the value of attribute content_type.
  #
  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#11
  def content_type; end

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#25
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  private

  # source://httpx//lib/httpx/transcoder/utils/deflater.rb#57
  def buffer_deflate!; end
end

# source://httpx//lib/httpx/transcoder/form.rb#9
module HTTPX::Transcoder::Form
  private

  # source://httpx//lib/httpx/transcoder/form.rb#56
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/form.rb#48
  def encode(form); end

  # source://httpx//lib/httpx/transcoder/form.rb#69
  def multipart?(data); end

  class << self
    # source://httpx//lib/httpx/transcoder/form.rb#56
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/form.rb#48
    def encode(form); end

    # @return [Boolean]
    #
    # source://httpx//lib/httpx/transcoder/form.rb#69
    def multipart?(data); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#38
module HTTPX::Transcoder::Form::Decoder
  private

  # source://httpx//lib/httpx/transcoder/form.rb#41
  def call(response, *_arg1); end

  class << self
    # source://httpx//lib/httpx/transcoder/form.rb#41
    def call(response, *_arg1); end
  end
end

# source://httpx//lib/httpx/transcoder/form.rb#14
class HTTPX::Transcoder::Form::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/form.rb#23
  def initialize(form); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/form.rb#33
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_str(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/form.rb#12
HTTPX::Transcoder::Form::PARAM_DEPTH_LIMIT = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/transcoder/gzip.rb#10
module HTTPX::Transcoder::GZIP
  private

  # source://httpx//lib/httpx/transcoder/gzip.rb#68
  def decode(response, bytesize: T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#64
  def encode(body); end

  class << self
    # source://httpx//lib/httpx/transcoder/gzip.rb#68
    def decode(response, bytesize: T.unsafe(nil)); end

    # source://httpx//lib/httpx/transcoder/gzip.rb#64
    def encode(body); end
  end
end

# source://httpx//lib/httpx/transcoder/gzip.rb#11
class HTTPX::Transcoder::GZIP::Deflater < ::HTTPX::Transcoder::Deflater
  # @return [Deflater] a new instance of Deflater
  #
  # source://httpx//lib/httpx/transcoder/gzip.rb#12
  def initialize(body); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#17
  def deflate(chunk); end

  private

  # source://httpx//lib/httpx/transcoder/gzip.rb#38
  def compressed_chunk; end

  # source://httpx//lib/httpx/transcoder/gzip.rb#34
  def write(chunk); end
end

# source://httpx//lib/httpx/transcoder/gzip.rb#45
class HTTPX::Transcoder::GZIP::Inflater
  # @return [Inflater] a new instance of Inflater
  #
  # source://httpx//lib/httpx/transcoder/gzip.rb#46
  def initialize(bytesize); end

  # source://httpx//lib/httpx/transcoder/gzip.rb#51
  def call(chunk); end
end

# source://httpx//lib/httpx/transcoder/json.rb#6
module HTTPX::Transcoder::JSON
  private

  # source://httpx//lib/httpx/transcoder/json.rb#32
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/json.rb#28
  def encode(json); end

  # source://httpx//lib/httpx/transcoder/json.rb#53
  def json_dump(*args); end

  # source://httpx//lib/httpx/transcoder/json.rb#52
  def json_load(*args); end

  class << self
    # @raise [HTTPX::Error]
    #
    # source://httpx//lib/httpx/transcoder/json.rb#32
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/json.rb#28
    def encode(json); end

    # source://httpx//lib/httpx/transcoder/json.rb#53
    def json_dump(*args); end

    # source://httpx//lib/httpx/transcoder/json.rb#52
    def json_load(*args); end
  end
end

# source://httpx//lib/httpx/transcoder/json.rb#11
class HTTPX::Transcoder::JSON::Encoder
  extend ::Forwardable

  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/json.rb#18
  def initialize(json); end

  # source://forwardable/1.3.3/forwardable.rb#231
  def bytesize(*args, **_arg1, &block); end

  # source://httpx//lib/httpx/transcoder/json.rb#23
  def content_type; end

  # source://forwardable/1.3.3/forwardable.rb#231
  def to_s(*args, **_arg1, &block); end
end

# source://httpx//lib/httpx/transcoder/json.rb#9
HTTPX::Transcoder::JSON::JSON_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/encoder.rb#4
module HTTPX::Transcoder::Multipart; end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#20
class HTTPX::Transcoder::Multipart::Decoder
  include ::HTTPX::Utils

  # @return [Decoder] a new instance of Decoder
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#30
  def initialize(response); end

  # @raise [Error]
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#43
  def call(response, *_arg1); end

  private

  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#57
  def parse; end
end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#24
HTTPX::Transcoder::Multipart::Decoder::BOUNDARY_RE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#23
HTTPX::Transcoder::Multipart::Decoder::CRLF = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#26
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_DISPOSITION = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#27
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_ID = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#25
HTTPX::Transcoder::Multipart::Decoder::MULTIPART_CONTENT_TYPE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#28
HTTPX::Transcoder::Multipart::Decoder::WINDOW_SIZE = T.let(T.unsafe(nil), Integer)

# source://httpx//lib/httpx/transcoder/multipart/encoder.rb#5
class HTTPX::Transcoder::Multipart::Encoder
  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#8
  def initialize(form); end

  # Returns the value of attribute bytesize.
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#6
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#17
  def content_type; end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#21
  def read(length = T.unsafe(nil), outbuf = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#30
  def rewind; end

  private

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#70
  def header_part(key, content_type, filename); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#78
  def read_chunks(buffer, length = T.unsafe(nil)); end

  # if there's a current part to read from, tries to read a chunk.
  #
  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#95
  def read_from_part(max_length = T.unsafe(nil)); end

  # source://httpx//lib/httpx/transcoder/multipart/encoder.rb#43
  def to_parts(form); end
end

# source://httpx//lib/httpx/transcoder/multipart/decoder.rb#9
class HTTPX::Transcoder::Multipart::FilePart < ::SimpleDelegator
  # @return [FilePart] a new instance of FilePart
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#12
  def initialize(filename, content_type); end

  # Returns the value of attribute content_type.
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#10
  def content_type; end

  # Returns the value of attribute original_filename.
  #
  # source://httpx//lib/httpx/transcoder/multipart/decoder.rb#10
  def original_filename; end
end

# source://httpx//lib/httpx/transcoder/multipart.rb#10
HTTPX::Transcoder::Multipart::MULTIPART_VALUE_COND = T.let(T.unsafe(nil), Proc)

# source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#5
module HTTPX::Transcoder::Multipart::MimeTypeDetector
  private

  # source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#26
  def call(file, filename); end

  class << self
    # source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#26
    def call(file, filename); end
  end
end

# source://httpx//lib/httpx/transcoder/multipart/mime_type_detector.rb#8
HTTPX::Transcoder::Multipart::MimeTypeDetector::DEFAULT_MIMETYPE = T.let(T.unsafe(nil), String)

# source://httpx//lib/httpx/transcoder/multipart/part.rb#5
module HTTPX::Transcoder::Multipart::Part
  private

  # source://httpx//lib/httpx/transcoder/multipart/part.rb#8
  def call(value); end

  class << self
    # source://httpx//lib/httpx/transcoder/multipart/part.rb#8
    def call(value); end
  end
end

# source://httpx//lib/httpx/transcoder/xml.rb#8
module HTTPX::Transcoder::Xml
  private

  # source://httpx//lib/httpx/transcoder/xml.rb#39
  def decode(response); end

  # source://httpx//lib/httpx/transcoder/xml.rb#32
  def encode(xml); end

  class << self
    # source://httpx//lib/httpx/transcoder/xml.rb#39
    def decode(response); end

    # source://httpx//lib/httpx/transcoder/xml.rb#32
    def encode(xml); end
  end
end

# source://httpx//lib/httpx/transcoder/xml.rb#13
class HTTPX::Transcoder::Xml::Encoder
  # @return [Encoder] a new instance of Encoder
  #
  # source://httpx//lib/httpx/transcoder/xml.rb#14
  def initialize(xml); end

  # source://httpx//lib/httpx/transcoder/xml.rb#23
  def bytesize; end

  # source://httpx//lib/httpx/transcoder/xml.rb#18
  def content_type; end

  # source://httpx//lib/httpx/transcoder/xml.rb#27
  def to_s; end
end

# source://httpx//lib/httpx/transcoder/xml.rb#11
HTTPX::Transcoder::Xml::MIME_TYPES = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/io/udp.rb#6
class HTTPX::UDP
  include ::HTTPX::Loggable

  # @return [UDP] a new instance of UDP
  #
  # source://httpx//lib/httpx/io/udp.rb#9
  def initialize(ip, port, options); end

  # source://httpx//lib/httpx/io/udp.rb#26
  def close; end

  # source://httpx//lib/httpx/io/udp.rb#20
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/udp.rb#22
  def connected?; end

  # source://httpx//lib/httpx/io/udp.rb#51
  def read(size, buffer); end

  # source://httpx//lib/httpx/io/udp.rb#16
  def to_io; end

  # In JRuby, sendmsg_nonblock is not implemented
  #
  # source://httpx//lib/httpx/io/udp.rb#39
  def write(buffer); end
end

# source://httpx//lib/httpx/io/unix.rb#4
class HTTPX::UNIX < ::HTTPX::TCP
  # @return [UNIX] a new instance of UNIX
  #
  # source://httpx//lib/httpx/io/unix.rb#11
  def initialize(origin, addresses, options); end

  # source://httpx//lib/httpx/io/unix.rb#35
  def connect; end

  # @return [Boolean]
  #
  # source://httpx//lib/httpx/io/unix.rb#52
  def expired?; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#7
  def host; end

  # :nocov:
  #
  # source://httpx//lib/httpx/io/unix.rb#57
  def inspect; end

  # Returns the value of attribute path.
  #
  # source://httpx//lib/httpx/io/unix.rb#7
  def path; end

  private

  # source://httpx//lib/httpx/io/unix.rb#64
  def build_socket; end
end

# source://httpx//lib/httpx/extensions.rb#36
module HTTPX::URIExtensions; end

# source://httpx//lib/httpx/errors.rb#7
class HTTPX::UnsupportedSchemeError < ::HTTPX::Error; end

# source://httpx//lib/httpx/utils.rb#4
module HTTPX::Utils
  private

  # source://httpx//lib/httpx/utils.rb#18
  def elapsed_time(monotonic_timestamp); end

  # source://httpx//lib/httpx/utils.rb#33
  def get_filename(header, _prefix_regex = T.unsafe(nil)); end

  # source://httpx//lib/httpx/utils.rb#14
  def now; end

  # The value of this field can be either an HTTP-date or a number of
  # seconds to delay after the response is received.
  #
  # source://httpx//lib/httpx/utils.rb#24
  def parse_retry_after(retry_after); end

  # source://httpx//lib/httpx/utils.rb#59
  def to_uri(uri); end

  class << self
    # source://httpx//lib/httpx/utils.rb#18
    def elapsed_time(monotonic_timestamp); end

    # source://httpx//lib/httpx/utils.rb#33
    def get_filename(header, _prefix_regex = T.unsafe(nil)); end

    # source://httpx//lib/httpx/utils.rb#14
    def now; end

    # The value of this field can be either an HTTP-date or a number of
    # seconds to delay after the response is received.
    #
    # source://httpx//lib/httpx/utils.rb#24
    def parse_retry_after(retry_after); end

    # source://httpx//lib/httpx/utils.rb#59
    def to_uri(uri); end
  end
end

# source://httpx//lib/httpx/utils.rb#10
HTTPX::Utils::FILENAME_EXTENSION_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#9
HTTPX::Utils::FILENAME_REGEX = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#7
HTTPX::Utils::TOKEN = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/utils.rb#57
HTTPX::Utils::URIParser = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# source://httpx//lib/httpx/utils.rb#8
HTTPX::Utils::VALUE = T.let(T.unsafe(nil), Regexp)

# source://httpx//lib/httpx/version.rb#4
HTTPX::VERSION = T.let(T.unsafe(nil), String)

# Error raised when there was a timeout while sending a request from the server.
#
# source://httpx//lib/httpx/errors.rb#60
class HTTPX::WriteTimeoutError < ::HTTPX::RequestTimeoutError; end
