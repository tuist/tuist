---
{
  "title": "The Modular Architecture (TMA)",
  "titleTemplate": ":title · Projects · Features · Guides · Tuist",
  "description": "Learn about The Modular Architecture (TMA) and how to structure your projects using it."
}
---
# البنية المعيارية (TMA) {#the-modular-architecture-tma}

TMA هو نهج معماري لتنظيم تطبيقات نظام التشغيل Apple OS بهدف تمكين قابلية التوسع،
وتحسين دورات البناء والاختبار، وضمان اتباع الممارسات الجيدة في فريقك. وتتمثل
فكرته الأساسية في بناء تطبيقاتك عن طريق إنشاء ميزات مستقلة مترابطة باستخدام
واجهات برمجة تطبيقات واضحة وموجزة.

تقدم هذه الإرشادات مبادئ البنية، مما يساعدك على تحديد ميزات التطبيق وتنظيمها في
طبقات مختلفة. كما تقدم نصائح وأدوات وإرشادات إذا قررت استخدام هذه البنية.

::: info µFEATURES
<!-- -->
كانت هذه البنية تُعرف سابقًا باسم µFeatures. وقد قمنا بتغيير اسمها إلى البنية
المعيارية (TMA) لتعكس بشكل أفضل الغرض منها والمبادئ التي تقوم عليها.
<!-- -->
:::

## المبدأ الأساسي {#core-principle}

يجب أن يكون المطورون قادرين على **بناء واختبار وتجربة** ميزاتهم بسرعة، بشكل
مستقل عن التطبيق الرئيسي، مع ضمان عمل ميزات Xcode مثل معاينة واجهة المستخدم
وإكمال الكود وتصحيح الأخطاء بشكل موثوق.

## ما هي الوحدة النمطية {#what-is-a-module}

تمثل الوحدة النمطية ميزة التطبيق وهي مزيج من الأهداف الخمسة التالية (حيث يشير
الهدف إلى هدف Xcode):

- **المصدر:** يحتوي على شفرة المصدر للميزة (Swift، Objective-C، C++،
  JavaScript...) ومواردها (الصور، الخطوط، القصص المصورة، xibs).
- **الواجهة:** إنه هدف مصاحب يحتوي على الواجهة العامة ونماذج الميزة.
- **الاختبارات:** يحتوي على اختبارات الوحدة النمطية والتكامل.
- **الاختبار:** يوفر بيانات اختبار يمكن استخدامها في الاختبارات والتطبيق
  النموذجي. كما يوفر نماذج لفئات الوحدات النمطية والبروتوكولات التي يمكن
  استخدامها في ميزات أخرى كما سنرى لاحقًا.
- **مثال:** يحتوي على تطبيق نموذجي يمكن للمطورين استخدامه لتجربة الميزة في ظل
  ظروف معينة (لغات مختلفة، أحجام شاشات مختلفة، إعدادات مختلفة).

نوصي باتباع قواعد تسمية موحدة للأهداف، وهو أمر يمكنك تطبيقه في مشروعك بفضل DSL
من Tuist.

| الهدف              | التبعيات                    | المحتوى                  |
| ------------------ | --------------------------- | ------------------------ |
| `ميزة`             | `FeatureInterface`          | كود المصدر والموارد      |
| `FeatureInterface` | -                           | الواجهة العامة والنماذج  |
| `اختبارات الميزات` | `ميزة` ، `FeatureTesting`   | اختبارات الوحدة والتكامل |
| `اختبار الميزات`   | `FeatureInterface`          | اختبار البيانات والنماذج |
| `مثال على الميزة`  | `اختبار الميزات` ، `الميزة` | تطبيق مثال               |

::: tip UI Previews
<!-- -->
`ميزة` يمكن استخدام `FeatureTesting` كأصل تطويري للسماح بمعاينة واجهة المستخدم
<!-- -->
:::

::: warning COMPILER DIRECTIVES INSTEAD OF TESTING TARGETS
<!-- -->
بدلاً من ذلك، يمكنك استخدام توجيهات المُجمع لتضمين بيانات الاختبار والمحاكاة في
أهداف `Feature` أو `FeatureInterface` عند التجميع لـ `Debug`. يمكنك تبسيط الرسم
البياني، ولكنك ستنتهي بتجميع كود لن تحتاجه لتشغيل التطبيق.
<!-- -->
:::

## لماذا الوحدة {#why-a-module}

### واجهات برمجة تطبيقات API واضحة وموجزة {#clear-and-concise-apis}

عندما يكون كل كود مصدر التطبيق موجودًا في نفس الهدف، من السهل جدًا إنشاء تبعيات
ضمنية في الكود وينتهي الأمر بوجود كود معقد للغاية. كل شيء مرتبط ارتباطًا وثيقًا،
والحالة تكون أحيانًا غير متوقعة، ويصبح إدخال تغييرات جديدة كابوسًا. عندما نحدد
الميزات في أهداف مستقلة، نحتاج إلى تصميم واجهات برمجة تطبيقات عامة كجزء من تنفيذ
الميزات. نحتاج إلى تحديد ما يجب أن يكون عامًا، وكيف يجب استخدام ميزتنا، وما يجب
أن يظل خاصًا. لدينا سيطرة أكبر على الطريقة التي نريد أن يستخدم بها عملاؤنا
الميزة، ويمكننا فرض الممارسات الجيدة من خلال تصميم واجهات برمجة تطبيقات آمنة.

### الوحدات الصغيرة {#small-modules}

[قسّم واحتل](https://en.wikipedia.org/wiki/Divide_and_conquer). يتيح لك العمل في
وحدات صغيرة التركيز بشكل أكبر واختبار الميزة وتجربتها بشكل منفصل. علاوة على ذلك،
تصبح دورات التطوير أسرع بكثير لأننا نحصل على تجميع أكثر انتقائية، حيث يتم تجميع
المكونات الضرورية فقط لتشغيل الميزة. لا يكون تجميع التطبيق بأكمله ضروريًا إلا في
نهاية العمل، عندما نحتاج إلى دمج الميزة في التطبيق.

### إعادة الاستخدام {#reusability}

يُشجع إعادة استخدام الكود عبر التطبيقات والمنتجات الأخرى مثل الإضافات باستخدام
الأطر أو المكتبات. من خلال إنشاء وحدات نمطية، يصبح إعادة استخدامها أمرًا بسيطًا
للغاية. يمكننا إنشاء إضافة iMessage أو إضافة Today أو تطبيق watchOS بمجرد دمج
الوحدات النمطية الموجودة وإضافة _(عند الضرورة)_ طبقات واجهة المستخدم الخاصة
بالمنصة.

## التبعيات {# التبعيات}

عندما تعتمد وحدة نمطية على وحدة نمطية أخرى، فإنها تعلن عن تبعية تجاه هدف
واجهتها. لهذه الطريقة فائدتان. فهي تمنع ربط تنفيذ وحدة نمطية بتنفيذ وحدة نمطية
أخرى، وتسرع عمليات البناء النظيفة لأنها لا تتطلب سوى ترجمة تنفيذ ميزة ما وواجهات
التبعيات المباشرة والانتقالية. هذه الطريقة مستوحاة من فكرة SwiftRock حول [تقليل
أوقات بناء iOS باستخدام وحدات
واجهة](https://swiftrocks.com/reducing-ios-build-times-by-using-interface-targets).

اعتمادًا على الواجهات، يتطلب الأمر من التطبيقات إنشاء مخطط للتنفيذات في وقت
التشغيل، وحقن التبعية في الوحدات النمطية التي تحتاج إليها. على الرغم من أن TMA
لا تملك رأيًا محددًا حول كيفية القيام بذلك، فإننا نوصي باستخدام حلول أو أنماط
حقن التبعية أو الحلول التي لا تضيف توجيهات غير مباشرة في وقت الإنشاء أو تستخدم
واجهات برمجة تطبيقات منصة لم تصمم لهذا الغرض.

## أنواع المنتجات {#product-types}

عند بناء وحدة نمطية، يمكنك الاختيار بين **المكتبات والأطر** ، و **الربط الثابت
والديناميكي** للأهداف. بدون تويست، يكون اتخاذ هذا القرار أكثر تعقيدًا بعض الشيء
لأنك تحتاج إلى تكوين الرسم البياني للتبعية يدويًا. ومع ذلك، بفضل مشاريع تويست،
لم تعد هذه مشكلة.

نوصي باستخدام المكتبات الديناميكية أو الأطر أثناء التطوير باستخدام
<LocalizedLink href="/guides/features/projects/synthesized-files#bundle-accessors">أدوات
الوصول إلى الحزم</LocalizedLink> لفصل منطق الوصول إلى الحزم عن طبيعة المكتبة أو
الإطار للهدف. هذا أمر أساسي لسرعة التجميع وضمان عمل [SwiftUI
Previews](https://developer.apple.com/documentation/swiftui/previews-in-xcode)
بشكل موثوق. واستخدم المكتبات الثابتة أو الأطر لإصدارات الإصدار لضمان سرعة تشغيل
التطبيق. يمكنك الاستفادة من
<LocalizedLink href="/guides/features/projects/dynamic-configuration#configuration-through-environment-variables">التكوين
الديناميكي</LocalizedLink> لتغيير نوع المنتج في وقت الإنشاء:

```bash
# You'll have to read the value of the variable from the manifest {#youll-have-to-read-the-value-of-the-variable-from-the-manifest}
# and use it to change the linking type {#and-use-it-to-change-the-linking-type}
TUIST_PRODUCT_TYPE=static-library tuist generate
```

```swift
// You can place this in your manifest files or helpers
// and use the returned value when instantiating targets.
func productType() -> Product {
    if case let .string(productType) = Environment.productType {
        return productType == "static-library" ? .staticLibrary : .framework
    } else {
        return .framework
    }
}
```


::: warning MERGEABLE LIBRARIES
<!-- -->
حاولت Apple التخفيف من صعوبة التبديل بين المكتبات الثابتة والديناميكية من خلال
إدخال [مكتبات قابلة
للدمج](https://developer.apple.com/documentation/xcode/configuring-your-project-to-use-mergeable-libraries).
ومع ذلك، فإن ذلك يؤدي إلى عدم تحديد وقت البناء، مما يجعل البناء غير قابل للتكرار
ويصعب تحسينه، لذا لا نوصي باستخدامه.
<!-- -->
:::

## الكود {#code}

لا تتخذ TMA موقفًا محددًا بشأن بنية الكود وأنماط الوحدات النمطية الخاصة بك. ومع
ذلك، نود مشاركة بعض النصائح بناءً على خبرتنا:

- **الاستفادة من المُجمّع أمر رائع.** قد يؤدي الإفراط في الاستفادة من المُجمّع
  إلى عدم الإنتاجية وتسبب في عدم موثوقية بعض ميزات Xcode مثل المعاينة. نوصي
  باستخدام المُجمّع لتطبيق الممارسات الجيدة واكتشاف الأخطاء مبكرًا، ولكن دون أن
  يؤدي ذلك إلى صعوبة قراءة الكود وصيانته.
- **استخدم Swift Macros باعتدال.** يمكن أن تكون قوية جدًا ولكنها قد تجعل الكود
  أصعب في القراءة والصيانة.
- **احتضن المنصة واللغة، ولا تجردهما من مضمونهما.** قد تؤدي محاولة ابتكار طبقات
  تجريدية معقدة إلى نتائج عكسية. تتمتع المنصة واللغة بقوة كافية لإنشاء تطبيقات
  رائعة دون الحاجة إلى طبقات تجريدية إضافية. استخدم أنماط البرمجة والتصميم
  الجيدة كمرجع لإنشاء ميزاتك.

## الموارد {#resources}

- [بناء µFeatures](https://speakerdeck.com/pepibumur/building-ufeatures)
- [البرمجة الموجهة
  للإطار](https://speakerdeck.com/pepibumur/framework-oriented-programming-mobilization-dot-pl)
- [رحلة إلى الأطر و
  Swift](https://speakerdeck.com/pepibumur/a-journey-into-frameworks-and-swift)
- [الاستفادة من الأطر لتسريع عملية التطوير على نظام iOS - الجزء
  1](https://developers.soundcloud.com/blog/leveraging-frameworks-to-speed-up-our-development-on-ios-part-1)
- [البرمجة الموجهة
  للمكتبة](https://academy.realm.io/posts/justin-spahr-summers-library-oriented-programming/)
- [بناء أطر عمل حديثة](https://developer.apple.com/videos/play/wwdc2014/416/)
- [الدليل غير الرسمي لملفات
  xcconfig](https://pewpewthespells.com/blog/xcconfig_guide.html)
- [المكتبات الثابتة
  والديناميكية](https://pewpewthespells.com/blog/static_and_dynamic_libraries.html)
