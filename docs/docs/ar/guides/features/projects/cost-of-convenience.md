---
{
  "title": "The cost of convenience",
  "titleTemplate": ":title · Projects · Features · Guides · Tuist",
  "description": "Learn about the cost of convenience in Xcode and how Tuist helps you prevent the issues that come with it."
}
---
# تكلفة الراحة {#the-cost-of-convenience}

يعد تصميم محرر أكواد يمكن استخدامه في مشاريع صغيرة إلى كبيرة الحجم **** مهمة
صعبة. تتعامل العديد من الأدوات مع هذه المشكلة عن طريق طبقات الحلول وتوفير قابلية
التوسع. الطبقة السفلية منخفضة المستوى للغاية وقريبة من نظام البناء الأساسي،
والطبقة العليا عبارة عن تجريد عالي المستوى سهل الاستخدام ولكنه أقل مرونة. وبذلك،
فإنها تجعل الأمور البسيطة سهلة، وكل شيء آخر ممكنًا.

ومع ذلك، قررت شركة **[Apple](https://www.apple.com) اتباع نهج مختلف مع Xcode**.
السبب غير معروف، ولكن من المحتمل أن تحسين التحديات التي تواجه المشاريع الكبيرة
لم يكن هدفهم أبدًا. لقد استثمروا بشكل مفرط في الراحة للمشاريع الصغيرة، ولم
يوفروا سوى القليل من المرونة، وربطوا الأدوات بقوة بنظام البناء الأساسي. لتحقيق
الراحة، يوفرون إعدادات افتراضية معقولة، يمكنك استبدالها بسهولة، وأضفوا الكثير من
السلوكيات الضمنية التي يتم حلها في وقت البناء والتي هي السبب في العديد من
المشكلات على نطاق واسع.

## الوضوح والحجم {#explicitness-and-scale}

عند العمل على نطاق واسع، فإن الوضوح في **هو المفتاح**. فهو يسمح لنظام البناء
بتحليل وفهم بنية المشروع والتبعيات مسبقًا، وإجراء تحسينات كان من المستحيل
إجراؤها بخلاف ذلك. كما أن الوضوح نفسه هو المفتاح لضمان أن تعمل ميزات المحرر مثل
[معاينات
SwiftUI](https://developer.apple.com/documentation/swiftui/previews-in-xcode) أو
[ماكرو
Swift](https://docs.swift.org/swift-book/documentation/the-swift-programming-language/macros/)
بشكل موثوق ويمكن التنبؤ به. نظرًا لأن مشاريع Xcode و Xcode اعتمدت على الغموض
كخيار تصميم صالح لتحقيق الراحة، وهو مبدأ ورثه Swift Package Manager، فإن صعوبات
استخدام Xcode موجودة أيضًا في Swift Package Manager.

::: info THE ROLE OF TUIST
<!-- -->
يمكننا تلخيص دور Tuist كأداة تمنع المشاريع المحددة ضمناً وتستفيد من الوضوح
لتوفير تجربة أفضل للمطورين (مثل التحقق من الصحة والتحسينات). وتذهب أدوات مثل
[Bazel](https://bazel.build) إلى أبعد من ذلك من خلال نقلها إلى مستوى نظام
البناء.
<!-- -->
:::

هذه مشكلة نادراً ما تُناقش في المجتمع، لكنها مشكلة مهمة. أثناء العمل على Tuist،
لاحظنا أن العديد من المؤسسات والمطورين يعتقدون أن التحديات الحالية التي
يواجهونها سيتم معالجتها بواسطة [Swift Package
Manager](https://www.swift.org/documentation/package-manager/)، ولكن ما لا
يدركونه هو أنه نظرًا لأنه مبني على نفس المبادئ، على الرغم من أنه يخفف من تعارضات
Git المعروفة جيدًا، إلا أنه يقلل من تجربة المطور في مجالات أخرى ويستمر في جعل
المشاريع غير قابلة للتحسين.

في الأقسام التالية، سنناقش بعض الأمثلة الحقيقية لكيفية تأثير الضمناية على تجربة
المطور وصحة المشروع. القائمة ليست شاملة، ولكنها ستعطيك فكرة جيدة عن التحديات
التي قد تواجهها عند العمل مع مشاريع Xcode أو حزم Swift.

## الراحة تعيق طريقك {#convenience-getting-in-your-way}

### دليل المنتجات المدمجة المشتركة {#shared-built-products-directory}

يستخدم Xcode دليلًا داخل دليل البيانات المشتقة لكل منتج. داخله، يخزن عناصر
البنية، مثل الثنائيات المجمعة وملفات dSYM والسجلات. نظرًا لأن جميع منتجات
المشروع تذهب إلى نفس الدليل، والذي يكون مرئيًا بشكل افتراضي من الأهداف الأخرى
للربط، **فقد ينتهي بك الأمر بأهداف تعتمد بشكل ضمني على بعضها البعض.** في حين أن
هذا قد لا يمثل مشكلة عند وجود عدد قليل من الأهداف، إلا أنه قد يظهر على شكل فشل
في البنية يصعب تصحيحه عندما ينمو المشروع.

نتيجة لهذا القرار التصميمي، يتم تجميع العديد من المشاريع عن طريق الخطأ باستخدام
رسم بياني غير محدد جيدًا.

::: tip TUIST DETECTION OF IMPLICIT DEPENDENCIES
<!-- -->
يوفر Tuist أمر
<LocalizedLink href="/guides/features/inspect/implicit-dependencies">command</LocalizedLink>
لاكتشاف التبعيات الضمنية. يمكنك استخدام الأمر للتحقق في CI من أن جميع التبعيات
واضحة.
<!-- -->
:::

### ابحث عن التبعيات الضمنية في المخططات {#find-implicit-dependencies-in-schemes}

يصبح تعريف مخطط التبعية والحفاظ عليه في Xcode أكثر صعوبة مع نمو المشروع. يصعب
ذلك لأنها مرمزة في ملفات `.pbxproj` كمرحلة بناء وإعدادات بناء، ولا توجد أدوات
لتصور الرسم البياني والعمل به، وقد تتطلب التغييرات في الرسم البياني (مثل إضافة
إطار عمل ديناميكي جديد مسبق التجميع) تغييرات في التكوين في المراحل الأولى (مثل
إضافة مرحلة بناء جديدة لنسخ إطار العمل إلى الحزمة).

قررت Apple في مرحلة ما أنه بدلاً من تطوير نموذج الرسم البياني إلى شيء أكثر
قابلية للإدارة، سيكون من المنطقي أكثر إضافة خيار لحل التبعيات الضمنية في وقت
الإنشاء. وهذا مرة أخرى خيار تصميم مشكوك فيه لأنك قد ينتهي بك الأمر بوقت إنشاء
أبطأ أو إنشاءات غير متوقعة. على سبيل المثال، قد ينجح الإنشاء محليًا بسبب حالة ما
في البيانات المشتقة، والتي تعمل كـ
[singleton](https://en.wikipedia.org/wiki/Singleton_pattern)، ولكن بعد ذلك يفشل
التجميع على CI لأن الحالة مختلفة.

:::: إكرامية
<!-- -->
نوصي بتعطيل هذه الميزة في مخططات مشروعك، واستخدام Tuist الذي يسهل إدارة مخطط
التبعية.
<!-- -->
:::

### معاينات SwiftUI والمكتبات/الأطر الثابتة {#swiftui-previews-and-static-librariesframeworks}

تتطلب بعض ميزات المحرر مثل SwiftUI Previews أو Swift Macros تجميع مخطط التبعية
من الملف الذي يتم تحريره. يتطلب هذا التكامل بين المحرر أن يقوم نظام البناء بحل
أي غموض وإخراج العناصر الصحيحة اللازمة لتشغيل هذه الميزات. كما يمكنك أن تتخيل،
**كلما كان المخطط أكثر غموضًا، زادت صعوبة المهمة بالنسبة لنظام البناء** ،
وبالتالي فليس من المستغرب أن العديد من هذه الميزات لا تعمل بشكل موثوق. كثيرًا ما
نسمع من المطورين أنهم توقفوا عن استخدام معاينات SwiftUI منذ فترة طويلة لأنها غير
موثوقة. وبدلاً من ذلك، يستخدمون تطبيقات نموذجية أو يتجنبون بعض الأمور، مثل
استخدام المكتبات الثابتة أو مراحل إنشاء البرامج النصية، لأنها تتسبب في تعطل
الميزة.

### مكتبات قابلة للدمج {#mergeable-libraries}

تتميز الأطر الديناميكية بمرونة أكبر وسهولة في الاستخدام، ولكنها تؤثر سلبًا على
وقت تشغيل التطبيقات. من ناحية أخرى، تتميز المكتبات الثابتة بسرعة التشغيل، ولكنها
تؤثر على وقت التجميع وتكون أصعب في الاستخدام، خاصة في سيناريوهات الرسوم البيانية
المعقدة. *أليس من الرائع أن تتمكن من التبديل بين أحدهما والآخر حسب التكوين؟* هذا
ما فكرت فيه شركة Apple عندما قررت العمل على مكتبات قابلة للدمج. ولكن مرة أخرى،
نقلوا المزيد من الاستدلال في وقت البناء إلى وقت البناء. إذا كنت تفكر في رسم
بياني للتبعية، تخيل أنك تضطر إلى القيام بذلك عندما يتم حل الطبيعة الثابتة أو
الديناميكية للهدف في وقت البناء بناءً على بعض إعدادات البناء في بعض الأهداف.
حظًا سعيدًا في جعل ذلك يعمل بشكل موثوق مع ضمان عدم تعطل ميزات مثل معاينات
SwiftUI.

**يأتي العديد من المستخدمين إلى Tuist رغبةً في استخدام مكتبات قابلة للدمج،
وجوابنا دائمًا هو نفسه. لا داعي لذلك.** يمكنك التحكم في الطبيعة الثابتة أو
الديناميكية لأهدافك في وقت الإنشاء، مما يؤدي إلى مشروع يكون مخططه معروفًا قبل
التجميع. لا حاجة إلى حل المتغيرات في وقت الإنشاء.

```bash
# The value of TUIST_DYNAMIC can be read from the project {#the-value-of-tuist_dynamic-can-be-read-from-the-project}
# to set the product as static or dynamic based on the value. {#to-set-the-product-as-static-or-dynamic-based-on-the-value}
TUIST_DYNAMIC=1 tuist generate
```

## صريح، صريح، وصريح {#explicit-explicit-and-explicit}

إذا كان هناك مبدأ غير مكتوب مهم نوصي به كل مطور أو مؤسسة ترغب في تطوير Xcode على
نطاق واسع، فهو أن يتبنوا الصراحة. وإذا كان من الصعب إدارة الصراحة مع مشاريع
Xcode الأولية، فيجب عليهم التفكير في شيء آخر، إما [Tuist](https://tuist.io) أو
[Bazel](https://bazel.build). **عندها فقط ستكون الموثوقية والقدرة على التنبؤ
والتحسينات ممكنة.**

## المستقبل {#future}

من غير المعروف ما إذا كانت Apple ستتخذ إجراءات لمنع جميع المشكلات المذكورة
أعلاه. لا تشير قراراتهم المستمرة المضمنة في Xcode و Swift Package Manager إلى
أنهم سيفعلون ذلك. بمجرد السماح بالتكوين الضمني كحالة صالحة، **يصعب التغيير دون
إحداث تغييرات جذرية.** قد يؤدي العودة إلى المبادئ الأساسية وإعادة التفكير في
تصميم الأدوات إلى تعطيل العديد من مشاريع Xcode التي تم تجميعها عن طريق الخطأ
لسنوات. تخيل ضجة المجتمع إذا حدث ذلك.

تجد Apple نفسها في مأزق يشبه مشكلة الدجاجة والبيضة. الراحة هي ما يساعد المطورين
على البدء بسرعة وإنشاء المزيد من التطبيقات لنظامهم البيئي. لكن قراراتهم بجعل
التجربة مريحة على هذا النطاق تجعل من الصعب عليهم ضمان عمل بعض ميزات Xcode بشكل
موثوق.

نظرًا لأن المستقبل غير معروف، نحاول **أن نكون أقرب ما يمكن إلى معايير الصناعة
ومشاريع Xcode**. نحن نمنع المشكلات المذكورة أعلاه، ونستفيد من المعرفة التي لدينا
لتوفير تجربة أفضل للمطورين. من الناحية المثالية، لن نضطر إلى اللجوء إلى إنشاء
المشاريع من أجل ذلك، ولكن عدم قابلية التوسع في Xcode و Swift Package Manager
يجعلها الخيار الوحيد القابل للتطبيق. كما أنها خيار آمن لأنهم سيضطرون إلى تعطيل
مشاريع Xcode لتعطيل مشاريع Tuist.

من الناحية المثالية، **كان نظام البناء أكثر قابلية للتوسعة** ، ولكن أليس من غير
المناسب أن يكون هناك مكونات إضافية/ملحقات تتعارض مع عالم من الضمنية؟ لا يبدو أن
هذه فكرة جيدة. لذا يبدو أننا سنحتاج إلى أدوات خارجية مثل Tuist أو
[Bazel](https://bazel.build) لتوفير تجربة أفضل للمطورين. أو ربما ستفاجئنا Apple
جميعًا وتجعل Xcode أكثر قابلية للتوسعة ووضوحًا...

حتى يحدث ذلك، عليك أن تختار ما إذا كنت تريد الاستفادة من مزايا Xcode وتحمل العبء
الذي يأتي معها، أو أن تثق بنا في هذه الرحلة لتوفير تجربة أفضل للمطورين. لن نخيب
ظنك.
