---
{
  "title": "Principles",
  "titleTemplate": ":title · Contributors · Tuist",
  "description": "This document describes the principles that guide the development of Tuist."
}
---
# 原則{#principles}

本頁闡述了作為 Tuist 設計與開發支柱的核心原則。這些原則將隨專案演進而調整，旨在確保與專案根基高度契合的永續成長。

## 預設遵循慣例{#default-to-conventions}

Tuist 存在的理由之一，在於 Xcode 在規範方面較為薄弱，導致專案結構複雜且難以擴展維護。因此 Tuist
採取不同策略，預設採用簡潔且經過周詳設計的規範。**開發者雖可選擇不遵循規範，但這屬於刻意為之的決策，使用起來並不自然。**

例如，透過使用提供的公開介面來定義目標間的依賴關係，此為既定規範。藉此方式，Tuist
確保專案生成時具備正確的連結配置。開發人員雖可透過建置設定定義依賴關係，但此為隱式操作，將破壞 Tuist 的核心功能，例如：`tuist graph`
或`tuist cache` 這些功能皆仰賴特定規範的遵循。

我們採用預設規範的原因在於：能替開發者預先決策的事項越多，他們便能更專注於打造應用程式功能。當專案缺乏規範（如多數專案現況），我們被迫做出的決策往往與既有決策不一致，最終導致難以管理的意外複雜性。

## 清單是真相的來源{#manifests-are-the-source-of-truth}

`多重配置層級與其間的契約關係，導致專案設定難以理解與維護。 試想一個普通專案：專案定義存於`.xcodeproj 目錄，` 目錄存放 CLI
指令，Fastfiles 存於` 目錄，CI 邏輯則在 pipelines
中。這三層架構間存在相互依賴關係，需要我們持續維護。*你是否曾遇到這種情況：修改專案後，一週後才發現發布腳本失效？*

我們可透過建立單一權威來源——清單檔案來簡化流程。這些檔案為 Tuist 提供生成 Xcode
專案所需的資訊，開發者可藉此編輯檔案。此外，此機制還允許建立標準指令，從本地或 CI 環境進行專案建置。

**Tuist 應承擔技術複雜性，並提供簡潔、安全且愉悅的介面，讓開發者能盡可能明確地描述其專案。**

## 將隱含的內容明確化{#make-the-implicit-explicit}

Xcode 支援隱含配置。其典型範例在於推斷隱含定義的依賴關係。隱含配置雖適用於配置簡單的小型專案，但隨著專案規模擴大，可能導致執行遲緩或異常行為。

Tuist 應針對 Xcode 的隱含行為提供明確的 API。同時應支援定義 Xcode 隱含特性，但其實現方式應鼓勵開發者選擇顯式方法。支援 Xcode
的隱含特性與複雜機制有助於 Tuist 的採用，團隊後續可逐步消除隱含特性。

依賴項的定義便是絕佳範例。開發者雖可透過建置設定與階段定義依賴項，但 Tuist 提供的精美 API 更能有效促進其採用。

**透過設計明確的 API，Tuist 能對專案執行某些檢查與優化，這些操作在缺乏明確規範時將難以實現。** 此外，此設計還啟用了諸如`tuist graph`
功能（可輸出依賴關係圖表示），以及`tuist cache` 功能（將所有目標以二進位檔形式快取）。

::: tip
<!-- -->
我們應將每次從 Xcode 移植功能的請求視為契機，藉此透過簡潔明確的 API 簡化概念。
<!-- -->
:::

## 保持簡潔{#keep-it-simple}

擴展 Xcode 專案的主要挑戰之一，在於 Xcode 將大量複雜性暴露給使用者。****
因此團隊面臨高巴士因子風險，僅少數成員能理解專案架構與建置系統產生的錯誤。這種情況極為不利，因為團隊運作過度依賴少數關鍵人員。

Xcode 雖是優秀工具，但多年來的改進、新平台與程式語言的演進，皆反映在其介面上——而該介面始終在掙扎著維持簡潔。

Tuist 應把握機會保持簡潔，因為處理簡單事物既有趣又能激勵我們。無人願耗費時間調試編譯過程末端產生的錯誤，或費心探究應用程式為何無法在裝置上運行。Xcode
將任務委派給底層建置系統，而該系統在某些情況下將錯誤轉譯為可操作項目的表現極為拙劣。 您是否曾遭遇「*」的「框架 X 未找到」錯誤（*
），卻束手無策？試想若能獲得潛在根本原因清單，該有多好。

## 從開發者的經驗出發{#start-from-the-developers-experience}

Xcode
周邊缺乏創新（或換言之，不如其他程式設計環境豐富）的部分原因在於，我們往往從現有解決方案出發分析問題。**因此當今多數解決方案仍圍繞相同概念與工作流程。雖然納入現有方案是合理做法，但不應讓它們限制我們的創造力。**

**我們認同[湯姆·普雷斯頓](https://tom.preston-werner.com/)在[這集播客](https://tom.preston-werner.com/)中的觀點：*「只要在宇宙法則允許的範圍內，腦海中的構想大多能透過程式碼實現。」*
若我們能想像理想的開發者體驗（參見** ），實現它只是時間問題——從開發者體驗切入分析問題，將賦予我們獨特視角，進而導向使用者樂於採用的解決方案。

我們或許會想跟隨眾人做法，即使這意味著繼續忍受眾人抱怨的不便之處。但請別這麼做。我該如何規劃應用程式的歸檔？我理想中的程式碼簽署應具備哪些特質？透過 Tuist
能協助簡化哪些流程？例如，新增 [Fastlane](https://fastlane.tools/)
支援功能，正是解決問題的方案——但我們必須先釐清問題本質。
透過追問「為什麼」，我們能直指問題根源。當釐清動機來源後，便能思考Tuist如何提供最佳協助。解決方案或許是整合Fastlane，但關鍵在於我們不該在權衡取捨前，就忽視其他同等有效的替代方案。

## 錯誤可能發生且確實會發生{#errors-can-and-will-happen}

我們開發者天生傾向忽視錯誤發生的可能性，因此在設計與測試軟體時，往往只考量理想情境。

Swift
語言的類型系統與良好架構的程式碼雖能預防部分錯誤，但無法涵蓋所有情況，因為某些因素超出我們的掌控範圍。我們無法假設使用者始終具備網路連線，亦無法保證系統指令必定成功執行。Tuist
運作的環境並非我們能控制的沙盒，因此必須主動理解這些環境可能產生的變動及其對 Tuist 的影響。

錯誤處理不當將導致糟糕的使用體驗，使用者可能因此對專案失去信任。我們希望使用者能享受 Tuist 的每個細節，甚至包括我們呈現錯誤的方式。

我們應設身處地站在使用者立場，設想自己期望錯誤訊息傳達哪些資訊。若將程式語言視為錯誤傳播的管道，使用者則是錯誤訊息的接收端，錯誤訊息理應採用目標對象（使用者）所使用的語言撰寫。內容需包含足夠的事件資訊，同時隱藏無關細節。此外，錯誤訊息應具備可操作性，明確告知使用者可採取哪些步驟進行復原。

最後但同樣重要的是，我們的測試案例應涵蓋失敗情境。這不僅能確保錯誤處理符合預期，更能防止未來開發者破壞該邏輯。
