---
{
  "title": "Module cache",
  "titleTemplate": ":title · Cache · Features · Guides · Tuist",
  "description": "Optimize your build times by caching compiled binaries and sharing them across different environments."
}
---

# Кэш модулей {#module-cache}

::: предупреждение РЕКВИЗИТЫ
<!-- -->
- Проект, созданный
  <LocalizedLink href="/guides/features/projects"></LocalizedLink>
- A <LocalizedLink href="/guides/server/accounts-and-projects">Туистский счет и проект</LocalizedLink>
<!-- -->
:::

Кэш модулей Tuist предоставляет мощный способ оптимизации времени сборки за счет
кэширования модулей в виде двоичных файлов (`.xcframework`s) и их совместного
использования в различных средах. Эта возможность позволяет использовать ранее
сгенерированные двоичные файлы, сокращая необходимость в повторной компиляции и
ускоряя процесс разработки.

## Согревающий {#warming}

Tuist эффективно
<LocalizedLink href="/guides/features/projects/hashing">использует хэши</LocalizedLink> для каждой цели в графе зависимостей, чтобы обнаружить
изменения. Используя эти данные, он создает и присваивает уникальные
идентификаторы двоичным файлам, полученным из этих целей. Во время генерации
графа Tuist плавно заменяет исходные цели их соответствующими двоичными
версиями.

Эта операция, известная как *"прогрев",* создает двоичные файлы для локального
использования или для обмена с товарищами по команде и CI-средой через Tuist.
Процесс разогрева кэша прост и может быть инициирован простой командой:


```bash
tuist cache
```

Команда повторно использует двоичные файлы, чтобы ускорить процесс.

## Использование {#usage}

По умолчанию, когда команды Tuist требуют создания проекта, они автоматически
заменяют зависимости их двоичными эквивалентами из кэша, если они доступны.
Кроме того, если вы укажете список целей, на которых нужно сосредоточиться,
Tuist также заменит все зависимые цели их двоичными файлами из кэша, если они
доступны. Для тех, кто предпочитает другой подход, есть возможность полностью
отказаться от такого поведения, используя специальный флаг:

::: code-group
```bash [Project generation]
tuist generate # Only dependencies
tuist generate Search # Dependencies + Search dependencies
tuist generate Search Settings # Dependencies, and Search and Settings dependencies
tuist generate --no-binary-cache # No cache at all
```

```bash [Testing]
tuist test
```
<!-- -->
:::

::: ПРЕДУПРЕЖДЕНИЕ
<!-- -->
Двоичное кэширование - это функция, предназначенная для рабочих процессов
разработки, таких как запуск приложения на симуляторе или устройстве, а также
проведение тестов. Она не предназначена для сборки релизов. При архивации
приложения создайте проект с исходными текстами, используя флаг
`--no-binary-cache`.
<!-- -->
:::

## Профили кэша {#cache-profiles}

Tuist поддерживает профили кэша для управления тем, насколько активно цели
заменяются кэшированными двоичными файлами при генерации проектов.

- Встроенные шкафы:
  - `only-external`: заменять только внешние зависимости (по умолчанию).
  - `Все возможные`: заменить как можно больше целей (включая внутренние цели)
  - `none`: никогда не заменять кэшированными двоичными файлами

Выберите профиль с помощью `--cache-profile` на `tuist generate`:

```bash
# Built-in profiles
tuist generate --cache-profile all-possible

# Custom profiles (defined in Tuist Config)
tuist generate --cache-profile development

# Use config default (no flag)
tuist generate

# Focus on specific targets (implies all-possible)
tuist generate MyModule AnotherTarget

# Disable binary replacement entirely (backwards compatible)
tuist generate --no-binary-cache  # equivalent to --cache-profile none
```

Приоритет при разрешении эффективного поведения (от высшего к низшему):

1. `--no-binary-cache` → профиль `none`
2. Фокус на цели (передача целей на `для генерации`) → профиль `всевозможные`
3. `--cache-profile &lt;значение&gt;`
4. Конфигурация по умолчанию (если установлена)
5. Система по умолчанию (только`- внешний`)

## Поддерживаемые продукты {#supported-products}

Tuist может кэшировать только следующие целевые продукты:

- Фреймворки (статические и динамические), которые не зависят от
  [XCTest](https://developer.apple.com/documentation/xctest)
- Бандлы
- Макросы Swift

Мы работаем над поддержкой библиотек и целей, которые зависят от XCTest.

::: info UPSTREAM DEPENDENCIES
<!-- -->
Если цель является некэшируемой, это делает некэшируемыми и вышележащие цели.
Например, если у вас есть граф зависимостей `A &gt; B`, где A зависит от B, если
B не кэшируется, A также будет не кэшироваться.
<!-- -->
:::

## Эффективность {#efficiency}

Уровень эффективности, которого можно достичь с помощью бинарного кэширования,
сильно зависит от структуры графа. Для достижения наилучших результатов мы
рекомендуем следующее:

1. Избегайте очень вложенных графов зависимостей. Чем мельче граф, тем лучше.
2. Определяйте зависимости с помощью целей протокола/интерфейса, а не
   реализации, и внедряйте зависимости от самых верхних целей.
3. Разделите часто изменяемые цели на более мелкие, вероятность изменения
   которых ниже.

Приведенные выше предложения являются частью
<LocalizedLink href="/guides/features/projects/tma-architecture">Модульной архитектуры</LocalizedLink>, которую мы предлагаем в качестве способа
структурировать ваши проекты, чтобы максимально использовать не только
преимущества двоичного кэширования, но и возможности Xcode.

## Рекомендуемая настройка {#recommended-setup}

Мы рекомендуем иметь задание CI, которое **запускается при каждом коммите в
основной ветке** для прогрева кэша. Это обеспечит постоянное наличие в кэше
двоичных файлов для изменений в `основной ветки`, чтобы локальная и CI ветки
собирались на их основе инкрементально.

::: tip CACHE WARMING USES BINARIES
<!-- -->
Команда `tuist cache` также использует двоичный кэш для ускорения прогрева.
<!-- -->
:::

Ниже приведены примеры распространенных рабочих процессов:

### Разработчик начинает работать над новой функцией {#a-developer-starts-to-work-on-a-new-feature}

1. Они создают новую ветку от `главной`.
2. Они запускают `туист генерирует`.
3. Tuist извлекает самые последние двоичные файлы из `main` и генерирует с их
   помощью проект.

### Разработчик продвигает изменения вверх по течению {#a-developer-pushes-changes-upstream}

1. Конвейер CI запустит `xcodebuild build` или `tuist test` для сборки или
   тестирования проекта.
2. Рабочий процесс будет извлекать самые последние двоичные файлы из `main` и
   генерировать проект с их помощью.
3. Затем он будет собирать или тестировать проект постепенно.

## Конфигурация {#configuration}

### Ограничение параллельности кэша {#cache-concurrency-limit}

По умолчанию Tuist загружает и выгружает артефакты кэша без ограничения
параллелизма, что позволяет максимально увеличить пропускную способность. Вы
можете управлять этим поведением с помощью переменной окружения
`TUIST_CACHE_CONCURRENCY_LIMIT`:

```bash
# Set a specific concurrency limit
export TUIST_CACHE_CONCURRENCY_LIMIT=10
tuist generate

# Use "none" for no limit (default behavior)
export TUIST_CACHE_CONCURRENCY_LIMIT=none
tuist generate
```

Это может быть полезно в средах с ограниченной пропускной способностью сети или
для снижения нагрузки на систему во время операций с кэшем.

## Устранение неполадок {#troubleshooting}

### Он не использует двоичные файлы для моих целей {#it-doesnt-use-binaries-for-my-targets}

Убедитесь, что
<LocalizedLink href="/guides/features/projects/hashing#debugging">хэши детерминированы</LocalizedLink> между окружениями и запусками. Это может
произойти, если в проекте есть ссылки на окружение, например, через абсолютные
пути. Вы можете использовать команду `diff` для сравнения проектов, созданных
двумя последовательными вызовами `tuist generate`, а также между окружениями или
запусками.

Также убедитесь, что цель не зависит прямо или косвенно от
<LocalizedLink href="/guides/features/cache/generated-project#supported-products">некэшируемой цели</LocalizedLink>.

### Отсутствующие символы {#missing-symbols}

При использовании исходных текстов система сборки Xcode с помощью Derived Data
может разрешить зависимости, которые не объявлены явно. Однако, если вы
полагаетесь на бинарный кэш, зависимости должны быть объявлены явно; в противном
случае вы будете видеть ошибки компиляции, когда символы не могут быть найдены.
Чтобы отладить это, мы рекомендуем использовать команду
<LocalizedLink href="/guides/features/projects/inspect/implicit-dependencies">`tuist inspect implicit-imports`</LocalizedLink> и настроить ее в CI для предотвращения
регрессий в неявном связывании.
