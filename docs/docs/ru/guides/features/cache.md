---
{
  "title": "Cache",
  "titleTemplate": ":title · Features · Guides · Tuist",
  "description": "Optimize your build times by caching compiled binaries and sharing them across different environments."
}
---
# Кэш {#cache}

> [!ВАЖНЫЕ] ТРЕБОВАНИЯ
> - Проект, созданный
>   <LocalizedLink href="/guides/features/projects"></LocalizedLink>
> - A <LocalizedLink href="/guides/server/accounts-and-projects">Туистский счет
>   и проект</LocalizedLink>

Система сборки Xcode обеспечивает [инкрементные
сборки](https://en.wikipedia.org/wiki/Incremental_build_model), что повышает
эффективность в обычных условиях. Однако эта функция не работает в средах
[непрерывной интеграции
(CI)](https://en.wikipedia.org/wiki/Continuous_integration), где данные,
необходимые для инкрементных сборок, не используются совместно в разных сборках.
Кроме того, разработчики **часто сбрасывают эти данные локально для устранения
сложных проблем компиляции**, что приводит к более частым чистым сборкам. Это
приводит к тому, что команды тратят лишнее время на ожидание завершения
локальных сборок или конвейеров непрерывной интеграции для получения обратной
связи по запросам на исправление. Более того, частое переключение контекста в
такой среде усугубляет эту непродуктивность.

Tuist эффективно решает эти проблемы с помощью функции кэширования. Этот
инструмент оптимизирует процесс сборки за счет кэширования скомпилированных
двоичных файлов, что значительно сокращает время сборки как в локальной
разработке, так и в среде CI. Такой подход не только ускоряет циклы обратной
связи, но и минимизирует необходимость переключения контекста, что в конечном
итоге повышает производительность.

## Потепление {#warming}

Tuist эффективно
<LocalizedLink href="/guides/features/projects/hashing">использует
хэши</LocalizedLink> для каждой цели в графе зависимостей, чтобы обнаружить
изменения. Используя эти данные, он создает и присваивает уникальные
идентификаторы двоичным файлам, полученным из этих целей. Во время генерации
графа Tuist плавно заменяет исходные цели их соответствующими двоичными
версиями.

Эта операция, известная как *"прогрев",* создает двоичные файлы для локального
использования или для обмена с товарищами по команде и CI-средой через Tuist.
Процесс разогрева кэша прост и может быть инициирован простой командой:


```bash
tuist cache
```

Команда повторно использует двоичные файлы, чтобы ускорить процесс.

## Использование {#usage}

По умолчанию, когда команды Tuist требуют создания проекта, они автоматически
заменяют зависимости их двоичными эквивалентами из кэша, если они доступны.
Кроме того, если вы укажете список целей, на которых нужно сосредоточиться,
Tuist также заменит все зависимые цели их двоичными файлами из кэша, если они
доступны. Для тех, кто предпочитает другой подход, есть возможность полностью
отказаться от такого поведения, используя специальный флаг:

::: кодовая группа
```bash [Project generation]
tuist generate # Only dependencies
tuist generate Search # Dependencies + Search dependencies
tuist generate Search Settings # Dependencies, and Search and Settings dependencies
tuist generate --no-binary-cache # No cache at all
```

```bash [Testing]
tuist test
```
:::

> [!ВНИМАНИЕ] Двоичное кэширование - это функция, предназначенная для рабочих
> процессов разработки, таких как запуск приложения на симуляторе или
> устройстве, или проведение тестов. Она не предназначена для сборки релизов.
> При архивировании приложения создайте проект с исходными текстами, используя
> флаг `--no-binary-cache`.

## Поддерживаемые продукты {#supported-products}

Tuist может кэшировать только следующие целевые продукты:

- Фреймворки (статические и динамические), которые не зависят от
  [XCTest](https://developer.apple.com/documentation/xctest)
- Пучки
- Макросы Swift

Мы работаем над поддержкой библиотек и целей, которые зависят от XCTest.

> [!ПРИМЕЧАНИЕ] UPSTREAM DEPENDENCIES Когда цель является некэшируемой, это
> делает некэшируемыми и вышележащие цели. Например, если у вас есть граф
> зависимостей `A &gt; B`, где A зависит от B, если B не кэшируется, A также
> будет не кэшироваться.

## Эффективность {#efficiency}

Уровень эффективности, которого можно достичь с помощью бинарного кэширования,
сильно зависит от структуры графа. Для достижения наилучших результатов мы
рекомендуем следующее:

1. Избегайте очень вложенных графов зависимостей. Чем мельче граф, тем лучше.
2. Определяйте зависимости с помощью целей протокола/интерфейса, а не
   реализации, и внедряйте зависимости от самых верхних целей.
3. Разделите часто изменяемые цели на более мелкие, вероятность изменения
   которых ниже.

Приведенные выше предложения являются частью
<LocalizedLink href="/guides/features/projects/tma-architecture">Модульной
архитектуры</LocalizedLink>, которую мы предлагаем в качестве способа
структурировать ваши проекты, чтобы максимально использовать не только
преимущества двоичного кэширования, но и возможности Xcode.

## Рекомендуемая настройка {#recommended-setup}

Мы рекомендуем иметь CI-задание, которое **запускается при каждом коммите в
основной ветке** для прогрева кэша. Это обеспечит постоянное наличие в кэше
двоичных файлов для изменений в `основной ветки`, чтобы локальная и CI ветки
собирались на их основе инкрементально.

> [Команда `tuist cache` также использует бинарный кэш для ускорения прогрева.

Ниже приведены примеры распространенных рабочих процессов:

### Разработчик начинает работать над новой функцией {#a-developer-starts-to-work-on-a-new-feature}

1. Они создают новую ветку от `главной`.
2. Они запускают `туист генерирует`.
3. Tuist извлекает самые последние двоичные файлы из `main` и генерирует с их
   помощью проект.

### Разработчик продвигает изменения вверх по течению {#a-developer-pushes-changes-upstream}

1. Конвейер CI запустит `tuist build` или `tuist test` для сборки или
   тестирования проекта.
2. Рабочий процесс будет извлекать самые последние двоичные файлы из `main` и
   генерировать проект с их помощью.
3. Затем он будет собирать или тестировать проект постепенно.

## Устранение неполадок {#troubleshooting}

### Он не использует двоичные файлы для моих целей {#it-doesnt-use-binaries-for-my-targets}

Убедитесь, что
<LocalizedLink href="/guides/features/projects/hashing#debugging">хэши
детерминированы</LocalizedLink> между окружениями и запусками. Это может
произойти, если в проекте есть ссылки на окружение, например, через абсолютные
пути. Вы можете использовать команду `diff` для сравнения проектов, созданных
двумя последовательными вызовами `tuist generate`, а также между окружениями или
запусками.

Также убедитесь, что цель не зависит прямо или косвенно от
<LocalizedLink href="/guides/features/cache#supported-products">некэшируемой
цели</LocalizedLink>.
