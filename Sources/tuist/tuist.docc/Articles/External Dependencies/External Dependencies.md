# Adding external dependencies

Working on large-scale requires integrating third party dependencies into your Xcode project, and it's crucial doing it in a way that minimizes disruption and optimizes for developer experience.

Integrating external dependencies is an important but often painful part of Xcode project management. Dependency managers like [CocoaPods](https://cocoapods.org) integrate it when running `pod install` leveraging Xcode workspaces, and [Swift Package Manager](https://www.swift.org/package-manager) does it at build time leveraging Xcode's closed build system. Both approaches might lead to integration issues that can cause compilation issues down the road.

We are aware that's not a great developer experience, and thus we take a different approach to managing external dependencies that allow leveraging Tuist features such as linting and caching. The idea is simple: developers define their dependencies in `Tuist/Dependencies.swift` and `Tuist/Package.swift` files, and they are fetched by running `tuist fetch` and integrated into the generated Xcode project at generation time. Because we merge your project and the external dependencies' graph into a single graph, we validate and fail early if the resulting graph is invalid.

## Declaring dependencies

External dependencies and they versions are declared in the `Tuist/Package.swift` file with the same `Swift Package Manager` syntax you might be familiar with. Then, in the `Tuist/Dependencies.swift` file you can define some more additional configuration details such as the desired target platform, or some custom mapping for your dependencies.

The snippets below shows an example `Dependencies.swift` and `Pacakge.swift` manifest files:

```swift
import ProjectDescription

let dependencies = Dependencies(
    swiftPackageManager: .init(),
    platforms: [.iOS]
)
```

```swift
// swift-tools-version: 5.8
import PackageDescription

let package = Package(
    name: "PackageName",
    dependencies: [
        .package(url: "https://github.com/Alamofire/Alamofire", from: "5.0.0"),
    ]
)
```

## Fetching dependencies

After dependencies have been declared, you need to fetch them by running `tuist fetch`. Tuist uses `Swift Package Manager` to pull the dependencies under the `Tuist/Dependencies` directory, and maps them to `Tuist` target and projects:

```bash
Tuist
    |- Dependencies.swift # Manifest
    |- Packages.swift # Dependencies definition and versions
    |- Dependencies
        |- graph.json # stores the serialized dependencies graph generated by `tuist fetch`
        |- Lockfiles # stores the lockfiles generated by the dependencies resolution
            |- Package.resolved
        |- SwiftPackageManager
            |- .build # stores content of `.build/` directory generated by `Swift Package Manager`
                |- artifacts
                |- checkouts
                |- repositories
                |- manifest.db
                |- workspace-state.json
            |- Package.swift # the generated Package.swift
```

We recommend excluding the following files and directories from [version control](https://en.wikipedia.org/wiki/Version_control) (for example, in your `.gitignore` file).

```bash
Tuist/Dependencies/graph.json # Avoid checking in the serialized dependencies graph generated by Tuist.
Tuist/Dependencies/Carthage # Avoid checking in build artifacts from Carthage dependencies.
Tuist/Dependencies/SwiftPackageManager # Avoid checking in build artifacts from Swift Package Manager dependencies.
```

## Integrating dependencies into your project

Once dependencies have been fetched, you can declare dependencies from your projects' targets. Run `tuist edit` to edit your project's manifest, and use the `.external` target dependency option to declare the dependency.

The snippet below shows an example `Project.swift` manifest file:

```swift
import ProjectDescription

let project = Project(
    name: "App",
    organizationName: "tuist.io",
    targets: [
        Target(
            name: "App",
            platform: .iOS,
            product: .app,
            bundleId: "io.tuist.app",
            deploymentTarget: .iOS(targetVersion: "13.0", devices: .iphone),
            infoPlist: .default,
            sources: ["Targets/App/Sources/**"],
            dependencies: [
                // highlight-next-line
                .external(name: "Alamofire"),
            ]
        ),
    ]
)
```

## Some notes on the integration of Swift packages

- When Swift packages are integrated as source code into your project's graph, no scheme is created for them, as you usually don't want to build only the dependency explicitly. If you need it (for example, for testing some problem in the library), you can create the scheme directly from Xcode, or you can define it in your `Project.swift` if you need it to be available across generations.
- If present, Tuist uses the product type defined in the package manifest file. Otherwise, it defaults to use `.staticFramework`. You can override the product type using the `SwiftPackageManagerDependencies.productTypes` property.
- To use Swift packages from an Objective-C target, add the path to the public headers of the package to the `HEADER_SEARCH_PATHS` of the target. The path will be something like `Tuist/Dependencies/SwiftPackageManager/.build/checkouts/<your_package>/<the_headers>` ([workaround for issue 4180](https://github.com/tuist/tuist/issues/4180)).
