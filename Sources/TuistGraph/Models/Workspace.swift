import Foundation
import TSCBasic
import TSCUtility

public struct Workspace: Equatable, Codable {
    /// Contains options related to the workspace generation.
    public enum GenerationOption: Codable, Equatable {
        /// Represents the behavior Xcode will apply to the workspace regarding
        /// schema generation using the `IDEWorkspaceSharedSettings_AutocreateContextsIfNeeded` key.
        /// - seealso: `WorkspaceSettingsDescriptor`
        public enum AutomaticXcodeSchemes: String, Codable, Equatable {
            /// Will add the key with the value set to `true`.
            case enabled

            /// Will add the key with the value set to `false`.
            case disabled
        }

        /// Contains options for the autogenerated wotkspace schemes
        public enum AutogeneratedWorkspaceSchemes: Codable, Equatable {
            /// Contains options for code coverage
            public enum CodeCoverageMode: Codable, Equatable {
                /// Gather code coverage for all targets
                case all
                /// Gather code coverage only for targets, that have code coverage enabled at least in one scheme
                case relevant
                /// Gather code coverage only for given targets
                case targets([TargetReference])
                /// Do not gather code coverage
                case disabled
            }

            /// Tuist will not automatically generate the workspace schemes
            case disabled
            /// Tuist will generate the workspace schemes
            case enabled(codeCoverageMode: CodeCoverageMode = .disabled, testingOptions: TestingOptions = [])
        }

        /// Tuist generates a WorkspaceSettings.xcsettings file, setting the related key to the associated value.
        case automaticXcodeSchemes(AutomaticXcodeSchemes)

        /// Options controlling how / if Tuist automatically generates the workspace scheme.
        /// Default value when not set is `.autogeneratedWorkspaceSchemes(.enabled([]))`
        case autogeneratedWorkspaceSchemes(AutogeneratedWorkspaceSchemes)
    }

    // MARK: - Attributes

    /// Path to where the manifest / root directory of this workspace is located
    public var path: AbsolutePath
    /// Path to where the `.xcworkspace` will be generated
    public var xcWorkspacePath: AbsolutePath
    public var name: String
    public var projects: [AbsolutePath]
    public var schemes: [Scheme]
    public var ideTemplateMacros: IDETemplateMacros?
    public var additionalFiles: [FileElement]
    public var lastUpgradeCheck: Version?
    public var generationOptions: [GenerationOption]

    // MARK: - Init

    public init(
        path: AbsolutePath,
        xcWorkspacePath: AbsolutePath,
        name: String,
        projects: [AbsolutePath],
        schemes: [Scheme] = [],
        generationOptions: [GenerationOption] = [],
        ideTemplateMacros: IDETemplateMacros? = nil,
        additionalFiles: [FileElement] = [],
        lastUpgradeCheck: Version? = nil
    ) {
        self.path = path
        self.xcWorkspacePath = xcWorkspacePath
        self.name = name
        self.projects = projects
        self.schemes = schemes
        self.generationOptions = generationOptions
        self.ideTemplateMacros = ideTemplateMacros
        self.additionalFiles = additionalFiles
        self.lastUpgradeCheck = lastUpgradeCheck
    }
}

extension Workspace {
    public func with(name: String) -> Workspace {
        var copy = self
        copy.name = name
        return copy
    }

    public func adding(files: [AbsolutePath]) -> Workspace {
        Workspace(
            path: path,
            xcWorkspacePath: xcWorkspacePath,
            name: name,
            projects: projects,
            schemes: schemes,
            generationOptions: generationOptions,
            ideTemplateMacros: ideTemplateMacros,
            additionalFiles: additionalFiles + files.map { .file(path: $0) },
            lastUpgradeCheck: lastUpgradeCheck
        )
    }

    public func replacing(projects: [AbsolutePath]) -> Workspace {
        Workspace(
            path: path,
            xcWorkspacePath: xcWorkspacePath,
            name: name,
            projects: projects,
            schemes: schemes,
            generationOptions: generationOptions,
            ideTemplateMacros: ideTemplateMacros,
            additionalFiles: additionalFiles,
            lastUpgradeCheck: lastUpgradeCheck
        )
    }

    public func merging(projects otherProjects: [AbsolutePath]) -> Workspace {
        Workspace(
            path: path,
            xcWorkspacePath: xcWorkspacePath,
            name: name,
            projects: Array(Set(projects + otherProjects)),
            schemes: schemes,
            generationOptions: generationOptions,
            ideTemplateMacros: ideTemplateMacros,
            additionalFiles: additionalFiles,
            lastUpgradeCheck: lastUpgradeCheck
        )
    }

    public func codeCoverageTargets(projects: [Project]) -> [TargetReference] {
        switch self.codeCoverageMode {
        case .all, .disabled: return []
        case let .targets(targets): return targets
        case .relevant:
            let allSchemes = schemes + projects.flatMap(\.schemes)
            var resultTargets = Set<TargetReference>()

            allSchemes.forEach { scheme in
                // try to add code coverage targets only if code coverage is enabled
                guard let testAction = scheme.testAction, testAction.coverage else { return }

                let schemeCoverageTargets = testAction.codeCoverageTargets

                // having empty `codeCoverageTargets` means that we should gather code coverage for all build targets
                if schemeCoverageTargets.isEmpty, let buildAction = scheme.buildAction {
                    resultTargets.formUnion(buildAction.targets)
                } else {
                    resultTargets.formUnion(schemeCoverageTargets)
                }
            }

            // if we find no schemes that gather code coverage data, there are no relevant targets,
            // so we disable code coverage
            if resultTargets.isEmpty {
                return []
            }

            return Array(resultTargets)
        }
    }
}

extension Workspace {
    public var automaticXcodeSchemes: GenerationOption.AutomaticXcodeSchemes? {
        return generationOptions.compactMap { option -> GenerationOption.AutomaticXcodeSchemes? in
            switch option {
            case let .automaticXcodeSchemes(options): return options
            default: return nil
            }
        }.first
    }

    public var autogeneratedWorkspaceOptions: GenerationOption.AutogeneratedWorkspaceSchemes {
        generationOptions.compactMap { option -> GenerationOption.AutogeneratedWorkspaceSchemes? in
            switch option {
            case let .autogeneratedWorkspaceSchemes(options): return options
            default: return nil
            }
        }.first ?? .disabled
    }

    public var codeCoverageMode: GenerationOption.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
        switch self.autogeneratedWorkspaceOptions {
        case let .enabled(codeCoverageMode, _):
            return codeCoverageMode
        case .disabled:
            return .disabled
        }
    }

    public var testingOptions: TestingOptions {
        switch self.autogeneratedWorkspaceOptions {
        case let .enabled(_, testingOptions):
            return testingOptions
        case .disabled:
            return []
        }
    }
}
