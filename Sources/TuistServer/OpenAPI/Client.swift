// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// Create a a new command analytics event
    ///
    /// - Remark: HTTP `POST /api/analytics`.
    /// - Remark: Generated from `#/paths//api/analytics/post(createCommandEvent)`.
    public func createCommandEvent(_ input: Operations.createCommandEvent.Input) async throws
        -> Operations.createCommandEvent.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createCommandEvent.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/analytics",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.createCommandEvent.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createCommandEvent.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.CommandEvent.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.createCommandEvent.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createCommandEvent.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.createCommandEvent.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createCommandEvent.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Authenticate with email and password.
    ///
    /// This endpoint returns API tokens for a given email and password.
    ///
    /// - Remark: HTTP `POST /api/auth`.
    /// - Remark: Generated from `#/paths//api/auth/post(authenticate)`.
    public func authenticate(_ input: Operations.authenticate.Input) async throws
        -> Operations.authenticate.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.authenticate.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(template: "/api/auth", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.authenticate.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.authenticate.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthenticationTokens.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.authenticate.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.authenticate.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Get a specific device code.
    ///
    /// This endpoint returns a token for a given device code if the device code is authenticated.
    ///
    /// - Remark: HTTP `GET /api/auth/device_code/{device_code}`.
    /// - Remark: Generated from `#/paths//api/auth/device_code/{device_code}/get(getDeviceCode)`.
    public func getDeviceCode(_ input: Operations.getDeviceCode.Input) async throws
        -> Operations.getDeviceCode.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getDeviceCode.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/auth/device_code/{}",
                    parameters: [input.path.device_code]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.getDeviceCode.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.getDeviceCode.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.getDeviceCode.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 202:
                    let headers: Operations.getDeviceCode.Output.Accepted.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.getDeviceCode.Output.Accepted.Body =
                        try converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIObjectContainer.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .accepted(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.getDeviceCode.Output.BadRequest.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.getDeviceCode.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Request new tokens.
    ///
    /// This endpoint returns new tokens for a given refresh token if the refresh token is valid.
    ///
    /// - Remark: HTTP `POST /api/auth/refresh_token`.
    /// - Remark: Generated from `#/paths//api/auth/refresh_token/post(refreshToken)`.
    public func refreshToken(_ input: Operations.refreshToken.Input) async throws
        -> Operations.refreshToken.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.refreshToken.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/auth/refresh_token",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.refreshToken.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.refreshToken.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.AuthenticationTokens.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.refreshToken.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.refreshToken.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Downloads an artifact from the cache.
    ///
    /// This endpoint returns a signed URL that can be used to download an artifact from the cache.
    ///
    /// - Remark: HTTP `GET /api/cache`.
    /// - Remark: Generated from `#/paths//api/cache/get(downloadCacheArtifact)`.
    public func downloadCacheArtifact(_ input: Operations.downloadCacheArtifact.Input) async throws
        -> Operations.downloadCacheArtifact.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.downloadCacheArtifact.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(template: "/api/cache", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "cache_category",
                    value: input.query.cache_category
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.downloadCacheArtifact.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.downloadCacheArtifact.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.CacheArtifactDownloadURL.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.downloadCacheArtifact.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.downloadCacheArtifact.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 402:
                    let headers: Operations.downloadCacheArtifact.Output.PaymentRequired.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.downloadCacheArtifact.Output.PaymentRequired.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .paymentRequired(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.downloadCacheArtifact.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.downloadCacheArtifact.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.downloadCacheArtifact.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.downloadCacheArtifact.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It checks if an artifact exists in the cache.
    ///
    /// This endpoint checks if an artifact exists in the cache. It returns a 404 status code if the artifact does not exist.
    ///
    /// - Remark: HTTP `GET /api/cache/exists`.
    /// - Remark: Generated from `#/paths//api/cache/exists/get(cacheArtifactExists)`.
    public func cacheArtifactExists(_ input: Operations.cacheArtifactExists.Input) async throws
        -> Operations.cacheArtifactExists.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.cacheArtifactExists.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/cache/exists",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "cache_category",
                    value: input.query.cache_category
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.cacheArtifactExists.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cacheArtifactExists.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.cacheArtifactExists.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.cacheArtifactExists.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cacheArtifactExists.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 402:
                    let headers: Operations.cacheArtifactExists.Output.PaymentRequired.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cacheArtifactExists.Output.PaymentRequired.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .paymentRequired(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.cacheArtifactExists.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cacheArtifactExists.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.cacheArtifactExists.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cacheArtifactExists.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.cacheArtifactExists.Output.NotFound.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It completes a multi-part upload.
    ///
    /// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart upload. The cache will then be able to serve the artifact.
    ///
    /// - Remark: HTTP `POST /api/cache/multipart/complete`.
    /// - Remark: Generated from `#/paths//api/cache/multipart/complete/post(completeCacheArtifactMultipartUpload)`.
    public func completeCacheArtifactMultipartUpload(
        _ input: Operations.completeCacheArtifactMultipartUpload.Input
    ) async throws -> Operations.completeCacheArtifactMultipartUpload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.completeCacheArtifactMultipartUpload.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/cache/multipart/complete",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "cache_category",
                    value: input.query.cache_category
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "upload_id",
                    value: input.query.upload_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.completeCacheArtifactMultipartUpload.Output.Ok.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.completeCacheArtifactMultipartUpload.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.completeCacheArtifactMultipartUpload.Output.Ok.Body
                                .jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers:
                        Operations.completeCacheArtifactMultipartUpload.Output.Unauthorized.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeCacheArtifactMultipartUpload.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 402:
                    let headers:
                        Operations.completeCacheArtifactMultipartUpload.Output.PaymentRequired
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeCacheArtifactMultipartUpload.Output.PaymentRequired.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .paymentRequired(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.completeCacheArtifactMultipartUpload.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeCacheArtifactMultipartUpload.Output.Forbidden.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.completeCacheArtifactMultipartUpload.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.completeCacheArtifactMultipartUpload.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It generates a signed URL for uploading a part.
    ///
    /// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
    ///
    /// - Remark: HTTP `POST /api/cache/multipart/generate-url`.
    /// - Remark: Generated from `#/paths//api/cache/multipart/generate-url/post(generateCacheArtifactMultipartUploadURL)`.
    public func generateCacheArtifactMultipartUploadURL(
        _ input: Operations.generateCacheArtifactMultipartUploadURL.Input
    ) async throws -> Operations.generateCacheArtifactMultipartUploadURL.Output {
        try await client.send(
            input: input,
            forOperation: Operations.generateCacheArtifactMultipartUploadURL.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/cache/multipart/generate-url",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "cache_category",
                    value: input.query.cache_category
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "part_number",
                    value: input.query.part_number
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "upload_id",
                    value: input.query.upload_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.Ok.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.generateCacheArtifactMultipartUploadURL.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.ArtifactMultipartUploadURL.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.Unauthorized
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 402:
                    let headers:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.PaymentRequired
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.PaymentRequired
                            .Body = try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .paymentRequired(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.Forbidden.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateCacheArtifactMultipartUploadURL.Output.NotFound.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It initiates a multipart upload in the cache.
    ///
    /// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and complete the upload.
    ///
    /// - Remark: HTTP `POST /api/cache/multipart/start`.
    /// - Remark: Generated from `#/paths//api/cache/multipart/start/post(startCacheArtifactMultipartUpload)`.
    public func startCacheArtifactMultipartUpload(
        _ input: Operations.startCacheArtifactMultipartUpload.Input
    ) async throws -> Operations.startCacheArtifactMultipartUpload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.startCacheArtifactMultipartUpload.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/cache/multipart/start",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "cache_category",
                    value: input.query.cache_category
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsText(
                    in: &request,
                    name: "name",
                    value: input.query.name
                )
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.startCacheArtifactMultipartUpload.Output.Ok.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.startCacheArtifactMultipartUpload.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.ArtifactUploadID.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers:
                        Operations.startCacheArtifactMultipartUpload.Output.Unauthorized.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.startCacheArtifactMultipartUpload.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 402:
                    let headers:
                        Operations.startCacheArtifactMultipartUpload.Output.PaymentRequired.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.startCacheArtifactMultipartUpload.Output.PaymentRequired.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .paymentRequired(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.startCacheArtifactMultipartUpload.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.startCacheArtifactMultipartUpload.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.startCacheArtifactMultipartUpload.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.startCacheArtifactMultipartUpload.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Lists the organizations
    ///
    /// Returns all the organizations the authenticated subject is part of.
    ///
    /// - Remark: HTTP `GET /api/organizations`.
    /// - Remark: Generated from `#/paths//api/organizations/get(listOrganizations)`.
    public func listOrganizations(_ input: Operations.listOrganizations.Input) async throws
        -> Operations.listOrganizations.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.listOrganizations.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.listOrganizations.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listOrganizations.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.listOrganizations.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.listOrganizations.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listOrganizations.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.listOrganizations.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listOrganizations.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Creates an organization
    ///
    /// Creates an organization with the given name.
    ///
    /// - Remark: HTTP `POST /api/organizations`.
    /// - Remark: Generated from `#/paths//api/organizations/post(createOrganization)`.
    public func createOrganization(_ input: Operations.createOrganization.Input) async throws
        -> Operations.createOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createOrganization.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.createOrganization.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createOrganization.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.createOrganization.Output.BadRequest.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createOrganization.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Shows an organization
    ///
    /// Returns the organization with the given identifier.
    ///
    /// - Remark: HTTP `GET /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/get(showOrganization)`.
    public func showOrganization(_ input: Operations.showOrganization.Input) async throws
        -> Operations.showOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.showOrganization.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.showOrganization.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganization.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.showOrganization.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganization.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.showOrganization.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganization.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.showOrganization.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganization.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Updates an organization
    ///
    /// Updates an organization with given parameters.
    ///
    /// - Remark: HTTP `PATCH /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/patch(updateOrganization (2))`.
    public func updateOrganization__2_(_ input: Operations.updateOrganization__2_.Input)
        async throws -> Operations.updateOrganization__2_.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.updateOrganization__2_.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .patch)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.updateOrganization__2_.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization__2_.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.updateOrganization__2_.Output.BadRequest.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization__2_.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.updateOrganization__2_.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization__2_.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.updateOrganization__2_.Output.Forbidden.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization__2_.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.updateOrganization__2_.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization__2_.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Updates an organization
    ///
    /// Updates an organization with given parameters.
    ///
    /// - Remark: HTTP `PUT /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/put(updateOrganization)`.
    public func updateOrganization(_ input: Operations.updateOrganization.Input) async throws
        -> Operations.updateOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.updateOrganization.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.updateOrganization.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.updateOrganization.Output.BadRequest.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.updateOrganization.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.updateOrganization.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.updateOrganization.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganization.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes an organization
    ///
    /// Deletes the organization with the given name.
    ///
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/delete(deleteOrganization)`.
    public func deleteOrganization(_ input: Operations.deleteOrganization.Input) async throws
        -> Operations.deleteOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.deleteOrganization.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.deleteOrganization.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers: Operations.deleteOrganization.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteOrganization.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.deleteOrganization.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteOrganization.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.deleteOrganization.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteOrganization.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Creates an invitation
    ///
    /// Invites a user with a given email to a given organization.
    ///
    /// - Remark: HTTP `POST /api/organizations/{organization_name}/invitations`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/invitations/post(createInvitation)`.
    public func createInvitation(_ input: Operations.createInvitation.Input) async throws
        -> Operations.createInvitation.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createInvitation.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}/invitations",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.createInvitation.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createInvitation.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Invitation.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.createInvitation.Output.BadRequest.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createInvitation.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.createInvitation.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createInvitation.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.createInvitation.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createInvitation.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.createInvitation.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createInvitation.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Cancels an invitation
    ///
    /// Cancels an invitation for a given invitee email and an organization.
    ///
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}/invitations`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/invitations/delete(cancelInvitation)`.
    public func cancelInvitation(_ input: Operations.cancelInvitation.Input) async throws
        -> Operations.cancelInvitation.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.cancelInvitation.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}/invitations",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.cancelInvitation.Output.NoContent.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cancelInvitation.Output.NoContent.Body =
                        try converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .noContent(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.cancelInvitation.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cancelInvitation.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.cancelInvitation.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cancelInvitation.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.cancelInvitation.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cancelInvitation.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Updates a member in an organization
    ///
    /// Updates a member in a given organization
    ///
    /// - Remark: HTTP `PUT /api/organizations/{organization_name}/members/{user_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/members/{user_name}/put(updateOrganizationMember)`.
    public func updateOrganizationMember(_ input: Operations.updateOrganizationMember.Input)
        async throws -> Operations.updateOrganizationMember.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.updateOrganizationMember.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}/members/{}",
                    parameters: [input.path.organization_name, input.path.user_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.updateOrganizationMember.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganizationMember.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.OrganizationMember.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.updateOrganizationMember.Output.BadRequest.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganizationMember.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.updateOrganizationMember.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganizationMember.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.updateOrganizationMember.Output.Forbidden.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganizationMember.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.updateOrganizationMember.Output.NotFound.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.updateOrganizationMember.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Removes a member from an organization
    ///
    /// Removes a member with a given username from a given organization
    ///
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}/members/{user_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/members/{user_name}/delete(removeOrganizationMember)`.
    public func removeOrganizationMember(_ input: Operations.removeOrganizationMember.Input)
        async throws -> Operations.removeOrganizationMember.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.removeOrganizationMember.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}/members/{}",
                    parameters: [input.path.organization_name, input.path.user_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.removeOrganizationMember.Output.NoContent.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.removeOrganizationMember.Output.NoContent.Body =
                        try converter.getResponseBodyAsJSON(
                            OpenAPIRuntime.OpenAPIValueContainer.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .noContent(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.removeOrganizationMember.Output.BadRequest.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.removeOrganizationMember.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.removeOrganizationMember.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.removeOrganizationMember.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.removeOrganizationMember.Output.Forbidden.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.removeOrganizationMember.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.removeOrganizationMember.Output.NotFound.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.removeOrganizationMember.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Shows the usage of an organization
    ///
    /// Returns the usage of the organization with the given identifier. (e.g. number of remote cache hits)
    ///
    /// - Remark: HTTP `GET /api/organizations/{organization_name}/usage`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/usage/get(showOrganizationUsage)`.
    public func showOrganizationUsage(_ input: Operations.showOrganizationUsage.Input) async throws
        -> Operations.showOrganizationUsage.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.showOrganizationUsage.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/organizations/{}/usage",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.showOrganizationUsage.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganizationUsage.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.OrganizationUsage.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.showOrganizationUsage.Output.Unauthorized.Headers =
                        .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganizationUsage.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.showOrganizationUsage.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganizationUsage.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.showOrganizationUsage.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showOrganizationUsage.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List projects the authenticated user has access to.
    ///
    /// - Remark: HTTP `GET /api/projects`.
    /// - Remark: Generated from `#/paths//api/projects/get(listProjects)`.
    public func listProjects(_ input: Operations.listProjects.Input) async throws
        -> Operations.listProjects.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.listProjects.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.listProjects.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjects.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.listProjects.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.listProjects.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjects.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a new project.
    ///
    /// - Remark: HTTP `POST /api/projects`.
    /// - Remark: Generated from `#/paths//api/projects/post(createProject)`.
    public func createProject(_ input: Operations.createProject.Input) async throws
        -> Operations.createProject.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createProject.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects",
                    parameters: []
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.createProject.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProject.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 400:
                    let headers: Operations.createProject.Output.BadRequest.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProject.Output.BadRequest.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .badRequest(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.createProject.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProject.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.createProject.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProject.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Returns a project based on the handle.
    ///
    /// - Remark: HTTP `GET /api/projects/{account_handle}/{project_handle}`.
    /// - Remark: Generated from `#/paths//api/projects/{account_handle}/{project_handle}/get(showProject)`.
    public func showProject(_ input: Operations.showProject.Input) async throws
        -> Operations.showProject.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.showProject.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}/{}",
                    parameters: [input.path.account_handle, input.path.project_handle]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.showProject.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showProject.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.Project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.showProject.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showProject.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.showProject.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showProject.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.showProject.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.showProject.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Cleans cache for a given project
    ///
    /// - Remark: HTTP `PUT /api/projects/{account_handle}/{project_handle}/cache/clean`.
    /// - Remark: Generated from `#/paths//api/projects/{account_handle}/{project_handle}/cache/clean/put(cleanCache)`.
    public func cleanCache(_ input: Operations.cleanCache.Input) async throws
        -> Operations.cleanCache.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.cleanCache.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}/{}/cache/clean",
                    parameters: [input.path.account_handle, input.path.project_handle]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.cleanCache.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers: Operations.cleanCache.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cleanCache.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.cleanCache.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cleanCache.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.cleanCache.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.cleanCache.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// List all project tokens.
    ///
    /// This endpoint returns all tokens for a given project.
    ///
    /// - Remark: HTTP `GET /api/projects/{account_handle}/{project_handle}/tokens`.
    /// - Remark: Generated from `#/paths//api/projects/{account_handle}/{project_handle}/tokens/get(listProjectTokens)`.
    public func listProjectTokens(_ input: Operations.listProjectTokens.Input) async throws
        -> Operations.listProjectTokens.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.listProjectTokens.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}/{}/tokens",
                    parameters: [input.path.account_handle, input.path.project_handle]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.listProjectTokens.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjectTokens.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.listProjectTokens.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.listProjectTokens.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjectTokens.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.listProjectTokens.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjectTokens.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.listProjectTokens.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.listProjectTokens.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Create a new project token.
    ///
    /// This endpoint returns a new project token.
    ///
    /// - Remark: HTTP `POST /api/projects/{account_handle}/{project_handle}/tokens`.
    /// - Remark: Generated from `#/paths//api/projects/{account_handle}/{project_handle}/tokens/post(createProjectToken)`.
    public func createProjectToken(_ input: Operations.createProjectToken.Input) async throws
        -> Operations.createProjectToken.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createProjectToken.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}/{}/tokens",
                    parameters: [input.path.account_handle, input.path.project_handle]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers: Operations.createProjectToken.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProjectToken.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Operations.createProjectToken.Output.Ok.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers: Operations.createProjectToken.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProjectToken.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.createProjectToken.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProjectToken.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.createProjectToken.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.createProjectToken.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Revokes a project token.
    ///
    /// - Remark: HTTP `DELETE /api/projects/{account_handle}/{project_handle}/tokens/{id}`.
    /// - Remark: Generated from `#/paths//api/projects/{account_handle}/{project_handle}/tokens/{id}/delete(revokeProjectToken)`.
    public func revokeProjectToken(_ input: Operations.revokeProjectToken.Input) async throws
        -> Operations.revokeProjectToken.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.revokeProjectToken.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}/{}/tokens/{}",
                    parameters: [
                        input.path.account_handle, input.path.project_handle, input.path.id,
                    ]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.revokeProjectToken.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers: Operations.revokeProjectToken.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.revokeProjectToken.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.revokeProjectToken.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.revokeProjectToken.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.revokeProjectToken.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.revokeProjectToken.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Deletes a project with a given id.
    ///
    /// - Remark: HTTP `DELETE /api/projects/{id}`.
    /// - Remark: Generated from `#/paths//api/projects/{id}/delete(deleteProject)`.
    public func deleteProject(_ input: Operations.deleteProject.Input) async throws
        -> Operations.deleteProject.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.deleteProject.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/projects/{}",
                    parameters: [input.path.id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers: Operations.deleteProject.Output.NoContent.Headers = .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers: Operations.deleteProject.Output.Unauthorized.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteProject.Output.Unauthorized.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers: Operations.deleteProject.Output.Forbidden.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteProject.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers: Operations.deleteProject.Output.NotFound.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.deleteProject.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It completes a multi-part upload.
    ///
    /// Given the upload ID and all the parts with their ETags, this endpoint completes the multipart upload.
    ///
    /// - Remark: HTTP `POST /api/runs/{run_id}/complete`.
    /// - Remark: Generated from `#/paths//api/runs/{run_id}/complete/post(completeAnalyticsArtifactMultipartUpload)`.
    public func completeAnalyticsArtifactMultipartUpload(
        _ input: Operations.completeAnalyticsArtifactMultipartUpload.Input
    ) async throws -> Operations.completeAnalyticsArtifactMultipartUpload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.completeAnalyticsArtifactMultipartUpload.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/runs/{}/complete",
                    parameters: [input.path.run_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.NoContent.Headers =
                            .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.Unauthorized
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.Forbidden.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeAnalyticsArtifactMultipartUpload.Output.NotFound.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// Completes artifacts uploads for a given command event
    ///
    /// Given a command event, it marks all artifact uploads as finished and does extra processing of a given command run, such as test flakiness detection.
    ///
    /// - Remark: HTTP `PUT /api/runs/{run_id}/complete_artifacts_uploads`.
    /// - Remark: Generated from `#/paths//api/runs/{run_id}/complete_artifacts_uploads/put(completeAnalyticsArtifactsUploads)`.
    public func completeAnalyticsArtifactsUploads(
        _ input: Operations.completeAnalyticsArtifactsUploads.Input
    ) async throws -> Operations.completeAnalyticsArtifactsUploads.Output {
        try await client.send(
            input: input,
            forOperation: Operations.completeAnalyticsArtifactsUploads.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/runs/{}/complete_artifacts_uploads",
                    parameters: [input.path.run_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204:
                    let headers:
                        Operations.completeAnalyticsArtifactsUploads.Output.NoContent.Headers =
                            .init()
                    return .noContent(.init(headers: headers, body: nil))
                case 401:
                    let headers:
                        Operations.completeAnalyticsArtifactsUploads.Output.Unauthorized.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.completeAnalyticsArtifactsUploads.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.completeAnalyticsArtifactsUploads.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.completeAnalyticsArtifactsUploads.Output.Forbidden.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.completeAnalyticsArtifactsUploads.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.completeAnalyticsArtifactsUploads.Output.NotFound.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It generates a signed URL for uploading a part.
    ///
    /// Given an upload ID and a part number, this endpoint returns a signed URL that can be used to upload a part of a multipart upload. The URL is short-lived and expires in 120 seconds.
    ///
    /// - Remark: HTTP `POST /api/runs/{run_id}/generate-url`.
    /// - Remark: Generated from `#/paths//api/runs/{run_id}/generate-url/post(generateAnalyticsArtifactMultipartUploadURL)`.
    public func generateAnalyticsArtifactMultipartUploadURL(
        _ input: Operations.generateAnalyticsArtifactMultipartUploadURL.Input
    ) async throws -> Operations.generateAnalyticsArtifactMultipartUploadURL.Output {
        try await client.send(
            input: input,
            forOperation: Operations.generateAnalyticsArtifactMultipartUploadURL.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/runs/{}/generate-url",
                    parameters: [input.path.run_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Ok.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Ok.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas.ArtifactMultipartUploadURL.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Unauthorized
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Unauthorized
                            .Body = try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Forbidden
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.Forbidden.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.NotFound
                            .Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.generateAnalyticsArtifactMultipartUploadURL.Output.NotFound.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// It initiates a multipart upload for a command event artifact.
    ///
    /// The endpoint returns an upload ID that can be used to generate URLs for the individual parts and complete the upload.
    ///
    /// - Remark: HTTP `POST /api/runs/{run_id}/start`.
    /// - Remark: Generated from `#/paths//api/runs/{run_id}/start/post(startAnalyticsArtifactMultipartUpload)`.
    public func startAnalyticsArtifactMultipartUpload(
        _ input: Operations.startAnalyticsArtifactMultipartUpload.Input
    ) async throws -> Operations.startAnalyticsArtifactMultipartUpload.Output {
        try await client.send(
            input: input,
            forOperation: Operations.startAnalyticsArtifactMultipartUpload.id,
            serializer: { input in
                let path = try converter.renderedRequestPath(
                    template: "/api/runs/{}/start",
                    parameters: [input.path.run_id]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setHeaderFieldAsText(
                    in: &request.headerFields,
                    name: "accept",
                    value: "application/json"
                )
                request.body = try converter.setOptionalRequestBodyAsJSON(
                    input.body,
                    headerFields: &request.headerFields,
                    transforming: { wrapped in
                        switch wrapped {
                        case let .json(value):
                            return .init(
                                value: value,
                                contentType: "application/json; charset=utf-8"
                            )
                        }
                    }
                )
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let headers:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.Ok.Headers = .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body: Operations.startAnalyticsArtifactMultipartUpload.Output.Ok.Body =
                        try converter.getResponseBodyAsJSON(
                            Components.Schemas.ArtifactUploadID.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    return .ok(.init(headers: headers, body: body))
                case 401:
                    let headers:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.Unauthorized.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.Unauthorized.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .unauthorized(.init(headers: headers, body: body))
                case 403:
                    let headers:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.Forbidden.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.Forbidden.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .forbidden(.init(headers: headers, body: body))
                case 404:
                    let headers:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.NotFound.Headers =
                            .init()
                    try converter.validateContentTypeIfPresent(
                        in: response.headerFields,
                        substring: "application/json"
                    )
                    let body:
                        Operations.startAnalyticsArtifactMultipartUpload.Output.NotFound.Body =
                            try converter.getResponseBodyAsJSON(
                                Components.Schemas._Error.self,
                                from: response.body,
                                transforming: { value in .json(value) }
                            )
                    return .notFound(.init(headers: headers, body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
