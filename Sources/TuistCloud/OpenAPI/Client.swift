// Generated by swift-openapi-generator, do not modify.
@_spi(Generated) import OpenAPIRuntime
#if os(Linux)
@preconcurrency import Foundation
#else
import Foundation
#endif
public struct Client: APIProtocol {
    /// The underlying HTTP client.
    private let client: UniversalClient
    /// Creates a new client.
    /// - Parameters:
    ///   - serverURL: The server URL that the client connects to. Any server
    ///   URLs defined in the OpenAPI document are available as static methods
    ///   on the ``Servers`` type.
    ///   - configuration: A set of configuration values for the client.
    ///   - transport: A transport that performs HTTP operations.
    ///   - middlewares: A list of middlewares to call before the transport.
    public init(
        serverURL: URL,
        configuration: Configuration = .init(),
        transport: any ClientTransport,
        middlewares: [any ClientMiddleware] = []
    ) {
        self.client = .init(
            serverURL: serverURL,
            configuration: configuration,
            transport: transport,
            middlewares: middlewares
        )
    }
    private var converter: Converter { client.converter }
    /// - Remark: HTTP `GET /api/projects`.
    /// - Remark: Generated from `#/paths//api/projects/get(listProjects)`.
    public func listProjects(_ input: Operations.listProjects.Input) async throws -> Operations.listProjects.Output {
        try await client.send(
            input: input,
            forOperation: Operations.listProjects.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/projects", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "account_name",
                    value: input.query.account_name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "project_name",
                    value: input.query.project_name
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.listProjects.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Projects.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `POST /api/projects`.
    /// - Remark: Generated from `#/paths//api/projects/post(createProject)`.
    public func createProject(_ input: Operations.createProject.Input) async throws -> Operations.createProject.Output {
        try await client.send(
            input: input,
            forOperation: Operations.createProject.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/projects", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createProject.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createProject.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `GET /api/organizations`.
    /// - Remark: Generated from `#/paths//api/organizations/get(listOrganizations)`.
    public func listOrganizations(_ input: Operations.listOrganizations.Input) async throws
        -> Operations.listOrganizations.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.listOrganizations.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/organizations", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.listOrganizations.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organizations.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `POST /api/organizations`.
    /// - Remark: Generated from `#/paths//api/organizations/post(createOrganization)`.
    public func createOrganization(_ input: Operations.createOrganization.Input) async throws
        -> Operations.createOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createOrganization.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/organizations", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganization.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganization.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /api/projects/{id}`.
    /// - Remark: Generated from `#/paths//api/projects/{id}/delete(deleteProject)`.
    public func deleteProject(_ input: Operations.deleteProject.Input) async throws -> Operations.deleteProject.Output {
        try await client.send(
            input: input,
            forOperation: Operations.deleteProject.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/api/projects/{}", parameters: [input.path.id])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204: return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteProject.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteProject.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `GET /api/projects/{account_name}/{project_name}`.
    /// - Remark: Generated from `#/paths//api/projects/{account_name}/{project_name}/get(getProject)`.
    public func getProject(_ input: Operations.getProject.Input) async throws -> Operations.getProject.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getProject.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/projects/{}/{}",
                    parameters: [input.path.account_name, input.path.project_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProject.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Project.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProject.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getProject.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /api/projects/{full_name}/cache/clean`.
    /// - Remark: Generated from `#/paths//api/projects/{full_name}/cache/clean/put(cleanCache)`.
    public func cleanCache(_ input: Operations.cleanCache.Input) async throws -> Operations.cleanCache.Output {
        try await client.send(
            input: input,
            forOperation: Operations.cleanCache.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/projects/{}/cache/clean",
                    parameters: [input.path.full_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204: return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cleanCache.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `GET /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/get(getOrganization)`.
    public func getOrganization(_ input: Operations.getOrganization.Input) async throws
        -> Operations.getOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.getOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrganization.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Organization.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrganization.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getOrganization.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/delete(deleteOrganization)`.
    public func deleteOrganization(_ input: Operations.deleteOrganization.Input) async throws
        -> Operations.deleteOrganization.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.deleteOrganization.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204: return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteOrganization.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.deleteOrganization.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `POST /api/organizations/{organization_name}/invitations`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/invitations/post(createOrganizationInvite)`.
    public func createOrganizationInvite(_ input: Operations.createOrganizationInvite.Input) async throws
        -> Operations.createOrganizationInvite.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.createOrganizationInvite.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}/invitations",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganizationInvite.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.Invitation.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganizationInvite.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganizationInvite.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 400:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.createOrganizationInvite.Output.BadRequest.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .badRequest(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}/invitations`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/invitations/delete(cancelOrganizationInvite)`.
    public func cancelOrganizationInvite(_ input: Operations.cancelOrganizationInvite.Input) async throws
        -> Operations.cancelOrganizationInvite.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.cancelOrganizationInvite.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}/invitations",
                    parameters: [input.path.organization_name]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204: return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cancelOrganizationInvite.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cancelOrganizationInvite.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `PUT /api/organizations/{organization_name}/members/{username}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/members/{username}/put(updateOrganizationMember)`.
    public func updateOrganizationMember(_ input: Operations.updateOrganizationMember.Input) async throws
        -> Operations.updateOrganizationMember.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.updateOrganizationMember.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}/members/{}",
                    parameters: [input.path.organization_name, input.path.username]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .put)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                switch input.body {
                case let .json(value):
                    request.body = try converter.setRequiredRequestBodyAsJSON(
                        value,
                        headerFields: &request.headerFields,
                        contentType: "application/json; charset=utf-8"
                    )
                }
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateOrganizationMember.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.OrganizationMember.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateOrganizationMember.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.updateOrganizationMember.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `DELETE /api/organizations/{organization_name}/members/{username}`.
    /// - Remark: Generated from `#/paths//api/organizations/{organization_name}/members/{username}/delete(removeOrganizationMember)`.
    public func removeOrganizationMember(_ input: Operations.removeOrganizationMember.Input) async throws
        -> Operations.removeOrganizationMember.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.removeOrganizationMember.id,
            serializer: { input in
                let path = try converter.renderedPath(
                    template: "/api/organizations/{}/members/{}",
                    parameters: [input.path.organization_name, input.path.username]
                )
                var request: OpenAPIRuntime.Request = .init(path: path, method: .delete)
                suppressMutabilityWarning(&request)
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 204: return .noContent(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.removeOrganizationMember.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.removeOrganizationMember.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `GET /api/cache/exists`.
    /// - Remark: Generated from `#/paths//api/cache/exists/get(cacheExists)`.
    public func cacheExists(_ input: Operations.cacheExists.Input) async throws -> Operations.cacheExists.Output {
        try await client.send(
            input: input,
            forOperation: Operations.cacheExists.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/cache/exists", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200: return .ok(.init())
                case 404:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cacheExists.Output.NotFound.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Operations.cacheExists.Output.NotFound.Body.jsonPayload.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .notFound(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cacheExists.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 402:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.cacheExists.Output.PaymentRequired.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .paymentRequired(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `GET /api/cache`.
    /// - Remark: Generated from `#/paths//api/cache/get(getCache)`.
    public func getCache(_ input: Operations.getCache.Input) async throws -> Operations.getCache.Output {
        try await client.send(
            input: input,
            forOperation: Operations.getCache.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/cache", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .get)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCache.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CacheArtifact.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCache.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 402:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.getCache.Output.PaymentRequired.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .paymentRequired(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `POST /api/cache`.
    /// - Remark: Generated from `#/paths//api/cache/post(uploadCache)`.
    public func uploadCache(_ input: Operations.uploadCache.Input) async throws -> Operations.uploadCache.Output {
        try await client.send(
            input: input,
            forOperation: Operations.uploadCache.id,
            serializer: { input in let path = try converter.renderedPath(template: "/api/cache", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "content_md5",
                    value: input.query.content_md5
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.uploadCache.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CacheArtifact.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                case 401:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.uploadCache.Output.Unauthorized.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .unauthorized(.init(body: body))
                case 402:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.uploadCache.Output.PaymentRequired.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas._Error.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .paymentRequired(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
    /// - Remark: HTTP `POST /api/cache/verify_upload`.
    /// - Remark: Generated from `#/paths//api/cache/verify_upload/post(verifyCacheUpload)`.
    public func verifyCacheUpload(_ input: Operations.verifyCacheUpload.Input) async throws
        -> Operations.verifyCacheUpload.Output
    {
        try await client.send(
            input: input,
            forOperation: Operations.verifyCacheUpload.id,
            serializer: { input in
                let path = try converter.renderedPath(template: "/api/cache/verify_upload", parameters: [])
                var request: OpenAPIRuntime.Request = .init(path: path, method: .post)
                suppressMutabilityWarning(&request)
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "project_id",
                    value: input.query.project_id
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "hash",
                    value: input.query.hash
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "name",
                    value: input.query.name
                )
                try converter.setQueryItemAsURI(
                    in: &request,
                    style: .form,
                    explode: true,
                    name: "content_md5",
                    value: input.query.content_md5
                )
                converter.setAcceptHeader(in: &request.headerFields, contentTypes: input.headers.accept)
                return request
            },
            deserializer: { response in
                switch response.statusCode {
                case 200:
                    let contentType = converter.extractContentTypeIfPresent(in: response.headerFields)
                    let body: Operations.verifyCacheUpload.Output.Ok.Body
                    if try contentType == nil
                        || converter.isMatchingContentType(received: contentType, expectedRaw: "application/json")
                    {
                        body = try converter.getResponseBodyAsJSON(
                            Components.Schemas.CacheArtifactUploadVerification.self,
                            from: response.body,
                            transforming: { value in .json(value) }
                        )
                    } else {
                        throw converter.makeUnexpectedContentTypeError(contentType: contentType)
                    }
                    return .ok(.init(body: body))
                default: return .undocumented(statusCode: response.statusCode, .init())
                }
            }
        )
    }
}
