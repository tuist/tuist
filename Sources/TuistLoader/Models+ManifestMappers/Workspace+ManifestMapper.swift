import Foundation
import ProjectDescription
import TSCBasic
import TuistCore
import TuistGraph
import TuistSupport

extension TuistGraph.Workspace {
    /// Maps a ProjectDescription.Workspace instance into a TuistGraph.Workspace model.
    /// - Parameters:
    ///   - manifest: Manifest representation of  workspace.
    ///   - generatorPaths: Generator paths.
    static func from(
        manifest: ProjectDescription.Workspace,
        path: AbsolutePath,
        generatorPaths: GeneratorPaths,
        manifestLoader: ManifestLoading
    ) throws -> TuistGraph.Workspace {
        func globProjects(_ path: Path) throws -> [AbsolutePath] {
            let resolvedPath = try generatorPaths.resolve(path: path)
            let projects = FileHandler.shared.glob(AbsolutePath.root, glob: String(resolvedPath.pathString.dropFirst()))
                .lazy
                .filter(FileHandler.shared.isFolder)
                .filter {
                    manifestLoader.manifests(at: $0).contains(.project)
                }

            if projects.isEmpty {
                // FIXME: This should be done in a linter.
                // Before we can do that we have to change the linters to run with the TuistCore models and not the ProjectDescription ones.
                logger.warning("No projects found at: \(path.pathString)")
            }

            return Array(projects)
        }

        let additionalFiles = try manifest.additionalFiles.flatMap {
            try TuistGraph.FileElement.from(manifest: $0, generatorPaths: generatorPaths)
        }

        let schemes = try manifest.schemes.map { try TuistGraph.Scheme.from(manifest: $0, generatorPaths: generatorPaths) }

        let generationOptions = try manifest.generationOptionsWithDefaults.map {
            try TuistGraph.Workspace.GenerationOption.from(manifest: $0, generatorPaths: generatorPaths)
        }

        let ideTemplateMacros = try manifest.fileHeaderTemplate
            .map { try IDETemplateMacros.from(manifest: $0, generatorPaths: generatorPaths) }

        return TuistGraph.Workspace(
            path: path,
            xcWorkspacePath: path.appending(component: "\(manifest.name).xcworkspace"),
            name: manifest.name,
            projects: try manifest.projects.flatMap(globProjects),
            schemes: schemes,
            generationOptions: generationOptions,
            ideTemplateMacros: ideTemplateMacros,
            additionalFiles: additionalFiles
        )
    }
}

extension ProjectDescription.Workspace {
    var generationOptionsWithDefaults: [GenerationOption] {
        var generationOptions = generationOptions
        let containsAutogeneratedWorkspaceSchemes = generationOptions.contains {
            if case .autogeneratedWorkspaceSchemes = $0 {
                return true
            } else {
                return false
            }
        }
        if !containsAutogeneratedWorkspaceSchemes {
            generationOptions.append(.autogeneratedWorkspaceSchemes(.enabled()))
        }
        return generationOptions
    }
}

extension TuistGraph.Workspace.GenerationOption {
    /// Maps a ProjectDescription.Workspace.GenerationOption instance into a TuistGraph.Workspace.GenerationOption model.
    /// - Parameters:
    ///   - manifest: Manifest representation of Tuist config generation options
    ///   - generatorPaths: Generator paths.
    static func from(
        manifest: ProjectDescription.Workspace.GenerationOption,
        generatorPaths: GeneratorPaths
    ) throws -> Self {
        switch manifest {
        case let .automaticXcodeSchemes(automaticXcodeSchemes):
            switch automaticXcodeSchemes {
            case .enabled:
                return .automaticXcodeSchemes(.enabled)
            case .disabled:
                return .automaticXcodeSchemes(.disabled)
            }
        case let .autogeneratedWorkspaceSchemes(autogeneratedWorkspaceSchemes):
            return .autogeneratedWorkspaceSchemes(try .from(manifest: autogeneratedWorkspaceSchemes, generatorPaths: generatorPaths))
        }
    }
}

extension TuistGraph.Workspace.GenerationOption.AutogeneratedWorkspaceSchemes {
    static func from(
        manifest: ProjectDescription.Workspace.GenerationOption.AutogeneratedWorkspaceSchemes,
        generatorPaths: GeneratorPaths
    ) throws -> Self {
        switch manifest {
        case .disabled:
            return .disabled
        case let .enabled(codeCoverage, testingOptions):
            return .enabled(
                codeCoverageMode: try .from(manifest: codeCoverage, generatorPaths: generatorPaths),
                testingOptions: .from(manifest: testingOptions)
            )
        }
    }
}

extension TuistGraph.Workspace.GenerationOption.AutogeneratedWorkspaceSchemes.CodeCoverageMode {
    static func from(
        manifest: ProjectDescription.Workspace.GenerationOption.AutogeneratedWorkspaceSchemes.CodeCoverageMode,
        generatorPaths: GeneratorPaths
    ) throws -> Self {
        switch manifest {
        case .all: return .all
        case .relevant: return .relevant
        case let .targets(targets):
            let targets: [TuistGraph.TargetReference] = try targets.map {
                .init(
                    projectPath: try generatorPaths.resolveSchemeActionProjectPath($0.projectPath),
                    name: $0.targetName
                )
            }
            return .targets(targets)
        case .disabled:
            return .disabled
        }
    }
}
