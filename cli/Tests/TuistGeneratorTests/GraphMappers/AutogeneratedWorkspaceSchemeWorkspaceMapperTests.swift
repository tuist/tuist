import Foundation
import Mockable
import TuistCore
import XcodeGraph
import XCTest

@testable import TuistGenerator
@testable import TuistTesting

final class AutogeneratedWorkspaceSchemeWorkspaceMapperTests: TuistUnitTestCase {
    private var buildInsightsActionMapper: MockBuildInsightsActionMapping!
    private var testInsightsActionMapper: MockTestInsightsActionMapping!

    override func setUp() {
        super.setUp()

        buildInsightsActionMapper = MockBuildInsightsActionMapping()
        testInsightsActionMapper = MockTestInsightsActionMapping()

        given(buildInsightsActionMapper)
            .map(.any, target: .any, buildInsightsDisabled: .any)
            .willProduce { buildAction, _, _ in buildAction }

        given(testInsightsActionMapper)
            .map(.any, target: .any, testInsightsDisabled: .any)
            .willProduce { testAction, _, _ in testAction }
    }

    override func tearDown() {
        buildInsightsActionMapper = nil
        testInsightsActionMapper = nil

        super.tearDown()
    }

    func test_map() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let targetB = Target.test(
            name: "B"
        )
        let targetBTests = Target.test(
            name: "BTests",
            product: .unitTests,
            dependencies: [.target(name: "B")]
        )

        let projectBPath = try temporaryPath().appending(component: "ProjectB")
        let projectB = Project.test(
            path: projectBPath,
            targets: [
                targetB,
                targetBTests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
                projectB.path,
            ]
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
                projectBPath: projectB,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes.count, 1)
        let scheme = try XCTUnwrap(schemes.first)
        XCTAssertTrue(scheme.shared)
        XCTAssertEqual(scheme.name, "A-Workspace")
        XCTAssertEqual(
            Set(scheme.buildAction.map(\.targets) ?? []),
            Set([
                TargetReference(
                    projectPath: projectBPath,
                    name: targetB.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetA.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetATests.name
                ),
                TargetReference(
                    projectPath: projectBPath,
                    name: targetBTests.name
                ),
            ])
        )
        XCTAssertEqual(
            Set(scheme.testAction.map(\.targets) ?? []),
            Set([
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectPath,
                        name: targetATests.name
                    ),
                    parallelization: .none
                ),
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectBPath,
                        name: targetBTests.name
                    ),
                    parallelization: .none
                ),
            ])
        )
        XCTAssertFalse(try XCTUnwrap(scheme.testAction?.coverage))
    }

    func test_map_when_binary_sources() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let framework = Target.test(
            name: "Framework",
            product: .framework,
            metadata: TargetMetadata.metadata(tags: Set(["tuist:binary-sources"]))
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                framework,
            ]
        )
        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ]
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes.count, 2)
        let workspaceScheme = try XCTUnwrap(schemes.first(where: { $0.name.hasSuffix("-Workspace") }))
        let cachedWorkspace = try XCTUnwrap(schemes.first(where: { $0.name.hasSuffix("-Cached") }))
        XCTAssertEqual(workspaceScheme.buildAction?.targets.isEmpty, true)
        XCTAssertEqual(cachedWorkspace.buildAction?.targets.count, 1)
        XCTAssertEqual(cachedWorkspace.buildAction?.targets.first?.name, framework.name)
    }

    func test_map_disabled() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: false,
            testInsightsDisabled: false,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let targetB = Target.test(
            name: "B"
        )
        let targetBTests = Target.test(
            name: "BTests",
            product: .unitTests,
            dependencies: [.target(name: "B")]
        )

        let projectBPath = try temporaryPath().appending(component: "ProjectB")
        let projectB = Project.test(
            path: projectBPath,
            targets: [
                targetB,
                targetBTests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
                projectB.path,
            ],
            generationOptions: .test(autogeneratedWorkspaceSchemes: .disabled)
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
                projectBPath: projectB,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes, [])
    }

    func test_map_disabled_but_forced() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: true,
            buildInsightsDisabled: false,
            testInsightsDisabled: false,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let targetB = Target.test(
            name: "B"
        )
        let targetBTests = Target.test(
            name: "BTests",
            product: .unitTests,
            dependencies: [.target(name: "B")]
        )

        let projectBPath = try temporaryPath().appending(component: "ProjectB")
        let projectB = Project.test(
            path: projectBPath,
            targets: [
                targetB,
                targetBTests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
                projectB.path,
            ],
            generationOptions: .test(autogeneratedWorkspaceSchemes: .disabled)
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
                projectBPath: projectB,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes.count, 1)
        let scheme = try XCTUnwrap(schemes.first)
        XCTAssertTrue(scheme.shared)
        XCTAssertEqual(scheme.name, "A-Workspace")
        XCTAssertEqual(
            Set(scheme.buildAction.map(\.targets) ?? []),
            Set([
                TargetReference(
                    projectPath: projectBPath,
                    name: targetB.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetA.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetATests.name
                ),
                TargetReference(
                    projectPath: projectBPath,
                    name: targetBTests.name
                ),
            ])
        )
        XCTAssertEqual(
            Set(scheme.testAction.map(\.targets) ?? []),
            Set([
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectPath,
                        name: targetATests.name
                    ),
                    parallelization: .none
                ),
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectBPath,
                        name: targetBTests.name
                    ),
                    parallelization: .none
                ),
            ])
        )
        XCTAssertFalse(try XCTUnwrap(scheme.testAction?.coverage))
    }

    func test_multiple_project_sorting() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )

        let targetA = Target.test(name: "A")
        let targetB = Target.test(name: "B")
        let targetC = Target.test(name: "C")

        let projectB = Project.test(
            path: try temporaryPath().appending(component: "B"),
            name: "ProjectB",
            targets: [
                targetB,
            ]
        )

        let projectA = Project.test(
            path: try temporaryPath(),
            name: "ProjectA",
            targets: [
                targetA,
                targetC,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                projectA.path,
                projectB.path,
            ],
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectB.path: projectB,
                projectA.path: projectA,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        let targetsNames = scheme.buildAction?.targets.map(\.name)
        XCTAssertEqual(targetsNames, ["A", "B", "C"])
    }

    func test_map_when_multiple_platforms() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A",
            platform: .iOS
        )
        let targetATests = Target.test(
            name: "ATests",
            platform: .iOS,
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let targetB = Target.test(
            name: "B",
            platform: .macOS
        )
        let targetBTests = Target.test(
            name: "BTests",
            platform: .macOS,
            product: .unitTests,
            dependencies: [.target(name: "B")]
        )

        let projectBPath = try temporaryPath().appending(component: "ProjectB")
        let projectB = Project.test(
            path: projectBPath,
            targets: [
                targetB,
                targetBTests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
                projectB.path,
            ]
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
                projectBPath: projectB,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes.count, 1)
        XCTAssertEqual(
            Set(schemes.map(\.name)),
            Set([
                "A-Workspace",
            ])
        )
        let scheme = try XCTUnwrap(schemes.first(where: { $0.name == "A-Workspace" }))
        XCTAssertEqual(
            scheme.buildAction.map(\.targets) ?? [],
            [
                TargetReference(
                    projectPath: projectPath,
                    name: targetA.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetATests.name
                ),
                TargetReference(
                    projectPath: projectBPath,
                    name: targetB.name
                ),
                TargetReference(
                    projectPath: projectBPath,
                    name: targetBTests.name
                ),
            ]
        )

        XCTAssertEqual(
            scheme.testAction.map(\.targets) ?? [],
            [
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectPath,
                        name: targetATests.name
                    ),
                    parallelization: .none
                ),
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectBPath,
                        name: targetBTests.name
                    ),
                    parallelization: .none
                ),
            ]
        )
    }

    func test_map_codeCoverage_disabled() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(autogeneratedWorkspaceSchemes: .enabled(codeCoverageMode: .disabled, testingOptions: []))
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        XCTAssertFalse(try XCTUnwrap(scheme.testAction?.coverage))
    }

    func test_map_codeCoverageMode_all() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: false,
            testInsightsDisabled: false,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(codeCoverageMode: .all, testingOptions: [])
            )
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        XCTAssertTrue(try XCTUnwrap(scheme.testAction?.coverage))
    }

    func test_map_when_build_insights_are_enabled() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: false,
            testInsightsDisabled: false,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ]
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        verify(buildInsightsActionMapper)
            .map(.any, target: .any, buildInsightsDisabled: .any)
            .called(1)
    }

    func test_map_codeCoverageMode_targets() async throws {
        // Given
        let targetA = Target.test(
            name: "A"
        )
        let targetB = Target.test(
            name: "B"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetB,
                targetATests,
            ]
        )

        let targetBRef = TargetReference(projectPath: projectPath, name: "B")
        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(
                    codeCoverageMode: .targets([targetBRef]), testingOptions: []
                )
            )
        )

        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        let testAction = try XCTUnwrap(scheme.testAction)

        XCTAssertTrue(testAction.coverage)
        XCTAssertEqual(testAction.codeCoverageTargets, [targetBRef])
    }

    func test_map_codeCoverageMode_relevant_nonEmpty() async throws {
        // Given
        let targetA = Target.test(
            name: "A"
        )
        let targetB = Target.test(
            name: "B"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let targetBRef = TargetReference(projectPath: projectPath, name: "B")
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetB,
                targetATests,
            ],
            schemes: [
                Scheme.test(
                    name: "B",
                    testAction: TestAction.test(
                        coverage: true,
                        codeCoverageTargets: [targetBRef]
                    )
                ),
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(
                    codeCoverageMode: .relevant, testingOptions: []
                )
            )
        )

        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        let testAction = try XCTUnwrap(scheme.testAction)

        XCTAssertTrue(testAction.coverage)
        XCTAssertEqual(testAction.codeCoverageTargets, [targetBRef])
    }

    func test_map_codeCoverageMode_relevant_complex() async throws {
        // Given
        let targetA = Target.test(
            name: "A"
        )
        let targetB = Target.test(
            name: "B"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectAPath = try temporaryPath()
        let targetBRef = TargetReference(projectPath: projectAPath, name: "B")
        let projectSingleCoverage = Project.test(
            path: projectAPath,
            targets: [
                targetA,
                targetB,
                targetATests,
            ],
            schemes: [
                Scheme.test(
                    name: "B",
                    testAction: TestAction.test(
                        coverage: true,
                        codeCoverageTargets: [targetBRef]
                    )
                ),
            ]
        )

        let projectBPath = try temporaryPath().appending(component: "B")
        let targetCRef = TargetReference(projectPath: projectBPath, name: "C")
        let targetDRef = TargetReference(projectPath: projectBPath, name: "D")
        let projectAllCoverage = Project.test(
            path: projectBPath,
            targets: [
                Target.test(name: "C"),
                Target.test(name: "D"),
            ],
            schemes: [
                Scheme.test(
                    buildAction: BuildAction.test(targets: [targetCRef, targetDRef]),
                    testAction: TestAction.test(coverage: true)
                ),
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                projectSingleCoverage.path,
                projectAllCoverage.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(
                    codeCoverageMode: .relevant, testingOptions: []
                )
            )
        )

        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectSingleCoverage.path: projectSingleCoverage,
                projectAllCoverage.path: projectAllCoverage,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        let testAction = try XCTUnwrap(scheme.testAction)

        XCTAssertTrue(testAction.coverage)
        XCTAssertEqual(testAction.codeCoverageTargets.count, 3)
        XCTAssertEqual(Set(testAction.codeCoverageTargets), Set([targetBRef, targetCRef, targetDRef]))
    }

    func test_map_codeCoverageMode_relevant_empty() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: false,
            testInsightsDisabled: false,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetB = Target.test(
            name: "B"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetB,
                targetATests,
            ],
            schemes: []
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(
                    codeCoverageMode: .relevant, testingOptions: []
                )
            )
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        let testAction = try XCTUnwrap(scheme.testAction)

        XCTAssertFalse(testAction.coverage)
        XCTAssertEmpty(testAction.codeCoverageTargets)
    }

    func test_map_testing_options_all() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let targetB = Target.test(
            name: "B"
        )
        let targetBTests = Target.test(
            name: "BTests",
            product: .unitTests,
            dependencies: [.target(name: "B")]
        )

        let projectBPath = try temporaryPath().appending(component: "ProjectB")
        let projectB = Project.test(
            path: projectBPath,
            targets: [
                targetB,
                targetBTests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
                projectB.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(
                    codeCoverageMode: .disabled,
                    testingOptions: [.parallelizable, .randomExecutionOrdering]
                )
            )
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
                projectBPath: projectB,
            ]
        )

        // When
        let (got, sideEffects, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        XCTAssertEmpty(sideEffects)
        let schemes = got.workspace.schemes

        XCTAssertEqual(schemes.count, 1)
        let scheme = try XCTUnwrap(schemes.first)
        XCTAssertTrue(scheme.shared)
        XCTAssertEqual(scheme.name, "A-Workspace")
        XCTAssertEqual(
            Set(scheme.buildAction.map(\.targets) ?? []),
            Set([
                TargetReference(
                    projectPath: projectBPath,
                    name: targetB.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetA.name
                ),
                TargetReference(
                    projectPath: projectPath,
                    name: targetATests.name
                ),
                TargetReference(
                    projectPath: projectBPath,
                    name: targetBTests.name
                ),
            ])
        )
        XCTAssertEqual(
            Set(scheme.testAction.map(\.targets) ?? []),
            Set([
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectPath,
                        name: targetATests.name
                    ),
                    parallelization: .all,
                    randomExecutionOrdering: true
                ),
                TestableTarget(
                    target: TargetReference(
                        projectPath: projectBPath,
                        name: targetBTests.name
                    ),
                    parallelization: .all,
                    randomExecutionOrdering: true
                ),
            ])
        )
        XCTAssertFalse(try XCTUnwrap(scheme.testAction?.coverage))
    }

    func test_map_language_region() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "ATests",
            product: .unitTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(testLanguage: "cs", testRegion: "CZ")
            )
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        XCTAssertEqual(try XCTUnwrap(scheme.testAction?.language), "cs")
        XCTAssertEqual(try XCTUnwrap(scheme.testAction?.region), "CZ")
    }

    func test_map_preferredScreenCaptureFormat() async throws {
        // Given
        let subject = AutogeneratedWorkspaceSchemeGraphMapper(
            forceWorkspaceSchemes: false,
            buildInsightsDisabled: true,
            testInsightsDisabled: true,
            buildInsightsActionMapper: buildInsightsActionMapper,
            testInsightsActionMapper: testInsightsActionMapper
        )
        let targetA = Target.test(
            name: "A"
        )
        let targetATests = Target.test(
            name: "AUITests",
            product: .uiTests,
            dependencies: [.target(name: "A")]
        )

        let projectPath = try temporaryPath()
        let project = Project.test(
            path: projectPath,
            targets: [
                targetA,
                targetATests,
            ]
        )

        let workspace = Workspace.test(
            name: "A",
            projects: [
                project.path,
            ],
            generationOptions: .test(
                autogeneratedWorkspaceSchemes: .enabled(testScreenCaptureFormat: .screenshots)
            )
        )

        let graph = Graph.test(
            workspace: workspace,
            projects: [
                projectPath: project,
            ]
        )

        // When
        let (got, _, _) = try await subject.map(
            graph: graph,
            environment: MapperEnvironment()
        )

        // Then
        let scheme = try XCTUnwrap(got.workspace.schemes.first)
        XCTAssertEqual(try XCTUnwrap(scheme.testAction?.preferredScreenCaptureFormat), .screenshots)
    }
}
