import Foundation
import Logging
import TuistCore
import XcodeGraph

/// Mapper that generates a new scheme `ProjectName-Workspace` that includes all targets from a given workspace
public final class AutogeneratedWorkspaceSchemeGraphMapper: GraphMapping { // swiftlint:disable:this type_name
    private let forceWorkspaceSchemes: Bool
    private let buildInsightsDisabled: Bool
    private let testInsightsDisabled: Bool
    private let buildInsightsActionMapper: BuildInsightsActionMapping
    private let testInsightsActionMapper: TestInsightsActionMapping

    // MARK: - Init

    public convenience init(
        forceWorkspaceSchemes: Bool,
        buildInsightsDisabled: Bool,
        testInsightsDisabled: Bool
    ) {
        self.init(
            forceWorkspaceSchemes: forceWorkspaceSchemes,
            buildInsightsDisabled: buildInsightsDisabled,
            testInsightsDisabled: testInsightsDisabled,
            buildInsightsActionMapper: BuildInsightsActionMapper(),
            testInsightsActionMapper: TestInsightsActionMapper()
        )
    }

    init(
        forceWorkspaceSchemes: Bool,
        buildInsightsDisabled: Bool,
        testInsightsDisabled: Bool,
        buildInsightsActionMapper: BuildInsightsActionMapping,
        testInsightsActionMapper: TestInsightsActionMapping
    ) {
        self.forceWorkspaceSchemes = forceWorkspaceSchemes
        self.buildInsightsDisabled = buildInsightsDisabled
        self.testInsightsDisabled = testInsightsDisabled
        self.buildInsightsActionMapper = buildInsightsActionMapper
        self.testInsightsActionMapper = testInsightsActionMapper
    }

    public func map(
        graph: Graph,
        environment: MapperEnvironment
    ) async throws -> (Graph, [SideEffectDescriptor], MapperEnvironment) {
        guard graph.workspace.generationOptions.autogeneratedWorkspaceSchemes != .disabled || forceWorkspaceSchemes,
              let project = graph.projects.first?.value
        else {
            return (graph, [], environment)
        }
        Logger.current
            .debug("Transforming graph \(graph.name): Auto-generating workspace scheme")

        let platforms = Set(
            graph.projects.map(\.value)
                .flatMap {
                    $0.targets.values.flatMap(\.supportedPlatforms)
                }
        )

        var schemes = [
            try await workspaceScheme(
                name: "\(graph.workspace.name)-Workspace",
                platforms: platforms,
                project: project,
                workspace: graph.workspace,
                graph: graph
            ),
        ]

        if let cachedScheme = try await cachedScheme(
            name: "\(graph.workspace.name)-Cached",
            platforms: platforms,
            project: project,
            workspace: graph.workspace,
            graph: graph
        ) {
            schemes.append(cachedScheme)
        }

        var graph = graph
        var workspace = graph.workspace
        workspace.schemes.append(contentsOf: schemes)
        graph.workspace = workspace
        return (graph, [], environment)
    }

    // MARK: - Helpers

    private func workspaceScheme(
        name: String,
        platforms: Set<Platform>,
        project: Project,
        workspace: Workspace,
        graph: Graph
    ) async throws -> Scheme {
        let testingOptions = workspace.generationOptions.autogeneratedWorkspaceSchemes.testingOptions
        var (targets, testableTargets): ([TargetReference], [TestableTarget]) = workspace.projects
            .compactMap { graph.projects[$0] }
            .reduce(([], [])) { result, project in
                let targets = project.targets
                    .values
                    .filter {
                        !$0.supportedPlatforms.isDisjoint(with: platforms) && !$0.metadata.tags.contains("tuist:binary-sources")
                    }
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                let testableTargets = project.targets
                    .values
                    .filter {
                        !$0.supportedPlatforms.isDisjoint(with: platforms) && !$0.metadata.tags.contains("tuist:binary-sources")
                    }
                    .filter(\.product.testsBundle)
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                    .map {
                        TestableTarget(
                            target: $0,
                            parallelization: testingOptions.contains(.parallelizable) ? .all : .none,
                            randomExecutionOrdering: testingOptions.contains(.randomExecutionOrdering)
                        )
                    }

                return (result.0 + targets, result.1 + testableTargets)
            }

        targets = targets.sorted(by: { $0.name < $1.name })
        testableTargets = testableTargets.sorted(by: { $0.target.name < $1.target.name })

        let coverageSettings = codeCoverageSettings(workspace: workspace, graph: graph)
        let buildAction = try await buildInsightsActionMapper.map(
            BuildAction(
                targets: targets
            ),
            target: targets.first,
            buildInsightsDisabled: buildInsightsDisabled
        )
        return Scheme(
            name: name,
            shared: true,
            buildAction: buildAction,
            testAction: try await testInsightsActionMapper.map(
                TestAction(
                    targets: testableTargets,
                    arguments: nil,
                    configurationName: project.defaultDebugBuildConfigurationName,
                    attachDebugger: true,
                    coverage: coverageSettings.isEnabled,
                    codeCoverageTargets: coverageSettings.targets,
                    expandVariableFromTarget: nil,
                    preActions: [],
                    postActions: [],
                    diagnosticsOptions: SchemeDiagnosticsOptions(
                        mainThreadCheckerEnabled: true,
                        performanceAntipatternCheckerEnabled: true
                    ),
                    language: workspace.generationOptions.autogeneratedWorkspaceSchemes.testLanguage,
                    region: workspace.generationOptions.autogeneratedWorkspaceSchemes.testRegion,
                    preferredScreenCaptureFormat: workspace.generationOptions.autogeneratedWorkspaceSchemes
                        .testScreenCaptureFormat
                ),
                target: testableTargets.first?.target,
                testInsightsDisabled: testInsightsDisabled
            )
        )
    }

    private func cachedScheme(
        name: String,
        platforms: Set<Platform>,
        project: Project,
        workspace: Workspace,
        graph: Graph
    ) async throws -> Scheme? {
        let testingOptions = workspace.generationOptions.autogeneratedWorkspaceSchemes.testingOptions
        var targets: [TargetReference] = workspace.projects
            .compactMap { graph.projects[$0] }
            .reduce([]) { result, project in
                let targets = project.targets
                    .values
                    .filter {
                        !$0.supportedPlatforms.isDisjoint(with: platforms) && $0.metadata.tags.contains("tuist:binary-sources")
                    }
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                let testableTargets = project.targets
                    .values
                    .filter {
                        !$0.supportedPlatforms.isDisjoint(with: platforms) && $0.metadata.tags.contains("tuist:binary-sources")
                    }
                    .filter(\.product.testsBundle)
                    .map { TargetReference(projectPath: project.path, name: $0.name) }
                    .map {
                        TestableTarget(
                            target: $0,
                            parallelization: testingOptions.contains(.parallelizable) ? .all : .none,
                            randomExecutionOrdering: testingOptions.contains(.randomExecutionOrdering)
                        )
                    }

                return result + targets
            }

        targets = targets.sorted(by: { $0.name < $1.name })

        if targets.isEmpty {
            return nil
        }
        let coverageSettings = codeCoverageSettings(workspace: workspace, graph: graph)
        let buildAction = BuildAction(
            targets: targets
        )
        return Scheme(
            name: name,
            shared: true,
            buildAction: buildAction,
            testAction: nil
        )
    }

    private func codeCoverageSettings(
        workspace: Workspace,
        graph: Graph
    ) -> (isEnabled: Bool, targets: [TargetReference]) {
        let codeCoverageTargets = workspace.codeCoverageTargets(projects: graph.projects.map(\.value))

        switch workspace.generationOptions.autogeneratedWorkspaceSchemes.codeCoverageMode {
        case .all: return (true, codeCoverageTargets)
        case .disabled: return (false, codeCoverageTargets)
        case .targets: return (true, codeCoverageTargets)
        case .relevant:
            return (!codeCoverageTargets.isEmpty, codeCoverageTargets)
        }
    }
}
