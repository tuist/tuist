// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: keyvalue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that you are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

struct CompilationCacheService_Keyvalue_V1_GetValueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var key: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct CompilationCacheService_Keyvalue_V1_GetValueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var found: Bool = false

    var value: Data = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct CompilationCacheService_Keyvalue_V1_SaveRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var casID: String = .init()

    var data: Data = .init()

    var type: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct CompilationCacheService_Keyvalue_V1_SaveResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    var casID: String = .init()

    var success: Bool = false

    var message: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "compilation_cache_service.keyvalue.v1"

extension CompilationCacheService_Keyvalue_V1_GetValueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".GetValueRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &key)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularBytesField(value: key, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: CompilationCacheService_Keyvalue_V1_GetValueRequest,
        rhs: CompilationCacheService_Keyvalue_V1_GetValueRequest
    ) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_GetValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".GetValueResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "found"),
        2: .same(proto: "value"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBoolField(value: &found)
            case 2: try decoder.decodeSingularBytesField(value: &value)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if found != false {
            try visitor.visitSingularBoolField(value: found, fieldNumber: 1)
        }
        if !value.isEmpty {
            try visitor.visitSingularBytesField(value: value, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: CompilationCacheService_Keyvalue_V1_GetValueResponse,
        rhs: CompilationCacheService_Keyvalue_V1_GetValueResponse
    ) -> Bool {
        if lhs.found != rhs.found { return false }
        if lhs.value != rhs.value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_SaveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".SaveRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .same(proto: "data"),
        3: .same(proto: "type"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &casID)
            case 2: try decoder.decodeSingularBytesField(value: &data)
            case 3: try decoder.decodeSingularStringField(value: &type)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !casID.isEmpty {
            try visitor.visitSingularStringField(value: casID, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: CompilationCacheService_Keyvalue_V1_SaveRequest,
        rhs: CompilationCacheService_Keyvalue_V1_SaveRequest
    ) -> Bool {
        if lhs.casID != rhs.casID { return false }
        if lhs.data != rhs.data { return false }
        if lhs.type != rhs.type { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_SaveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".SaveResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .same(proto: "success"),
        3: .same(proto: "message"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &casID)
            case 2: try decoder.decodeSingularBoolField(value: &success)
            case 3: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !casID.isEmpty {
            try visitor.visitSingularStringField(value: casID, fieldNumber: 1)
        }
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (
        lhs: CompilationCacheService_Keyvalue_V1_SaveResponse,
        rhs: CompilationCacheService_Keyvalue_V1_SaveResponse
    ) -> Bool {
        if lhs.casID != rhs.casID { return false }
        if lhs.success != rhs.success { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
