// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cas.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that you are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

/// Request message for Save RPC
struct CompilationCacheService_Cas_V1_SaveRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Content-addressable storage ID (hash of the artifact data)
    var casID: Data = .init()

    /// The artifact data itself (precompiled modules, objects, metadata)
    var data: Data = .init()

    /// Artifact type (e.g., "pcm", "o", "metadata")
    var type: String = .init()

    /// Optional metadata key-value pairs
    var metadata: [String: String] = [:]

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

/// Response message for Save RPC
struct CompilationCacheService_Cas_V1_SaveResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    /// Confirmed CAS ID
    var casID: Data = .init()

    /// Whether the save operation succeeded
    var success: Bool = false

    /// Optional status message
    var message: String = .init()

    var unknownFields = SwiftProtobuf.UnknownStorage()
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "compilation_cache_service.cas.v1"

extension CompilationCacheService_Cas_V1_SaveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".SaveRequest"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .same(proto: "data"),
        3: .same(proto: "type"),
        4: .same(proto: "metadata"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &casID)
            case 2: try decoder.decodeSingularBytesField(value: &data)
            case 3: try decoder.decodeSingularStringField(value: &type)
            case 4: try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                    value: &metadata
                )
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !casID.isEmpty {
            try visitor.visitSingularBytesField(value: casID, fieldNumber: 1)
        }
        if !data.isEmpty {
            try visitor.visitSingularBytesField(value: data, fieldNumber: 2)
        }
        if !type.isEmpty {
            try visitor.visitSingularStringField(value: type, fieldNumber: 3)
        }
        if !metadata.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufString>.self,
                value: metadata,
                fieldNumber: 4
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CompilationCacheService_Cas_V1_SaveRequest, rhs: CompilationCacheService_Cas_V1_SaveRequest) -> Bool {
        if lhs.casID != rhs.casID { return false }
        if lhs.data != rhs.data { return false }
        if lhs.type != rhs.type { return false }
        if lhs.metadata != rhs.metadata { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_SaveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    static let protoMessageName: String = _protobuf_package + ".SaveResponse"
    static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .same(proto: "success"),
        3: .same(proto: "message"),
    ]

    mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &casID)
            case 2: try decoder.decodeSingularBoolField(value: &success)
            case 3: try decoder.decodeSingularStringField(value: &message)
            default: break
            }
        }
    }

    func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !casID.isEmpty {
            try visitor.visitSingularBytesField(value: casID, fieldNumber: 1)
        }
        if success != false {
            try visitor.visitSingularBoolField(value: success, fieldNumber: 2)
        }
        if !message.isEmpty {
            try visitor.visitSingularStringField(value: message, fieldNumber: 3)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    static func == (lhs: CompilationCacheService_Cas_V1_SaveResponse, rhs: CompilationCacheService_Cas_V1_SaveResponse) -> Bool {
        if lhs.casID != rhs.casID { return false }
        if lhs.success != rhs.success { return false }
        if lhs.message != rhs.message { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
