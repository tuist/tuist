// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: cas.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ===--- compilation_caching_cas.proto - CAS service definition -----------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// ===----------------------------------------------------------------------===//

import Foundation
import SwiftProtobuf

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that you are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

// MARK: - Data types

public struct CompilationCacheService_Cas_V1_CASDataID {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var id: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

/// `CASObject` and `CASBlob` should be wire compatible.
public struct CompilationCacheService_Cas_V1_CASObject {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var blob: CompilationCacheService_Cas_V1_CASBytes {
        get { return _blob ?? CompilationCacheService_Cas_V1_CASBytes() }
        set { _blob = newValue }
    }

    /// Returns true if `blob` has been explicitly set.
    public var hasBlob: Bool { return _blob != nil }
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    public mutating func clearBlob() { _blob = nil }

    public var references: [CompilationCacheService_Cas_V1_CASDataID] = []

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _blob: CompilationCacheService_Cas_V1_CASBytes?
}

/// `CASObject` and `CASBlob` should be wire compatible.
public struct CompilationCacheService_Cas_V1_CASBlob {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var blob: CompilationCacheService_Cas_V1_CASBytes {
        get { return _blob ?? CompilationCacheService_Cas_V1_CASBytes() }
        set { _blob = newValue }
    }

    /// Returns true if `blob` has been explicitly set.
    public var hasBlob: Bool { return _blob != nil }
    /// Clears the value of `blob`. Subsequent reads from it will return its default value.
    public mutating func clearBlob() { _blob = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _blob: CompilationCacheService_Cas_V1_CASBytes?
}

public struct CompilationCacheService_Cas_V1_CASBytes {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contents: CompilationCacheService_Cas_V1_CASBytes.OneOf_Contents?

    public var data: Data {
        get {
            if case let .data(v)? = contents { return v }
            return Data()
        }
        set { contents = .data(newValue) }
    }

    public var filePath: String {
        get {
            if case let .filePath(v)? = contents { return v }
            return String()
        }
        set { contents = .filePath(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case data(Data)
        case filePath(String)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Cas_V1_CASBytes.OneOf_Contents,
                rhs: CompilationCacheService_Cas_V1_CASBytes.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.data, .data): return {
                        guard case let .data(l) = lhs, case let .data(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.filePath, .filePath): return {
                        guard case let .filePath(l) = lhs, case let .filePath(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

public struct CompilationCacheService_Cas_V1_ResponseError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: Put

public struct CompilationCacheService_Cas_V1_CASPutRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: CompilationCacheService_Cas_V1_CASObject {
        get { return _data ?? CompilationCacheService_Cas_V1_CASObject() }
        set { _data = newValue }
    }

    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool { return _data != nil }
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() { _data = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: CompilationCacheService_Cas_V1_CASObject?
}

public struct CompilationCacheService_Cas_V1_CASPutResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contents: CompilationCacheService_Cas_V1_CASPutResponse.OneOf_Contents?

    public var error: CompilationCacheService_Cas_V1_ResponseError {
        get {
            if case let .error(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_ResponseError()
        }
        set { contents = .error(newValue) }
    }

    public var casID: CompilationCacheService_Cas_V1_CASDataID {
        get {
            if case let .casID(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_CASDataID()
        }
        set { contents = .casID(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case error(CompilationCacheService_Cas_V1_ResponseError)
        case casID(CompilationCacheService_Cas_V1_CASDataID)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Cas_V1_CASPutResponse.OneOf_Contents,
                rhs: CompilationCacheService_Cas_V1_CASPutResponse.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.casID, .casID): return {
                        guard case let .casID(l) = lhs, case let .casID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

// MARK: Get

public struct CompilationCacheService_Cas_V1_CASGetRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var casID: CompilationCacheService_Cas_V1_CASDataID {
        get { return _casID ?? CompilationCacheService_Cas_V1_CASDataID() }
        set { _casID = newValue }
    }

    /// Returns true if `casID` has been explicitly set.
    public var hasCasID: Bool { return _casID != nil }
    /// Clears the value of `casID`. Subsequent reads from it will return its default value.
    public mutating func clearCasID() { _casID = nil }

    /// If set, the client asks for the service to write the blob part to disk, with a
    /// file path of the service's choosing.
    ///
    /// However this is not a hard requirement, the service can still choose to
    /// return the blob back as `bytes`. The client should always check whether
    /// the blob came back as `bytes` or as a file on disk.
    ///
    /// If the service writes the blob to a file, it should have the right
    /// access for the client to be able to move it to a different path.
    public var writeToDisk: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _casID: CompilationCacheService_Cas_V1_CASDataID?
}

public struct CompilationCacheService_Cas_V1_CASGetResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var outcome: CompilationCacheService_Cas_V1_CASGetResponse.Outcome = .error

    public var contents: CompilationCacheService_Cas_V1_CASGetResponse.OneOf_Contents?

    public var error: CompilationCacheService_Cas_V1_ResponseError {
        get {
            if case let .error(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_ResponseError()
        }
        set { contents = .error(newValue) }
    }

    public var data: CompilationCacheService_Cas_V1_CASObject {
        get {
            if case let .data(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_CASObject()
        }
        set { contents = .data(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case error(CompilationCacheService_Cas_V1_ResponseError)
        case data(CompilationCacheService_Cas_V1_CASObject)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Cas_V1_CASGetResponse.OneOf_Contents,
                rhs: CompilationCacheService_Cas_V1_CASGetResponse.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.data, .data): return {
                        guard case let .data(l) = lhs, case let .data(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public enum Outcome: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// if unset, we'll get error
        case error // = 0
        case objectNotFound // = 1
        case success // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .error
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .error
            case 1: self = .objectNotFound
            case 2: self = .success
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .error: return 0
            case .objectNotFound: return 1
            case .success: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension CompilationCacheService_Cas_V1_CASGetResponse.Outcome: CaseIterable {
        /// The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [CompilationCacheService_Cas_V1_CASGetResponse.Outcome] = [
            .error,
            .objectNotFound,
            .success,
        ]
    }

#endif // swift(>=4.2)

// MARK: Save

public struct CompilationCacheService_Cas_V1_CASSaveRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var data: CompilationCacheService_Cas_V1_CASBlob {
        get { return _data ?? CompilationCacheService_Cas_V1_CASBlob() }
        set { _data = newValue }
    }

    /// Returns true if `data` has been explicitly set.
    public var hasData: Bool { return _data != nil }
    /// Clears the value of `data`. Subsequent reads from it will return its default value.
    public mutating func clearData() { _data = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _data: CompilationCacheService_Cas_V1_CASBlob?
}

public struct CompilationCacheService_Cas_V1_CASSaveResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var contents: CompilationCacheService_Cas_V1_CASSaveResponse.OneOf_Contents?

    public var error: CompilationCacheService_Cas_V1_ResponseError {
        get {
            if case let .error(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_ResponseError()
        }
        set { contents = .error(newValue) }
    }

    public var casID: CompilationCacheService_Cas_V1_CASDataID {
        get {
            if case let .casID(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_CASDataID()
        }
        set { contents = .casID(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case error(CompilationCacheService_Cas_V1_ResponseError)
        case casID(CompilationCacheService_Cas_V1_CASDataID)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Cas_V1_CASSaveResponse.OneOf_Contents,
                rhs: CompilationCacheService_Cas_V1_CASSaveResponse.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.casID, .casID): return {
                        guard case let .casID(l) = lhs, case let .casID(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public init() {}
}

// MARK: Load

public struct CompilationCacheService_Cas_V1_CASLoadRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var casID: CompilationCacheService_Cas_V1_CASDataID {
        get { return _casID ?? CompilationCacheService_Cas_V1_CASDataID() }
        set { _casID = newValue }
    }

    /// Returns true if `casID` has been explicitly set.
    public var hasCasID: Bool { return _casID != nil }
    /// Clears the value of `casID`. Subsequent reads from it will return its default value.
    public mutating func clearCasID() { _casID = nil }

    /// If set, the client asks for the service to write the blob part to disk, with a
    /// file path of the service's choosing.
    ///
    /// However this is not a hard requirement, the service can still choose to
    /// return the blob back as `bytes`. The client should always check whether
    /// the blob came back as `bytes` or as a file on disk.
    ///
    /// If the service writes the blob to a file, it should have the right
    /// access for the client to be able to move it to a different path.
    public var writeToDisk: Bool = false

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    fileprivate var _casID: CompilationCacheService_Cas_V1_CASDataID?
}

public struct CompilationCacheService_Cas_V1_CASLoadResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var outcome: CompilationCacheService_Cas_V1_CASLoadResponse.Outcome = .error

    public var contents: CompilationCacheService_Cas_V1_CASLoadResponse.OneOf_Contents?

    public var error: CompilationCacheService_Cas_V1_ResponseError {
        get {
            if case let .error(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_ResponseError()
        }
        set { contents = .error(newValue) }
    }

    public var data: CompilationCacheService_Cas_V1_CASBlob {
        get {
            if case let .data(v)? = contents { return v }
            return CompilationCacheService_Cas_V1_CASBlob()
        }
        set { contents = .data(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case error(CompilationCacheService_Cas_V1_ResponseError)
        case data(CompilationCacheService_Cas_V1_CASBlob)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Cas_V1_CASLoadResponse.OneOf_Contents,
                rhs: CompilationCacheService_Cas_V1_CASLoadResponse.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.data, .data): return {
                        guard case let .data(l) = lhs, case let .data(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public enum Outcome: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// if unset, we'll get error
        case error // = 0
        case objectNotFound // = 1
        case success // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .error
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .error
            case 1: self = .objectNotFound
            case 2: self = .success
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .error: return 0
            case .objectNotFound: return 1
            case .success: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension CompilationCacheService_Cas_V1_CASLoadResponse.Outcome: CaseIterable {
        /// The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [CompilationCacheService_Cas_V1_CASLoadResponse.Outcome] = [
            .error,
            .objectNotFound,
            .success,
        ]
    }

#endif // swift(>=4.2)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "compilation_cache_service.cas.v1"

extension CompilationCacheService_Cas_V1_CASDataID: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASDataID"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &id)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !id.isEmpty {
            try visitor.visitSingularBytesField(value: id, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: CompilationCacheService_Cas_V1_CASDataID, rhs: CompilationCacheService_Cas_V1_CASDataID) -> Bool {
        if lhs.id != rhs.id { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASObject: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASObject"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blob"),
        2: .same(proto: "references"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_blob)
            case 2: try decoder.decodeRepeatedMessageField(value: &references)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _blob {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if !references.isEmpty {
            try visitor.visitRepeatedMessageField(value: references, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: CompilationCacheService_Cas_V1_CASObject, rhs: CompilationCacheService_Cas_V1_CASObject) -> Bool {
        if lhs._blob != rhs._blob { return false }
        if lhs.references != rhs.references { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASBlob: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASBlob"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "blob"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_blob)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _blob {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: CompilationCacheService_Cas_V1_CASBlob, rhs: CompilationCacheService_Cas_V1_CASBlob) -> Bool {
        if lhs._blob != rhs._blob { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASBytes: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASBytes"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
        2: .standard(proto: "file_path"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    if self.contents != nil { try decoder.handleConflictingOneOf() }
                    var v: Data?
                    try decoder.decodeSingularBytesField(value: &v)
                    if let v { self.contents = .data(v) }
                }()
            case 2: try {
                    if self.contents != nil { try decoder.handleConflictingOneOf() }
                    var v: String?
                    try decoder.decodeSingularStringField(value: &v)
                    if let v { self.contents = .filePath(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .data?: try {
                guard case let .data(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularBytesField(value: v, fieldNumber: 1)
            }()
        case .filePath?: try {
                guard case let .filePath(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularStringField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (lhs: CompilationCacheService_Cas_V1_CASBytes, rhs: CompilationCacheService_Cas_V1_CASBytes) -> Bool {
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_ResponseError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".ResponseError"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_ResponseError,
        rhs: CompilationCacheService_Cas_V1_ResponseError
    ) -> Bool {
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASPutRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASPutRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _data {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASPutRequest,
        rhs: CompilationCacheService_Cas_V1_CASPutRequest
    ) -> Bool {
        if lhs._data != rhs._data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASPutResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASPutResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "error"),
        2: .standard(proto: "cas_id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: CompilationCacheService_Cas_V1_ResponseError?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .error(v) }
                }()
            case 2: try {
                    var v: CompilationCacheService_Cas_V1_CASDataID?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .casID(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .casID(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .error?: try {
                guard case let .error(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .casID?: try {
                guard case let .casID(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASPutResponse,
        rhs: CompilationCacheService_Cas_V1_CASPutResponse
    ) -> Bool {
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASGetRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASGetRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .standard(proto: "write_to_disk"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_casID)
            case 2: try decoder.decodeSingularBoolField(value: &writeToDisk)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _casID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if writeToDisk != false {
            try visitor.visitSingularBoolField(value: writeToDisk, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASGetRequest,
        rhs: CompilationCacheService_Cas_V1_CASGetRequest
    ) -> Bool {
        if lhs._casID != rhs._casID { return false }
        if lhs.writeToDisk != rhs.writeToDisk { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASGetResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASGetResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "outcome"),
        2: .same(proto: "error"),
        3: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &outcome)
            case 2: try {
                    var v: CompilationCacheService_Cas_V1_ResponseError?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .error(v) }
                }()
            case 3: try {
                    var v: CompilationCacheService_Cas_V1_CASObject?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .data(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .data(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if outcome != .error {
            try visitor.visitSingularEnumField(value: outcome, fieldNumber: 1)
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .error?: try {
                guard case let .error(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .data?: try {
                guard case let .data(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASGetResponse,
        rhs: CompilationCacheService_Cas_V1_CASGetResponse
    ) -> Bool {
        if lhs.outcome != rhs.outcome { return false }
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASGetResponse.Outcome: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ERROR"),
        1: .same(proto: "OBJECT_NOT_FOUND"),
        2: .same(proto: "SUCCESS"),
    ]
}

extension CompilationCacheService_Cas_V1_CASSaveRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASSaveRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_data)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _data {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASSaveRequest,
        rhs: CompilationCacheService_Cas_V1_CASSaveRequest
    ) -> Bool {
        if lhs._data != rhs._data { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASSaveResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASSaveResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "error"),
        2: .standard(proto: "cas_id"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try {
                    var v: CompilationCacheService_Cas_V1_ResponseError?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .error(v) }
                }()
            case 2: try {
                    var v: CompilationCacheService_Cas_V1_CASDataID?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .casID(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .casID(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .error?: try {
                guard case let .error(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
            }()
        case .casID?: try {
                guard case let .casID(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASSaveResponse,
        rhs: CompilationCacheService_Cas_V1_CASSaveResponse
    ) -> Bool {
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASLoadRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASLoadRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .standard(proto: "cas_id"),
        2: .standard(proto: "write_to_disk"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_casID)
            case 2: try decoder.decodeSingularBoolField(value: &writeToDisk)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _casID {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        if writeToDisk != false {
            try visitor.visitSingularBoolField(value: writeToDisk, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASLoadRequest,
        rhs: CompilationCacheService_Cas_V1_CASLoadRequest
    ) -> Bool {
        if lhs._casID != rhs._casID { return false }
        if lhs.writeToDisk != rhs.writeToDisk { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASLoadResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".CASLoadResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "outcome"),
        2: .same(proto: "error"),
        3: .same(proto: "data"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &outcome)
            case 2: try {
                    var v: CompilationCacheService_Cas_V1_ResponseError?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .error(v) }
                }()
            case 3: try {
                    var v: CompilationCacheService_Cas_V1_CASBlob?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .data(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .data(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if outcome != .error {
            try visitor.visitSingularEnumField(value: outcome, fieldNumber: 1)
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .error?: try {
                guard case let .error(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .data?: try {
                guard case let .data(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Cas_V1_CASLoadResponse,
        rhs: CompilationCacheService_Cas_V1_CASLoadResponse
    ) -> Bool {
        if lhs.outcome != rhs.outcome { return false }
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Cas_V1_CASLoadResponse.Outcome: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ERROR"),
        1: .same(proto: "OBJECT_NOT_FOUND"),
        2: .same(proto: "SUCCESS"),
    ]
}
