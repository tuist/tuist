// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: keyvalue.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

// ===--- compilation_caching_kv.proto - Key/Value service definition ------===//
//
// Part of the LLVM Project, under the Apache License v2.0 with LLVM Exceptions.
// See https://llvm.org/LICENSE.txt for license information.
// SPDX-License-Identifier: Apache-2.0 WITH LLVM-exception
//
// ===----------------------------------------------------------------------===//

import Foundation
import SwiftProtobuf

/// If the compiler emits an error on this type, it is because this file
/// was generated by a version of the `protoc` Swift plug-in that is
/// incompatible with the version of SwiftProtobuf to which you are linking.
/// Please ensure that you are building against the same version of the API
/// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
    struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
    typealias Version = _2
}

public struct CompilationCacheService_Keyvalue_V1_Value {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var entries: [String: Data] = [:]

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct CompilationCacheService_Keyvalue_V1_GetValueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: Data = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

public struct CompilationCacheService_Keyvalue_V1_GetValueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var outcome: CompilationCacheService_Keyvalue_V1_GetValueResponse.Outcome = .error

    public var contents: CompilationCacheService_Keyvalue_V1_GetValueResponse.OneOf_Contents?

    public var error: CompilationCacheService_Keyvalue_V1_ResponseError {
        get {
            if case let .error(v)? = contents { return v }
            return CompilationCacheService_Keyvalue_V1_ResponseError()
        }
        set { contents = .error(newValue) }
    }

    public var value: CompilationCacheService_Keyvalue_V1_Value {
        get {
            if case let .value(v)? = contents { return v }
            return CompilationCacheService_Keyvalue_V1_Value()
        }
        set { contents = .value(newValue) }
    }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public enum OneOf_Contents: Equatable {
        case error(CompilationCacheService_Keyvalue_V1_ResponseError)
        case value(CompilationCacheService_Keyvalue_V1_Value)

        #if !swift(>=4.1)
            public static func == (
                lhs: CompilationCacheService_Keyvalue_V1_GetValueResponse.OneOf_Contents,
                rhs: CompilationCacheService_Keyvalue_V1_GetValueResponse.OneOf_Contents
            ) -> Bool {
                // The use of inline closures is to circumvent an issue where the compiler
                // allocates stack space for every case branch when no optimizations are
                // enabled. https://github.com/apple/swift-protobuf/issues/1034
                switch (lhs, rhs) {
                case (.error, .error): return {
                        guard case let .error(l) = lhs, case let .error(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                case (.value, .value): return {
                        guard case let .value(l) = lhs, case let .value(r) = rhs else { preconditionFailure() }
                        return l == r
                    }()
                default: return false
                }
            }
        #endif
    }

    public enum Outcome: SwiftProtobuf.Enum {
        public typealias RawValue = Int

        /// if unset, we'll get error
        case error // = 0
        case keyNotFound // = 1
        case success // = 2
        case UNRECOGNIZED(Int)

        public init() {
            self = .error
        }

        public init?(rawValue: Int) {
            switch rawValue {
            case 0: self = .error
            case 1: self = .keyNotFound
            case 2: self = .success
            default: self = .UNRECOGNIZED(rawValue)
            }
        }

        public var rawValue: Int {
            switch self {
            case .error: return 0
            case .keyNotFound: return 1
            case .success: return 2
            case let .UNRECOGNIZED(i): return i
            }
        }
    }

    public init() {}
}

#if swift(>=4.2)

    extension CompilationCacheService_Keyvalue_V1_GetValueResponse.Outcome: CaseIterable {
        /// The compiler won't synthesize support with the UNRECOGNIZED case.
        public static var allCases: [CompilationCacheService_Keyvalue_V1_GetValueResponse.Outcome] = [
            .error,
            .keyNotFound,
            .success,
        ]
    }

#endif // swift(>=4.2)

public struct CompilationCacheService_Keyvalue_V1_PutValueRequest {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var key: Data = .init()

    public var value: CompilationCacheService_Keyvalue_V1_Value {
        get { return _value ?? CompilationCacheService_Keyvalue_V1_Value() }
        set { _value = newValue }
    }

    /// Returns true if `value` has been explicitly set.
    public var hasValue: Bool { return _value != nil }
    /// Clears the value of `value`. Subsequent reads from it will return its default value.
    public mutating func clearValue() { _value = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _value: CompilationCacheService_Keyvalue_V1_Value?
}

public struct CompilationCacheService_Keyvalue_V1_PutValueResponse {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var error: CompilationCacheService_Keyvalue_V1_ResponseError {
        get { return _error ?? CompilationCacheService_Keyvalue_V1_ResponseError() }
        set { _error = newValue }
    }

    /// Returns true if `error` has been explicitly set.
    public var hasError: Bool { return _error != nil }
    /// Clears the value of `error`. Subsequent reads from it will return its default value.
    public mutating func clearError() { _error = nil }

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}

    private var _error: CompilationCacheService_Keyvalue_V1_ResponseError?
}

public struct CompilationCacheService_Keyvalue_V1_ResponseError {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var description_p: String = .init()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "compilation_cache_service.keyvalue.v1"

extension CompilationCacheService_Keyvalue_V1_Value: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".Value"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "entries"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeMapField(
                    fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufBytes>.self,
                    value: &entries
                )
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !entries.isEmpty {
            try visitor.visitMapField(
                fieldType: SwiftProtobuf._ProtobufMap<SwiftProtobuf.ProtobufString, SwiftProtobuf.ProtobufBytes>.self,
                value: entries,
                fieldNumber: 1
            )
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_Value,
        rhs: CompilationCacheService_Keyvalue_V1_Value
    ) -> Bool {
        if lhs.entries != rhs.entries { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_GetValueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".GetValueRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &key)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularBytesField(value: key, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_GetValueRequest,
        rhs: CompilationCacheService_Keyvalue_V1_GetValueRequest
    ) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_GetValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".GetValueResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "outcome"),
        2: .same(proto: "error"),
        3: .same(proto: "value"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularEnumField(value: &outcome)
            case 2: try {
                    var v: CompilationCacheService_Keyvalue_V1_ResponseError?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .error(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .error(v) }
                }()
            case 3: try {
                    var v: CompilationCacheService_Keyvalue_V1_Value?
                    if let current = self.contents {
                        try decoder.handleConflictingOneOf()
                        if case let .value(m) = current { v = m }
                    }
                    try decoder.decodeSingularMessageField(value: &v)
                    if let v { self.contents = .value(v) }
                }()
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if outcome != .error {
            try visitor.visitSingularEnumField(value: outcome, fieldNumber: 1)
        }
        // The use of inline closures is to circumvent an issue where the compiler
        // allocates stack space for every case branch when no optimizations are
        // enabled. https://github.com/apple/swift-protobuf/issues/1034
        switch contents {
        case .error?: try {
                guard case let .error(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
            }()
        case .value?: try {
                guard case let .value(v)? = self.contents else { preconditionFailure() }
                try visitor.visitSingularMessageField(value: v, fieldNumber: 3)
            }()
        case nil: break
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_GetValueResponse,
        rhs: CompilationCacheService_Keyvalue_V1_GetValueResponse
    ) -> Bool {
        if lhs.outcome != rhs.outcome { return false }
        if lhs.contents != rhs.contents { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_GetValueResponse.Outcome: SwiftProtobuf._ProtoNameProviding {
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        0: .same(proto: "ERROR"),
        1: .same(proto: "KEY_NOT_FOUND"),
        2: .same(proto: "SUCCESS"),
    ]
}

extension CompilationCacheService_Keyvalue_V1_PutValueRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".PutValueRequest"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "key"),
        2: .same(proto: "value"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularBytesField(value: &key)
            case 2: try decoder.decodeSingularMessageField(value: &_value)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !key.isEmpty {
            try visitor.visitSingularBytesField(value: key, fieldNumber: 1)
        }
        if let v = _value {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_PutValueRequest,
        rhs: CompilationCacheService_Keyvalue_V1_PutValueRequest
    ) -> Bool {
        if lhs.key != rhs.key { return false }
        if lhs._value != rhs._value { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_PutValueResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".PutValueResponse"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "error"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularMessageField(value: &_error)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if let v = _error {
            try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_PutValueResponse,
        rhs: CompilationCacheService_Keyvalue_V1_PutValueResponse
    ) -> Bool {
        if lhs._error != rhs._error { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}

extension CompilationCacheService_Keyvalue_V1_ResponseError: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
    SwiftProtobuf._ProtoNameProviding
{
    public static let protoMessageName: String = _protobuf_package + ".ResponseError"
    public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
        1: .same(proto: "description"),
    ]

    public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
        while let fieldNumber = try decoder.nextFieldNumber() {
            // The use of inline closures is to circumvent an issue where the compiler
            // allocates stack space for every case branch when no optimizations are
            // enabled. https://github.com/apple/swift-protobuf/issues/1034
            switch fieldNumber {
            case 1: try decoder.decodeSingularStringField(value: &description_p)
            default: break
            }
        }
    }

    public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
        if !description_p.isEmpty {
            try visitor.visitSingularStringField(value: description_p, fieldNumber: 1)
        }
        try unknownFields.traverse(visitor: &visitor)
    }

    public static func == (
        lhs: CompilationCacheService_Keyvalue_V1_ResponseError,
        rhs: CompilationCacheService_Keyvalue_V1_ResponseError
    ) -> Bool {
        if lhs.description_p != rhs.description_p { return false }
        if lhs.unknownFields != rhs.unknownFields { return false }
        return true
    }
}
