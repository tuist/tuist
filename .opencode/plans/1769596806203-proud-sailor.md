# Plan: Align SQLite writer with ClickHouse buffers

## Goals
- Move cache SQLite buffering closer to server ClickHouse buffers: one buffer per table/domain, shared generic buffer logic.
- Preserve SQLite-specific behavior: `insert_all` upserts, delete batches, busy-lock retries, simpler encoding.
- Keep external APIs stable (or provide compatibility) while reducing coupling between tables.

## Current state (from `jj` bookmark `cschmatzler/sqlite-writer`)
- Cache uses a single GenServer (`cache/lib/cache/sqlite_writer.ex`) that batches key-values, CAS artifacts, and S3 transfers.
- Server uses a generic buffer (`server/lib/tuist/ingestion/buffer.ex`) plus per-table buffer modules and `Tuist.Ingestion.Bufferable`.

## Recommended approach
- Introduce a generic SQLite buffer GenServer (analogous to `Tuist.Ingestion.Buffer`) and per-table buffers.
- Remove the single writer module and migrate call sites directly to per-table buffers.
- Maintain current retry/backoff and telemetry, but tag by buffer/table instead of a single writer.

## Detailed steps
1) Add generic SQLite buffer module
   - New module: `cache/lib/cache/sqlite_buffer.ex`.
   - Responsibilities: timer-driven flush, max batch size, retry/backoff, telemetry, `flush/0|1`, and `enqueue/1`.
   - Keep retry logic from `Cache.SQLiteWriter` (busy errors, backoff caps).
   - Support `:drain` on terminate, similar to current writer and server buffer.

2) Add a SQLite buffer contract (lightweight behavior or macro)
   - New module: `cache/lib/cache/sqlite_bufferable.ex` (behavior or macro).
   - Defines callbacks like:
     - `buffer_name/0` (for telemetry tags)
     - `enqueue/1` input shape
     - `handle_event/2` (dedupe by key for upserts, handle deletes)
     - `flush_batches/1` (return `{op, rows}` per group)
     - `write_batch/2` (per op, run `Repo.insert_all` or `Repo.delete_all`)

3) Split per-table buffers (one process per table/domain)
   - `cache/lib/cache/key_value_buffer.ex`
     - Aggregation by key, upsert-only.
     - Uses `Repo.insert_all(KeyValueEntry, ...)` with conflict replacement.
   - `cache/lib/cache/cas_artifacts_buffer.ex`
     - Two groups: `:access` (upsert) and `:delete` (delete by key).
     - Keeps existing dedupe behavior (delete removes pending access entries).
   - `cache/lib/cache/s3_transfers_buffer.ex`
     - Two groups: `:insert` and `:delete`.
     - Deduplicate inserts by `{type, key}` like current writer.

4) Migrate call sites directly to per-table buffers
   - `cache/lib/cache/key_value_store.ex` -> enqueue via `Cache.KeyValueBuffer`.
   - `cache/lib/cache/cache_artifacts.ex` -> enqueue via `Cache.CasArtifactsBuffer` and flush that buffer.
   - `cache/lib/cache/s3_transfers.ex` -> enqueue via `Cache.S3TransfersBuffer` and flush that buffer.

5) Remove the single writer module
   - Delete `cache/lib/cache/sqlite_writer.ex`.
   - Update any remaining references (including tests and PromEx plugin) to point at new buffers.

6) Supervision tree and config
   - Replace single worker in `cache/lib/cache/application.ex` with per-table buffers.
   - Add per-buffer config in `cache/config/config.exs`:
     - `:cache, Cache.SQLiteBuffer` defaults (flush interval, batch size, retry).
     - Optional overrides per buffer module (`Cache.KeyValueBuffer`, etc.).
   - Remove `:cache, :sqlite_writer` config if no longer referenced.

7) Telemetry and PromEx
   - Replace `cache/lib/cache/sqlite_writer/prom_ex_plugin.ex` with a new plugin (e.g. `Cache.SQLiteBuffer.PromExPlugin`).
   - Keep metric names stable if possible, but add `buffer` tag to distinguish tables.

8) Tests
   - Add tests for the generic buffer and per-table buffers (e.g. `cache/test/cache/sqlite_buffer_test.exs`).
   - Update existing tests to allow sandbox access to each buffer process (replacing `SQLiteWriter`).
   - Ensure `flush` behavior is still explicit in tests (matching current semantics).

## Key files to change/add
- `cache/lib/cache/sqlite_buffer.ex`
- `cache/lib/cache/sqlite_bufferable.ex`
- `cache/lib/cache/key_value_buffer.ex`
- `cache/lib/cache/cas_artifacts_buffer.ex`
- `cache/lib/cache/s3_transfers_buffer.ex`
- (remove) `cache/lib/cache/sqlite_writer.ex`
- (replace) `cache/lib/cache/sqlite_writer/prom_ex_plugin.ex`
- `cache/lib/cache/application.ex`
- `cache/config/config.exs`
- `cache/lib/cache/key_value_store.ex`
- `cache/lib/cache/cache_artifacts.ex`
- `cache/lib/cache/s3_transfers.ex`
- tests under `cache/test/cache/`

## Verification
- Run cache tests that cover SQLite buffering:
  - `mix test cache/test/cache/sqlite_writer_test.exs`
  - `mix test cache/test/cache/key_value_store_test.exs`
  - `mix test cache/test/cache/s3_transfers_test.exs`
  - Any new buffer tests added (e.g. `mix test cache/test/cache/sqlite_buffer_test.exs`).
- Spot-check metrics emission by running a short local flow if needed.
